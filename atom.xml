<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aiolimp</title>
  
  
  <link href="http://aiolimp.com/atom.xml" rel="self"/>
  
  <link href="http://aiolimp.com/"/>
  <updated>2025-04-12T11:53:19.460Z</updated>
  <id>http://aiolimp.com/</id>
  
  <author>
    <name>Aiolimp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Fabric.js</title>
    <link href="http://aiolimp.com/2024/08/03/Fabric/"/>
    <id>http://aiolimp.com/2024/08/03/Fabric/</id>
    <published>2024-08-03T08:57:49.000Z</published>
    <updated>2025-04-12T11:53:19.460Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Fabric-js"><a href="#Fabric-js" class="headerlink" title="Fabric.js"></a>Fabric.js</h1><p><a href="https://link.juejin.cn/?target=http://fabricjs.com/">Fabric.js</a> 是一个流行的 JavaScript HTML5 canvas 库，它使得在 JavaScript 中处理和操作图形变得更加简单。这个库提供了一组丰富的 API，可以帮助你方便地创建、操作和修改 HTML5 canvas 上的图形对象。</p><h2 id="一、安装和设置"><a href="#一、安装和设置" class="headerlink" title="一、安装和设置"></a>一、安装和设置</h2><p>首先，确保你已经安装了 Node.js 和 npm。然后，你可以使用 npm 来安装 Fabric.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install fabric --save</span><br></pre></td></tr></table></figure><p>还可以使用cdn的方式引入Fabric.js：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、为什么使用Fabric-js"><a href="#二、为什么使用Fabric-js" class="headerlink" title="二、为什么使用Fabric.js"></a>二、为什么使用Fabric.js</h2><p>因为它提供了许多强大的功能和优点，推荐使用它有以下几个原因：</p><ol><li><strong>全面的功能：</strong>  Fabric.js 提供了丰富的图形元素和工具，如矩形、椭圆、多边形、线条、文本等，并允许你在画布上灵活地操作它们。此外，它还支持各种变换和组合模式，如旋转、缩放、倾斜、编组等。</li><li><strong>性能优化：</strong>  Fabric.js 在处理大量对象或复杂图形时，能够提供良好的性能。它使用了一个高效的渲染引擎，能够智能地管理渲染缓存，并在需要时进行优化。</li><li><strong>灵活性和可扩展性：</strong>  Fabric.js 的设计非常灵活，可以通过继承和扩展现有的对象类来轻松地添加新的功能。此外，它还提供了各种事件（例如点击、触摸、双指缩放等），以方便与用户交互。</li><li><strong>社区支持：</strong>  Fabric.js 有一个活跃的社区，提供了大量的教程、示例和插件。这意味着当你遇到问题时，你很容易找到帮助和解决方案。</li><li><strong>兼容性：</strong>  Fabric.js 在各种浏览器上表现良好，包括现代移动设备。这意味着你可以在各种设备上使用 Fabric.js 来创建丰富的交互体验。</li><li><strong>易于使用：</strong>  Fabric.js 的 API 清晰明了，易于学习和使用。即使是没有编程经验的人，也能快速上手并开始创建自己的项目。</li></ol><p>以上这些优点使得 Fabric.js 成为一种强大且全面的 JavaScript 图形库，无论你是创建复杂的游戏、数据可视化应用还是简单的交互式网页元素，Fabric.js 都值得考虑。</p><h2 id="三、Fabric-js对比原生canvas"><a href="#三、Fabric-js对比原生canvas" class="headerlink" title="三、Fabric.js对比原生canvas"></a>三、Fabric.js对比原生canvas</h2><p>Fabric.js 和原生canvas都是用于创建和操作图形的强大工具，但它们在某些方面有所不同。以下是使用这两种库创建矩形的基本示例。</p><p><strong>使用 Fabric.js 创建矩形：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 Fabric 库  </span></span><br><span class="line"><span class="keyword">import</span> fabric <span class="keyword">from</span> <span class="string">&#x27;fabric&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> canvas = <span class="keyword">new</span> fabric.Canvas(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建矩形对象  </span></span><br><span class="line"><span class="keyword">const</span> rect = <span class="keyword">new</span> fabric.Rect(&#123;</span><br><span class="line">  left: <span class="number">100</span>,</span><br><span class="line">  top: <span class="number">100</span>,</span><br><span class="line">  fill: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  width: <span class="number">200</span>,</span><br><span class="line">  height: <span class="number">200</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 将矩形添加到画布上  </span></span><br><span class="line">canvas.add(rect);</span><br></pre></td></tr></table></figure><p><strong>使用原生 canvas 创建矩形：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取页面中的canvas元素</span></span><br><span class="line"><span class="keyword">const</span> cnv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;c&#x27;</span>) </span><br><span class="line"><span class="keyword">const</span> ctx = cnv.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">ctx.moveTo(<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line">ctx.lineTo(<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line">ctx.lineTo(<span class="number">200</span>, <span class="number">120</span>)</span><br><span class="line">ctx.lineTo(<span class="number">50</span>, <span class="number">120</span>)</span><br><span class="line">ctx.lineTo(<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line">ctx.fillStyle = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">ctx.fill()</span><br></pre></td></tr></table></figure><blockquote><p>这两段代码都会在 HTML 页面中创建一个红色的矩形，但是使用 Fabric.js 可以创建更复杂的图形，并且可以方便地操作它们的属性（例如颜色，位置，大小等）。此外，Fabric.js 还提供了更高级的功能，如事件处理、图层管理、滤镜等。而原生 canvas 在某些情况下可能具有更高的性能。</p></blockquote><blockquote><p>你可以根据需要选择更适合你的项目的库。如果你需要处理复杂的图形或者需要方便地操作图形的属性，那么 Fabric.js 可能更适合你。如果你只需要在画布上绘制简单的形状，并且追求更高的性能，那么原生 canvas 可能更适合你。</p></blockquote><h2 id="四、基本概念"><a href="#四、基本概念" class="headerlink" title="四、基本概念"></a>四、基本概念</h2><p><strong>1. 画布（Canvas）</strong></p><p>在 Fabric.js 中，画布是一个非常重要的元素。你可以将它看作是绘画的“画布”，可以在上面绘制各种形状、图像和文本。Fabric.js 也提供了丰富的交互和动画功能。</p><p><strong>2. 对象（Object）</strong></p><p>Fabric.js 提供了许多内置对象，如矩形、椭圆、线条、文本等，这些对象都有一些通用属性，如 <code>left</code>、<code>top</code>、<code>width</code>、<code>height</code> 等。同时，Fabric.js 也允许你创建自定义对象。</p><p><strong>3. 属性（Properties）</strong></p><p>对象的属性定义了该对象的特点，比如颜色、大小、位置等。在 Fabric.js 中，你可以直接设置或修改对象的属性。</p><p><strong>4. 事件（Events）</strong></p><p>Fabric.js 提供了丰富的事件模型，包括 mouse events，touch events，object events 等。你可以很容易地添加事件监听器到 Fabric.js 对象上，当特定事件发生时，你的回调函数会被调用。</p><p><strong>5. 变换（Transformations）</strong></p><p>Fabric.js 提供了各种变换方法，如旋转（<code>rotate()</code>）、缩放（<code>scale()</code>）、倾斜（<code>skewX()</code> 和 <code>skewY()</code>）等。这些方法可以用来改变对象的位置、大小和形状。</p><p><strong>6. 组合（Composition）</strong></p><p>在 Fabric.js 中，你可以创建复杂的图形组合。一个组合可以包含多个对象，这些对象会作为一个整体进行变换。</p><p><strong>7. 图层（Layers）</strong></p><p>在 Fabric.js 中，你可以创建多个画布，并在这些画布上添加对象。这样，你可以轻松地管理复杂的图形层次结构，每个层次可以包含多个对象。</p><p><strong>8. SVG 支持</strong></p><p>Fabric.js 还支持从 SVG 文件创建对象。这意味着你可以很容易地从 SVG 文件导入图形，然后在 Fabric.js 画布上进行操作。</p><h2 id="五、创建画布"><a href="#五、创建画布" class="headerlink" title="五、创建画布"></a>五、创建画布</h2><p>本文介绍的是在React中使用Fabric.js创建画布，你可以按照以下步骤进行操作：</p><ol><li>首先，确保已经安装了Fabric.js和React。你可以使用npm或yarn来安装它们。</li><li>创建一个React组件，用于包含Fabric画布。例如，创建一个名为<code>Canvas.js</code>的文件，并导入Fabric和React。</li><li>在组件中创建一个<code>ref</code>来引用Fabric画布的DOM元素。可以使用<code>useRef</code>钩子来创建该引用。</li><li>在组件的<code>render</code>函数中，渲染一个<code>&lt;canvas&gt;</code>元素，并将<code>ref</code>附加到它上面。确保导入Fabric的所需对象和函数。</li><li>在组件中创建一个<code>useEffect</code>钩子来初始化Fabric画布，并将其关联到React组件的生命周期。在<code>useEffect</code>中，使用<code>fabric.Canvas</code>创建一个新的画布实例，并将其附加到<code>ref</code>引用的DOM元素上：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Canvas</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvasRef = useRef(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> canvas = <span class="keyword">new</span> fabric.Canvas(canvasRef.current, &#123;</span><br><span class="line">        fireRightClick: <span class="literal">true</span>, <span class="comment">// 启用右键，button的数字为3</span></span><br><span class="line">        stopContextMenu: <span class="literal">true</span>, <span class="comment">// 禁止默认右键菜单</span></span><br><span class="line">        controlsAboveOverlay: <span class="literal">true</span>, <span class="comment">// 超出clipPath后仍然展示控制条</span></span><br><span class="line">        preserveObjectStacking: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 在这里可以添加自定义的画布设置和操作...  </span></span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;canvas ref=&#123;canvasRef&#125; width=&#123;<span class="number">600</span>&#125; height=&#123;<span class="number">400</span>&#125;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、创建对象"><a href="#六、创建对象" class="headerlink" title="六、创建对象"></a>六、创建对象</h2><p>Fabric.js 提供了多种对象供我们使用，包括矩形、圆形、线、文本等。下面我们分别介绍一下这些对象的创建方法。</p><h3 id="1、矩形"><a href="#1、矩形" class="headerlink" title="1、矩形"></a>1、矩形</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rect = <span class="keyword">new</span> fabric.Rect(&#123;</span><br><span class="line">  left: <span class="number">100</span>,</span><br><span class="line">  top: <span class="number">100</span>,</span><br><span class="line">  fill: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  width: <span class="number">200</span>,</span><br><span class="line">  height: <span class="number">200</span></span><br><span class="line">&#125;);</span><br><span class="line">canvas.add(rect);</span><br></pre></td></tr></table></figure><h3 id="2、圆形"><a href="#2、圆形" class="headerlink" title="2、圆形"></a>2、圆形</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> fabric.Circle(&#123;</span><br><span class="line">  left: <span class="number">100</span>,</span><br><span class="line">  top: <span class="number">100</span>,</span><br><span class="line">  fill: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">  radius: <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br><span class="line">canvas.add(circle);</span><br></pre></td></tr></table></figure><h3 id="3、线"><a href="#3、线" class="headerlink" title="3、线"></a>3、线</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> line = <span class="keyword">new</span> fabric.Line([<span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>], &#123;</span><br><span class="line">  stroke: <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">  strokeWidth: <span class="number">4</span>,</span><br><span class="line">&#125;);</span><br><span class="line">canvas.add(line);</span><br></pre></td></tr></table></figure><h3 id="4、文本"><a href="#4、文本" class="headerlink" title="4、文本"></a>4、文本</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="keyword">new</span> fabric.Text(<span class="string">&#x27;今晚吃鸡，大吉大利&#x27;</span>, &#123;</span><br><span class="line">  left: <span class="number">100</span>,</span><br><span class="line">  top: <span class="number">100</span>,</span><br><span class="line">  fill: <span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">  fontSize: <span class="number">30</span>,</span><br><span class="line">&#125;);</span><br><span class="line">canvas.add(text);</span><br></pre></td></tr></table></figure><h3 id="5、图片"><a href="#5、图片" class="headerlink" title="5、图片"></a>5、图片</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fabric.Image.fromURL(<span class="string">&#x27;https://osstest.jrdaimao.com/ac/1692347493428_300x300.jpg&#x27;</span>, <span class="function"><span class="params">img</span> =&gt;</span> &#123;</span><br><span class="line">  img.set(&#123;</span><br><span class="line">    width: <span class="number">300</span>,</span><br><span class="line">    height: <span class="number">300</span>,</span><br><span class="line">    left: <span class="number">100</span>,</span><br><span class="line">    top: <span class="number">100</span>,</span><br><span class="line">    scaleX: <span class="number">0.5</span>,</span><br><span class="line">    scaleY: <span class="number">0.5</span></span><br><span class="line">  &#125;);</span><br><span class="line">  canvas.add(img);</span><br><span class="line">&#125;, &#123;<span class="attr">crossOrigin</span>: <span class="string">&#x27;anonymous&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="七、设置对象的属性"><a href="#七、设置对象的属性" class="headerlink" title="七、设置对象的属性"></a>七、设置对象的属性</h2><p>Fabric.js 允许你通过其对象模型来设置和修改对象的属性。</p><p>以下是关于 Rect、Text 和 Image 对象的属性介绍：</p><h3 id="1、Rect-对象属性"><a href="#1、Rect-对象属性" class="headerlink" title="1、Rect 对象属性"></a>1、Rect 对象属性</h3><ul><li><code>left</code>：矩形左边界相对于 canvas 左边框的位置。</li><li><code>top</code>：矩形上边界相对于 canvas 上边框的位置。</li><li><code>fill</code>：矩形的填充颜色。</li><li><code>stroke</code>：矩形的描边颜色。</li><li><code>strokeWidth</code>：矩形的描边宽度。</li><li><code>strokeDashArray</code>：矩形的描边样式，例如虚线。</li><li><code>width</code>：矩形的宽度。</li><li><code>height</code>：矩形的高度。</li><li><code>angle</code>：矩形的旋转角度（以度为单位）。</li><li><code>opacity</code>：矩形的透明度（0-1）。</li><li><code>flipX</code> 和 <code>flipY</code>：矩形的翻转标志。</li></ul><h3 id="2、Text-对象属性"><a href="#2、Text-对象属性" class="headerlink" title="2、Text 对象属性"></a>2、Text 对象属性</h3><ul><li><code>left</code>：文本左边界相对于 canvas 左边框的位置。</li><li><code>top</code>：文本上边界相对于 canvas 上边框的位置。</li><li><code>fill</code>：文本的颜色。</li><li><code>stroke</code>：文本描边的颜色。</li><li><code>strokeWidth</code>：文本描边的宽度。</li><li><code>strokeDashArray</code>：文本描边的样式，例如虚线。</li><li><code>fontFamily</code>：文本的字体。</li><li><code>fontSize</code>：文本的大小（像素）。</li><li><code>fontWeight</code>：文本的粗细，如 ‘normal’, ‘bold’, ‘bolder’, ‘lighter’, 或者数字（0-1000）。</li><li><code>fontStyle</code>：文本的样式，如 ‘normal’, ‘italic’, ‘oblique’。</li><li><code>lineHeight</code>：文本的行高（比率或像素值）。</li><li><code>textDecoration</code>：文本的装饰样式，如 ‘none’, ‘underline’, ‘overline’, ‘line-through’ 或者 ‘blink’。</li><li><code>textAlign</code>：文本的水平对齐方式，如 ‘left’, ‘center’, ‘right’。</li><li><code>textBaseline</code>：文本的垂直对齐方式，如 ‘top’, ‘middle’, ‘bottom’。</li></ul><h3 id="3、Image-对象属性"><a href="#3、Image-对象属性" class="headerlink" title="3、Image 对象属性"></a>3、Image 对象属性</h3><ul><li><code>left</code>：图片左边界相对于 canvas 左边框的位置。</li><li><code>top</code>：图片上边界相对于 canvas 上边框的位置。</li><li><code>src</code>：图片的源 URL。</li><li><code>width</code> 和 <code>height</code>：图片的宽度和高度（如果未指定，则将根据其自然大小缩放）。</li><li><code>scaleX</code> 和 <code>scaleY</code>：图片的水平方向和垂直方向的缩放比例（相对于其自然大小）。</li><li><code>opacity</code>：图片的透明度（0-1）。</li><li><code>angle</code>：图片的旋转角度（以度为单位）。</li><li><code>flipX</code> 和 <code>flipY</code>：图片的翻转标志。</li></ul><p>以下是一些基本示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rect = <span class="keyword">new</span> fabric.Rect(&#123;</span><br><span class="line">  left: <span class="number">100</span>,</span><br><span class="line">  top: <span class="number">100</span>,</span><br><span class="line">  fill: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  height: <span class="number">100</span></span><br><span class="line">&#125;);</span><br><span class="line">canvas.add(rect);</span><br><span class="line">canvas.renderAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 set() 方法设置对象的属性，将矩形的 left 属性设置为 300，fill 属性设置为 &#x27;green&#x27;</span></span><br><span class="line">rect.set(&#123;</span><br><span class="line">  left: <span class="number">300</span>,</span><br><span class="line">  fill: <span class="string">&#x27;green&#x27;</span></span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以使用 set() 方法同时设置多个属性 </span></span><br><span class="line"><span class="comment">// 将矩形的 left、top、fill、width 和 height 属性进行设置</span></span><br><span class="line">rect.set(&#123;</span><br><span class="line">  left: <span class="number">400</span>,</span><br><span class="line">  top: <span class="number">400</span>,</span><br><span class="line">  fill: <span class="string">&#x27;yellow&#x27;</span>,</span><br><span class="line">  width: <span class="number">50</span>,</span><br><span class="line">  height: <span class="number">50</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置属性后重新更新视图</span></span><br><span class="line">canvas.renderAll();</span><br></pre></td></tr></table></figure><h2 id="八、一些常用的事件"><a href="#八、一些常用的事件" class="headerlink" title="八、一些常用的事件"></a>八、一些常用的事件</h2><p>Fabric.js 提供了丰富的事件处理机制，包括鼠标点击、鼠标移动、鼠标释放等。下面我们分别介绍一下这些事件的处理方式。</p><h3 id="1、鼠标移动事件"><a href="#1、鼠标移动事件" class="headerlink" title="1、鼠标移动事件"></a>1、鼠标移动事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.on(<span class="string">&#x27;mouse:move&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">opt</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`x <span class="subst">$&#123;opt.pointer.x&#125;</span> | y <span class="subst">$&#123;opt.pointer.y&#125;</span>`</span>);&#125;)</span><br></pre></td></tr></table></figure><h3 id="2、鼠标按下和鼠标抬起事件"><a href="#2、鼠标按下和鼠标抬起事件" class="headerlink" title="2、鼠标按下和鼠标抬起事件"></a>2、鼠标按下和鼠标抬起事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">canvas.on(<span class="string">&#x27;mouse:down&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;鼠标按下&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">canvas.on(<span class="string">&#x27;mouse:up&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;鼠标抬起&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3、鼠标滚轮事件"><a href="#3、鼠标滚轮事件" class="headerlink" title="3、鼠标滚轮事件"></a>3、鼠标滚轮事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">canvas.on(<span class="string">&#x27;mouse:wheel&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">this</span>, opt</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> zoom = <span class="built_in">this</span>.getZoom();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;当前画布缩放比例&#x27;</span>, zoom);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4、对象更新后的事件"><a href="#4、对象更新后的事件" class="headerlink" title="4、对象更新后的事件"></a>4、对象更新后的事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas.on(<span class="string">&#x27;after:render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;  </span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;update&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5、一次绑定多个事件"><a href="#5、一次绑定多个事件" class="headerlink" title="5、一次绑定多个事件"></a>5、一次绑定多个事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selected</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;selected&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绑定多个事件</span></span><br><span class="line">canvas.on(&#123;</span><br><span class="line">   <span class="string">&#x27;selection:created&#x27;</span>: selected,</span><br><span class="line">   <span class="string">&#x27;selection:updated&#x27;</span>: selected,</span><br><span class="line">   <span class="string">&#x27;selection:cleared&#x27;</span>: selected,</span><br><span class="line">   <span class="string">&#x27;mouse:wheel&#x27;</span>: onWheel</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 解绑多个事件</span></span><br><span class="line">canvas.off(&#123;</span><br><span class="line">  <span class="string">&#x27;selection:created&#x27;</span>: selected,</span><br><span class="line">  <span class="string">&#x27;selection:updated&#x27;</span>: selected,</span><br><span class="line">  <span class="string">&#x27;selection:cleared&#x27;</span>: selected,</span><br><span class="line">  <span class="string">&#x27;mouse:wheel&#x27;</span>: onWheel</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="九、变换"><a href="#九、变换" class="headerlink" title="九、变换"></a>九、变换</h2><p>Fabric.js 提供了多种变换操作，包括平移（Translation）、缩放（Scaling）、旋转（Rotation）和倾斜（Shearing）等。具体来说，平移操作可以使用 <code>translate</code> 方法来实现，缩放操作可以使用 <code>scale</code> 方法，旋转操作可以使用 <code>rotate</code> 方法，倾斜操作可以使用 <code>skewX</code> 和 <code>skewY</code> 方法。这些方法都接受一个角度参数，用于指定变换的角度。同时，还可以使用 <code>setCenter</code> 方法来改变图形中心点的位置。此外，还可以通过修改图形的 <code>left</code>、<code>top</code>、<code>width</code> 和 <code>height</code> 属性来直接改变图形的位置和大小。除了这些基本的变换操作，Fabric.js 还提供了更高级的变换方式，例如通过设置变换矩阵来实现复杂的变换操作。可以使用 <code>setTransformMatrix</code> 方法来设置自定义的变换矩阵，该方法接受一个包含六个元素的数组作为参数，这些元素定义了变换矩阵的各个元素。</p><p>以下是一些Fabric.js中rect、text和image的变换方法:</p><p><strong>1. 对于 rect和image</strong></p><ul><li><code>scale(scaleX, scaleY)</code>: 对矩形进行缩放</li><li><code>rotate(angle)</code>: 对矩形进行旋转</li><li><code>translate(x, y)</code>: 对矩形进行平移</li><li><code>set(&#123; left: value, top: value &#125;)</code>: 设置矩形的位置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rect = <span class="keyword">new</span> fabric.Rect(&#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;);  </span><br><span class="line"></span><br><span class="line">rect.scale(<span class="number">2</span>, <span class="number">2</span>);  <span class="comment">// 将矩形放大两倍</span></span><br><span class="line"></span><br><span class="line">rect.rotate(<span class="number">45</span>, <span class="string">&#x27;center&#x27;</span>); <span class="comment">// 将矩形顺时针旋转45度，旋转的中心点是矩形的中心</span></span><br><span class="line"></span><br><span class="line">rect.translate(<span class="number">50</span>, <span class="number">50</span>);  <span class="comment">// 将矩形向右移动50px，向下移动50px</span></span><br><span class="line"></span><br><span class="line">rect.set(&#123; <span class="attr">left</span>: <span class="number">50</span>, <span class="attr">top</span>: <span class="number">50</span> &#125;); <span class="comment">// 将矩形向右移动50px，向下移动50px</span></span><br></pre></td></tr></table></figure><p><strong>2. 对于 text</strong></p><ul><li><code>setFontSize(value)</code>: 设置文本的字体大小</li><li><code>setFontFamily(value)</code>: 设置文本的字体类型</li><li><code>setFill(value)</code>: 设置文本的颜色</li><li><code>setStroke(value)</code>: 设置文本的描边颜色</li><li><code>setStrokeWidth(value)</code>: 设置文本的描边宽度</li><li><code>setTransform(value)</code>: 设置文本的变换，如旋转、缩放等</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="keyword">new</span> fabric.Text(<span class="string">&#x27;Hello World&#x27;</span>); </span><br><span class="line"></span><br><span class="line">text.setFontSize(<span class="number">88</span>); <span class="comment">// 将文字的字体大小设置成88px</span></span><br><span class="line"></span><br><span class="line">text.setFontFamily(<span class="string">&#x27;serif&#x27;</span>); <span class="comment">// 将文字的字体类型设置成serif</span></span><br><span class="line"></span><br><span class="line">text.setFill(<span class="string">&#x27;#888888&#x27;</span>); <span class="comment">// 将文字的字体颜色设置成#888888</span></span><br><span class="line"></span><br><span class="line">text.setStroke(<span class="string">&#x27;red&#x27;</span>); <span class="comment">// 将文本的描边颜色设置为红色</span></span><br><span class="line"></span><br><span class="line">text.setStrokeWidth(<span class="number">2</span>); <span class="comment">// 将文本的描边宽度设置为2px</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="第三方库" scheme="http://aiolimp.com/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
    <category term="第三方库" scheme="http://aiolimp.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySql</title>
    <link href="http://aiolimp.com/2024/06/02/MySql/"/>
    <id>http://aiolimp.com/2024/06/02/MySql/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2025-04-12T11:49:13.751Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>启动mysql</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="operator">/</span>usr<span class="operator">/</span><span class="keyword">local</span><span class="operator">/</span>mysql<span class="operator">/</span>support<span class="operator">-</span>files<span class="operator">/</span>mysql.server <span class="keyword">start</span></span><br></pre></td></tr></table></figure><p><strong>进入 MySQL 命令行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p </span><br></pre></td></tr></table></figure><ul><li><code>-u root</code> 表示使用 root 用户登录（也可以换成其他用户名）</li><li><code>-p</code> 表示需要输入密码（执行后会提示输入密码）</li></ul><p>以下是 <strong>MySQL 常用命令大全</strong>，涵盖 <strong>数据库操作、表管理、数据增删改查、用户权限</strong> 等，适合快速查阅和日常使用。</p><hr><h2 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1. 数据库操作"></a><strong>1. 数据库操作</strong></h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>SHOW DATABASES;</code></td><td>查看所有数据库</td></tr><tr><td><code>CREATE DATABASE 数据库名;</code></td><td>创建数据库</td></tr><tr><td><code>USE 数据库名;</code></td><td>切换数据库</td></tr><tr><td><code>DROP DATABASE 数据库名;</code></td><td>删除数据库</td></tr><tr><td><code>SHOW CREATE DATABASE 数据库名;</code></td><td>查看数据库创建语句</td></tr></tbody></table><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test_db;</span><br><span class="line">USE test_db;</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure><hr><h2 id="2-表操作"><a href="#2-表操作" class="headerlink" title="2. 表操作"></a><strong>2. 表操作</strong></h2><h3 id="1-创建表"><a href="#1-创建表" class="headerlink" title="(1) 创建表"></a><strong>(1) 创建表</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (</span><br><span class="line">    列<span class="number">1</span> 数据类型 [约束],</span><br><span class="line">    列<span class="number">2</span> 数据类型 [约束],</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-查看表"><a href="#2-查看表" class="headerlink" title="(2) 查看表"></a><strong>(2) 查看表</strong></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>SHOW TABLES;</code></td><td>查看当前数据库的所有表</td></tr><tr><td><code>DESC 表名;</code></td><td>查看表结构</td></tr><tr><td><code>SHOW CREATE TABLE 表名;</code></td><td>查看建表语句</td></tr></tbody></table><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="keyword">DESC</span> users;</span><br></pre></td></tr></table></figure><h3 id="3-修改表"><a href="#3-修改表" class="headerlink" title="(3) 修改表"></a><strong>(3) 修改表</strong></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>ALTER TABLE 表名 ADD 列名 数据类型;</code></td><td>添加列</td></tr><tr><td><code>ALTER TABLE 表名 DROP COLUMN 列名;</code></td><td>删除列</td></tr><tr><td><code>ALTER TABLE 表名 MODIFY COLUMN 列名 新数据类型;</code></td><td>修改列数据类型</td></tr><tr><td><code>ALTER TABLE 表名 RENAME TO 新表名;</code></td><td>重命名表</td></tr></tbody></table><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> phone <span class="type">VARCHAR</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> age;</span><br></pre></td></tr></table></figure><h3 id="4-删除表"><a href="#4-删除表" class="headerlink" title="(4) 删除表"></a><strong>(4) 删除表</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure><hr><h2 id="3-数据增删改查（CRUD）"><a href="#3-数据增删改查（CRUD）" class="headerlink" title="3. 数据增删改查（CRUD）"></a><strong>3. 数据增删改查（CRUD）</strong></h2><h3 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="(1) 插入数据"></a><strong>(1) 插入数据</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 (列<span class="number">1</span>, 列<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (name, email) <span class="keyword">VALUES</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;zhangsan@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="2-查询数据"><a href="#2-查询数据" class="headerlink" title="(2) 查询数据"></a><strong>(2) 查询数据</strong></h3><table><thead><tr><th align="left">命令</th><th>说明</th></tr></thead><tbody><tr><td align="left"><code>SELECT * FROM 表名;</code></td><td>查询所有数据</td></tr><tr><td align="left"><code>SELECT 列1, 列2 FROM 表名;</code></td><td>查询指定列</td></tr><tr><td align="left"><code>SELECT * FROM 表名 WHERE 条件;</code></td><td>条件查询</td></tr><tr><td align="left">`SELECT * FROM 表名 ORDER BY 列名 [ASC</td><td>DESC];`</td></tr><tr><td align="left"><code>SELECT * FROM 表名 LIMIT 数量;</code></td><td>限制返回条数</td></tr><tr><td align="left"><code>SELECT FROM 表名 WHERE name = &#39;张三&#39; AND age &lt;= 20;</code></td><td>多个条件联合查询（and）</td></tr><tr><td align="left"><code>SELECT FROM 表名 WHERE name = &#39;张三&#39;or age &lt;= 20;</code></td><td>多个条件联合查询（or）</td></tr><tr><td align="left"><code>SELECT * FROM 表名 WHERE name LIKE &#39;%张%&#39;</code></td><td>模糊查询</td></tr></tbody></table><ul><li>“张%”：匹配以”张”开头的字符串，后面可以是任意字符。</li><li>“%张”：匹配以”张”结尾的字符串，前面可以是任意字符。</li><li>“%张%”：匹配包含”张”的任意位置的字符串，前后可以是任意字符。</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;</span><br><span class="line"><span class="keyword">SELECT</span> name, email <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">18</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_57570052/article/details/132171270">查询大全</a></p><h3 id="3-更新数据"><a href="#3-更新数据" class="headerlink" title="(3) 更新数据"></a><strong>(3) 更新数据</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名 <span class="keyword">SET</span> 列<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>, 列<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span> <span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE users <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;李四&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="4-删除数据"><a href="#4-删除数据" class="headerlink" title="(4) 删除数据"></a><strong>(4) 删除数据</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure><p><strong>批量删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="4-用户与权限管理"><a href="#4-用户与权限管理" class="headerlink" title="4. 用户与权限管理"></a><strong>4. 用户与权限管理</strong></h2><h3 id="1-创建用户"><a href="#1-创建用户" class="headerlink" title="(1) 创建用户"></a><strong>(1) 创建用户</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;test_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-授权"><a href="#2-授权" class="headerlink" title="(2) 授权"></a><strong>(2) 授权</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限 <span class="keyword">ON</span> 数据库.表 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> test_db.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;test_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;  <span class="comment">-- 刷新权限</span></span><br></pre></td></tr></table></figure><h3 id="3-撤销权限"><a href="#3-撤销权限" class="headerlink" title="(3) 撤销权限"></a><strong>(3) 撤销权限</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限 <span class="keyword">ON</span> 数据库.表 <span class="keyword">FROM</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> test_db.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;test_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="4-删除用户"><a href="#4-删除用户" class="headerlink" title="(4) 删除用户"></a><strong>(4) 删除用户</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="5-其他实用命令"><a href="#5-其他实用命令" class="headerlink" title="5. 其他实用命令"></a><strong>5. 其他实用命令</strong></h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>SHOW PROCESSLIST;</code></td><td>查看当前连接会话</td></tr><tr><td><code>KILL 进程ID;</code></td><td>终止某个 MySQL 连接</td></tr><tr><td><code>EXIT;</code> 或 <code>\q</code></td><td>退出 MySQL 命令行</td></tr><tr><td><code>SOURCE 文件路径;</code></td><td>执行 SQL 脚本文件</td></tr></tbody></table><hr><h2 id="6-表达式和函数"><a href="#6-表达式和函数" class="headerlink" title="6.表达式和函数"></a>6.表达式和函数</h2><p>以下是一份详细的 <strong>MySQL 表达式与函数指南</strong>，涵盖常用运算符、内置函数及复杂表达式用法：</p><h3 id="1-MySQL-表达式"><a href="#1-MySQL-表达式" class="headerlink" title="(1) MySQL 表达式"></a>(1) <strong>MySQL 表达式</strong></h3><p>表达式是由字面量、列名、运算符和函数组成的代码片段，用于计算或生成值。</p><h4 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1. 运算符"></a>1. <strong>运算符</strong></h4><p><strong>算术运算符</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span> 加法  <span class="operator">-</span> 减法  <span class="operator">*</span> 乘法  <span class="operator">/</span> 除法  <span class="operator">%</span> 取模  DIV 整除</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">10</span> <span class="operator">+</span> <span class="number">5</span>;        <span class="comment">-- 15</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">7</span> <span class="operator">%</span> <span class="number">3</span>;         <span class="comment">-- 1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">10</span> DIV <span class="number">3</span>;      <span class="comment">-- 3</span></span><br></pre></td></tr></table></figure><p><strong>比较运算符</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">=</span> 等于  <span class="operator">&lt;&gt;</span> 或 <span class="operator">!=</span> 不等于  <span class="operator">&gt;</span> 大于  <span class="operator">&lt;</span> 小于  <span class="operator">&gt;=</span> 大于等于  <span class="operator">&lt;=</span> 小于等于</span><br><span class="line"><span class="keyword">BETWEEN</span> ... <span class="keyword">AND</span> ...   <span class="keyword">IN</span>(...)   <span class="keyword">IS</span> <span class="keyword">NULL</span>   <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">LIKE</span> (模糊匹配)   REGEXP (正则匹配)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">18</span> <span class="keyword">AND</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="keyword">IN</span> (<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> logs <span class="keyword">WHERE</span> message <span class="keyword">LIKE</span> <span class="string">&#x27;%error%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>逻辑运算符</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AND</span>   <span class="keyword">OR</span>   <span class="keyword">NOT</span>   XOR</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;paid&#x27;</span> <span class="keyword">AND</span> amount <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>位运算符</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&amp;</span> 按位与  <span class="operator">|</span> 按位或  <span class="operator">^</span> 按位异或  <span class="operator">&lt;&lt;</span> 左移  <span class="operator">&gt;&gt;</span> 右移  <span class="operator">~</span> 按位取反</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">5</span> <span class="operator">&amp;</span> <span class="number">3</span>;  <span class="comment">-- 1 (二进制 0101 &amp; 0011)</span></span><br></pre></td></tr></table></figure><h4 id="2-条件表达式"><a href="#2-条件表达式" class="headerlink" title="2. 条件表达式"></a>2. <strong>条件表达式</strong></h4><p><strong>CASE 表达式</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    name,</span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> age <span class="operator">&lt;</span> <span class="number">18</span> <span class="keyword">THEN</span> <span class="string">&#x27;未成年&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> age <span class="keyword">BETWEEN</span> <span class="number">18</span> <span class="keyword">AND</span> <span class="number">60</span> <span class="keyword">THEN</span> <span class="string">&#x27;成年&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;老年&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> age_group</span><br><span class="line"><span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure><p><strong>IF 函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IF(score <span class="operator">&gt;=</span> <span class="number">60</span>, <span class="string">&#x27;及格&#x27;</span>, <span class="string">&#x27;不及格&#x27;</span>) <span class="keyword">AS</span> <span class="keyword">result</span> <span class="keyword">FROM</span> exams;</span><br></pre></td></tr></table></figure><p><strong>COALESCE 处理 NULL</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(address, <span class="string">&#x27;未知地址&#x27;</span>) <span class="keyword">FROM</span> customers; <span class="comment">-- 返回第一个非 NULL 值</span></span><br></pre></td></tr></table></figure><p><strong>NULLIF 比较相等返回 NULL</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(column1, column2); <span class="comment">-- 若 column1 = column2，返回 NULL</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-MySQL-内置函数"><a href="#2-MySQL-内置函数" class="headerlink" title="(2) .MySQL 内置函数"></a>(2) .<strong>MySQL 内置函数</strong></h3><p><strong>1. 字符串函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连接字符串</span></span><br><span class="line">CONCAT(str1, str2, ...)  </span><br><span class="line">CONCAT_WS(分隔符, str1, str2, ...)  <span class="comment">-- 带分隔符的连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;World&#x27;</span>);  <span class="comment">-- Hello World</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT_WS(<span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>); <span class="comment">-- Apple, Banana</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 大小写转换</span></span><br><span class="line"><span class="built_in">LOWER</span>(str)  <span class="built_in">UPPER</span>(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 截取与长度</span></span><br><span class="line"><span class="built_in">SUBSTRING</span>(str, <span class="keyword">start</span>, length)  <span class="keyword">CHAR_LENGTH</span>(str)  LENGTH(str)（字节长度）</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 替换与去除空格</span></span><br><span class="line">REPLACE(str, <span class="keyword">old</span>, <span class="keyword">new</span>)  <span class="built_in">TRIM</span>([<span class="keyword">LEADING</span><span class="operator">|</span><span class="keyword">TRAILING</span><span class="operator">|</span><span class="keyword">BOTH</span>] <span class="string">&#x27; &#x27;</span> <span class="keyword">FROM</span> str)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 格式化</span></span><br><span class="line">FORMAT(number, decimal_places) <span class="comment">-- 数字格式化</span></span><br><span class="line">LPAD(str, length, pad_str)     <span class="comment">-- 左填充</span></span><br></pre></td></tr></table></figure><p><strong>2. 数值函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ROUND(number, decimals)  <span class="comment">-- 四舍五入</span></span><br><span class="line"><span class="built_in">CEIL</span>(number)             <span class="comment">-- 向上取整</span></span><br><span class="line"><span class="built_in">FLOOR</span>(number)            <span class="comment">-- 向下取整</span></span><br><span class="line"><span class="built_in">ABS</span>(number)              <span class="comment">-- 绝对值</span></span><br><span class="line"><span class="built_in">MOD</span>(dividend, divisor)   <span class="comment">-- 取模</span></span><br><span class="line">RAND()                   <span class="comment">-- 生成0~1随机数</span></span><br><span class="line">POW(base, exponent)      <span class="comment">-- 幂运算</span></span><br><span class="line"><span class="built_in">SQRT</span>(number)             <span class="comment">-- 平方根</span></span><br></pre></td></tr></table></figure><p><strong>3. 日期与时间函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当前时间</span></span><br><span class="line">NOW()       <span class="comment">-- 当前日期和时间（如 &#x27;2023-10-01 12:34:56&#x27;）</span></span><br><span class="line">CURDATE()   <span class="comment">-- 当前日期</span></span><br><span class="line">CURTIME()   <span class="comment">-- 当前时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取部分日期</span></span><br><span class="line"><span class="keyword">YEAR</span>(<span class="type">date</span>)  <span class="keyword">MONTH</span>(<span class="type">date</span>)  <span class="keyword">DAY</span>(<span class="type">date</span>)  </span><br><span class="line"><span class="keyword">HOUR</span>(<span class="type">time</span>)  <span class="keyword">MINUTE</span>(<span class="type">time</span>)  <span class="keyword">SECOND</span>(<span class="type">time</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 日期计算</span></span><br><span class="line">DATE_ADD(<span class="type">date</span>, <span class="type">INTERVAL</span> expr unit)  <span class="comment">-- 增加时间间隔</span></span><br><span class="line">DATE_SUB(<span class="type">date</span>, <span class="type">INTERVAL</span> expr unit)  <span class="comment">-- 减少时间间隔</span></span><br><span class="line">DATEDIFF(end_date, start_date)      <span class="comment">-- 日期差（天数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 格式化日期</span></span><br><span class="line">DATE_FORMAT(<span class="type">date</span>, format)  </span><br><span class="line"><span class="comment">-- 示例：将日期格式化为 &#x27;2023年10月01日&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(NOW(), <span class="string">&#x27;%Y年%m月%d日&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>4. 聚合函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>)         <span class="comment">-- 统计行数</span></span><br><span class="line"><span class="built_in">SUM</span>(<span class="keyword">column</span>)      <span class="comment">-- 求和</span></span><br><span class="line"><span class="built_in">AVG</span>(<span class="keyword">column</span>)      <span class="comment">-- 平均值</span></span><br><span class="line"><span class="built_in">MAX</span>(<span class="keyword">column</span>)      <span class="comment">-- 最大值</span></span><br><span class="line"><span class="built_in">MIN</span>(<span class="keyword">column</span>)      <span class="comment">-- 最小值</span></span><br><span class="line">GROUP_CONCAT(<span class="keyword">column</span>) <span class="comment">-- 合并分组的值（默认逗号分隔）</span></span><br></pre></td></tr></table></figure><p><strong>5. 高级函数</strong></p><p><strong>窗口函数（MySQL 8.0+）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span>) <span class="comment">-- 行号</span></span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> ...) <span class="comment">-- 排名</span></span><br><span class="line"><span class="built_in">LEAD</span>(<span class="keyword">column</span>) <span class="keyword">OVER</span> (...)            <span class="comment">-- 访问后续行的值</span></span><br></pre></td></tr></table></figure><p><strong>JSON 函数（MySQL 5.7+）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON_EXTRACT(json_column, <span class="string">&#x27;$.key&#x27;</span>)  <span class="comment">-- 提取 JSON 字段</span></span><br><span class="line">JSON_SET(json_column, <span class="string">&#x27;$.key&#x27;</span>, <span class="keyword">value</span>) <span class="comment">-- 修改 JSON 字段</span></span><br></pre></td></tr></table></figure><p><strong>加密函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MD5(str)          <span class="comment">-- 计算 MD5 哈希值</span></span><br><span class="line">SHA1(str)         <span class="comment">-- 计算 SHA1 哈希值</span></span><br><span class="line">AES_ENCRYPT(data, key) <span class="comment">-- AES 加密</span></span><br></pre></td></tr></table></figure><p><strong>6. 类型转换函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAST</span>(expr <span class="keyword">AS</span> type)   <span class="comment">-- 转换数据类型（如 CAST(&#x27;123&#x27; AS SIGNED)）</span></span><br><span class="line"><span class="keyword">CONVERT</span>(expr, type)  <span class="comment">-- 同上</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-表达式与函数使用示例"><a href="#3-表达式与函数使用示例" class="headerlink" title="(3) 表达式与函数使用示例"></a><strong>(3) 表达式与函数使用示例</strong></h3><p><strong>示例 1：复杂查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    user_id,</span><br><span class="line">    CONCAT(first_name, <span class="string">&#x27; &#x27;</span>, last_name) <span class="keyword">AS</span> full_name,</span><br><span class="line">    <span class="keyword">YEAR</span>(register_date) <span class="keyword">AS</span> register_year,</span><br><span class="line">    <span class="built_in">AVG</span>(order_amount) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_id) <span class="keyword">AS</span> avg_order</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    DATEDIFF(NOW(), last_login) <span class="operator">&lt;</span> <span class="number">30</span></span><br><span class="line">    <span class="keyword">AND</span> <span class="built_in">COALESCE</span>(email, <span class="string">&#x27;&#x27;</span>) <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>示例 2：动态计算</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    product_id,</span><br><span class="line">    price,</span><br><span class="line">    IF(price <span class="operator">&gt;</span> <span class="number">100</span>, price <span class="operator">*</span> <span class="number">0.9</span>, price) <span class="keyword">AS</span> discounted_price,</span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> stock <span class="operator">&lt;=</span> <span class="number">0</span> <span class="keyword">THEN</span> <span class="string">&#x27;缺货&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> stock <span class="operator">&lt;</span> <span class="number">10</span> <span class="keyword">THEN</span> <span class="string">&#x27;库存紧张&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;充足&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> stock_status</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure><hr><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="(4) 注意事项"></a>(4) <strong>注意事项</strong></h3><ol><li><p><strong>NULL 处理</strong>：大多数函数遇到 NULL 会返回 NULL，需用 <code>IFNULL()</code> 或 <code>COALESCE()</code> 处理。</p></li><li><p><strong>性能影响</strong>：复杂函数（如正则、窗口函数）可能影响查询速度，避免在大数据集滥用。</p></li><li><p><strong>版本兼容性</strong>：部分函数（如窗口函数）仅限 MySQL 8.0+，需确认数据库版本。</p></li><li><p><strong>大小写敏感</strong>：字符串函数默认大小写不敏感，可用 <code>BINARY</code> 强制区分：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;Apple&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;apple&#x27;</span>;          <span class="comment">-- 1 (不敏感)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">BINARY</span> <span class="string">&#x27;Apple&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;apple&#x27;</span>;   <span class="comment">-- 0 (敏感)</span></span><br></pre></td></tr></table></figure></li></ol><hr><p>如果需要更具体的函数说明或实际场景的案例，请补充说明！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li><strong>数据库操作</strong>：<code>CREATE DATABASE</code>, <code>USE</code>, <code>DROP DATABASE</code>  </li><li><strong>表操作</strong>：<code>CREATE TABLE</code>, <code>ALTER TABLE</code>, <code>DROP TABLE</code>  </li><li><strong>数据操作</strong>：<code>INSERT</code>, <code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code>  </li><li><strong>用户权限</strong>：<code>CREATE USER</code>, <code>GRANT</code>, <code>REVOKE</code>  </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="服务端" scheme="http://aiolimp.com/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    
    <category term="服务端" scheme="http://aiolimp.com/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Web Worker 基本使用</title>
    <link href="http://aiolimp.com/2024/04/13/WebWork/"/>
    <id>http://aiolimp.com/2024/04/13/WebWork/</id>
    <published>2024-04-12T16:00:00.000Z</published>
    <updated>2025-04-12T11:46:55.346Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Web-Worker-基本使用"><a href="#Web-Worker-基本使用" class="headerlink" title="Web Worker 基本使用"></a>Web Worker 基本使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Web开发中，JavaScript的单线程特性常常成为性能瓶颈。当我们遇到需要大量计算的场景时（如图像处理、数据分析等），Web Worker 就成为了关键的解决方案。本文将通过一个完整示例，带你快速掌握Web Worker的使用方法。</p><hr><h2 id="一、什么是Web-Worker？"><a href="#一、什么是Web-Worker？" class="headerlink" title="一、什么是Web Worker？"></a>一、什么是Web Worker？</h2><p>Web Worker是浏览器提供的JavaScript多线程解决方案，它允许我们在后台线程中运行脚本，与主线程并行执行。关键特性：</p><ul><li>独立全局上下文</li><li>无法直接操作DOM</li><li>通过消息机制通信</li><li>支持传递可序列化数据</li></ul><p><strong>什么时候用 Web Worker？</strong></p><p> 适合：</p><ul><li>计算密集型任务（如加密、数据处理）</li><li>长时间运行的任务（如 WebSockets、消息队列）</li><li>渲染优化（如复杂动画、WebGL）</li></ul><p> 不适合：</p><ul><li>需要操作 DOM</li><li>轻量级任务（可能带来额外线程管理成本）</li></ul><hr><h2 id="二、快速创建Web-Worker"><a href="#二、快速创建Web-Worker" class="headerlink" title="二、快速创建Web Worker"></a>二、快速创建Web Worker</h2><h3 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h3><p>![image-20250401135226498](/Users/dayuyu/Library/Application Support/typora-user-images/image-20250401135226498.png)</p><h3 id="2-样式文件（index-html）"><a href="#2-样式文件（index-html）" class="headerlink" title="2.样式文件（index.html）"></a>2.样式文件（index.html）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web Worker 调试演示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">font-family</span>: Arial, sans-serif;</span></span><br><span class="line"><span class="css">      <span class="attribute">max-width</span>: <span class="number">800px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#f0f2f5</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .container &#123;</span><br><span class="line"><span class="css">      <span class="attribute">background</span>: white;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">4px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-tag">button</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#007bff</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="css">      <span class="attribute">border</span>: none;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin</span>: <span class="number">5px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#0056b3</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #output &#123;</span><br><span class="line"><span class="css">      <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#f8f9fa</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">min-height</span>: <span class="number">100px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web Worker 调试演示<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;startWorker()&quot;</span>&gt;</span>启动Worker<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;sendMessage()&quot;</span>&gt;</span>发送消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;stopWorker()&quot;</span>&gt;</span>停止Worker<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-主线程代码（main-js）"><a href="#3-主线程代码（main-js）" class="headerlink" title="3. 主线程代码（main.js）"></a>3. 主线程代码（main.js）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> worker;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;output&#x27;</span>).innerHTML += <span class="string">`&lt;div&gt;<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;</span>: <span class="subst">$&#123;message&#125;</span>&lt;/div&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startWorker</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> (Worker) === <span class="string">&#x27;undefined&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    log(<span class="string">&#x27;浏览器不支持Web Workers&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!worker)</span><br><span class="line">  &#123;</span><br><span class="line">    worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;./worker.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收Worker消息</span></span><br><span class="line">    worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      log(<span class="string">`收到Worker消息: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(e.data)&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    worker.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      log(<span class="string">`Worker错误: <span class="subst">$&#123;e.message&#125;</span> (行号:<span class="subst">$&#123;e.lineno&#125;</span>)`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    log(<span class="string">&#x27;Worker已启动&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (worker)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> message = &#123;</span><br><span class="line">      type: <span class="string">&#x27;CALCULATE&#x27;</span>,</span><br><span class="line">      data: <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">100</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    worker.postMessage(message);</span><br><span class="line">    log(<span class="string">`已发送消息: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(message)&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopWorker</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (worker)</span><br><span class="line">  &#123;</span><br><span class="line">    worker.terminate();</span><br><span class="line">    worker = <span class="literal">null</span>;</span><br><span class="line">    log(<span class="string">&#x27;Worker已停止&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Worker线程代码（worker-js）"><a href="#4-Worker线程代码（worker-js）" class="headerlink" title="4. Worker线程代码（worker.js）"></a>4. Worker线程代码（worker.js）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听主线程消息</span></span><br><span class="line"><span class="comment">// self 代表当前 Worker 线程的全局对象（类似于主线程中的 window）。</span></span><br><span class="line">self.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Worker收到消息:&#x27;</span>, e.data);</span><br><span class="line">  <span class="keyword">switch</span> (e.data.type)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;CALCULATE&#x27;</span>:</span><br><span class="line">      <span class="keyword">const</span> result = fibonacci(e.data.data);</span><br><span class="line">      self.postMessage(&#123;</span><br><span class="line">        type: <span class="string">&#x27;RESULT&#x27;</span>,</span><br><span class="line">        input: e.data.data,</span><br><span class="line">        result: result</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      self.postMessage(&#123;</span><br><span class="line">        type: <span class="string">&#x27;ERROR&#x27;</span>,</span><br><span class="line">        message: <span class="string">&#x27;未知的消息类型&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟计算密集型任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line">self.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;Worker内部错误:&#x27;</span>, e);</span><br><span class="line">  self.postMessage(&#123;</span><br><span class="line">    type: <span class="string">&#x27;ERROR&#x27;</span>,</span><br><span class="line">    message: e.message,</span><br><span class="line">    stack: e.error?.stack</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试用定时器</span></span><br><span class="line"><span class="keyword">let</span> debugCounter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Worker运行中:&#x27;</span>, debugCounter++);</span><br><span class="line">  self.postMessage(&#123;</span><br><span class="line">    type: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">    counter: debugCounter</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h3 id="5-创建npm项目配置文件，定义调试服务器启动脚本。"><a href="#5-创建npm项目配置文件，定义调试服务器启动脚本。" class="headerlink" title="5. 创建npm项目配置文件，定义调试服务器启动脚本。"></a>5. 创建npm项目配置文件，定义调试服务器启动脚本。</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;worker-demo&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;http-server -p 8080&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;http-server&quot;</span>: <span class="string">&quot;^14.1.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-功能演示"><a href="#6-功能演示" class="headerlink" title="6.功能演示"></a>6.功能演示</h3><ol><li>点击【启动 Worker】初始化</li><li>点击【发送消息】触发斐波那契数列计算</li><li>观察 Worker 定时发送的 debug 计数器</li><li>点击【停止 Worker】终止线程</li></ol><h2 id="三、核心API解析"><a href="#三、核心API解析" class="headerlink" title="三、核心API解析"></a>三、核心API解析</h2><ol><li><p><strong>创建Worker</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;worker.js&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>消息传递</strong></p><ul><li><p>主线程发送：<code>worker.postMessage(data)</code></p></li><li><p>Worker发送：<code>self.postMessage(data)</code></p></li></ul><p><strong>(1) 传递普通数据（字符串、数字、对象）</strong></p><p>postMessage() 可以发送<strong>字符串、数字、数组、对象</strong>等：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(&#123; <span class="attr">task</span>: <span class="string">&quot;sum&quot;</span>, <span class="attr">num</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><p><strong>(2) 传递 TypedArray（更快的数据处理）</strong></p><p>适用于处理二进制数据，如 ArrayBuffer：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1024</span>);</span><br><span class="line">worker.postMessage(buffer);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果 postMessage() 传递 ArrayBuffer，默认会<strong>转移（Transferable Objects）</strong>，主线程无法再访问原数据。</p></li><li><p><strong>消息接收</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker线程</span></span><br><span class="line">self.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>终止Worker</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker.terminate(); <span class="comment">// 主线程调用</span></span><br><span class="line">self.close();      <span class="comment">// Worke</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="四-Worker-线程中的限制"><a href="#四-Worker-线程中的限制" class="headerlink" title="四. Worker 线程中的限制"></a><strong>四. Worker 线程中的限制</strong></h2><ul><li><p><strong>不能操作 DOM</strong>（不能使用 document、window）</p></li><li><p><strong>不能直接访问本地存储（localStorage、sessionStorage）</strong></p></li><li><p><strong>可以使用 fetch、WebSockets 等进行网络请求</strong></p></li><li><p><strong>可以使用 setTimeout / setInterval（但不推荐）</strong></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>node基础</title>
    <link href="http://aiolimp.com/2024/03/11/node/"/>
    <id>http://aiolimp.com/2024/03/11/node/</id>
    <published>2024-03-10T16:00:00.000Z</published>
    <updated>2025-04-12T11:51:58.222Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><ol><li><p>nodejs 并不是<code>JavaScript</code>应用，也不是编程语言，因为编程语言使用的<code>JavaScript</code>,Nodejs是 <code>JavaScript</code>的运行时。</p></li><li><p>Nodejs是构建在V8引擎之上的，V8引擎是由C/C++编写的，因此我们的JavaSCript代码需要由C/C++转化后再执行。</p></li><li><p>NodeJs 使用异步 I/O 和事件驱动的设计理念，可以高效地处理大量并发请求，提供了非阻塞式 I/O 接口和事件循环机制，使得开发人员可以编写高性能、可扩展的应用程序,异步I/O最终都是由<code>libuv</code> 事件循环库去实现的。</p></li><li><p>NodeJs 使用npm 作为包管理工具类似于python的pip，或者是java的Maven，目前npm拥有上百万个模块。 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/">www.npmjs.com/</a></p></li><li><p>nodejs适合干一些IO密集型应用，不适合CPU密集型应用，nodejsIO依靠libuv有很强的处理能力，而CPU因为nodejs单线程原因，容易造成CPU占用率高，如果非要做CPU密集型应用，可以使用C++插件编写 或者nodejs提供的<code>cluster</code>。(CPU密集型指的是图像的处理 或者音频处理需要大量数据结构 + 算法)</p></li></ol><h2 id="2-NPM"><a href="#2-NPM" class="headerlink" title="2.NPM"></a>2.NPM</h2><h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h4><p><code>npm</code>（全称 Node Package Manager）是 Node.js 的包管理工具，它是一个基于命令行的工具，用于帮助开发者在自己的项目中安装、升级、移除和管理依赖项。</p><h4 id="npm命令"><a href="#npm命令" class="headerlink" title="npm命令"></a>npm命令</h4><ol><li><code>npm init</code>：初始化一个新的 npm 项目，创建 package.json 文件。</li><li><code>npm install</code>：安装一个包或一组包，并且会在当前目录存放一个node_modules。</li><li><code>npm install &lt;package-name&gt;</code>：安装指定的包。</li><li><code>npm install &lt;package-name&gt; --save</code>：安装指定的包，并将其添加到 package.json 文件中的依赖列表中。</li><li><code>npm install &lt;package-name&gt; --save-dev</code>：安装指定的包，并将其添加到 package.json 文件中的开发依赖列表中。</li><li><code>npm install -g &lt;package-name&gt;</code>：全局安装指定的包。</li><li><code>npm update &lt;package-name&gt;</code>：更新指定的包。</li><li><code>npm uninstall &lt;package-name&gt;</code>：卸载指定的包。</li><li><code>npm run &lt;script-name&gt;</code>：执行 package.json 文件中定义的脚本命令。</li><li><code>npm search &lt;keyword&gt;</code>：搜索 npm 库中包含指定关键字的包。</li><li><code>npm info &lt;package-name&gt;</code>：查看指定包的详细信息。</li><li><code>npm list</code>：列出当前项目中安装的所有包。</li><li><code>npm outdated</code>：列出当前项目中需要更新的包。</li><li><code>npm audit</code>：检查当前项目中的依赖项是否存在安全漏洞。</li><li><code>npm publish</code>：发布自己开发的包到 npm 库中。</li><li><code>npm login</code>：登录到 npm 账户。</li><li><code>npm logout</code>：注销当前 npm 账户。</li><li><code>npm link</code>: 将本地模块链接到全局的 <code>node_modules</code> 目录下</li><li><code>npm config list</code> 用于列出所有的 npm 配置信息。执行该命令可以查看当前系统和用户级别的所有 npm 配置信息，以及当前项目的配置信息（如果在项目目录下执行该命令）</li><li><code>npm get registry</code> 用于获取当前 npm 配置中的 registry 配置项的值。registry 配置项用于指定 npm 包的下载地址，如果未指定，则默认使用 npm 官方的包注册表地址</li><li><code>npm set registry</code> <code>npm config set registry &lt;registry-url&gt;</code> 命令，将 registry 配置项的值修改为指定的 <code>&lt;registry-url&gt;</code> 地址</li></ol><h4 id="Package-json"><a href="#Package-json" class="headerlink" title="Package json"></a>Package json</h4><p>执行npm init 便可以初始化一个package.json</p><ol><li><code>name</code>：项目名称，必须是唯一的字符串，通常采用小写字母和连字符的组合。</li><li><code>version</code>：项目版本号，通常采用语义化版本号规范。</li><li><code>description</code>：项目描述。</li><li><code>main</code>：项目的主入口文件路径，通常是一个 JavaScript 文件。</li><li><code>keywords</code>：项目的关键字列表，方便他人搜索和发现该项目。</li><li><code>author</code>：项目作者的信息，包括姓名、邮箱、网址等。</li><li><code>license</code>：项目的许可证类型，可以是自定义的许可证类型或者常见的开源许可证（如 MIT、Apache 等）。</li><li><code>dependencies</code>：项目所依赖的包的列表，这些包会在项目运行时自动安装。</li><li><code>devDependencies</code>：项目开发过程中所需要的包的列表，这些包不会随项目一起发布，而是只在开发时使用。</li><li><code>peerDependencies</code>：项目的同级依赖，即项目所需要的模块被其他模块所依赖。</li><li><code>scripts</code>：定义了一些脚本命令，比如启动项目、运行测试等。</li><li><code>repository</code>：项目代码仓库的信息，包括类型、网址等。</li><li><code>bugs</code>：项目的 bug 报告地址。</li><li><code>homepage</code>：项目的官方网站地址或者文档地址。</li></ol><h4 id="Npm-install-原理"><a href="#Npm-install-原理" class="headerlink" title="Npm install 原理"></a>Npm install 原理</h4><h5 id="在执行npm-install-的时候发生了什么？"><a href="#在执行npm-install-的时候发生了什么？" class="headerlink" title="在执行npm install 的时候发生了什么？"></a>在执行npm install 的时候发生了什么？</h5><p>首先安装的依赖都会存放在根目录的node_modules,默认采用扁平化的方式安装，并且排序规则.bin第一个然后@系列，再然后按照首字母排序abcd等，并且使用的算法是广度优先遍历，在遍历依赖树时，npm会首先处理项目根目录下的依赖，然后逐层处理每个依赖包的依赖，直到所有依赖都被处理完毕。在处理每个依赖时，npm会检查该依赖的版本号是否符合依赖树中其他依赖的版本要求，如果不符合，则会尝试安装适合的版本</p><h5 id="npm-install-后续流程"><a href="#npm-install-后续流程" class="headerlink" title="npm install 后续流程"></a>npm install 后续流程</h5><ol><li><p>从**.npmrc**文件中获取npm配置（项目级.npmrc =&gt; 用户级.npmrc =&gt; 全局的.npmrc =&gt; npm内置.npmrc）</p></li><li><p>检查 <strong>package-lock.json</strong>是否存在：</p><ul><li><strong>存在</strong>：对比<strong>package.json</strong> 和 <strong>package-lock.json</strong>，如果一致则检查缓存。如果不一致，则根据<strong>package.json</strong>中的语法和版本号更新依赖包。</li><li><strong>不存在</strong>：根据 package.json 中的依赖，解析依赖树。检查本地缓存，如果包已存在且完整性校验通过，则直接使用缓存中的包。如果包不存在或缓存被禁用，则从远程注册表获取，并存储到本地缓存，最后将包解压并放置到 <strong>node_modules</strong>。</li></ul></li><li><p><strong>package-lock.json</strong>：</p><ul><li>锁定版本记录依赖树详细信息</li><li>生成唯一key，缓存依赖包</li></ul></li></ol><h4 id="Npm-run-原理"><a href="#Npm-run-原理" class="headerlink" title="Npm run 原理"></a>Npm run 原理</h4><h5 id="npm-run-xxx-发生了什么"><a href="#npm-run-xxx-发生了什么" class="headerlink" title="npm run xxx 发生了什么"></a>npm run xxx 发生了什么</h5><p>读取package json 的scripts 对应的脚本命令(dev:vite),vite是个可执行脚本，他的查找规则是：</p><ul><li>先从当前项目的node_modules/.bin去查找可执行命令vite</li><li>如果没找到就去全局的node_modules 去找可执行命令vite</li><li>如果还没找到就去环境变量查找</li><li>再找不到就进行报错</li></ul><p>如果成功找到会发现有三个文件（因为nodejs 是跨平台的所以可执行命令兼容各个平台）</p><ul><li>.sh文件是给Linux unix Macos 使用</li><li>.cmd 给windows的cmd使用</li><li>.ps1 给windows的powerShell 使用</li></ul><h5 id="npm-生命周期"><a href="#npm-生命周期" class="headerlink" title="npm 生命周期"></a>npm 生命周期</h5><p>​    •    在运行指定脚本前后，会自动执行生命周期钩子（如果存在）：</p><p>​    •    pre <code>&lt;script-name&gt;</code>:</p><p>​    •    运行脚本前执行。例如，npm run build 前会执行 prebuild。</p><p>​    •    <code>&lt;script-name&gt;</code>:</p><p>​    •    执行定义的脚本。</p><p>​    •    post<code>&lt;script-name&gt;</code>:</p><p>​    •    运行脚本后执行。例如，npm run build 后会执行 postbuild。</p><h2 id="3-npx"><a href="#3-npx" class="headerlink" title="3.npx"></a>3.npx</h2><p>npx 是一个运行 npm 包的工具，随 Node.js 的 npm 版本 5.2.0 及以上一起发布。它的核心功能是让用户方便地运行本地或远程的 npm 包，而无需手动安装全局包。</p><p>npx的作用是在命令行中运行node包中的可执行文件，而不需要全局安装这些包。这可以使开发人员更轻松地管理包的依赖关系，并且可以避免全局污染的问题。它还可以帮助开发人员在项目中使用不同版本的包，而不会出现版本冲突的问题。</p><p><strong>npx 的优势</strong></p><ol><li>避免全局安装：<code>npx</code>允许你执行npm package，而不需要你先全局安装它。</li><li>总是使用最新版本：如果你没有在本地安装相应的npm package，<code>npx</code>会从npm的package仓库中下载并使用最新版。</li><li>执行任意npm包：<code>npx</code>不仅可以执行在<code>package.json</code>的<code>scripts</code>部分定义的命令，还可以执行任何npm package。</li><li>执行GitHub gist：<code>npx</code>甚至可以执行GitHub gist或者其他公开的JavaScript文件。</li></ol><p><strong>npx和npm区别</strong></p><p><code>npx</code>侧重于执行命令的，执行某个模块命令。虽然会自动安装模块，但是重在执行某个命令</p><p><code>npm</code>侧重于安装或者卸载某个模块的。重在安装，并不具备执行某个模块的功能。</p><table><thead><tr><th>特性</th><th>npm</th><th>npx</th></tr></thead><tbody><tr><td>用途</td><td>用于安装和管理 npm 包</td><td>用于直接执行 npm 包中的命令</td></tr><tr><td>全局安装</td><td>默认全局安装使用 npm install -g</td><td>无需全局安装，直接运行</td></tr><tr><td>版本控制</td><td>无法指定临时运行的包版本</td><td>可直接指定运行的版本</td></tr><tr><td>依赖清理</td><td>全局安装后需要手动清理</td><td>使用后自动清理临时文件</td></tr><tr><td>执行本地命令</td><td>需要指定完整路径（如 node_modules/.bin/<command>）</td><td>自动查找本地依赖并执行</td></tr></tbody></table><h2 id="4-nvm和nrm"><a href="#4-nvm和nrm" class="headerlink" title="4.nvm和nrm"></a>4.nvm和nrm</h2><p><strong>1. nvm (Node Version Manager)</strong></p><p>​    •    <strong>功能</strong>：nvm 是用于管理 Node.js 版本的工具。它允许开发者在同一台机器上安装和切换不同版本的 Node.js，避免了全局安装版本冲突的问题。</p><p>​    •    <strong>用途</strong>：用于安装、切换和卸载 Node.js 版本。非常适合需要在不同版本之间切换的开发环境（例如：开发、生产、测试环境）。</p><p>​    •    <strong>安装管理的对象</strong>：管理 Node.js 版本。</p><p>​    •    <strong>常用命令</strong>：</p><p>​    •    nvm install <code> &lt;version&gt;</code>：安装特定版本的 Node.js。</p><p>​    •    nvm use <code>&lt;version&gt;</code>：切换到指定版本的 Node.js。</p><p>​    •    nvm ls：列出已安装的版本。</p><p>​    •    nvm ls-remote：列出可用的 Node.js 版本。</p><p><strong>2. nrm (NPM Registry Manager)</strong></p><p>​    •    <strong>功能</strong>：nrm 是用于管理 NPM 镜像源的工具。它允许你快速切换不同的 NPM 源，尤其是在需要切换到国内源（如淘宝源）时，可以提高安装依赖的速度。</p><p>​    •    <strong>用途</strong>：用于管理和切换 NPM 的 registry 源。特别适用于在中国的开发者，能够方便地切换到如淘宝的 NPM 镜像源，以提高下载速度。</p><p>​    •    <strong>安装管理的对象</strong>：管理 NPM 镜像源。</p><p>​    •    <strong>常用命令</strong>：</p><p>​    •    nrm use<code> &lt;registry&gt;</code>：切换到指定的 NPM 源。</p><p>​    •    nrm ls：列出可用的 NPM 镜像源。</p><p>​    •    nrm add<code> &lt;name&gt; &lt;url&gt;</code>：添加一个自定义的 NPM 镜像源。</p><h2 id="5-模块化"><a href="#5-模块化" class="headerlink" title="5.模块化"></a>5.模块化</h2><h4 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h4><p>引入模块（require）支持四种格式</p><ol><li>支持引入内置模块例如 <code>http</code> <code>os</code> <code>fs</code> <code>child_process</code> 等nodejs内置模块</li><li>支持引入第三方模块<code>express</code> <code>md5</code> <code>koa</code> 等</li><li>支持引入自己编写的模块 ./ ../ 等</li><li>支持引入addon C++扩展模块 .node文件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;node:fs&#x27;</span>);  <span class="comment">// 导入核心模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);  <span class="comment">// 导入 node_modules 目录下的模块</span></span><br><span class="line"><span class="keyword">const</span> myModule = <span class="built_in">require</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);  <span class="comment">// 导入相对路径下的模块</span></span><br><span class="line"><span class="keyword">const</span> nodeModule = <span class="built_in">require</span>(<span class="string">&#x27;./myModule.node&#x27;</span>);  <span class="comment">// 导入扩展模块</span></span><br></pre></td></tr></table></figure><p>导出模块exports 和 module.exports</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果不想导出对象直接导出值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="ESM模块规范"><a href="#ESM模块规范" class="headerlink" title="ESM模块规范"></a>ESM模块规范</h4><p>引入模块 <strong>import</strong> 必须写在头部</p><blockquote><p>注意使用ESM模块的时候必须开启一个选项 打开package.json 设置 type:module</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果要引入json文件需要特殊处理 需要增加断言并且指定类型json node低版本不支持</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">&#x27;./data.json&#x27;</span> assert &#123; <span class="attr">type</span>: <span class="string">&quot;json&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure><p>加载模块的整体对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> all <span class="keyword">from</span> <span class="string">&#x27;xxx.js&#x27;</span></span><br></pre></td></tr></table></figure><p>动态导入模块</p><p>import静态加载不支持掺杂在逻辑中如果想动态加载请使用import函数模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./test.js&#x27;</span>).then()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块导出</p><ul><li>导出一个默认对象 default只能有一个不可重复export default</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>导出变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="Cjs-和-ESM-的区别"><a href="#Cjs-和-ESM-的区别" class="headerlink" title="Cjs 和 ESM 的区别"></a>Cjs 和 ESM 的区别</h4><ol><li>Cjs是基于运行时的同步加载，esm是基于编译时的异步加载</li><li>Cjs是可以修改值的，esm值并且不可修改（可读的）</li><li>Cjs不可以tree shaking，esm支持tree shaking</li><li>commonjs中顶层的this指向这个模块本身，而ES6中顶层this指向undefined</li></ol><h2 id="6-全局变量"><a href="#6-全局变量" class="headerlink" title="6.全局变量"></a>6.全局变量</h2><h4 id="如何在nodejs定义全局变量"><a href="#如何在nodejs定义全局变量" class="headerlink" title="如何在nodejs定义全局变量"></a>如何在nodejs定义全局变量</h4><p>在nodejs中使用<strong>global</strong>定义全局变量，定义的变量，可以在引入的文件中也可以访问到该变量，例如<code>a.js</code> <code>global.xxx = &#39;xxx&#39;</code> <code>require(&#39;xxx.js&#39;)</code>  xxx.js 也可以访问到该变量，在浏览器中我们定义的全局变量都在window,nodejs在global，不同的环境还需要判断，于是在ECMAScript 2020 出现了一个<code>globalThis</code>全局变量，在nodejs环境会自动切换成global ，浏览器环境自动切换window非常方便</p><h4 id="关于其他全局API"><a href="#关于其他全局API" class="headerlink" title="关于其他全局API"></a>关于其他全局API</h4><blockquote><p>由于nodejs中没有DOM和BOM，除了这些API，其他的ECMAscriptAPI基本都能用</p></blockquote><p>例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span> <span class="built_in">setInterval</span> <span class="built_in">Promise</span> <span class="built_in">Math</span>  <span class="built_in">console</span>  <span class="built_in">Date</span> fetch(node v18) 等...</span><br></pre></td></tr></table></figure><p>这些API 都是可以正常用的</p><h4 id="nodejs内置全局API"><a href="#nodejs内置全局API" class="headerlink" title="nodejs内置全局API"></a>nodejs内置全局API</h4><blockquote><p><strong><code>__dirname __filename 只能在cjs使用 esm规范没有这两个全局变量</code></strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__dirname</span><br></pre></td></tr></table></figure><p>它表示当前模块的所在<code>目录</code>的绝对路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__filename</span><br></pre></td></tr></table></figure><p>它表示当前模块<code>文件</code>的绝对路径，包括文件名和文件扩展名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure><h4 id="process"><a href="#process" class="headerlink" title="process"></a><strong>process</strong></h4><ol><li><code>process.argv</code>: 这是一个包含命令行参数的数组。第一个元素是Node.js的执行路径，第二个元素是当前执行的JavaScript文件的路径，之后的元素是传递给脚本的命令行参数。</li><li><code>process.env</code>: 这是一个包含当前环境变量的对象。您可以通过<code>process.env</code>访问并操作环境变量。</li><li><code>process.cwd()</code>: 这个方法返回当前工作目录的路径。</li><li><code>process.on(event, listener)</code>: 用于注册事件监听器。您可以使用<code>process.on</code>监听诸如<code>exit</code>、<code>uncaughtException</code>等事件，并在事件发生时执行相应的回调函数。</li><li><code>process.exit([code])</code>: 用于退出当前的Node.js进程。您可以提供一个可选的退出码作为参数。</li><li><code>process.pid</code>: 这个属性返回当前进程的PID（进程ID）。</li></ol><p>这些只是<code>process</code>对象的一些常用属性和方法，还有其他许多属性和方法可用于监控进程、设置信号处理、发送IPC消息等。</p><p>需要注意的是，<code>process</code>对象是一个全局对象，可以在任何模块中直接访问，无需导入或定义。</p><h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a><strong>Buffer</strong></h4><ol><li>创建 <code>Buffer</code> 实例：<ul><li><code>Buffer.alloc(size[, fill[, encoding]])</code>: 创建一个指定大小的新的<code>Buffer</code>实例，初始内容为零。<code>fill</code>参数可用于填充缓冲区，<code>encoding</code>参数指定填充的字符编码。</li><li><code>Buffer.from(array)</code>: 创建一个包含给定数组的<code>Buffer</code>实例。</li><li><code>Buffer.from(string[, encoding])</code>: 创建一个包含给定字符串的<code>Buffer</code>实例。</li></ul></li><li>读取和写入数据：<ul><li><code>buffer[index]</code>: 通过索引读取或写入<code>Buffer</code>实例中的特定字节。</li><li><code>buffer.length</code>: 获取<code>Buffer</code>实例的字节长度。</li><li><code>buffer.toString([encoding[, start[, end]]])</code>: 将<code>Buffer</code>实例转换为字符串。</li></ul></li><li>转换数据：<ul><li><code>buffer.toJSON()</code>: 将<code>Buffer</code>实例转换为JSON对象。</li><li><code>buffer.slice([start[, end]])</code>: 返回一个新的<code>Buffer</code>实例，其中包含原始<code>Buffer</code>实例的部分内容。</li></ul></li><li>其他方法：<ul><li><code>Buffer.isBuffer(obj)</code>: 检查一个对象是否是<code>Buffer</code>实例。</li><li><code>Buffer.concat(list[, totalLength])</code>: 将一组<code>Buffer</code>实例或字节数组连接起来形成一个新的<code>Buffer</code>实例。</li></ul></li></ol><p>请注意，从Node.js 6.0版本开始，<code>Buffer</code>构造函数的使用已被弃用，推荐使用<code>Buffer.alloc()</code>、<code>Buffer.from()</code>等方法来创建<code>Buffer</code>实例。</p><p><code>Buffer</code>类在处理文件、网络通信、加密和解密等操作中非常有用，尤其是在需要处理二进制数据时</p><h2 id="7-CSR-SSR-SEO"><a href="#7-CSR-SSR-SEO" class="headerlink" title="7.CSR SSR SEO"></a>7.CSR SSR SEO</h2><h4 id="CSR（Client-Side-Rendering）——客户端渲染"><a href="#CSR（Client-Side-Rendering）——客户端渲染" class="headerlink" title="CSR（Client-Side Rendering）——客户端渲染"></a><strong>CSR（Client-Side Rendering）——客户端渲染</strong></h4><p><strong>渲染时机</strong>：所有页面内容在客户端通过 JavaScript 渲染。</p><p><strong>工作流程</strong>：</p><pre><code>1. 浏览器加载一个基础 HTML 文件（通常包含空的` &lt;div&gt;` 标签）。1. 加载并执行 JavaScript（如 React、Vue 等框架）。1. JavaScript 渲染页面内容</code></pre><p><strong>优点</strong>：</p><pre><code>1. 页面切换流畅，适合单页应用（SPA）。1. 减少服务器压力，更多任务转移到客户端。</code></pre><p><strong>缺点</strong>：</p><pre><code>1. 初次加载慢，尤其是 JavaScript 文件较大时。1. 对 SEO 不友好，因为爬虫可能无法解析动态生成的内容。</code></pre><p><strong>适用场景</strong>：</p><ul><li>后台管理系统。</li><li>用户交互复杂、实时性强的应用（如聊天、仪表盘）</li></ul><h4 id="SSR（Server-Side-Rendering）——服务端渲染"><a href="#SSR（Server-Side-Rendering）——服务端渲染" class="headerlink" title="SSR（Server-Side Rendering）——服务端渲染"></a><strong>SSR（Server-Side Rendering）——服务端渲染</strong></h4><p><strong>渲染时机</strong>：页面内容在服务器生成，然后返回完整的 HTML。</p><p><strong>工作流程</strong>：</p><p>​    1. 用户请求页面时，服务器渲染完整的 HTML 页面。</p><p>​    2. 浏览器显示完整内容。</p><p>​    3. 后续通过 JavaScript 提供交互功能。</p><p><strong>优点</strong>：</p><p>​    1. 更快的首屏加载，用户可以更快看到内容。</p><p>​    2. 更好的 SEO 支持，搜索引擎爬虫可以直接读取 HTML 内容。</p><p><strong>缺点</strong>：</p><p>​    1.增加服务器负担，每次请求都需要渲染页面。</p><p>​    2.页面动态交互需要额外处理（如数据绑定）。</p><p><strong>适用场景</strong>：</p><ul><li>需要强 SEO 支持的内容型网站（如博客、电商）。</li><li>高度关注首屏加载速度的应用。</li></ul><h4 id="SEO（Search-Engine-Optimization）——搜索引擎优化"><a href="#SEO（Search-Engine-Optimization）——搜索引擎优化" class="headerlink" title="SEO（Search Engine Optimization）——搜索引擎优化"></a><strong>SEO（Search Engine Optimization）——搜索引擎优化</strong></h4><p><strong>目标</strong>：通过优化网站结构和内容，提高搜索引擎收录和排名，吸引更多自然流量。</p><p><strong>关键点</strong>：</p><ol><li><p><strong>内容优化</strong>：关键词、标题、描述等。</p></li><li><p><strong>技术优化</strong>：</p><ul><li><p>确保页面内容可被搜索引擎爬取（CSR 的内容需要特别处理）。</p></li><li><p>使用 SSR 或静态生成（SSG）提升爬虫的可见性。</p></li></ul></li><li><p><strong>性能优化</strong>：</p></li></ol><ul><li>提高页面加载速度。</li><li>使用 CDN、压缩资源等手段。</li></ul><h4 id="CSR-和-SSR-区别"><a href="#CSR-和-SSR-区别" class="headerlink" title="CSR 和 SSR 区别"></a>CSR 和 SSR 区别</h4><table><thead><tr><th>对比项</th><th><strong>CSR</strong></th><th>SSR</th></tr></thead><tbody><tr><td>首屏加载速度</td><td>较慢，需等待 JavaScript 渲染完成</td><td>较快，直接返回完整 HTML</td></tr><tr><td>SEO 支持</td><td>较差，需额外配置</td><td>较好，HTML 可被直接爬取</td></tr><tr><td>服务器压力</td><td>较小，渲染在客户端完成</td><td>较大，每次请求需服务器渲染</td></tr><tr><td>开发复杂度</td><td>较低，前后端分离</td><td>较高，需同时处理前端和后端渲染逻辑</td></tr><tr><td>适用场景</td><td>动态交互强的 SPA</td><td>内容型网站或注重首屏体验的应用</td></tr></tbody></table><h2 id="8-path"><a href="#8-path" class="headerlink" title="8.path"></a>8.path</h2><blockquote><p>path模块在不同的操作系统是有差异的(windows | posix)</p></blockquote><p><code>windows</code>大家肯定熟悉，<code>posix</code>可能大家没听说过</p><p><strong>posix（Portable Operating System Interface of UNIX）</strong></p><p>posix表示可移植操作系统接口，也就是定义了一套标准，遵守这套标准的操作系统有(unix,like unix,linux,macOs,windows wsl)，为什么要定义这套标准，比如在Linux系统启动一个进程需要调用<code>fork</code>函数,在windows启动一个进程需要调用<code>creatprocess</code>函数，这样就会有问题，比如我在linux写好了代码，需要移植到windows发现函数不统一，posix标准的出现就是为了解决这个问题。</p><p>Windows 并没有完全遵循 POSIX 标准。Windows 在设计上采用了不同于 POSIX 的路径表示方法。</p><p>在 Windows 系统中，路径使用反斜杠（<code>\</code>）作为路径分隔符。这与 POSIX 系统使用的正斜杠（<code>/</code>）是不同的。这是 Windows 系统的历史原因所致，早期的 Windows 操作系统采用了不同的设计选择。</p><h4 id="windows-posix-差异"><a href="#windows-posix-差异" class="headerlink" title="windows posix 差异"></a>windows posix 差异</h4><p><code>path.basename()</code> 方法返回的是给定路径中的最后一部分</p><p>在posix处理windows路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.basename(<span class="string">&#x27;C:\temp\myfile.html&#x27;</span>);</span><br><span class="line"><span class="comment">// 返回: &#x27;C:\temp\myfile.html&#x27;</span></span><br></pre></td></tr></table></figure><p>结果返回的并不对 应该返回 myfile.html</p><p>如果要在posix系统处理windows的路径需要调用对应操作系统的方法应该修改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.win32.basename(<span class="string">&#x27;C:\temp\myfile.html&#x27;</span>);</span><br></pre></td></tr></table></figure><p>返回 myfile.html</p><h4 id="path-dirname"><a href="#path-dirname" class="headerlink" title="path.dirname"></a>path.dirname</h4><p>这个API和basename正好互补</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.dirname(<span class="string">&#x27;/aaaa/bbbb/cccc/index.html&#x27;</span>)</span><br></pre></td></tr></table></figure><p>dirname API 返回 /aaaa/bbbb/cccc 除了最后一个路径的其他路径。</p><p>basename API 返回 最后一个路径 index.html</p><h4 id="path-extname"><a href="#path-extname" class="headerlink" title="path.extname"></a>path.extname</h4><p>这个API 用来返回扩展名例如/bbb/ccc/file.txt 返回就是.txt</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.extname(<span class="string">&#x27;/aaaa/bbbb/cccc/index.html.ccc.ddd.aaa&#x27;</span>)</span><br><span class="line"><span class="comment">//.aaa</span></span><br></pre></td></tr></table></figure><blockquote><p>如果有多个 <strong>.</strong> 返回最后一个 如果没有扩展名返回空</p></blockquote><h4 id="path-join"><a href="#path-join" class="headerlink" title="path.join"></a>path.join</h4><p>这个API 主要是用来拼接路径的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.join(<span class="string">&#x27;/foo&#x27;</span>,<span class="string">&#x27;/cxk&#x27;</span>,<span class="string">&#x27;/ikun&#x27;</span>)</span><br><span class="line"><span class="comment">// /foo/cxk/ikun</span></span><br></pre></td></tr></table></figure><blockquote><p>可以支持 .. ./ ../操作符</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.join(<span class="string">&#x27;/foo&#x27;</span>,<span class="string">&#x27;/cxk&#x27;</span>,<span class="string">&#x27;/ikun&#x27;</span>,<span class="string">&#x27;../&#x27;</span>)</span><br><span class="line"><span class="comment">// /foo/cxk/</span></span><br></pre></td></tr></table></figure><h4 id="path-resolve"><a href="#path-resolve" class="headerlink" title="path.resolve"></a>path.resolve</h4><p>用于将相对路径解析并且返回<code>绝对路径</code></p><p>如果传入了多个绝对路径 它将返回最右边的绝对路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(<span class="string">&#x27;/aaa&#x27;</span>,<span class="string">&#x27;/bbb&#x27;</span>,<span class="string">&#x27;/ccc&#x27;</span>)</span><br><span class="line"><span class="comment">//   /ccc</span></span><br></pre></td></tr></table></figure><p>传入绝对路径 + 相对路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(__dirname,<span class="string">&#x27;./index.js&#x27;</span>)</span><br><span class="line"><span class="comment">//  /User/xiaoman/DeskTop/node/index.js</span></span><br></pre></td></tr></table></figure><p>如果只传入相对路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(<span class="string">&#x27;./index.js&#x27;</span>)</span><br><span class="line"><span class="comment">// 返回工作目录 + index.js</span></span><br></pre></td></tr></table></figure><h4 id="path-parse-path-format"><a href="#path-parse-path-format" class="headerlink" title="path.parse  path.format"></a>path.parse  path.format</h4><p>path.format 和 path.parse 正好互补</p><p><strong>parse</strong></p><p>用于解析文件路径。它接受一个路径字符串作为输入，并返回一个包含路径各个组成部分的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">path.parse(<span class="string">&#x27;/home/user/dir/file.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  root: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  dir: <span class="string">&#x27;/home/user/dir&#x27;</span>,</span><br><span class="line">  base: <span class="string">&#x27;file.txt&#x27;</span>,</span><br><span class="line">  ext: <span class="string">&#x27;.txt&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;file&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>root</code>：路径的根目录，即 <code>/</code>。</li><li><code>dir</code>：文件所在的目录，即 <code>/home/user/documents</code>。</li><li><code>base</code>：文件名，即 <code>file.txt</code>。</li><li><code>ext</code>：文件扩展名，即 <code>.txt</code>。</li><li><code>name</code>：文件名去除扩展名，即 <code>file</code>。</li></ul><p><strong>format</strong> 正好相反 在把对象转回字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">path.format(&#123;</span><br><span class="line">    root: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    dir: <span class="string">&#x27;/home/user/documents&#x27;</span>,</span><br><span class="line">    base: <span class="string">&#x27;file.txt&#x27;</span>,</span><br><span class="line">    ext: <span class="string">&#x27;.txt&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;file&#x27;</span></span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="comment">// /home/user/dir/file.txt</span></span><br></pre></td></tr></table></figure><h2 id="9-os"><a href="#9-os" class="headerlink" title="9.os"></a>9.os</h2><p><strong>Nodejs os 模块可以跟操作系统进行交互</strong></p><p>Nodejs os 模块可以跟操作系统进行交互</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> os = <span class="built_in">require</span>(<span class="string">&quot;node:os&quot;</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>API</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td><strong>os.type()</strong></td><td>它在 Linux 上返回 <code>&#39;Linux&#39;</code>，在 macOS 上返回 <code>&#39;Darwin&#39;</code>，在 Windows 上返回 <code>&#39;Windows_NT&#39;</code></td></tr><tr><td>2</td><td><strong>os.platform()</strong></td><td>返回标识为其编译 Node.js 二进制文件的操作系统平台的字符串。 该值在编译时设置。 可能的值为 <code>&#39;aix&#39;</code>、<code>&#39;darwin&#39;</code>、<code>&#39;freebsd&#39;</code>、<code>&#39;linux&#39;</code>、<code>&#39;openbsd&#39;</code>、<code>&#39;sunos&#39;</code>、以及 <code>&#39;win32&#39;</code></td></tr><tr><td>3</td><td><strong>os.release()</strong></td><td>返回操作系统的版本例如10.xxxx win10</td></tr><tr><td>4</td><td><strong>os.homedir()</strong></td><td>返回用户目录 例如c:\user\xiaoman 原理就是 windows <code>echo %USERPROFILE% </code>posix $HOME</td></tr><tr><td>5</td><td><strong>os.arch()</strong></td><td>返回cpu的架构  可能的值为 <code>&#39;arm&#39;</code>、<code>&#39;arm64&#39;</code>、<code>&#39;ia32&#39;</code>、<code>&#39;mips&#39;</code>、<code>&#39;mipsel&#39;</code>、<code>&#39;ppc&#39;</code>、<code>&#39;ppc64&#39;</code>、<code>&#39;s390&#39;</code>、<code>&#39;s390x&#39;</code>、以及 <code>&#39;x64&#39;</code></td></tr><tr><td>6</td><td><strong>os.cpus()</strong></td><td>获取CPU的线程以及详细信息</td></tr><tr><td>7</td><td><strong>os.networkInterfaces()</strong></td><td>获取网络信息</td></tr></tbody></table><h2 id="10-process"><a href="#10-process" class="headerlink" title="10.process"></a>10.process</h2><p><code>process</code> 是Nodejs操作当前进程和控制当前进程的API，并且是挂载到globalThis下面的全局API</p><h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><p><strong>process.version：返回 Node.js 的版本号</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.version); <span class="comment">// 输出: &#x27;v18.16.0&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>process.versions：返回一个对象，包含 Node.js 和其依赖的版本信息。</strong></p><p><strong>process.platform：返回当前运行平台（如 ‘win32’、’linux’、’darwin’）</strong></p><p><strong>process.arch：返回当前 CPU 的架构（如 ‘x64’、’arm’）</strong></p><p><strong>process.pid：返回当前进程的 PID（进程 ID）</strong></p><p><strong>process.title：获取或设置进程的标题</strong></p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p><strong>process.env：返回包含环境变量的对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.env.PATH);</span><br><span class="line">process.env.MY_VAR = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(process.env.MY_VAR); <span class="comment">// 输出: &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a><strong>当前工作目录</strong></h4><p><strong>process.cwd()：返回当前工作目录</strong></p><p><strong>process.chdir(directory)：更改当前工作目录</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process.chdir(<span class="string">&#x27;/tmp&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(process.cwd()); <span class="comment">// 输出: &#x27;/tmp&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="进程运行信息"><a href="#进程运行信息" class="headerlink" title="进程运行信息"></a><strong>进程运行信息</strong></h4><p><strong>process.uptime()：返回当前进程的运行时间（以秒为单位）</strong></p><p><strong>process.memoryUsage()：返回一个对象，显示内存使用情况</strong></p><p><strong>process.hrtime([time])：返回高精度的时间，适合测量性能</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = process.hrtime();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> end = process.hrtime(start);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Time: <span class="subst">$&#123;end[<span class="number">0</span>]&#125;</span> seconds and <span class="subst">$&#123;end[<span class="number">1</span>]&#125;</span> nanoseconds`</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h4 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a><strong>标准输入输出</strong></h4><p><strong>process.stdin：获取用户输入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`You typed: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>process.stdout：输出到控制台</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.stdout.write(<span class="string">&#x27;Hello, World!\n&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>process.stderr:输出错误信息到控制台</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.stderr.write(<span class="string">&#x27;Error occurred!\n&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a><strong>信号处理</strong></h4><p><strong>process.on(event, callback):监听进程事件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Process exited with code: <span class="subst">$&#123;code&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">&#x27;SIGINT&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Caught interrupt signal&#x27;</span>);</span><br><span class="line">  process.exit();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>process.kill(pid, [signal]):向进程发送信号</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.kill(process.pid, <span class="string">&#x27;SIGTERM&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="退出进程"><a href="#退出进程" class="headerlink" title="退出进程"></a><strong>退出进程</strong></h4><p><strong>process.exit([code]):退出当前进程，默认 code 为 0。</strong></p><p><strong>process.exitCode:设置退出码，但不会立即退出。</strong></p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h4><p><strong>process.on(‘uncaughtException’, callback):捕获未处理的异常</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">&#x27;uncaughtException&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;Caught exception:&#x27;</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Test Error&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>process.on(‘unhandledRejection’, callback):捕获未处理的 Promise 拒绝</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">&#x27;unhandledRejection&#x27;</span>, <span class="function">(<span class="params">reason, promise</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;Unhandled Rejection at:&#x27;</span>, promise, <span class="string">&#x27;reason:&#x27;</span>, reason);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Promise Rejection&#x27;</span>));</span><br></pre></td></tr></table></figure><p>process 提供了强大的功能，用于管理和监控 Node.js 应用程序的生命周期，是编写 CLI 工具和系统级脚本的重要工具。</p><h2 id="11-child-process"><a href="#11-child-process" class="headerlink" title="11.child_process"></a><strong>11.child_process</strong></h2><p>在 Node.js 中，<strong>child_process</strong> 模块用于创建子进程，以便执行系统命令或运行其他脚本。通过这个模块，你可以执行 shell 命令、调用其他脚本、以及启动独立的子进程。</p><h4 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h4><p>Nodejs创建子进程共有<code>7个</code>API Sync同步API 不加是异步API</p><ol><li>spawn  执行命令</li><li>exec   执行命令</li><li>execFile   执行可执行文件</li><li>fork   创建node子进程</li><li><code>execSync</code> 执行命令 同步执行</li><li><code>execFileSync</code> 执行可执行文件 同步执行</li><li><code>spawnSync</code> 执行命令 同步执行</li></ol><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p><strong>exec：适合运行短时间的命令并获取命令的输出结果，输出会以缓冲区的形式返回，适合处理小量数据。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line">exec(<span class="string">&#x27;ls -la&#x27;</span>, <span class="function">(<span class="params">error, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`Error: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stderr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`Stderr: <span class="subst">$&#123;stderr&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Stdout: <span class="subst">$&#123;stdout&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>execFile：直接执行一个可执行文件（不通过 shell），更安全，因为它避免了 shell 注入攻击</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; execFile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line">execFile(<span class="string">&#x27;node&#x27;</span>, [<span class="string">&#x27;--version&#x27;</span>], <span class="function">(<span class="params">error, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`Error: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stderr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`Stderr: <span class="subst">$&#123;stderr&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Stdout: <span class="subst">$&#123;stdout&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>spawn：用于创建一个子进程并通过流（stream）处理数据，适合处理大量数据，或需要与子进程进行实时通信。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">&#x27;ls&#x27;</span>, [<span class="string">&#x27;-la&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">child.stdout.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Stdout: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.stderr.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`Stderr: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.on(<span class="string">&#x27;close&#x27;</span>, <span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Child process exited with code <span class="subst">$&#123;code&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>fork：专门用于创建 Node.js 子进程，加载一个独立的 JavaScript 模块，适合处理需要子进程与主进程通信的场景（通过 message 事件）。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; fork &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = fork(<span class="string">&#x27;child.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">child.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Message from child:&#x27;</span>, message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.send(&#123; <span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p><strong>execSync：同步执行命令，返回命令的标准输出。适用场景：需要立即获取结果并不介意阻塞主线程的情况。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; execSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> output = execSync(<span class="string">&#x27;ls -la&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(output.toString()); <span class="comment">// 将 Buffer 转为字符串</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`Error: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>execFileSync：同步执行一个文件，直接运行可执行文件，不经过 shell。适用场景：直接执行某个二进制文件或脚本，避免 shell 注入风险。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; execFileSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> output = execFileSync(<span class="string">&#x27;node&#x27;</span>, [<span class="string">&#x27;--version&#x27;</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(output.toString()); <span class="comment">// 输出 Node.js 版本</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`Error: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>spawnSync：同步生成子进程，用流（stream）处理数据。    适用场景：需要同步处理复杂的子进程任务，同时控制输入输出流。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawnSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = spawnSync(<span class="string">&#x27;ls&#x27;</span>, [<span class="string">&#x27;-la&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result.error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`Error: <span class="subst">$&#123;result.error.message&#125;</span>`</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result.stdout.toString()); <span class="comment">// 标准输出</span></span><br><span class="line">  <span class="built_in">console</span>.error(result.stderr.toString()); <span class="comment">// 标准错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-event"><a href="#12-event" class="headerlink" title="12.event"></a>12.event</h2><p><strong>on：用于绑定事件监听器</strong></p><p><strong>emit:用于触发事件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> emitter = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> emitter()</span><br><span class="line"><span class="comment">//监听test</span></span><br><span class="line">event.on(<span class="string">&#x27;test&#x27;</span>,<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">event.emit(<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;xmxmxmxmx&#x27;</span>) <span class="comment">//派发事件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>once:绑定的监听器只会被调用一次，之后自动移除。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emitter.once(eventName, listener);</span><br></pre></td></tr></table></figure><p><strong>off:移除指定事件的监听器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emitter.off(eventName, listener);</span><br></pre></td></tr></table></figure><p><strong>setMaxListeners:默认最大监听器数量是 10，可以通过 setMaxListeners 调整。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emitter.setMaxListeners(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>一些核心模块（如 fs、http）使用 EventEmitter 实现事件驱动。例如：</p><p><strong>http.Server</strong>：request 事件用于处理传入的 HTTP 请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.end(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Server running on port 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>process</strong></p><p>![image-20241230163536476](/Users/dayuyu/Library/Application Support/typora-user-images/image-20241230163536476.png)</p><p>打开nodejs 源码 搜索 <code>setupProcessObject</code> 这个函数</p><p>![image-20241230163615645](/Users/dayuyu/Library/Application Support/typora-user-images/image-20241230163615645.png)</p><ol><li>它首先引入 event模块</li><li>获取process 的原型对象</li><li>将evnet的原型对象设给了process 的原型对象</li><li>并且重新绑定上下文</li><li>将process 挂载到globalThis 所以我们可以全局访问这个API</li></ol><h2 id="13-unit"><a href="#13-unit" class="headerlink" title="13.unit"></a>13.unit</h2><p>util 是Node.js内部提供的很多实用或者工具类型的API，方便我们快速开发。</p><p><strong>util.promisify</strong>：使用util的<code>promisify</code> 改为promise 风格 Promiseify 接受 <code>original</code>一个函数体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; exec &#125; <span class="keyword">from</span> <span class="string">&#x27;node:child_process&#x27;</span></span><br><span class="line"><span class="keyword">import</span> util <span class="keyword">from</span> <span class="string">&#x27;node:util&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> execPromise = util.promisify(exec)</span><br><span class="line"></span><br><span class="line">execPromise(<span class="string">&#x27;node -v&#x27;</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res,<span class="string">&#x27;res&#x27;</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err,<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>util.callbackify</strong>:将promise类型的API变成 回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> util <span class="keyword">from</span> <span class="string">&#x27;node:util&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callback = util.callbackify(fn)</span><br><span class="line"></span><br><span class="line">callback(<span class="number">1222</span>,<span class="function">(<span class="params">err,val</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err,val)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>util.format</strong></p><ul><li><code>%s</code>: <code>String</code> 将用于转换除 <code>BigInt</code>、<code>Object</code> 和 <code>-0</code> 之外的所有值。 <code>BigInt</code> 值将用 <code>n</code> 表示，没有用户定义的 <code>toString</code> 函数的对象使用具有选项 <code>&#123; depth: 0, colors: false, compact: 3 &#125;</code> 的 <code>util.inspect()</code> 进行检查。</li><li><code>%d</code>: <code>Number</code> 将用于转换除 <code>BigInt</code> 和 <code>Symbol</code> 之外的所有值。</li><li><code>%i</code>: <code>parseInt(value, 10)</code> 用于除 <code>BigInt</code> 和 <code>Symbol</code> 之外的所有值。</li><li><code>%f</code>: <code>parseFloat(value)</code> 用于除 <code>Symbol</code> 之外的所有值。</li><li><code>%j</code>: JSON。 如果参数包含循环引用，则替换为字符串 <code>&#39;[Circular]&#39;</code>。</li><li><code>%o</code>: <code>Object</code>. 具有通用 JavaScript 对象格式的对象的字符串表示形式。 类似于具有选项 <code>&#123; showHidden: true, showProxy: true &#125;</code> 的 <code>util.inspect()</code>。 这将显示完整的对象，包括不可枚举的属性和代理。</li><li><code>%O</code>: <code>Object</code>. 具有通用 JavaScript 对象格式的对象的字符串表示形式。 类似于没有选项的 <code>util.inspect()</code>。 这将显示完整的对象，但不包括不可枚举的属性和代理。</li><li><code>%c</code>: <code>CSS</code>. 此说明符被忽略，将跳过任何传入的 CSS。</li><li><code>%%</code>: 单个百分号 (<code>&#39;%&#39;</code>)。 这不消费参数。</li></ul><p>语法 跟 C 语言的 <code>printf</code> 一样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">util.format(format, [args])</span><br></pre></td></tr></table></figure><p>例子 格式化一个字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">util.format(<span class="string">&#x27;%s-----%s %s/%s&#x27;</span>,<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;xm&#x27;</span>,<span class="string">&#x27;zs&#x27;</span>)</span><br><span class="line"><span class="comment">//foo-----bar xm/zs  可以返回指定的格式</span></span><br></pre></td></tr></table></figure><p>如果不传入格式化参数 就按空格分开</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">util.format(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">//1 2 3</span></span><br></pre></td></tr></table></figure><h2 id="14-fs"><a href="#14-fs" class="headerlink" title="14.fs"></a>14.fs</h2><p>在 Node.js 中，<code>fs</code> 模块是文件系统模块（File System module）的缩写，它提供了与文件系统进行交互的各种功能。通过 <code>fs</code> 模块，你可以执行诸如读取文件、写入文件、更改文件权限、创建目录等操作，<code>Node.js 核心API之一</code>。</p><h4 id="fs多种策略"><a href="#fs多种策略" class="headerlink" title="fs多种策略"></a>fs多种策略</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> fs2 <span class="keyword">from</span> <span class="string">&#x27;node:fs/promises&#x27;</span></span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line">fs2.readFile(<span class="string">&#x27;./index.txt&#x27;</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result.toString())</span><br><span class="line">&#125;)</span><br><span class="line">fs.readFile(<span class="string">&#x27;./index.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> txt = fs.readFileSync(<span class="string">&#x27;./index.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(txt.toString())</span><br></pre></td></tr></table></figure><ol><li>fs支持同步和异步两种模式 增加了<code>Sync</code> fs 就会采用同步的方式运行代码，会阻塞下面的代码，不加Sync就是异步的模式不会阻塞。</li><li>fs新增了promise版本，只需要在引入包后面增加/promise即可，fs便可支持promise回调。</li><li>fs返回的是一个buffer二进制数据 每两个十六进制数字表示一个字节</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Buffer <span class="number">31</span> e3 <span class="number">80</span> <span class="number">81</span> e9 <span class="number">82</span> a3 e4 b8 <span class="number">80</span> e5 b9 b4 e5 <span class="number">86</span> b3 e8 b5 9b ef bc 8c e6 <span class="number">98</span> af <span class="number">53</span> <span class="number">53</span> <span class="number">47</span> e5 af b9 e6 <span class="number">88</span> <span class="number">98</span> <span class="number">53</span> 4b <span class="number">54</span> ef bc 8c e6 9c <span class="number">80</span> e7 bb <span class="number">88</span> e6 af <span class="number">94</span> e5 ... <span class="number">635</span> more bytes&gt;</span><br></pre></td></tr></table></figure><h4 id="常用API-介绍"><a href="#常用API-介绍" class="headerlink" title="常用API 介绍"></a>常用API 介绍</h4><p>读取文件 <code>readFile</code> 第一个参数 读取的路径， 第二个参数是个配置项</p><p><code>encoding</code> 支持各种编码 utf-8之类的</p><p>flag 就很多了</p><ul><li><p><code>&#39;a&#39;</code>: 打开文件进行追加。 如果文件不存在，则创建该文件。</p></li><li><p><code>&#39;ax&#39;</code>: 类似于 <code>&#39;a&#39;</code> 但如果路径存在则失败。</p></li><li><p><code>&#39;a+&#39;</code>: 打开文件进行读取和追加。 如果文件不存在，则创建该文件。</p></li><li><p><code>&#39;ax+&#39;</code>: 类似于 <code>&#39;a+&#39;</code> 但如果路径存在则失败。</p></li><li><p><code>&#39;as&#39;</code>: 以同步模式打开文件进行追加。 如果文件不存在，则创建该文件。</p></li><li><p><code>&#39;as+&#39;</code>: 以同步模式打开文件进行读取和追加。 如果文件不存在，则创建该文件。</p></li><li><p><code>&#39;r&#39;</code>: 打开文件进行读取。 如果文件不存在，则会发生异常。</p></li><li><p><code>&#39;r+&#39;</code>: 打开文件进行读写。 如果文件不存在，则会发生异常。</p></li><li><p><code>&#39;rs+&#39;</code>: 以同步模式打开文件进行读写。 指示操作系统绕过本地文件系统缓存。</p><p>这主要用于在 NFS 挂载上打开文件，因为它允许跳过可能过时的本地缓存。 它对 I/O 性能有非常实际的影响，因此除非需要，否则不建议使用此标志。</p><p>这不会将 <code>fs.open()</code> 或 <code>fsPromises.open()</code> 变成同步阻塞调用。 如果需要同步操作，应该使用类似 <code>fs.openSync()</code> 的东西。</p></li><li><p><code>&#39;w&#39;</code>: 打开文件进行写入。 创建（如果它不存在）或截断（如果它存在）该文件。</p></li><li><p><code>&#39;wx&#39;</code>: 类似于 <code>&#39;w&#39;</code> 但如果路径存在则失败。</p></li><li><p><code>&#39;w+&#39;</code>: 打开文件进行读写。 创建（如果它不存在）或截断（如果它存在）该文件。</p></li><li><p><code>&#39;wx+&#39;</code>: 类似于 <code>&#39;w+&#39;</code> 但如果路径存在则失败。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs2 <span class="keyword">from</span> <span class="string">&#x27;node:fs/promises&#x27;</span></span><br><span class="line"></span><br><span class="line">fs2.readFile(<span class="string">&#x27;./index.txt&#x27;</span>,&#123;</span><br><span class="line">    encoding:<span class="string">&quot;utf8&quot;</span>,</span><br><span class="line">    flag:<span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result.toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用可读流读取 使用场景适合读取<code>大文件</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;./index.txt&#x27;</span>,&#123;</span><br><span class="line">    encoding:<span class="string">&quot;utf8&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">readStream.on(<span class="string">&#x27;data&#x27;</span>,<span class="function">(<span class="params">chunk</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">readStream.on(<span class="string">&#x27;end&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;close&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>创建文件夹</strong> 如果开启 <strong>recursive</strong> 可以递归创建多个文件夹</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.mkdir(<span class="string">&#x27;path/test/ccc&#x27;</span>, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;,<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>删除文件夹 如果开启<strong>recursive</strong> 递归删除全部文件夹</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.rm(<span class="string">&#x27;path&#x27;</span>, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;,<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p><strong>重命名文件</strong> 第一个参数原始名称 第二个参数新的名称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.renameSync(<span class="string">&#x27;./test.txt&#x27;</span>,<span class="string">&#x27;./test2.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>监听文件的变化</strong> 返回监听的事件如<code>change</code>,和监听的内容<code>filename</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.watch(<span class="string">&#x27;./test2.txt&#x27;</span>,<span class="function">(<span class="params">event,filename</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event,filename)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>写入内容</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;node:fs&#x27;</span>)</span><br><span class="line">fs.writeFileSync(<span class="string">&#x27;index.txt&#x27;</span>, <span class="string">&#x27;java之父\n余胜军&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>追加内容</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line">fs.writeFileSync(<span class="string">&#x27;index.txt&#x27;</span>, <span class="string">&#x27;\nvue之父\n鱿鱼须&#x27;</span>,&#123;</span><br><span class="line">    flag: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;node:fs&#x27;</span>)</span><br><span class="line">fs.appendFileSync(<span class="string">&#x27;index.txt&#x27;</span>, <span class="string">&#x27;\nunshift创始人\n麒麟哥&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>可写流</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;node:fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> verse = [</span><br><span class="line">    <span class="string">&#x27;待到秋来九月八&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;我花开后百花杀&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;冲天香阵透长安&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;满城尽带黄金甲&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> writeStream = fs.createWriteStream(<span class="string">&#x27;index.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">verse.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    writeStream.write(item + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">writeStream.end()</span><br><span class="line"></span><br><span class="line">writeStream.on(<span class="string">&#x27;finish&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;写入完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以创建一个可写流 打开一个通道，可以一直写入数据，用于处理大量的数据写入，写入完成之后调用end 关闭可写流，监听finish 事件 写入完成</p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>fs的源码是通过 <code>C++</code> 层的 <code>FSReqCallback</code> 这个类 对<code>libuv</code> 的<code>uv_fs_t</code> 的一个封装，其实也就是将我们fs 的参数透传给 <code>libuv</code> 层</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建目录的异步操作函数，通过uv_fs_mkdir函数调用</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// - loop: 事件循环对象，用于处理异步操作</span></span><br><span class="line"><span class="comment">// - req: 文件系统请求对象，用于保存操作的状态和结果</span></span><br><span class="line"><span class="comment">// - path: 要创建的目录的路径</span></span><br><span class="line"><span class="comment">// - mode: 目录的权限模式 777 421</span></span><br><span class="line"><span class="comment">// - cb: 操作完成后的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_fs_mkdir</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">uv_fs_t</span>* req,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">char</span>* path,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                uv_fs_cb cb)</span> </span>&#123;</span><br><span class="line">  INIT(MKDIR);</span><br><span class="line">  PATH;</span><br><span class="line">  req-&gt;mode = mode;</span><br><span class="line">  <span class="keyword">if</span> (cb != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">if</span> (uv__iou_fs_mkdir(loop, req))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  POST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;node:fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;./index.txt&#x27;</span>, &#123;</span><br><span class="line">    encoding: <span class="string">&#x27;utf-8&#x27;</span>,</span><br><span class="line">    flag: <span class="string">&#x27;r&#x27;</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为什么先走setImmediate 呢，而不是fs</p><p>Node.js 读取文件的时候是使用libuv进行调度的</p><p>而setImmediate是由V8进行调度的</p><p>文件读取完成后 libuv 才会将 fs的结果 推入V8的队列</p><h4 id="硬链接-和-软连接"><a href="#硬链接-和-软连接" class="headerlink" title="硬链接 和 软连接"></a>硬链接 和 软连接</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.linkSync(<span class="string">&#x27;./index.txt&#x27;</span>, <span class="string">&#x27;./index2.txt&#x27;</span>) <span class="comment">//硬链接</span></span><br><span class="line"></span><br><span class="line">fs.symlinkSync(<span class="string">&#x27;./index.txt&#x27;</span>, <span class="string">&#x27;./index3.txt&#x27;</span> ,<span class="string">&quot;file&quot;</span>) <span class="comment">//软连接</span></span><br></pre></td></tr></table></figure><p>硬链接的作用和用途如下：</p><ol><li>文件共享：硬链接允许多个文件名指向同一个文件，这样可以在不同的位置使用不同的文件名引用相同的内容。这样的共享文件可以节省存储空间，并且在多个位置对文件的修改会反映在所有引用文件上。</li><li>文件备份：通过创建硬链接，可以在不复制文件的情况下创建文件的备份。如果原始文件发生更改，备份文件也会自动更新。这样可以节省磁盘空间，并确保备份文件与原始文件保持同步。</li><li>文件重命名：通过创建硬链接，可以为文件创建一个新的文件名，而无需复制或移动文件。这对于需要更改文件名但保持相同内容和属性的场景非常有用。</li></ol><p>软链接的一些特点和用途如下：</p><ol><li>软链接可以创建指向文件或目录的引用。这使得你可以在不复制或移动文件的情况下引用它们，并在不同位置使用不同的文件名访问相同的内容。</li><li>软链接可以用于创建快捷方式或别名，使得你可以通过一个简短或易记的路径来访问复杂或深层次的目录结构。</li><li>软链接可以用于解决文件或目录的位置变化问题。如果目标文件或目录被移动或重命名，只需更新软链接的目标路径即可，而不需要修改引用该文件或目录的其他代码。</li></ol><h2 id="15-crypto"><a href="#15-crypto" class="headerlink" title="15.crypto"></a>15.crypto</h2><p>crypto模块的目的是为了提供通用的<code>加密和哈希算法</code>。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。nodejs用C/C++实现这些算法后，通过crypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。</p><p>密码学是计算机科学中的一个重要领域，它涉及到加密、解密、哈希函数和数字签名等技术。Node.js是一个流行的服务器端JavaScript运行环境，它提供了强大的密码学模块，使开发人员能够轻松地在其应用程序中实现各种密码学功能。本文将介绍密码学的基本概念，并探讨Node.js中常用的密码学API。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;node:crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个随机的 16 字节的初始化向量 (IV)</span></span><br><span class="line"><span class="keyword">const</span> iv = Buffer.from(crypto.randomBytes(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个随机的 32 字节的密钥</span></span><br><span class="line"><span class="keyword">const</span> key = crypto.randomBytes(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建加密实例，使用 AES-256-CBC 算法，提供密钥和初始化向量</span></span><br><span class="line"><span class="keyword">const</span> cipher = crypto.createCipheriv(<span class="string">&quot;aes-256-cbc&quot;</span>, key, iv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对输入数据进行加密，并输出加密结果的十六进制表示</span></span><br><span class="line">cipher.update(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="string">&quot;hex&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> result = cipher.final(<span class="string">&quot;hex&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="keyword">const</span> de = crypto.createDecipheriv(<span class="string">&quot;aes-256-cbc&quot;</span>, key, iv);</span><br><span class="line">de.update(result, <span class="string">&quot;hex&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> decrypted = de.final(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Decrypted:&quot;</span>, decrypted);</span><br></pre></td></tr></table></figure><p>对称加密是一种简单而快速的加密方式，它使用相同的密钥（称为对称密钥）来进行加密和解密。这意味着发送者和接收者在加密和解密过程中都使用相同的密钥。对称加密算法的加密速度很快，适合对大量数据进行加密和解密操作。然而，对称密钥的安全性是一个挑战，因为需要确保发送者和接收者都安全地共享密钥，否则有风险被未授权的人获取密钥并解密数据。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;node:crypto&#x27;</span>)</span><br><span class="line"><span class="comment">// 生成 RSA 密钥对</span></span><br><span class="line"><span class="keyword">const</span> &#123; privateKey, publicKey &#125; = crypto.generateKeyPairSync(<span class="string">&#x27;rsa&#x27;</span>, &#123;</span><br><span class="line">  modulusLength: <span class="number">2048</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要加密的数据</span></span><br><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用公钥进行加密</span></span><br><span class="line"><span class="keyword">const</span> encrypted = crypto.publicEncrypt(publicKey, Buffer.from(text, <span class="string">&#x27;utf-8&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥进行解密</span></span><br><span class="line"><span class="keyword">const</span> decrypted = crypto.privateDecrypt(privateKey, encrypted);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(decrypted.toString());</span><br></pre></td></tr></table></figure><p>非对称加密使用一对密钥，分别是公钥和私钥。发送者使用接收者的公钥进行加密，而接收者使用自己的私钥进行解密。公钥可以自由分享给任何人，而私钥必须保密。非对称加密算法提供了更高的安全性，因为即使公钥泄露，只有持有私钥的接收者才能解密数据。然而，非对称加密算法的加密速度相对较慢，不适合加密大量数据。因此，在实际应用中，通常使用非对称加密来交换对称密钥，然后使用对称加密算法来加密实际的数据。</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;node:crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要计算哈希的数据</span></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建哈希对象，并使用 MD5 算法</span></span><br><span class="line"><span class="keyword">const</span> hash = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新哈希对象的数据</span></span><br><span class="line">hash.update(text);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算哈希值，并以十六进制字符串形式输出</span></span><br><span class="line"><span class="keyword">const</span> hashValue = hash.digest(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Text:&#x27;</span>, text);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hash:&#x27;</span>, hashValue);</span><br></pre></td></tr></table></figure><p>哈希函数具有以下特点：</p><ol><li>固定长度输出：不论输入数据的大小，哈希函数的输出长度是固定的。例如，常见的哈希函数如 MD5 和 SHA-256 生成的哈希值长度分别为 128 位和 256 位。</li><li>不可逆性：哈希函数是单向的，意味着从哈希值推导出原始输入数据是非常困难的，几乎不可能。即使输入数据发生微小的变化，其哈希值也会完全不同。</li><li>唯一性：哈希函数应该具有较低的碰撞概率，即不同的输入数据生成相同的哈希值的可能性应该非常小。这有助于确保哈希值能够唯一地标识输入数据。</li></ol><p>使用场景</p><ol><li>我们可以避免密码明文传输 使用md5加密或者sha256</li><li>验证文件完整性，读取文件内容生成md5 如果前端上传的md5和后端的读取文件内部的md5匹配说明文件是完整的</li></ol><h2 id="16-cli"><a href="#16-cli" class="headerlink" title="16.cli"></a>16.cli</h2><h4 id="什么是脚手架？"><a href="#什么是脚手架？" class="headerlink" title="什么是脚手架？"></a>什么是脚手架？</h4><p>例如:<code>vue-cli</code> <code>Angular CLI</code>  <code>Create React App</code></p><p>编写自己的脚手架是指创建一个定制化的工具，用于快速生成项目的基础结构和代码文件，以及提供一些常用的命令和功能。通过编写自己的脚手架，你可以定义项目的目录结构、文件模板，管理项目的依赖项，生成代码片段，以及提供命令行接口等功能</p><ol><li>项目结构：脚手架定义了项目的目录结构，包括源代码、配置文件、静态资源等。</li><li>文件模板：脚手架提供了一些预定义的文件模板，如HTML模板、样式表、配置文件等，以加快开发者创建新文件的速度。</li><li>命令行接口：脚手架通常提供一个命令行接口，通过输入命令和参数，开发者可以执行各种任务，如创建新项目、生成代码文件、运行测试等。</li><li>依赖管理：脚手架可以帮助开发者管理项目的依赖项，自动安装和配置所需的库和工具。</li><li>代码生成：脚手架可以生成常见的代码结构，如组件、模块、路由等，以提高开发效率。</li><li>配置管理：脚手架可以提供一些默认的配置选项，并允许开发者根据需要进行自定义配置。</li></ol><p>![image-20241231170909079](/Users/dayuyu/Library/Application Support/typora-user-images/image-20241231170909079.png)</p><h4 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h4><ul><li><strong><code>commander</code></strong></li></ul><blockquote><p>Commander 是一个用于构建命令行工具的 npm 库。它提供了一种简单而直观的方式来创建命令行接口，并处理命令行参数和选项。使用 Commander，你可以轻松定义命令、子命令、选项和帮助信息。它还可以处理命令行的交互，使用户能够与你的命令行工具进行交互</p></blockquote><ul><li><strong><code>inquirer</code></strong></li></ul><blockquote><p>Inquirer 是一个强大的命令行交互工具，用于与用户进行交互和收集信息。它提供了各种丰富的交互式提示（如输入框、选择列表、确认框等），可以帮助你构建灵活的命令行界面。通过 Inquirer，你可以向用户提出问题，获取用户的输入，并根据用户的回答采取相应的操作。</p></blockquote><ul><li><strong><code>ora</code></strong></li></ul><blockquote><p>Ora 是一个用于在命令行界面显示加载动画的 npm 库。它可以帮助你在执行耗时的任务时提供一个友好的加载状态提示。Ora 提供了一系列自定义的加载动画，如旋转器、进度条等，你可以根据需要选择合适的加载动画效果，并在任务执行期间显示对应的加载状态。</p></blockquote><ul><li><strong><code>download-git-repo</code></strong></li></ul><blockquote><p>Download-git-repo 是一个用于下载 Git 仓库的 npm 库。它提供了一个简单的接口，可以方便地从远程 Git 仓库中下载项目代码。你可以指定要下载的仓库和目标目录，并可选择指定分支或标签。Download-git-repo 支持从各种 Git 托管平台（如 GitHub、GitLab、Bitbucket 等）下载代码。</p></blockquote><h4 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h4><ul><li>index.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="keyword">import</span> &#123; program &#125; <span class="keyword">from</span> <span class="string">&#x27;commander&#x27;</span></span><br><span class="line"><span class="keyword">import</span> inquirer <span class="keyword">from</span> <span class="string">&#x27;inquirer&#x27;</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; checkPath, downloadTemp &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils.js&#x27;</span></span><br><span class="line"><span class="keyword">let</span> json = fs.readFileSync(<span class="string">&#x27;./package.json&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">json = <span class="built_in">JSON</span>.parse(json)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">program.version(json.version) <span class="comment">//创建版本号</span></span><br><span class="line"><span class="comment">//添加create 命令 和 别名crt 以及描述 以及 执行完成之后的动作</span></span><br><span class="line">program.command(<span class="string">&#x27;create &lt;project&gt;&#x27;</span>).alias(<span class="string">&#x27;ctr&#x27;</span>).description(<span class="string">&#x27;create a new project&#x27;</span>).action(<span class="function">(<span class="params">project</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//命令行交互工具</span></span><br><span class="line">    inquirer.prompt([</span><br><span class="line">        &#123;</span><br><span class="line">        type: <span class="string">&#x27;input&#x27;</span>, <span class="comment">// 输入</span></span><br><span class="line">    name: <span class="string">&#x27;projectName&#x27;</span>, <span class="comment">// 返回值的key</span></span><br><span class="line">    message: <span class="string">&#x27;project name&#x27;</span>, <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">default</span>: project <span class="comment">// 默认值</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            type: <span class="string">&#x27;confirm&#x27;</span>,</span><br><span class="line">            name: <span class="string">&#x27;isTs&#x27;</span>,</span><br><span class="line">            message: <span class="string">&#x27;是否支持typeScript&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]).then(<span class="function">(<span class="params">answers</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkPath(answers.projectName)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;文件已存在&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (answers.isTs) &#123;</span><br><span class="line">            downloadTemp(<span class="string">&#x27;ts&#x27;</span>, answers.projectName)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            downloadTemp(<span class="string">&#x27;js&#x27;</span>, answers.projectName)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">program.parse(process.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么第一行要写 <code>#!/usr/bin/env node</code></p><p>这是一个 特殊的注释 用于告诉操作系统用node解释器去执行这个文件，而不是显式地调用 <code>node</code> 命令</p><ul><li>utils.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> download <span class="keyword">from</span> <span class="string">&#x27;download-git-repo&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ora <span class="keyword">from</span> <span class="string">&#x27;ora&#x27;</span></span><br><span class="line"><span class="keyword">const</span> spinner = ora(<span class="string">&#x27;下载中...&#x27;</span>)</span><br><span class="line"><span class="comment">//验证路径</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> checkPath = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.existsSync(path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> downloadTemp = <span class="function">(<span class="params">branch,project</span>) =&gt;</span> &#123;</span><br><span class="line">    spinner.start()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        download(<span class="string">`direct:https://gitee.com/chinafaker/vue-template.git#<span class="subst">$&#123;branch&#125;</span>`</span>, project , &#123; <span class="attr">clone</span>: <span class="literal">true</span>, &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">                <span class="built_in">console</span>.log(err)</span><br><span class="line">            &#125;</span><br><span class="line">            resolve()</span><br><span class="line">            spinner.succeed(<span class="string">&#x27;下载完成&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>package.json</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;type&quot;: &quot;module&quot;, //使用import需要设置这个</span><br><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">   &quot;vue-cli&quot;: &quot;src/index.js&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>用于生成软连接挂载到全局，便可以全局执行vue-cli 这个命令，配置完成之后 需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><h2 id="17-zlib"><a href="#17-zlib" class="headerlink" title="17.zlib"></a>17.zlib</h2><p>在 Node.js 中，<code>zlib</code> 模块提供了对数据压缩和解压缩的功能，以便在应用程序中减少数据的传输大小和提高性能。该模块支持多种压缩算法，包括 Deflate、Gzip 和 Raw Deflate。</p><p><code>zlib</code> 模块的主要作用如下：</p><ol><li>数据压缩：使用 <code>zlib</code> 模块可以将数据以无损压缩算法（如 Deflate、Gzip）进行压缩，减少数据的大小。这在网络传输和磁盘存储中特别有用，可以节省带宽和存储空间。</li><li>数据解压缩：<code>zlib</code> 模块还提供了对压缩数据的解压缩功能，可以还原压缩前的原始数据。</li><li>流压缩：<code>zlib</code> 模块支持使用流（<code>Stream</code>）的方式进行数据的压缩和解压缩。这种方式使得可以对大型文件或网络数据流进行逐步处理，而不需要将整个数据加载到内存中。</li><li>压缩格式支持：<code>zlib</code> 模块支持多种常见的压缩格式，如 Gzip 和 Deflate。这些格式在各种应用场景中广泛使用，例如 HTTP 响应的内容编码、文件压缩和解压缩等。</li></ol><p>使用 <code>zlib</code> 模块进行数据压缩和解压缩可以帮助优化应用程序的性能和资源利用。通过减小数据的大小，可以减少网络传输的时间和带宽消耗，同时减少磁盘上的存储空间。此外，<code>zlib</code> 模块还提供了丰富的选项和方法，使得开发者可以根据具体需求进行灵活的压缩和解压缩操作。</p><h3 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h3><p>压缩一个txt文件<strong>gzip</strong>  <code>index.txt(439kb)</code>   <code>压缩完index.txt.gz(4b)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入所需的模块</span></span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>); <span class="comment">// zlib 模块提供数据压缩和解压缩功能</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;node:fs&#x27;</span>); <span class="comment">// 引入 Node.js 的 fs 模块用于文件操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可读流和可写流</span></span><br><span class="line"><span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;index.txt&#x27;</span>); <span class="comment">// 创建可读流，读取名为 index.txt 的文件</span></span><br><span class="line"><span class="keyword">const</span> writeStream = fs.createWriteStream(<span class="string">&#x27;index.txt.gz&#x27;</span>); <span class="comment">// 创建可写流，将压缩后的数据写入 index.txt.gz 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用管道将可读流中的数据通过 Gzip 压缩，再通过管道传输到可写流中进行写入</span></span><br><span class="line">readStream.pipe(zlib.createGzip()).pipe(writeStream)</span><br></pre></td></tr></table></figure><p>解压 <strong>gzip</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;index.txt.gz&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> writeStream = fs.createWriteStream(<span class="string">&#x27;index2.txt&#x27;</span>)</span><br><span class="line">readStream.pipe(zlib.createGunzip()).pipe(writeStream)</span><br></pre></td></tr></table></figure><p>无损压缩 <code>deflate</code>  使用 createDeflate方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;index.txt&#x27;</span>); <span class="comment">// 创建可读流，读取名为 index.txt 的文件</span></span><br><span class="line"><span class="keyword">const</span> writeStream = fs.createWriteStream(<span class="string">&#x27;index.txt.deflate&#x27;</span>); <span class="comment">// 创建可写流，将压缩后的数据写入 index.txt.deflate 文件</span></span><br><span class="line">readStream.pipe(zlib.createDeflate()).pipe(writeStream);</span><br></pre></td></tr></table></figure><p>解压 <strong>deflate</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">&#x27;index.txt.deflate&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> writeStream = fs.createWriteStream(<span class="string">&#x27;index3.txt&#x27;</span>)</span><br><span class="line">readStream.pipe(zlib.createInflate()).pipe(writeStream)</span><br></pre></td></tr></table></figure><h3 id="gzip-和-deflate-区别"><a href="#gzip-和-deflate-区别" class="headerlink" title="gzip 和 deflate 区别"></a>gzip 和 deflate 区别</h3><ol><li>压缩算法：Gzip 使用的是 Deflate 压缩算法，该算法结合了 LZ77 算法和哈夫曼编码。LZ77 算法用于数据的重复字符串的替换和引用，而哈夫曼编码用于进一步压缩数据。</li><li>压缩效率：Gzip 压缩通常具有更高的压缩率，因为它使用了哈夫曼编码来进一步压缩数据。哈夫曼编码根据字符的出现频率，将较常见的字符用较短的编码表示，从而减小数据的大小。</li><li>压缩速度：相比于仅使用 Deflate 的方式，Gzip 压缩需要更多的计算和处理时间，因为它还要进行哈夫曼编码的步骤。因此，在压缩速度方面，Deflate 可能比 Gzip 更快。</li><li>应用场景：Gzip 压缩常用于文件压缩、网络传输和 HTTP 响应的内容编码。它广泛应用于 Web 服务器和浏览器之间的数据传输，以减小文件大小和提高网络传输效率。</li></ol><h3 id="http请求压缩"><a href="#http请求压缩" class="headerlink" title="http请求压缩"></a>http请求压缩</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//deflate 压缩前(8.2kb)` -&gt; `压缩后(236b)</span></span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;node:http&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> txt = <span class="string">&#x27;test&#x27;</span>.repeat(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//res.setHeader(&#x27;Content-Encoding&#x27;,&#x27;gzip&#x27;)</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-Encoding&#x27;</span>,<span class="string">&#x27;deflate&#x27;</span>)</span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-type&#x27;</span>,<span class="string">&#x27;text/plan;charset=utf-8&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">const</span> result = zlib.deflateSync(txt);</span><br><span class="line">    res.end(result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="comment">//gizp 压缩前(8.2kb)` -&gt; `压缩后(245b)</span></span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;node:http&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> txt = <span class="string">&#x27;test&#x27;</span>.repeat(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-Encoding&#x27;</span>,<span class="string">&#x27;gzip&#x27;</span>)</span><br><span class="line">    <span class="comment">//res.setHeader(&#x27;Content-Encoding&#x27;,&#x27;deflate&#x27;)</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Content-type&#x27;</span>,<span class="string">&#x27;text/plan;charset=utf-8&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">const</span> result = zlib.gzipSync(txt);</span><br><span class="line">    res.end(result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><h2 id="18-http"><a href="#18-http" class="headerlink" title="18.http"></a>18.http</h2><p>在 Node.js 中，你可以使用 http 模块创建 HTTP 服务器或客户端。</p><h3 id="创建-HTTP-服务器"><a href="#创建-HTTP-服务器" class="headerlink" title="创建 HTTP 服务器"></a>创建 HTTP 服务器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;);</span><br><span class="line">  res.end(<span class="string">&#x27;Hello, Node.js HTTP Server!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Server running at http://localhost:3000/&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>✅ <strong>解释</strong>：</p><ul><li> http.createServer() 创建一个 HTTP 服务器。</li><li> req 是请求对象，res 是响应对象。</li><li> res.writeHead(200, { ‘Content-Type’: ‘text/plain’ }) 设置 HTTP 头部信息。</li><li> res.end() 结束响应并发送数据。</li><li> server.listen(3000, callback) 监听 <strong>3000 端口</strong>。</li></ul><h3 id="创建-HTTP-客户端请求"><a href="#创建-HTTP-客户端请求" class="headerlink" title="创建 HTTP 客户端请求"></a>创建 HTTP 客户端请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  hostname: <span class="string">&#x27;jsonplaceholder.typicode.com&#x27;</span>,</span><br><span class="line">  path: <span class="string">&#x27;/posts/1&#x27;</span>,</span><br><span class="line">  method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = http.request(options, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">    data += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  res.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Response:&#x27;</span>, data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.on(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;Request error:&#x27;</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure><p>✅ <strong>解释</strong>：</p><ul><li> 使用 http.request(options, callback) 发起 HTTP 请求。</li><li> 监听 res.on(‘data’, callback) 处理数据流。</li><li> res.on(‘end’, callback) 处理请求完成后的逻辑。</li><li> req.end() 结束请求。</li></ul><h3 id="处理-JSON-数据"><a href="#处理-JSON-数据" class="headerlink" title="处理 JSON 数据"></a><strong>处理 JSON 数据</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span> &#125;);</span><br><span class="line">  res.end(<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">message</span>: <span class="string">&#x27;Hello, JSON!&#x27;</span> &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;JSON Server running at http://localhost:3000/&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>✅ <strong>解释</strong>：</p><ul><li> res.writeHead(200, { ‘Content-Type’: ‘application/json’ }) 设置 JSON 响应。</li><li> JSON.stringify() 转换对象为 JSON 字符串。</li></ul><h3 id="解析-URL-路由"><a href="#解析-URL-路由" class="headerlink" title="解析 URL 路由"></a><strong>解析 URL 路由</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> parsedUrl = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (parsedUrl.pathname === <span class="string">&#x27;/hello&#x27;</span>) &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;);</span><br><span class="line">    res.end(<span class="string">&#x27;Hello, World!&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">404</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;);</span><br><span class="line">    res.end(<span class="string">&#x27;Not Found&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Server running at http://localhost:3000/&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>✅ <strong>解释</strong>：</p><ul><li>使用 url.parse(req.url, true) 解析 URL。</li><li>根据 pathname 处理不同的路由。</li></ul><h2 id="19-反向代理"><a href="#19-反向代理" class="headerlink" title="19.反向代理"></a>19.反向代理</h2><h3 id="什么是反向代理"><a href="#什么是反向代理" class="headerlink" title="什么是反向代理?"></a>什么是反向代理?</h3><p>反向代理（Reverse Proxy）是一种网络通信模式，它充当服务器和客户端之间的中介，将客户端的请求转发到一个或多个后端服务器，并将后端服务器的响应返回给客户端。</p><ol><li>负载均衡：反向代理可以根据预先定义的算法将请求分发到多个后端服务器，以实现负载均衡。这样可以避免某个后端服务器过载，提高整体性能和可用性。</li><li>高可用性：通过反向代理，可以将请求转发到多个后端服务器，以提供冗余和故障转移。如果一个后端服务器出现故障，代理服务器可以将请求转发到其他可用的服务器，从而实现高可用性。</li><li>缓存和性能优化：反向代理可以缓存静态资源或经常访问的动态内容，以减轻后端服务器的负载并提高响应速度。它还可以通过压缩、合并和优化资源等技术来优化网络性能。</li><li>安全性：反向代理可以作为防火墙，保护后端服务器免受恶意请求和攻击。它可以过滤恶意请求、检测和阻止攻击，并提供安全认证和访问控制。</li><li>域名和路径重写：反向代理可以根据特定的规则重写请求的域名和路径，以实现 URL 路由和重定向。这对于系统架构的灵活性和可维护性非常有用。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote><p>用到的库 <code>http-proxy-middleware</code></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install http-proxy-middleware</span><br></pre></td></tr></table></figure><p><strong>根目录自定义配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aiolimp.config.js</span><br></pre></td></tr></table></figure><p>配置proxy代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    server:&#123;</span><br><span class="line">        proxy:&#123;</span><br><span class="line">        <span class="comment">//代理的路径</span></span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                target: <span class="string">&#x27;http://localhost:3000&#x27;</span>, <span class="comment">//转发的地址</span></span><br><span class="line">                changeOrigin: <span class="literal">true</span>, <span class="comment">//是否有跨域</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js 实现层</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;node:http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;node:fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;node:url&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> html = fs.readFileSync(<span class="string">&#x27;./index.html&#x27;</span>) <span class="comment">//给html文件起个服务</span></span><br><span class="line"><span class="keyword">const</span> &#123;createProxyMiddleware&#125; = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./aiolimp.config.js&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;pathname&#125; = url.parse(req.url)</span><br><span class="line">    <span class="keyword">const</span> proxyList = <span class="built_in">Object</span>.keys(config.server.proxy) <span class="comment">//获取代理的路径</span></span><br><span class="line">    <span class="keyword">if</span>(proxyList.includes(pathname))&#123; <span class="comment">//如果请求的路径在里面匹配到 就进行代理</span></span><br><span class="line">        <span class="keyword">const</span> proxy = createProxyMiddleware(config.server.proxy[pathname]) <span class="comment">//代理</span></span><br><span class="line">        proxy(req,res)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(proxyList)</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    res.end(html) <span class="comment">//返回html</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">80</span>) <span class="comment">//监听端口</span></span><br></pre></td></tr></table></figure><p>test.js 因为我们从80端口转发到3000端口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;node:http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;node:url&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> &#123;pathname&#125; = url.parse(req.url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pathname === <span class="string">&#x27;/api&#x27;</span>)&#123;</span><br><span class="line">        res.end(<span class="string">&#x27;success proxy&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;).listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">          fetch(<span class="string">&#x27;/api&#x27;</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>res.text()).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(res);</span></span><br><span class="line">          &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">这样就从80代理到了3000端口 并且无跨域</span><br></pre></td></tr></table></figure><h2 id="20-动静分离"><a href="#20-动静分离" class="headerlink" title="20.动静分离"></a>20.<strong>动静分离</strong></h2><p><strong>动静分离</strong>（Separation of Dynamic and Static Content）是一种 <strong>优化网站性能</strong> 的架构模式。它的核心思想是：</p><ul><li><strong>动态请求</strong>（API、数据库交互）交给 <strong>Node.js 或后端服务器</strong> 处理。</li><li><strong>静态资源</strong>（HTML、CSS、JS、图片）交给 <strong>CDN 或 Nginx</strong> 处理，以减少服务器压力，加快访问速度。</li></ul><p><strong>动静分离的几种实现方式</strong></p><p><strong>方式 1：Node.js 直接托管静态资源</strong></p><p>如果你的项目是一个 <strong>Node.js</strong> 应用（比如 Express），可以使用 express.static 提供静态资源：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 托管静态资源</span></span><br><span class="line">app.use(<span class="string">&#x27;/static&#x27;</span>, express.static(<span class="string">&#x27;public&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// API 接口</span></span><br><span class="line">app.get(<span class="string">&#x27;/api/data&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.json(&#123; <span class="attr">message</span>: <span class="string">&#x27;This is a dynamic response&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Server running at http://localhost:8080&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>✅ <strong>优点</strong>：</p><p>​    •    <strong>简单易用</strong>，不需要额外配置服务器。</p><p>​    •    <strong>适用于小型应用</strong>，开发环境测试很方便。</p><p>❌ <strong>缺点</strong>：</p><p>​    •    <strong>性能不如 Nginx/CDN</strong>，流量大时会影响 API 请求性能。</p><p>​    •    <strong>不适合生产环境</strong>。</p><p><strong>方式 2：Nginx + Node.js 动静分离</strong></p><p><strong>Nginx</strong> 非常适合动静分离，它可以：</p><p>​    •    <strong>直接返回静态资源</strong>，不经过 Node.js，提高性能。</p><p>​    •    <strong>将 API 请求代理到 Node.js</strong>，保证后端业务逻辑正常运行。</p><p>📌 <strong>示例：Nginx 配置</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 静态资源处理</span></span><br><span class="line">    <span class="attribute">location</span> /static/ &#123;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 代理 API 请求到 Node.js 服务器</span></span><br><span class="line">    <span class="attribute">location</span> /api/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:3000;  <span class="comment"># 你的 Node.js API 服务</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ <strong>优点</strong>：</p><p>​    •    <strong>Nginx 处理静态资源，减少 Node.js 服务器压力</strong>。</p><p>​    •    <strong>缓存优化</strong>，提高访问速度。</p><p>​    •    <strong>更适合高并发场景</strong>。</p><p><strong>方式 3：CDN + Node.js 动静分离</strong></p><p>如果你的网站 <strong>用户量大、覆盖范围广</strong>，可以使用 <strong>CDN（内容分发网络）</strong>：</p><p>​    •    <strong>静态资源</strong>（HTML/CSS/JS/图片）托管到 CDN，如 <strong>Cloudflare、阿里云 OSS、七牛云</strong>。</p><p>​    •    <strong>API 请求</strong> 仍然由 <strong>Node.js 处理</strong>。</p><p>📌 <strong>示例：前端 Vue/React 配置静态资源 CDN</strong></p><p>在 vite.config.js 或 webpack.config.js 里设置 <strong>CDN 地址</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  build: &#123;</span><br><span class="line">    rollupOptions: &#123;</span><br><span class="line">      output: &#123;</span><br><span class="line">        assetFileNames: <span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="regexp">/\.(gif|jpe?g|png|svg|css|js)$/</span>.test(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">`https://cdn.example.com/static/<span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;[name].[ext]&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>✅ <strong>优点</strong>：</p><p>​    •    <strong>全球加速</strong>，适合跨区域用户。</p><p>​    •    <strong>CDN 自动缓存</strong>，减少服务器带宽消耗。</p><p>​    •    <strong>API 和静态资源完全解耦，提升稳定性</strong>。</p><p>❌ <strong>缺点</strong>：</p><p>​    •    <strong>CDN 需要额外的成本</strong>（不过很多云厂商有免费额度）。</p><p>​    •    <strong>文件更新时要刷新 CDN 缓存</strong>。</p><p>🚀 <strong>推荐方案</strong>：</p><p>​    •    <strong>小项目</strong>：直接用 express.static() 处理静态资源。</p><p>​    •    <strong>中大型项目</strong>：使用 <strong>Nginx 代理</strong>，让它处理静态资源，Node.js 只负责 API。</p><p>​    •    <strong>超大流量项目</strong>：结合 <strong>CDN</strong>，最大化加速访问。</p><h2 id="21-防盗链"><a href="#21-防盗链" class="headerlink" title="21.防盗链"></a>21.防盗链</h2><p>防盗链（Hotlinking）是指在网页或其他网络资源中，通过直接链接到其他网站上的图片、视频或其他媒体文件，从而显示在自己的网页上。这种行为通常会给被链接的网站带来额外的带宽消耗和资源浪费，而且可能侵犯了原始网站的版权。</p><p>为了防止盗链，网站管理员可以采取一些措施：</p><ol><li>通过HTTP引用检查：网站可以检查HTTP请求的来源，如果来源网址与合法的来源不匹配，就拒绝提供资源。这可以通过服务器配置文件或特定的脚本实现。</li><li>使用Referrer检查：网站可以检查HTTP请求中的Referrer字段，该字段指示了请求资源的来源页面。如果Referrer字段不符合预期，就拒绝提供资源。这种方法可以在服务器配置文件或脚本中实现。</li><li>使用访问控制列表（ACL）：网站管理员可以配置服务器的访问控制列表，只允许特定的域名或IP地址访问资源，其他来源的请求将被拒绝。</li><li>使用防盗链插件或脚本：一些网站平台和内容管理系统提供了专门的插件或脚本来防止盗链。这些工具可以根据需要配置，阻止来自未经授权的网站的盗链请求。</li><li>使用水印技术：在图片或视频上添加水印可以帮助识别盗链行为，并提醒用户资源的来源。</li></ol><p><strong>1.防盗链一般主要就是验证<code>host</code> 或者 <code>referer</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> whitelist = [<span class="string">&#x27;localhost&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止热链中间件</span></span><br><span class="line"><span class="keyword">const</span> preventHotLinking = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//浏览器直接访问静态资源是不会携带referer字段的，需要在html中发起一个访问静态资源的请求才会携带     referer字段</span></span><br><span class="line">  <span class="keyword">const</span> referer = req.get(<span class="string">&#x27;referer&#x27;</span>); <span class="comment">// 获取请求头部中的 referer 字段</span></span><br><span class="line">  <span class="keyword">if</span> (referer) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; hostname &#125; = <span class="keyword">new</span> URL(referer); <span class="comment">// 从 referer 中解析主机名</span></span><br><span class="line">    <span class="keyword">if</span> (!whitelist.includes(hostname)) &#123; <span class="comment">// 检查主机名是否在白名单中</span></span><br><span class="line">      res.status(<span class="number">403</span>).send(<span class="string">&#x27;Forbidden&#x27;</span>); <span class="comment">// 如果不在白名单中，返回 403 Forbidden</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next(); <span class="comment">// 如果在白名单中，继续处理下一个中间件或路由</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(preventHotLinking); <span class="comment">// 应用防止热链中间件</span></span><br><span class="line">app.use(<span class="string">&#x27;/assets&#x27;</span>, express.static(<span class="string">&#x27;static&#x27;</span>)); <span class="comment">// 处理静态资源请求</span></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Listening on port 3000&#x27;</span>); <span class="comment">// 启动服务器，监听端口3000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>2.基于 Token 认证</strong></p><p>如果防盗链更严格，可以使用<strong>签名 Token 认证</strong>，例如：</p><ul><li><p>访问静态资源时，前端附带一个临时 Token（如 <a href="https://yourwebsite.com/images/logo.png?token=abc123%EF%BC%89%E3%80%82">https://yourwebsite.com/images/logo.png?token=abc123）。</a></p></li><li><p>服务器校验 Token 是否合法，合法才返回资源。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SECRET_KEY = <span class="string">&#x27;your-secret-key&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 Token</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateToken</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> crypto.createHmac(<span class="string">&#x27;sha256&#x27;</span>, SECRET_KEY).update(filePath).digest(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件：检查 Token</span></span><br><span class="line">app.use(<span class="string">&#x27;/images&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; token &#125; = req.query;</span><br><span class="line">    <span class="keyword">const</span> filePath = req.path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!token || token !== generateToken(filePath)) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.status(<span class="number">403</span>).send(<span class="string">&#x27;Invalid Token&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/images&#x27;</span>, express.static(path.join(__dirname, <span class="string">&#x27;images&#x27;</span>)));</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><ul><li><p>在请求资源时，前端需要带上 token（比如 logo.png?token=xyz）。</p></li><li><p>服务器验证 token 是否匹配，否则拒绝访问。</p></li></ul><p><strong>3.Nginx 配合 Express 防盗链</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images/ &#123;</span><br><span class="line">    <span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> yourwebsite.com;</span><br><span class="line">    <span class="attribute">if</span> ($invalid_referer) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Node" scheme="http://aiolimp.com/categories/Node/"/>
    
    
    <category term="Node" scheme="http://aiolimp.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://aiolimp.com/2023/08/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://aiolimp.com/2023/08/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-08-12T08:57:49.000Z</published>
    <updated>2025-04-12T09:36:25.359Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>是为一个对象提供一个代用品或占位符，以便控制对它的访问</p><blockquote><p>假设当A 在心情好的时候收到花，小明表白成功的几率有</p></blockquote><p>60%，而当A 在心情差的时候收到花，小明表白的成功率无限趋近于0。 小明跟A 刚刚认识两天，还无法辨别A 什么时候心情好。如果不合时宜地把花送给A，花 被直接扔掉的可能性很大，这束花可是小明吃了7 天泡面换来的。 但是A 的朋友B 却很了解A，所以小明只管把花交给B，B 会监听A 的心情变化，然后选 择A 心情好的时候把花转交给A，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Flower = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> xiaoming = &#123;</span><br><span class="line">  sendFlower: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flower = <span class="keyword">new</span> Flower()</span><br><span class="line">    target.receiveFlower(flower)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> B = &#123;</span><br><span class="line">  receiveFlower: <span class="function"><span class="keyword">function</span>(<span class="params">flower</span>) </span>&#123;</span><br><span class="line">    A.listenGoodMood(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      A.receiveFlower(flower)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> A = &#123;</span><br><span class="line">  receiveFlower: <span class="function"><span class="keyword">function</span>(<span class="params">flower</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;收到花&#x27;</span>+ flower)</span><br><span class="line">  &#125;,</span><br><span class="line">  listenGoodMood: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn()</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xiaoming.sendFlower(B)</span><br></pre></td></tr></table></figure><p><strong>场景</strong></p><ul><li>HTML元 素事件代理</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#ul&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  ul.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(event.target);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>ES6 的 proxy <a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/proxy">阮一峰Proxy</a></li><li>jQuery.proxy()方法</li></ul><p><strong>优点</strong></p><ul><li>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用</li><li>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；</li></ul><p><strong>缺点</strong></p><ul><li>处理请求速度可能有差别，非直接访问存在开销</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="设计模式" scheme="http://aiolimp.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://aiolimp.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://aiolimp.com/2023/08/12/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://aiolimp.com/2023/08/12/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-08-12T08:57:49.000Z</published>
    <updated>2025-04-12T09:43:43.790Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>大家知道一部智能手机的基本组成是操作系统（Operating System，我们下面缩写作 OS）和硬件（HardWare）组成。所以说如果我要开一个山寨手机工厂，那我这个工厂里必须是既准备好了操作系统，也准备好了硬件，才能实现手机的<strong>量产</strong>。考虑到操作系统和硬件这两样东西背后也存在不同的厂商，而我现在<strong>并不知道我下一个生产线到底具体想生产一台什么样的手机</strong>，我只知道手机必须有这两部分组成，所以我先来一个抽象类来<strong>约定住这台手机的基本组成</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobilePhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提供操作系统的接口</span></span><br><span class="line">    <span class="function"><span class="title">createOS</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;抽象工厂方法不允许直接调用，你需要将我重写！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 提供硬件的接口</span></span><br><span class="line">    <span class="function"><span class="title">createHardWare</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;抽象工厂方法不允许直接调用，你需要将我重写！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>楼上这个类，除了约定手机流水线的通用能力之外，啥也不干。如果你尝试让它干点啥，比如 new 一个 <code>MobilePhoneFactory</code> 实例，并尝试调用它的实例方法。它还会给你报错，提醒你“我不是让你拿去new一个实例的，我就是个定规矩的”。在抽象工厂模式里，楼上这个类就是我们食物链顶端最大的 <code>Boss——AbstractFactory</code>（抽象工厂）。</p><p>抽象工厂不干活，具体工厂（ConcreteFactory）来干活！当我们明确了生产方案，明确某一条手机生产流水线具体要生产什么样的手机了之后，就可以化抽象为具体，比如我现在想要一个专门生产 Android 系统 + 高通硬件的手机的生产线，我给这类手机型号起名叫 FakeStar，那我就可以为 FakeStar 定制一个具体工厂：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体工厂继承自抽象工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FakeStarFactory</span> <span class="keyword">extends</span> <span class="title">MobilePhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">createOS</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 提供安卓系统实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndroidOS()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">createHardWare</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 提供高通硬件实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QualcommHardWare()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在提供安卓系统的时候，调用了两个构造函数：AndroidOS 和 QualcommHardWare，它们分别用于生成具体的操作系统和硬件实例。像这种被我们拿来用于 new 出具体对象的类，叫做具体产品类（ConcreteProduct）。具体产品类往往不会孤立存在，不同的具体产品类往往有着共同的功能，比如安卓系统类和苹果系统类，它们都是操作系统，都有着可以<strong>操控手机硬件系统</strong>这样一个最基本的功能。因此我们可以用一个<strong>抽象产品（AbstractProduct）类</strong>来声明这一类产品应该具有的基本功能（众：什么抽象产品？？？要这些玩意儿干啥？老夫写代码就是一把梭，为啥不让我老老实实一个一个写具体类？？？大家稍安勿躁，先把例子看完，下文会有解释）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义操作系统这类产品的抽象产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">controlHardWare</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象产品方法不允许直接调用，你需要将我重写！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体操作系统的具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidOS</span> <span class="keyword">extends</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">controlHardWare</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会用安卓的方式去操作硬件&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleOS</span> <span class="keyword">extends</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">controlHardWare</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会用🍎的方式去操作硬件&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>硬件类产品同理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义手机硬件这类产品的抽象产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HardWare</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 手机硬件的共性方法，这里提取了“根据命令运转”这个共性</span></span><br><span class="line">    <span class="function"><span class="title">operateByOrder</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象产品方法不允许直接调用，你需要将我重写！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体硬件的具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QualcommHardWare</span> <span class="keyword">extends</span> <span class="title">HardWare</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">operateByOrder</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会用高通的方式去运转&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiWare</span> <span class="keyword">extends</span> <span class="title">HardWare</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">operateByOrder</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会用小米的方式去运转&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>好了，如此一来，当我们需要生产一台FakeStar手机时，我们只需要这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是我的手机</span></span><br><span class="line"><span class="keyword">const</span> myPhone = <span class="keyword">new</span> FakeStarFactory()</span><br><span class="line"><span class="comment">// 让它拥有操作系统</span></span><br><span class="line"><span class="keyword">const</span> myOS = myPhone.createOS()</span><br><span class="line"><span class="comment">// 让它拥有硬件</span></span><br><span class="line"><span class="keyword">const</span> myHardWare = myPhone.createHardWare()</span><br><span class="line"><span class="comment">// 启动操作系统(输出‘我会用安卓的方式去操作硬件’)</span></span><br><span class="line">myOS.controlHardWare()</span><br><span class="line"><span class="comment">// 唤醒硬件(输出‘我会用高通的方式去运转’)</span></span><br><span class="line">myHardWare.operateByOrder()</span><br></pre></td></tr></table></figure><p>关键的时刻来了——假如有一天，FakeStar过气了，我们需要产出一款新机投入市场，这时候怎么办？我们是不是<strong>不需要对抽象工厂MobilePhoneFactory做任何修改</strong>，只需要拓展它的种类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newStarFactory</span> <span class="keyword">extends</span> <span class="title">MobilePhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">createOS</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 操作系统实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">createHardWare</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 硬件实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么个操作，<strong>对原有的系统不会造成任何潜在影响</strong> 所谓的“对拓展开放，对修改封闭”就这么圆满实现了。前面我们之所以要实现<strong>抽象产品类</strong>，也是同样的道理。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大家现在回头对比一下抽象工厂和简单工厂的思路，思考一下：它们之间有哪些异同？</p><p>它们的共同点，在于都<strong>尝试去分离一个系统中变与不变的部分</strong>。它们的不同在于<strong>场景的复杂度</strong>。在简单工厂的使用场景里，处理的对象是类，并且是一些非常好对付的类——它们的共性容易抽离，同时因为逻辑本身比较简单，故而不苛求代码可扩展性。抽象工厂本质上处理的其实也是类，但是是一帮非常棘手、繁杂的类，这些类中不仅能划分出门派，还能划分出等级，同时存在着千变万化的扩展可能性——这使得我们必须对<strong>共性</strong>作更特别的处理、使用抽象类去降低扩展的成本，同时需要对类的性质作划分，于是有了这样的四个关键角色：</p><ul><li><strong>抽象工厂（抽象类，它不能被用于生成具体实例）：</strong> 用于声明最终目标产品的共性。在一个系统里，抽象工厂可以有多个（大家可以想象我们的手机厂后来被一个更大的厂收购了，这个厂里除了手机抽象类，还有平板、游戏机抽象类等等），每一个抽象工厂对应的这一类的产品，被称为“产品族”。</li><li><strong>具体工厂（用于生成产品族里的一个具体的产品）：</strong> 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。</li><li><strong>抽象产品（抽象类，它不能被用于生成具体实例）：</strong> 上面我们看到，具体工厂里实现的接口，会依赖一些类，这些类对应到各种各样的具体的细粒度产品（比如操作系统、硬件等），这些具体产品类的共性各自抽离，便对应到了各自的抽象产品类。</li><li><strong>具体产品（用于生成产品族里的一个具体的产品所依赖的更细粒度的产品）：</strong> 比如我们上文中具体的一种操作系统、或具体的一种硬件等。</li></ul><p>抽象工厂模式的定义，是<strong>围绕一个超级工厂创建其他工厂</strong>。本节内容对一些工作年限不多的同学来说可能不太友好，但抽象工厂目前来说在JS世界里也应用得并不广泛，所以大家不必拘泥于细节，只需留意以下三点：</p><ol><li>学会用 ES6 模拟 JAVA 中的抽象类；</li><li>了解抽象工厂模式中四个角色的定位与作用；</li><li>对“开放封闭原则”形成自己的理解，知道它好在哪，知道执行它的必要性。</li></ol><p>如果能对这三点有所掌握，那么这一节的目的就达到了，最难搞、最难受的抽象工厂也就告一段落了。</p><h3 id="最后，再跟大家谈谈学习"><a href="#最后，再跟大家谈谈学习" class="headerlink" title="最后，再跟大家谈谈学习"></a>最后，再跟大家谈谈学习</h3><p>现在我们回到开篇抛出的那个问题——抽象工厂对于各位而言的价值是什么？这么一个看似鸡肋、其实也确实不怎么常用的一个设计模式，凭什么值得我们花这么大力气去理解它？原因有三：</p><p><strong>其一：</strong> 开篇我们说过，<strong>前端工程师首先是软件工程师</strong>。只会写 JavaScript、只理解 JavaScript、只通过 JavaScript 去理解软件世界，是一件可怕的事情，它会窄化你的技术视野——因为 JavaScript 只是编程语言中的一个分支，准确地说，它是一个后辈。虽说它确实很流行，但它还不够强大（正是因为不够强大，所以在演化发展的过程中必然需要借鉴其它优秀语言的优秀特性，也会渐渐遇到其它语言的应用场景，不信大家看看 ES6789 都做了什么，再看看遍地开花的 TypeScript）。</p><p>但写这本小册并不是为了把大家指去学 Java/C++，而是为了以最小的时间成本帮大家去理解设计模式的套路和原则。比起要求大家为了这个设计模式去理解强类型语言、去理解强类型语言里的应用场景，我更希望能在这儿用 JavaScript 把这个东西给说清楚，把那些关键的设计模式概念在这儿给大家引出来——哪怕你当下用到它的场景还不是那么多（相信以当下前端语言和前端应用的发展速度和发展趋势来看，它会有用的：））。</p><p><strong>其二：</strong> 在大家今后的职业生涯里，可能会不止一次地遇到服务端/客户端出身、或者单纯对受试者知识广度有疯狂执念的各种不同背景不同脑回路的面试官。在他们的世界里，不知道抽象工厂就像不知道 <code>this</code> 一样恐怖：）。所以，<strong>要学</strong>。</p><p><strong>其三：</strong> 也是最重要的一点。前面我们说过，设计模式的“术”说到底是在佐证它的“道”。充分理解了设计原则后，设计模式纵有 1w 种也难不倒大家。<strong>抽象工厂是佐证“开放封闭原则”的良好素材</strong>，通过本节的学习，相信大家会对这个抽象的概念有更加具体和感性的认知。在后面的章节中，“开放封闭”作为各位的老朋友，会被反复提及。有了本节的平稳过渡，相信大家在后续的学习中可以真正做到心中有数、游刃有余。</p><p>说了这么多，无非是想传达给大家一个学习态度：<strong>不要小看那些看似“无用”的知识</strong>。</p><p>技术，尤其是前端技术，它的更新迭代速度是非常快的。仅仅因为“这个技术点我现在用不到”而推开摆在眼前的知识，是一种非常糟糕的学习方法——它会极大地限制你的能力和你职业生涯的可能性。举个例子，React 新版本推出的 Fiber 架构现在很火，很多同学认为这是个特别新潮的玩意儿——它新吗？新个屁！作为一种架构模式，它在软件领域早就有过不同姿势的生产实践了，React 并不是 Fiber 的发明者，而是 Fiber 的使用者和受益者。</p><p>同理，包括 ES2015 刚出来的时候，有同学说这个也没见过、那个也要重新学，累死了累死了，学不动了想转行…哎，其实它们都是软件世界里存在了很久很久的模式和知识点啊同学们。试想如果这份知识曾经摆在你面前的时候你没有拒绝它，此刻你的学习成本又该低了多少呢？</p><p>设计模式之外的东西，我们点到即止，剩下的就看大家的悟性和造化了。 接下来，我们一起看点更好玩的东西~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="设计模式" scheme="http://aiolimp.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://aiolimp.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="http://aiolimp.com/2023/08/12/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://aiolimp.com/2023/08/12/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-08-12T08:57:49.000Z</published>
    <updated>2025-04-12T11:52:46.415Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>一部智能手机的基本组成是操作系统（Operating System，我们下面缩写作 OS）和硬件（HardWare）组成。所以说如果我要开一个山寨手机工厂，那我这个工厂里必须是既准备好了操作系统，也准备好了硬件，才能实现手机的<strong>量产</strong>。考虑到操作系统和硬件这两样东西背后也存在不同的厂商，而我现在<strong>并不知道我下一个生产线到底具体想生产一台什么样的手机</strong>，我只知道手机必须有这两部分组成，所以我先来一个抽象类来<strong>约定住这台手机的基本组成</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobilePhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提供操作系统的接口</span></span><br><span class="line">    <span class="function"><span class="title">createOS</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;抽象工厂方法不允许直接调用，你需要将我重写！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 提供硬件的接口</span></span><br><span class="line">    <span class="function"><span class="title">createHardWare</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;抽象工厂方法不允许直接调用，你需要将我重写！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>楼上这个类，除了约定手机流水线的通用能力之外，啥也不干。如果你尝试让它干点啥，比如 new 一个 <code>MobilePhoneFactory</code> 实例，并尝试调用它的实例方法。它还会给你报错，提醒你“我不是让你拿去new一个实例的，我就是个定规矩的”。在抽象工厂模式里，楼上这个类就是我们食物链顶端最大的 <code>Boss——AbstractFactory</code>（抽象工厂）。</p><p>抽象工厂不干活，具体工厂（ConcreteFactory）来干活！当我们明确了生产方案，明确某一条手机生产流水线具体要生产什么样的手机了之后，就可以化抽象为具体，比如我现在想要一个专门生产 Android 系统 + 高通硬件的手机的生产线，我给这类手机型号起名叫 FakeStar，那我就可以为 FakeStar 定制一个具体工厂：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体工厂继承自抽象工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FakeStarFactory</span> <span class="keyword">extends</span> <span class="title">MobilePhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">createOS</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 提供安卓系统实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndroidOS()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">createHardWare</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 提供高通硬件实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QualcommHardWare()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在提供安卓系统的时候，调用了两个构造函数：AndroidOS 和 QualcommHardWare，它们分别用于生成具体的操作系统和硬件实例。像这种被我们拿来用于 new 出具体对象的类，叫做具体产品类（ConcreteProduct）。具体产品类往往不会孤立存在，不同的具体产品类往往有着共同的功能，比如安卓系统类和苹果系统类，它们都是操作系统，都有着可以<strong>操控手机硬件系统</strong>这样一个最基本的功能。因此我们可以用一个<strong>抽象产品（AbstractProduct）类</strong>来声明这一类产品应该具有的基本功能（众：什么抽象产品？？？要这些玩意儿干啥？老夫写代码就是一把梭，为啥不让我老老实实一个一个写具体类？？？大家稍安勿躁，先把例子看完，下文会有解释）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义操作系统这类产品的抽象产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">controlHardWare</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象产品方法不允许直接调用，你需要将我重写！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体操作系统的具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidOS</span> <span class="keyword">extends</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">controlHardWare</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会用安卓的方式去操作硬件&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleOS</span> <span class="keyword">extends</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">controlHardWare</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会用🍎的方式去操作硬件&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>硬件类产品同理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义手机硬件这类产品的抽象产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HardWare</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 手机硬件的共性方法，这里提取了“根据命令运转”这个共性</span></span><br><span class="line">    <span class="function"><span class="title">operateByOrder</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抽象产品方法不允许直接调用，你需要将我重写！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体硬件的具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QualcommHardWare</span> <span class="keyword">extends</span> <span class="title">HardWare</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">operateByOrder</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会用高通的方式去运转&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiWare</span> <span class="keyword">extends</span> <span class="title">HardWare</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">operateByOrder</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会用小米的方式去运转&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>好了，如此一来，当我们需要生产一台FakeStar手机时，我们只需要这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是我的手机</span></span><br><span class="line"><span class="keyword">const</span> myPhone = <span class="keyword">new</span> FakeStarFactory()</span><br><span class="line"><span class="comment">// 让它拥有操作系统</span></span><br><span class="line"><span class="keyword">const</span> myOS = myPhone.createOS()</span><br><span class="line"><span class="comment">// 让它拥有硬件</span></span><br><span class="line"><span class="keyword">const</span> myHardWare = myPhone.createHardWare()</span><br><span class="line"><span class="comment">// 启动操作系统(输出‘我会用安卓的方式去操作硬件’)</span></span><br><span class="line">myOS.controlHardWare()</span><br><span class="line"><span class="comment">// 唤醒硬件(输出‘我会用高通的方式去运转’)</span></span><br><span class="line">myHardWare.operateByOrder()</span><br></pre></td></tr></table></figure><p>关键的时刻来了——假如有一天，FakeStar过气了，我们需要产出一款新机投入市场，这时候怎么办？我们是不是<strong>不需要对抽象工厂MobilePhoneFactory做任何修改</strong>，只需要拓展它的种类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newStarFactory</span> <span class="keyword">extends</span> <span class="title">MobilePhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">createOS</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 操作系统实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">createHardWare</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 硬件实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么个操作，<strong>对原有的系统不会造成任何潜在影响</strong> 所谓的“对拓展开放，对修改封闭”就这么圆满实现了。前面我们之所以要实现<strong>抽象产品类</strong>，也是同样的道理。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大家现在回头对比一下抽象工厂和简单工厂的思路，思考一下：它们之间有哪些异同？</p><p>它们的共同点，在于都<strong>尝试去分离一个系统中变与不变的部分</strong>。它们的不同在于<strong>场景的复杂度</strong>。在简单工厂的使用场景里，处理的对象是类，并且是一些非常好对付的类——它们的共性容易抽离，同时因为逻辑本身比较简单，故而不苛求代码可扩展性。抽象工厂本质上处理的其实也是类，但是是一帮非常棘手、繁杂的类，这些类中不仅能划分出门派，还能划分出等级，同时存在着千变万化的扩展可能性——这使得我们必须对<strong>共性</strong>作更特别的处理、使用抽象类去降低扩展的成本，同时需要对类的性质作划分，于是有了这样的四个关键角色：</p><ul><li><strong>抽象工厂（抽象类，它不能被用于生成具体实例）：</strong> 用于声明最终目标产品的共性。在一个系统里，抽象工厂可以有多个（大家可以想象我们的手机厂后来被一个更大的厂收购了，这个厂里除了手机抽象类，还有平板、游戏机抽象类等等），每一个抽象工厂对应的这一类的产品，被称为“产品族”。</li><li><strong>具体工厂（用于生成产品族里的一个具体的产品）：</strong> 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。</li><li><strong>抽象产品（抽象类，它不能被用于生成具体实例）：</strong> 上面我们看到，具体工厂里实现的接口，会依赖一些类，这些类对应到各种各样的具体的细粒度产品（比如操作系统、硬件等），这些具体产品类的共性各自抽离，便对应到了各自的抽象产品类。</li><li><strong>具体产品（用于生成产品族里的一个具体的产品所依赖的更细粒度的产品）：</strong> 比如我们上文中具体的一种操作系统、或具体的一种硬件等。</li></ul><p>抽象工厂模式的定义，是<strong>围绕一个超级工厂创建其他工厂</strong>。本节内容对一些工作年限不多的同学来说可能不太友好，但抽象工厂目前来说在JS世界里也应用得并不广泛，所以大家不必拘泥于细节，只需留意以下三点：</p><ol><li>学会用 ES6 模拟 JAVA 中的抽象类；</li><li>了解抽象工厂模式中四个角色的定位与作用；</li><li>对“开放封闭原则”形成自己的理解，知道它好在哪，知道执行它的必要性。</li></ol><p>如果能对这三点有所掌握，那么这一节的目的就达到了，最难搞、最难受的抽象工厂也就告一段落了。</p><h3 id="最后，再跟大家谈谈学习"><a href="#最后，再跟大家谈谈学习" class="headerlink" title="最后，再跟大家谈谈学习"></a>最后，再跟大家谈谈学习</h3><p>现在我们回到开篇抛出的那个问题——抽象工厂对于各位而言的价值是什么？这么一个看似鸡肋、其实也确实不怎么常用的一个设计模式，凭什么值得我们花这么大力气去理解它？原因有三：</p><p><strong>其一：</strong> 开篇我们说过，<strong>前端工程师首先是软件工程师</strong>。只会写 JavaScript、只理解 JavaScript、只通过 JavaScript 去理解软件世界，是一件可怕的事情，它会窄化你的技术视野——因为 JavaScript 只是编程语言中的一个分支，准确地说，它是一个后辈。虽说它确实很流行，但它还不够强大（正是因为不够强大，所以在演化发展的过程中必然需要借鉴其它优秀语言的优秀特性，也会渐渐遇到其它语言的应用场景，不信大家看看 ES6789 都做了什么，再看看遍地开花的 TypeScript）。</p><p>但写这本小册并不是为了把大家指去学 Java/C++，而是为了以最小的时间成本帮大家去理解设计模式的套路和原则。比起要求大家为了这个设计模式去理解强类型语言、去理解强类型语言里的应用场景，我更希望能在这儿用 JavaScript 把这个东西给说清楚，把那些关键的设计模式概念在这儿给大家引出来——哪怕你当下用到它的场景还不是那么多（相信以当下前端语言和前端应用的发展速度和发展趋势来看，它会有用的：））。</p><p><strong>其二：</strong> 在大家今后的职业生涯里，可能会不止一次地遇到服务端/客户端出身、或者单纯对受试者知识广度有疯狂执念的各种不同背景不同脑回路的面试官。在他们的世界里，不知道抽象工厂就像不知道 <code>this</code> 一样恐怖：）。所以，<strong>要学</strong>。</p><p><strong>其三：</strong> 也是最重要的一点。前面我们说过，设计模式的“术”说到底是在佐证它的“道”。充分理解了设计原则后，设计模式纵有 1w 种也难不倒大家。<strong>抽象工厂是佐证“开放封闭原则”的良好素材</strong>，通过本节的学习，相信大家会对这个抽象的概念有更加具体和感性的认知。在后面的章节中，“开放封闭”作为各位的老朋友，会被反复提及。有了本节的平稳过渡，相信大家在后续的学习中可以真正做到心中有数、游刃有余。</p><p>说了这么多，无非是想传达给大家一个学习态度：<strong>不要小看那些看似“无用”的知识</strong>。</p><p>技术，尤其是前端技术，它的更新迭代速度是非常快的。仅仅因为“这个技术点我现在用不到”而推开摆在眼前的知识，是一种非常糟糕的学习方法——它会极大地限制你的能力和你职业生涯的可能性。举个例子，React 新版本推出的 Fiber 架构现在很火，很多同学认为这是个特别新潮的玩意儿——它新吗？新个屁！作为一种架构模式，它在软件领域早就有过不同姿势的生产实践了，React 并不是 Fiber 的发明者，而是 Fiber 的使用者和受益者。</p><p>同理，包括 ES2015 刚出来的时候，有同学说这个也没见过、那个也要重新学，累死了累死了，学不动了想转行…哎，其实它们都是软件世界里存在了很久很久的模式和知识点啊同学们。试想如果这份知识曾经摆在你面前的时候你没有拒绝它，此刻你的学习成本又该低了多少呢？</p><p>设计模式之外的东西，我们点到即止，剩下的就看大家的悟性和造化了。 接下来，我们一起看点更好玩的东西~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="设计模式" scheme="http://aiolimp.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://aiolimp.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript</title>
    <link href="http://aiolimp.com/2023/07/08/TypeScript/"/>
    <id>http://aiolimp.com/2023/07/08/TypeScript/</id>
    <published>2023-07-07T16:00:00.000Z</published>
    <updated>2025-04-12T11:42:06.091Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h3 id="TypeScript-基础类型"><a href="#TypeScript-基础类型" class="headerlink" title="TypeScript 基础类型"></a>TypeScript 基础类型</h3><h4 id="2-1-Boolean-类型"><a href="#2-1-Boolean-类型" class="headerlink" title="2.1 Boolean 类型"></a>2.1 Boolean 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// ES5：var isDone = false;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-Number-类型"><a href="#2-2-Number-类型" class="headerlink" title="2.2 Number 类型"></a>2.2 Number 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> count: <span class="built_in">number</span> = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// ES5：var count = 10;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-String-类型"><a href="#2-3-String-类型" class="headerlink" title="2.3 String 类型"></a>2.3 String 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">&quot;semliker&quot;</span>;</span><br><span class="line"><span class="comment">// ES5：var name = &#x27;semlinker&#x27;;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-Symbol-类型"><a href="#2-4-Symbol-类型" class="headerlink" title="2.4 Symbol 类型"></a>2.4 Symbol 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [sym]: <span class="string">&quot;semlinker&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[sym]); <span class="comment">// semlinker </span></span><br></pre></td></tr></table></figure><h4 id="2-5-Array-类型"><a href="#2-5-Array-类型" class="headerlink" title="2.5 Array 类型"></a>2.5 Array 类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// ES5：var list = [1,2,3];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// Array&lt;number&gt;泛型语法</span></span><br><span class="line"><span class="comment">// ES5：var list = [1,2,3];</span></span><br></pre></td></tr></table></figure><h4 id="2-6-Enum-类型"><a href="#2-6-Enum-类型" class="headerlink" title="2.6 Enum 类型"></a>2.6 Enum 类型</h4><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。</p><h5 id="1-数字枚举"><a href="#1-数字枚举" class="headerlink" title="1.数字枚举"></a>1.数字枚举</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  NORTH,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dir: Direction = Direction.NORTH;</span><br></pre></td></tr></table></figure><p>默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。</p><p>以上的枚举示例经编译后，对应的 ES5 代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;NORTH&quot;</span>] = <span class="number">0</span>)] = <span class="string">&quot;NORTH&quot;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;SOUTH&quot;</span>] = <span class="number">1</span>)] = <span class="string">&quot;SOUTH&quot;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;EAST&quot;</span>] = <span class="number">2</span>)] = <span class="string">&quot;EAST&quot;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;WEST&quot;</span>] = <span class="number">3</span>)] = <span class="string">&quot;WEST&quot;</span>;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br><span class="line"><span class="keyword">var</span> dir = Direction.NORTH;</span><br></pre></td></tr></table></figure><p>当然我们也可以设置 NORTH 的初始值，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  NORTH = <span class="number">3</span>,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-字符串枚举"><a href="#2-字符串枚举" class="headerlink" title="2.字符串枚举"></a>2.字符串枚举</h5><p>在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  NORTH = <span class="string">&quot;NORTH&quot;</span>,</span><br><span class="line">  SOUTH = <span class="string">&quot;SOUTH&quot;</span>,</span><br><span class="line">  EAST = <span class="string">&quot;EAST&quot;</span>,</span><br><span class="line">  WEST = <span class="string">&quot;WEST&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码对应的 ES5 代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> &quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">    Direction[<span class="string">&quot;NORTH&quot;</span>] = <span class="string">&quot;NORTH&quot;</span>;</span><br><span class="line">    Direction[<span class="string">&quot;SOUTH&quot;</span>] = <span class="string">&quot;SOUTH&quot;</span>;</span><br><span class="line">    Direction[<span class="string">&quot;EAST&quot;</span>] = <span class="string">&quot;EAST&quot;</span>;</span><br><span class="line">    Direction[<span class="string">&quot;WEST&quot;</span>] = <span class="string">&quot;WEST&quot;</span>;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>通过观察数字枚举和字符串枚举的编译结果，我们可以知道数字枚举除了支持 <strong>从成员名称到成员值</strong> 的普通映射之外，它还支持 <strong>从成员值到成员名称</strong> 的反向映射：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  NORTH,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dirName = Direction[<span class="number">0</span>]; <span class="comment">// NORTH</span></span><br><span class="line"><span class="keyword">let</span> dirVal = Direction[<span class="string">&quot;NORTH&quot;</span>]; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>另外，对于纯字符串枚举，我们不能省略任何初始化程序。而数字枚举如果没有显式设置值时，则会使用默认规则进行初始化。</p><h5 id="3-常量枚举"><a href="#3-常量枚举" class="headerlink" title="3.常量枚举"></a>3.常量枚举</h5><p>除了数字枚举和字符串枚举之外，还有一种特殊的枚举 —— 常量枚举。它是使用 <code>const</code> 关键字修饰的枚举，常量枚举会使用内联语法，不会为枚举类型编译生成任何 JavaScript。为了更好地理解这句话，我们来看一个具体的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> <span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  NORTH,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dir: Direction = Direction.NORTH;</span><br></pre></td></tr></table></figure><p>以上代码对应的 ES5 代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> dir = <span class="number">0</span> <span class="comment">/* NORTH */</span>;</span><br></pre></td></tr></table></figure><h5 id="4-异构枚举"><a href="#4-异构枚举" class="headerlink" title="4.异构枚举"></a>4.异构枚举</h5><p>异构枚举的成员值是数字和字符串的混合：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">enum</span> Enum &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">  C = <span class="string">&quot;C&quot;</span>,</span><br><span class="line">  D = <span class="string">&quot;D&quot;</span>,</span><br><span class="line">  E = <span class="number">8</span>,</span><br><span class="line">  F,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码对于的 ES5 代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> &quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> Enum;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Enum</span>) </span>&#123;</span><br><span class="line">    Enum[Enum[<span class="string">&quot;A&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    Enum[Enum[<span class="string">&quot;B&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    Enum[<span class="string">&quot;C&quot;</span>] = <span class="string">&quot;C&quot;</span>;</span><br><span class="line">    Enum[<span class="string">&quot;D&quot;</span>] = <span class="string">&quot;D&quot;</span>;</span><br><span class="line">    Enum[Enum[<span class="string">&quot;E&quot;</span>] = <span class="number">8</span>] = <span class="string">&quot;E&quot;</span>;</span><br><span class="line">    Enum[Enum[<span class="string">&quot;F&quot;</span>] = <span class="number">9</span>] = <span class="string">&quot;F&quot;</span>;</span><br><span class="line">&#125;)(Enum || (Enum = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>通过观察上述生成的 ES5 代码，我们可以发现数字枚举相对字符串枚举多了 “反向映射”：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(Enum.A) <span class="comment">//输出：0</span></span><br><span class="line"><span class="built_in">console</span>.log(Enum[<span class="number">0</span>]) <span class="comment">// 输出：A</span></span><br></pre></td></tr></table></figure><h4 id="2-7-Any-类型"><a href="#2-7-Any-类型" class="headerlink" title="2.7 Any 类型"></a>2.7 Any 类型</h4><p>在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型（也被称作全局超级类型）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">666</span>;</span><br><span class="line">notSure = <span class="string">&quot;semlinker&quot;</span>;</span><br><span class="line">notSure = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p><code>any</code> 类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由：TypeScript 允许我们对 <code>any</code> 类型的值执行任何操作，而无需事先执行任何形式的检查。比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> value: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">value.foo.bar; <span class="comment">// OK</span></span><br><span class="line">value.trim(); <span class="comment">// OK</span></span><br><span class="line">value(); <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">new</span> value(); <span class="comment">// OK</span></span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>在许多场景下，这太宽松了。使用 <code>any</code> 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 <code>any</code> 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 <code>any</code> 带来的问题，TypeScript 3.0 引入了 <code>unknown</code> 类型。</p><h4 id="2-8-Unknown-类型"><a href="#2-8-Unknown-类型" class="headerlink" title="2.8 Unknown 类型"></a>2.8 Unknown 类型</h4><p>就像所有类型都可以赋值给 <code>any</code>，所有类型也都可以赋值给 <code>unknown</code>。这使得 <code>unknown</code> 成为 TypeScript 类型系统的另一种顶级类型（另一种是 <code>any</code>）。下面我们来看一下 <code>unknown</code> 类型的使用示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> value: unknown;</span><br><span class="line"></span><br><span class="line">value = <span class="literal">true</span>; <span class="comment">// OK</span></span><br><span class="line">value = <span class="number">42</span>; <span class="comment">// OK</span></span><br><span class="line">value = <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// OK</span></span><br><span class="line">value = []; <span class="comment">// OK</span></span><br><span class="line">value = &#123;&#125;; <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Math</span>.random; <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">null</span>; <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">undefined</span>; <span class="comment">// OK</span></span><br><span class="line">value = <span class="keyword">new</span> <span class="built_in">TypeError</span>(); <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Symbol</span>(<span class="string">&quot;type&quot;</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>对 <code>value</code> 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 <code>unknown</code> 的值赋值给其他类型的变量时会发生什么？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> value: unknown;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value1: unknown = value; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> value2: <span class="built_in">any</span> = value; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> value3: <span class="built_in">boolean</span> = value; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value4: <span class="built_in">number</span> = value; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value5: <span class="built_in">string</span> = value; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value6: <span class="built_in">object</span> = value; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value7: <span class="built_in">any</span>[] = value; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value8: <span class="built_in">Function</span> = value; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p><code>unknown</code> 类型只能被赋值给 <code>any</code> 类型和 <code>unknown</code> 类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 <code>unknown</code> 类型的值。毕竟我们不知道变量 <code>value</code> 中存储了什么类型的值。</p><p>现在让我们看看当我们尝试对类型为 <code>unknown</code> 的值执行操作时会发生什么。以下是我们在之前 <code>any</code> 章节看过的相同操作：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> value: unknown;</span><br><span class="line"></span><br><span class="line">value.foo.bar; <span class="comment">// Error</span></span><br><span class="line">value.trim(); <span class="comment">// Error</span></span><br><span class="line">value(); <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">new</span> value(); <span class="comment">// Error</span></span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>将 <code>value</code> 变量类型设置为 <code>unknown</code> 后，这些操作都不再被认为是类型正确的。通过将 <code>any</code> 类型改变为 <code>unknown</code> 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。</p><h4 id="2-9-Tuple-类型"><a href="#2-9-Tuple-类型" class="headerlink" title="2.9 Tuple 类型"></a>2.9 Tuple 类型</h4><p><strong>众所周知，数组一般由同种类型的值组成，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组</strong>。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。</p><p>元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值。为了更直观地理解元组的概念，我们来看一个具体的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> tupleType: [<span class="built_in">string</span>, <span class="built_in">boolean</span>];</span><br><span class="line">tupleType = [<span class="string">&quot;semlinker&quot;</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure><p>在上面代码中，我们定义了一个名为 <code>tupleType</code> 的变量，它的类型是一个类型数组 <code>[string, boolean]</code>，然后我们按照正确的类型依次初始化 tupleType 变量。与数组一样，我们可以通过下标来访问元组中的元素：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">console</span>.log(tupleType[<span class="number">0</span>]); <span class="comment">// semlinker</span></span><br><span class="line"><span class="built_in">console</span>.log(tupleType[<span class="number">1</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在元组初始化的时候，如果出现类型不匹配的话，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tupleType = [<span class="literal">true</span>, <span class="string">&quot;semlinker&quot;</span>];</span><br></pre></td></tr></table></figure><p>此时，TypeScript 编译器会提示以下错误信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>]: <span class="type">Type</span> <span class="string">&#x27;true&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> assignable to <span class="built_in">type</span> <span class="string">&#x27;string&#x27;</span>.</span><br><span class="line">[<span class="number">1</span>]: <span class="type">Type</span> <span class="string">&#x27;string&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> assignable to <span class="built_in">type</span> <span class="string">&#x27;boolean&#x27;</span>.</span><br></pre></td></tr></table></figure><p>很明显是因为类型不匹配导致的。在元组初始化的时候，我们还必须提供每个属性的值，不然也会出现错误，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tupleType = [<span class="string">&quot;semlinker&quot;</span>];</span><br></pre></td></tr></table></figure><p>此时，TypeScript 编译器会提示以下错误信息：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Property <span class="string">&#x27;1&#x27;</span> is missing <span class="keyword">in</span> <span class="keyword">type</span> <span class="string">&#x27;[string]&#x27;</span> but required <span class="keyword">in</span> <span class="keyword">type</span> <span class="string">&#x27;[string, boolean]&#x27;</span>.</span><br></pre></td></tr></table></figure><h4 id="2-10-Void-类型"><a href="#2-10-Void-类型" class="headerlink" title="2.10 Void 类型"></a>2.10 Void 类型</h4><p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 声明函数返回值为void</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码编译生成的 ES5 代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> &quot;use strict&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，声明一个 void 类型的变量没有什么作用，因为在严格模式下，它的值只能为 <code>undefined</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h4 id="2-11-Null-和-Undefined-类型"><a href="#2-11-Null-和-Undefined-类型" class="headerlink" title="2.11 Null 和 Undefined 类型"></a>2.11 Null 和 Undefined 类型</h4><p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者有各自的类型分别为 <code>undefined</code> 和 <code>null</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="2-12-object-Object-和-类型"><a href="#2-12-object-Object-和-类型" class="headerlink" title="2.12 object, Object 和 {} 类型"></a>2.12 object, Object 和 {} 类型</h4><h5 id="1-object-类型"><a href="#1-object-类型" class="headerlink" title="1.object 类型"></a>1.object 类型</h5><p>object 类型是：TypeScript 2.2 引入的新类型，它用于表示非原始类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// node_modules/typescript/lib/lib.es5.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> ObjectConstructor &#123;</span><br><span class="line">  create(o: <span class="built_in">object</span> | <span class="literal">null</span>): <span class="built_in">any</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proto = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.create(proto);     <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">null</span>);      <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="number">1337</span>);      <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">true</span>);      <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="string">&quot;oops&quot;</span>);    <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h5 id="2-Object-类型"><a href="#2-Object-类型" class="headerlink" title="2.Object 类型"></a>2.Object 类型</h5><p>Object 类型：它是所有 Object 类的实例的类型，它由以下两个接口来定义：</p><ul><li>Object 接口定义了 Object.prototype 原型对象上的属性；</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// node_modules/typescript/lib/lib.es5.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> Object &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Function</span>;</span><br><span class="line">  toString(): <span class="built_in">string</span>;</span><br><span class="line">  toLocaleString(): <span class="built_in">string</span>;</span><br><span class="line">  valueOf(): <span class="built_in">Object</span>;</span><br><span class="line">  hasOwnProperty(v: PropertyKey): <span class="built_in">boolean</span>;</span><br><span class="line">  isPrototypeOf(v: <span class="built_in">Object</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  propertyIsEnumerable(v: PropertyKey): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ObjectConstructor 接口定义了 Object 类的属性。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// node_modules/typescript/lib/lib.es5.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> ObjectConstructor &#123;</span><br><span class="line">  <span class="comment">/** Invocation via `new` */</span></span><br><span class="line">  <span class="keyword">new</span>(value?: <span class="built_in">any</span>): <span class="built_in">Object</span>;</span><br><span class="line">  <span class="comment">/** Invocation via function calls */</span></span><br><span class="line">  (value?: <span class="built_in">any</span>): <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">readonly</span> prototype: <span class="built_in">Object</span>;</span><br><span class="line">  getPrototypeOf(o: <span class="built_in">any</span>): <span class="built_in">any</span>;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="built_in">Object</span>: ObjectConstructor;</span><br></pre></td></tr></table></figure><p>Object 类的所有实例都继承了 Object 接口中的所有属性。</p><h5 id="3-类型"><a href="#3-类型" class="headerlink" title="3.{} 类型"></a>3.{} 类型</h5><p>{} 类型描述了一个没有成员的对象。当你试图访问这样一个对象的任意属性时，TypeScript 会产生一个编译时错误。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Type &#123;&#125;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Property &#x27;prop&#x27; does not exist on type &#x27;&#123;&#125;&#x27;.</span></span><br><span class="line">obj.prop = <span class="string">&quot;semlinker&quot;</span>;</span><br></pre></td></tr></table></figure><p>但是，你仍然可以使用在 Object 类型上定义的所有属性和方法，这些属性和方法可通过 JavaScript 的原型链隐式地使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type &#123;&#125;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line">obj.toString();</span><br></pre></td></tr></table></figure><h4 id="2-13-Never-类型"><a href="#2-13-Never-类型" class="headerlink" title="2.13 Never 类型"></a>2.13 Never 类型</h4><p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如，<code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">controlFlowAnalysisWithNever</span>(<span class="params">foo: Foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里 foo 被收窄为 string 类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里 foo 被收窄为 number 类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// foo 在这里是 never</span></span><br><span class="line">    <span class="keyword">const</span> check: <span class="built_in">never</span> = foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br></pre></td></tr></table></figure><p>然而他忘记同时修改 <code>controlFlowAnalysisWithNever</code> 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 <code>boolean</code> 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保</p><p><code>controlFlowAnalysisWithNever</code> 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：<strong>使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。</strong></p><h3 id="三、TypeScript-断言"><a href="#三、TypeScript-断言" class="headerlink" title="三、TypeScript 断言"></a>三、TypeScript 断言</h3><h4 id="3-1-类型断言"><a href="#3-1-类型断言" class="headerlink" title="3.1 类型断言"></a>3.1 类型断言</h4><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p><p>类型断言有两种形式：</p><h5 id="1-“尖括号”-语法"><a href="#1-“尖括号”-语法" class="headerlink" title="1.“尖括号” 语法"></a>1.“尖括号” 语法</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure><h5 id="2-as-语法"><a href="#2-as-语法" class="headerlink" title="2.as 语法"></a>2.as 语法</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure><h4 id="3-2-非空断言"><a href="#3-2-非空断言" class="headerlink" title="3.2 非空断言"></a>3.2 非空断言</h4><p>在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 <code>!</code> 可以用于断言操作对象是非 null 和非 undefined 类型。<strong>具体而言，x! 将从 x 值域中排除 null 和 undefined 。</strong></p><p>那么非空断言操作符到底有什么用呢？下面我们先来看一下非空断言操作符的一些使用场景。</p><h5 id="1-忽略-undefined-和-null-类型"><a href="#1-忽略-undefined-和-null-类型" class="headerlink" title="1.忽略 undefined 和 null 类型"></a>1.忽略 undefined 和 null 类型</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">maybeString: <span class="built_in">string</span> | <span class="literal">undefined</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Type &#x27;string | null | undefined&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line">  <span class="comment">// Type &#x27;undefined&#x27; is not assignable to type &#x27;string&#x27;. </span></span><br><span class="line">  <span class="keyword">const</span> onlyString: <span class="built_in">string</span> = maybeString; <span class="comment">// Error</span></span><br><span class="line">  <span class="keyword">const</span> ignoreUndefinedAndNull: <span class="built_in">string</span> = maybeString!; <span class="comment">// Ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-调用函数时忽略-undefined-类型"><a href="#2-调用函数时忽略-undefined-类型" class="headerlink" title="2.调用函数时忽略 undefined 类型"></a>2.调用函数时忽略 undefined 类型</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">type</span> NumGenerator = <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">numGenerator: NumGenerator | <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Object is possibly &#x27;undefined&#x27;.(2532)</span></span><br><span class="line">  <span class="comment">// Cannot invoke an object which is possibly &#x27;undefined&#x27;.(2722)</span></span><br><span class="line">  <span class="keyword">const</span> num1 = numGenerator(); <span class="comment">// Error</span></span><br><span class="line">  <span class="keyword">const</span> num2 = numGenerator!(); <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>!</code> 非空断言操作符会从编译生成的 JavaScript 代码中移除，所以在实际使用的过程中，要特别注意。比如下面这个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> a: <span class="built_in">number</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> b: <span class="built_in">number</span> = a!;</span><br><span class="line"><span class="built_in">console</span>.log(b); </span><br></pre></td></tr></table></figure><p>以上 TS 代码会编译生成以下 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure><p>虽然在 TS 代码中，我们使用了非空断言，使得 <code>const b: number = a!;</code> 语句可以通过 TypeScript 类型检查器的检查。但在生成的 ES5 代码中，<code>!</code> 非空断言操作符被移除了，所以在浏览器中执行以上代码，在控制台会输出 <code>undefined</code>。</p><h4 id="3-3-确定赋值断言"><a href="#3-3-确定赋值断言" class="headerlink" title="3.3 确定赋值断言"></a>3.3 确定赋值断言</h4><p>在 TypeScript 2.7 版本中引入了确定赋值断言，即允许在实例属性和变量声明后面放置一个 <code>!</code> 号，从而告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> x: <span class="built_in">number</span>;</span><br><span class="line">initialize();</span><br><span class="line"><span class="comment">// Variable &#x27;x&#x27; is used before being assigned.(2454)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> * x); <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> x!: <span class="built_in">number</span>;</span><br><span class="line">initialize();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> * x); <span class="comment">// Ok</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>let x!: number;</code> 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。</p><h3 id="四、类型守卫"><a href="#四、类型守卫" class="headerlink" title="四、类型守卫"></a>四、类型守卫</h3><p><strong>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。</strong> 换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。目前主要有四种的方式来实现类型保护：</p><h4 id="4-1-in-关键字"><a href="#4-1-in-关键字" class="headerlink" title="4.1 in 关键字"></a>4.1 in 关键字</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">interface</span> Admin &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  privileges: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Employee &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  startDate: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UnknownEmployee = Employee | Admin;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printEmployeeInformation</span>(<span class="params">emp: UnknownEmployee</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Name: &quot;</span> + emp.name);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;privileges&quot;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Privileges: &quot;</span> + emp.privileges);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;startDate&quot;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Start Date: &quot;</span> + emp.startDate);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-typeof-关键字"><a href="#4-2-typeof-关键字" class="headerlink" title="4.2 typeof 关键字"></a>4.2 typeof 关键字</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> padding + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typeof</code> 类型保护只支持两种形式：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== typename</code>，<code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>， <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</p><h4 id="4-3-instanceof-关键字"><a href="#4-3-instanceof-关键字" class="headerlink" title="4.3 instanceof 关键字"></a>4.3 instanceof 关键字</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">interface</span> Padder &#123;</span><br><span class="line">  getPaddingString(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceRepeatingPadder</span> <span class="title">implements</span> <span class="title">Padder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">getPaddingString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="built_in">this</span>.numSpaces + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringPadder</span> <span class="title">implements</span> <span class="title">Padder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">getPaddingString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> padder: Padder = <span class="keyword">new</span> SpaceRepeatingPadder(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class="line">  <span class="comment">// padder的类型收窄为 &#x27;SpaceRepeatingPadder&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-自定义类型保护的类型谓词"><a href="#4-4-自定义类型保护的类型谓词" class="headerlink" title="4.4 自定义类型保护的类型谓词"></a>4.4 自定义类型保护的类型谓词</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&quot;number&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&quot;string&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、联合类型和类型别名"><a href="#五、联合类型和类型别名" class="headerlink" title="五、联合类型和类型别名"></a>五、联合类型和类型别名</h3><h4 id="5-1-联合类型"><a href="#5-1-联合类型" class="headerlink" title="5.1 联合类型"></a>5.1 联合类型</h4><p>联合类型通常与 <code>null</code> 或 <code>undefined</code> 一起使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> sayHello = <span class="function">(<span class="params">name: <span class="built_in">string</span> | <span class="literal">undefined</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如，这里 <code>name</code> 的类型是 <code>string | undefined</code> 意味着可以将 <code>string</code> 或 <code>undefined</code> 的值传递给<code>sayHello</code> 函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    sayHello(<span class="string">&quot;semlinker&quot;</span>);</span><br><span class="line">sayHello(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure><p>通过这个示例，你可以凭直觉知道类型 A 和类型 B 联合后的类型是同时接受 A 和 B 值的类型。此外，对于联合类型来说，你可能会遇到以下的用法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> num: <span class="number">1</span> | <span class="number">2</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">type</span> EventNames = <span class="string">&#x27;click&#x27;</span> | <span class="string">&#x27;scroll&#x27;</span> | <span class="string">&#x27;mousemove&#x27;</span>;</span><br></pre></td></tr></table></figure><p>以上示例中的 <code>1</code>、<code>2</code> 或 <code>&#39;click&#39;</code> 被称为字面量类型，用来约束取值只能是某几个值中的一个。</p><h4 id="5-2-可辨识联合"><a href="#5-2-可辨识联合" class="headerlink" title="5.2 可辨识联合"></a>5.2 可辨识联合</h4><p>TypeScript 可辨识联合（Discriminated Unions）类型，也称为代数数据类型或标签联合类型。<strong>它包含 3 个要点：可辨识、联合类型和类型守卫。</strong></p><p>这种类型的本质是结合联合类型和字面量类型的一种类型保护方法。<strong>如果一个类型是多个类型的联合类型，且多个类型含有一个公共属性，那么就可以利用这个公共属性，来创建不同的类型保护区块。</strong></p><h5 id="1-可辨识"><a href="#1-可辨识" class="headerlink" title="1.可辨识"></a>1.可辨识</h5><p>可辨识要求联合类型中的每个元素都含有一个单例类型属性，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">enum</span> CarTransmission &#123;</span><br><span class="line">  Automatic = <span class="number">200</span>,</span><br><span class="line">  Manual = <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Motorcycle &#123;</span><br><span class="line">  vType: <span class="string">&quot;motorcycle&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  make: <span class="built_in">number</span>; <span class="comment">// year</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Car &#123;</span><br><span class="line">  vType: <span class="string">&quot;car&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  transmission: CarTransmission</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Truck &#123;</span><br><span class="line">  vType: <span class="string">&quot;truck&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  capacity: <span class="built_in">number</span>; <span class="comment">// in tons</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们分别定义了 <code>Motorcycle</code>、 <code>Car</code> 和 <code>Truck</code> 三个接口，在这些接口中都包含一个 <code>vType</code> 属性，该属性被称为可辨识的属性，而其它的属性只跟特性的接口相关。</p><h5 id="2-联合类型"><a href="#2-联合类型" class="headerlink" title="2.联合类型"></a>2.联合类型</h5><p>基于前面定义了三个接口，我们可以创建一个 <code>Vehicle</code> 联合类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">码<span class="keyword">type</span> Vehicle = Motorcycle | Car | Truck;</span><br></pre></td></tr></table></figure><p>现在我们就可以开始使用 <code>Vehicle</code> 联合类型，对于 <code>Vehicle</code> 类型的变量，它可以表示不同类型的车辆。</p><h5 id="3-类型守卫"><a href="#3-类型守卫" class="headerlink" title="3.类型守卫"></a>3.类型守卫</h5><p>下面我们来定义一个 <code>evaluatePrice</code> 方法，该方法用于根据车辆的类型、容量和评估因子来计算价格，具体实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> EVALUATION_FACTOR = <span class="built_in">Math</span>.PI; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evaluatePrice</span>(<span class="params">vehicle: Vehicle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> vehicle.capacity * EVALUATION_FACTOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myTruck: Truck = &#123; <span class="attr">vType</span>: <span class="string">&quot;truck&quot;</span>, <span class="attr">capacity</span>: <span class="number">9.5</span> &#125;;</span><br><span class="line">evaluatePrice(myTruck);</span><br></pre></td></tr></table></figure><p>对于以上代码，TypeScript 编译器将会提示以下错误信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Property <span class="string">&#x27;capacity&#x27;</span> does not exist on <span class="built_in">type</span> <span class="string">&#x27;Vehicle&#x27;</span>.</span><br><span class="line">Property <span class="string">&#x27;capacity&#x27;</span> does not exist on <span class="built_in">type</span> <span class="string">&#x27;Motorcycle&#x27;</span>.</span><br></pre></td></tr></table></figure><p>原因是在 Motorcycle 接口中，并不存在 <code>capacity</code> 属性，而对于 Car 接口来说，它也不存在 <code>capacity</code> 属性。那么，现在我们应该如何解决以上问题呢？这时，我们可以使用类型守卫。下面我们来重构一下前面定义的 <code>evaluatePrice</code> 方法，重构后的代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">evaluatePrice</span>(<span class="params">vehicle: Vehicle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(vehicle.vType) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;car&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.transmission * EVALUATION_FACTOR;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;truck&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.capacity * EVALUATION_FACTOR;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;motorcycle&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.make * EVALUATION_FACTOR;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们使用 <code>switch</code> 和 <code>case</code> 运算符来实现类型守卫，从而确保在 <code>evaluatePrice</code> 方法中，我们可以安全地访问 <code>vehicle</code> 对象中的所包含的属性，来正确的计算该车辆类型所对应的价格。</p><h4 id="5-3-类型别名"><a href="#5-3-类型别名" class="headerlink" title="5.3 类型别名"></a>5.3 类型别名</h4><p>类型别名用来给一个类型起个新名字。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">type</span> Message = <span class="built_in">string</span> | <span class="built_in">string</span>[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greet = <span class="function">(<span class="params">message: Message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="六、交叉类型"><a href="#六、交叉类型" class="headerlink" title="六、交叉类型"></a>六、交叉类型</h3><p>在 TypeScript 中交叉类型是将多个类型合并为一个类型。通过 <code>&amp;</code> 运算符可以将现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">type</span> PartialPointX = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> Point = PartialPointX &amp; &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point: Point = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中我们先定义了 <code>PartialPointX</code> 类型，接着使用 <code>&amp;</code> 运算符创建一个新的 <code>Point</code> 类型，表示一个含有 x 和 y 坐标的点，然后定义了一个 <code>Point</code> 类型的变量并初始化。</p><h4 id="6-1-同名基础类型属性的合并"><a href="#6-1-同名基础类型属性的合并" class="headerlink" title="6.1 同名基础类型属性的合并"></a>6.1 同名基础类型属性的合并</h4><p>那么现在问题来了，假设在合并多个类型的过程中，刚好出现某些类型存在相同的成员，但对应的类型又不一致，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">interface</span> X &#123;</span><br><span class="line">  c: <span class="built_in">string</span>;</span><br><span class="line">  d: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Y &#123;</span><br><span class="line">  c: <span class="built_in">number</span>;</span><br><span class="line">  e: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XY = X &amp; Y;</span><br><span class="line"><span class="keyword">type</span> YX = Y &amp; X;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: XY;</span><br><span class="line"><span class="keyword">let</span> q: YX;</span><br></pre></td></tr></table></figure><p>在上面的代码中，接口 X  和接口 Y 都含有一个相同的成员 c，但它们的类型不一致。对于这种情况，此时 XY 类型或 YX 类型中成员 c 的类型是不是可以是 <code>string</code> 或 <code>number</code> 类型呢？比如下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = &#123; <span class="attr">c</span>: <span class="number">6</span>, <span class="attr">d</span>: <span class="string">&quot;d&quot;</span>, <span class="attr">e</span>: <span class="string">&quot;e&quot;</span> &#125;; </span><br></pre></td></tr></table></figure><h4 id="6-2-同名非基础类型属性的合并"><a href="#6-2-同名非基础类型属性的合并" class="headerlink" title="6.2 同名非基础类型属性的合并"></a>6.2 同名非基础类型属性的合并</h4><p>在上面示例中，刚好接口 X 和接口 Y 中内部成员 c 的类型都是基本数据类型，那么如果是非基本数据类型的话，又会是什么情形。我们来看个具体的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> D &#123; d: <span class="built_in">boolean</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> E &#123; e: <span class="built_in">string</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> F &#123; f: <span class="built_in">number</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A &#123; x: D; &#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123; x: E; &#125;</span><br><span class="line"><span class="keyword">interface</span> C &#123; x: F; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ABC = A &amp; B &amp; C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> abc: ABC = &#123;</span><br><span class="line">  x: &#123;</span><br><span class="line">    d: <span class="literal">true</span>,</span><br><span class="line">    e: <span class="string">&#x27;semlinker&#x27;</span>,</span><br><span class="line">    f: <span class="number">666</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abc:&#x27;</span>, abc);</span><br></pre></td></tr></table></figure><h3 id="七、TypeScript-函数"><a href="#七、TypeScript-函数" class="headerlink" title="七、TypeScript 函数"></a>七、TypeScript 函数</h3><h4 id="7-1-TypeScript-函数与-JavaScript-函数的区别"><a href="#7-1-TypeScript-函数与-JavaScript-函数的区别" class="headerlink" title="7.1 TypeScript 函数与 JavaScript 函数的区别"></a>7.1 TypeScript 函数与 JavaScript 函数的区别</h4><table><thead><tr><th>TypeScript</th><th>JavaScript</th></tr></thead><tbody><tr><td>含有类型</td><td>无类型</td></tr><tr><td>箭头函数</td><td>箭头函数（ES2015）</td></tr><tr><td>函数类型</td><td>无函数类型</td></tr><tr><td>必填和可选参数</td><td>所有参数都是可选的</td></tr><tr><td>默认参数</td><td>默认参数</td></tr><tr><td>剩余参数</td><td>剩余参数</td></tr><tr><td>函数重载</td><td>无函数重载</td></tr></tbody></table><h4 id="7-2-箭头函数"><a href="#7-2-箭头函数" class="headerlink" title="7.2 箭头函数"></a>7.2 箭头函数</h4><h5 id="1-常见语法"><a href="#1-常见语法" class="headerlink" title="1.常见语法"></a>1.常见语法</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    myBooks.forEach(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;reading&#x27;</span>));</span><br><span class="line"></span><br><span class="line">myBooks.forEach(<span class="function"><span class="params">title</span> =&gt;</span> <span class="built_in">console</span>.log(title));</span><br><span class="line"></span><br><span class="line">myBooks.forEach(<span class="function">(<span class="params">title, idx, arr</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(idx + <span class="string">&#x27;-&#x27;</span> + title);</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">myBooks.forEach(<span class="function">(<span class="params">title, idx, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(idx + <span class="string">&#x27;-&#x27;</span> + title);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2.使用示例"></a>2.使用示例</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 未使用箭头函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Book</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  self.publishDate = <span class="number">2016</span>;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(self.publishDate);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Book</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.publishDate = <span class="number">2016</span>;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.publishDate);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-参数类型和返回类型"><a href="#7-3-参数类型和返回类型" class="headerlink" title="7.3 参数类型和返回类型"></a>7.3 参数类型和返回类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-函数类型"><a href="#7-4-函数类型" class="headerlink" title="7.4 函数类型"></a>7.4 函数类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> IdGenerator: <span class="function">(<span class="params">chars: <span class="built_in">string</span>, nums: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name + id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IdGenerator = createUserId;</span><br></pre></td></tr></table></figure><h4 id="7-5-可选参数及默认参数"><a href="#7-5-可选参数及默认参数" class="headerlink" title="7.5 可选参数及默认参数"></a>7.5 可选参数及默认参数</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span>, age?: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name + id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUserId</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  name: <span class="built_in">string</span> = <span class="string">&quot;semlinker&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  id: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  age?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在声明函数时，可以通过 <code>?</code> 号来定义可选参数，比如 <code>age?: number</code> 这种形式。<strong>在实际使用时，需要注意的是可选参数要放在普通参数的后面，不然会导致编译错误</strong>。</p><h4 id="7-6-剩余参数"><a href="#7-6-剩余参数" class="headerlink" title="7.6 剩余参数"></a>7.6 剩余参数</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="7-7-函数重载"><a href="#7-7-函数重载" class="headerlink" title="7.7 函数重载"></a>7.7 函数重载</h4><p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: Combinable, b: Combinable</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// type Combinable = string | number;</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.toString() + b.toString();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们为 add 函数提供了多个函数类型定义，从而实现函数的重载。在 TypeScript 中除了可以重载普通函数之外，我们还可以重载类中的成员方法。</p><p>方法重载是指在同一个类中方法同名，参数不同（参数类型不同、参数个数不同或参数个数相同时参数的先后顺序不同），调用时根据实参的形式，选择与它匹配的方法执行操作的一种技术。所以类中成员方法满足重载的条件是：在同一个类中，方法名相同且参数列表不同。下面我们来举一个成员方法重载的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  add(a: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">  add(a: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">  add(a: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">  add(a: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">a: Combinable, b: Combinable</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.toString() + b.toString();</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line"><span class="keyword">const</span> result = calculator.add(<span class="string">&#x27;Semlinker&#x27;</span>, <span class="string">&#x27; Kakuqo&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这里需要注意的是，当 TypeScript 编译器处理函数重载时，它会查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。另外在 Calculator 类中，<code>add(a: Combinable, b: Combinable)&#123; &#125;</code> 并不是重载列表的一部分，因此对于 add 成员方法来说，我们只定义了四个重载方法。</p><h3 id="八、TypeScript-数组"><a href="#八、TypeScript-数组" class="headerlink" title="八、TypeScript 数组"></a>八、TypeScript 数组</h3><h4 id="8-1-数组解构"><a href="#8-1-数组解构" class="headerlink" title="8.1 数组解构"></a>8.1 数组解构</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> x: <span class="built_in">number</span>; <span class="keyword">let</span> y: <span class="built_in">number</span>; <span class="keyword">let</span> z: <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">let</span> five_array = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">[x,y,z] = five_array;</span><br></pre></td></tr></table></figure><h4 id="8-2-数组展开运算符"><a href="#8-2-数组展开运算符" class="headerlink" title="8.2 数组展开运算符"></a>8.2 数组展开运算符</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> two_array = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> five_array = [...two_array, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure><h4 id="8-3-数组遍历"><a href="#8-3-数组遍历" class="headerlink" title="8.3 数组遍历"></a>8.3 数组遍历</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> colors: <span class="built_in">string</span>[] = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> colors) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九、TypeScript-对象"><a href="#九、TypeScript-对象" class="headerlink" title="九、TypeScript 对象"></a>九、TypeScript 对象</h3><h4 id="9-1-对象解构"><a href="#9-1-对象解构" class="headerlink" title="9.1 对象解构"></a>9.1 对象解构</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Semlinker&quot;</span>,</span><br><span class="line">  gender: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, gender &#125; = person;</span><br></pre></td></tr></table></figure><h4 id="9-2-对象展开运算符"><a href="#9-2-对象展开运算符" class="headerlink" title="9.2 对象展开运算符"></a>9.2 对象展开运算符</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Semlinker&quot;</span>,</span><br><span class="line">  gender: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line">  address: <span class="string">&quot;Xiamen&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装对象</span></span><br><span class="line"><span class="keyword">let</span> personWithAge = &#123; ...person, <span class="attr">age</span>: <span class="number">33</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取除了某些项外的其它项</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, ...rest &#125; = person;</span><br></pre></td></tr></table></figure><h3 id="十、TypeScript-接口"><a href="#十、TypeScript-接口" class="headerlink" title="十、TypeScript 接口"></a>十、TypeScript 接口</h3><p>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。</p><p>TypeScript 中的接口是一个非常灵活的概念，除了可用于<a href="https://link.juejin.cn/?target=https://ts.xcatliu.com/advanced/class-and-interfaces.html%23%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状（Shape）」进行描述。</p><h4 id="10-1-对象的形状"><a href="#10-1-对象的形状" class="headerlink" title="10.1 对象的形状"></a>10.1 对象的形状</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> semlinker: Person = &#123;</span><br><span class="line">  name: <span class="string">&quot;semlinker&quot;</span>,</span><br><span class="line">  age: <span class="number">33</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="10-2-可选-只读属性"><a href="#10-2-可选-只读属性" class="headerlink" title="10.2 可选 | 只读属性"></a>10.2 可选 | 只读属性</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="keyword">readonly</span> name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><h4 id="10-3-任意属性"><a href="#10-3-任意属性" class="headerlink" title="10.3 任意属性"></a>10.3 任意属性</h4><p>有时候我们希望一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使用 <strong>索引签名</strong> 的形式来满足上述要求。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = &#123; <span class="attr">name</span>: <span class="string">&quot;semlinker&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> p2 = &#123; <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>, <span class="attr">age</span>: <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> p3 = &#123; <span class="attr">name</span>: <span class="string">&quot;kakuqo&quot;</span>, <span class="attr">sex</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="10-4-接口与类型别名的区别"><a href="#10-4-接口与类型别名的区别" class="headerlink" title="10.4 接口与类型别名的区别"></a>10.4 接口与类型别名的区别</h4><h5 id="1-Objects-Functions"><a href="#1-Objects-Functions" class="headerlink" title="1.Objects/Functions"></a>1.Objects/Functions</h5><p>接口和类型别名都可以用来描述对象的形状或函数签名：</p><p><strong>接口</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SetPoint &#123;</span><br><span class="line">  (x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类型别名</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">type</span> Point = &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SetPoint = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><h5 id="2-Other-Types"><a href="#2-Other-Types" class="headerlink" title="2.Other Types"></a>2.Other Types</h5><p>与接口类型不一样，类型别名可以用于一些其他类型，比如原始类型、联合类型和元组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// primitive</span></span><br><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line"><span class="keyword">type</span> PartialPointX = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> PartialPointY = &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union</span></span><br><span class="line"><span class="keyword">type</span> PartialPoint = PartialPointX | PartialPointY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tuple</span></span><br><span class="line"><span class="keyword">type</span> Data = [<span class="built_in">number</span>, <span class="built_in">string</span>];</span><br></pre></td></tr></table></figure><h5 id="3-Extend"><a href="#3-Extend" class="headerlink" title="3.Extend"></a>3.Extend</h5><p>接口和类型别名都能够被扩展，但语法有所不同。此外，接口和类型别名不是互斥的。接口可以扩展类型别名，而反过来是不行的。</p><p><strong>Interface extends interface</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">interface</span> PartialPointX &#123; x: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> Point <span class="keyword">extends</span> PartialPointX &#123; </span><br><span class="line">  y: <span class="built_in">number</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Type alias extends type alias</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">type</span> PartialPointX = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> Point = PartialPointX &amp; &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br></pre></td></tr></table></figure><p><strong>Interface extends type alias</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">type</span> PartialPointX = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">interface</span> Point <span class="keyword">extends</span> PartialPointX &#123; y: <span class="built_in">number</span>; &#125;</span><br></pre></td></tr></table></figure><p><strong>Type alias extends interface</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">interface</span> PartialPointX &#123; x: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">type</span> Point = PartialPointX &amp; &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br></pre></td></tr></table></figure><h5 id="4-Implements"><a href="#4-Implements" class="headerlink" title="4.Implements"></a>4.Implements</h5><p>类可以以相同的方式实现接口或类型别名，但类不能实现使用类型别名定义的联合类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomePoint</span> <span class="title">implements</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point2 = &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomePoint2</span> <span class="title">implements</span> <span class="title">Point2</span> </span>&#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PartialPoint = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125; | &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A class can only implement an object type or </span></span><br><span class="line"><span class="comment">// intersection of object types with statically known members.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomePartialPoint</span> <span class="title">implements</span> <span class="title">PartialPoint</span> </span>&#123; <span class="comment">// Error</span></span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-Declaration-merging"><a href="#5-Declaration-merging" class="headerlink" title="5.Declaration merging"></a>5.Declaration merging</h5><p>与类型别名不同，接口可以定义多次，会被自动合并为单个接口。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">interface</span> Point &#123; x: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> Point &#123; y: <span class="built_in">number</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> point: Point = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="十一、TypeScript-类"><a href="#十一、TypeScript-类" class="headerlink" title="十一、TypeScript 类"></a>十一、TypeScript 类</h3><h4 id="11-1-类的属性与方法"><a href="#11-1-类的属性与方法" class="headerlink" title="11.1 类的属性与方法"></a>11.1 类的属性与方法</h4><p>在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。</p><p>在 TypeScript 中，我们可以通过 <code>Class</code> 关键字来定义一个类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="keyword">static</span> cname: <span class="built_in">string</span> = <span class="string">&quot;Greeter&quot;</span>;</span><br><span class="line">  <span class="comment">// 成员属性</span></span><br><span class="line">  greeting: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数 - 执行初始化操作</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.greeting = message;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getClassName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Class name is Greeter&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成员方法</span></span><br><span class="line">  <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.greeting;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> Greeter(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><p>那么成员属性与静态属性，成员方法与静态方法有什么区别呢？这里无需过多解释，我们直接看一下编译生成的 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> Greeter = <span class="comment">/** <span class="doctag">@class </span>*/</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数 - 执行初始化操作</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.greeting = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    Greeter.getClassName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Class name is Greeter&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    Greeter.prototype.greet = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.greeting;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    Greeter.cname = <span class="string">&quot;Greeter&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> Greeter;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> greeter = <span class="keyword">new</span> Greeter(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="11-2-ECMAScript-私有字段"><a href="#11-2-ECMAScript-私有字段" class="headerlink" title="11.2 ECMAScript 私有字段"></a>11.2 ECMAScript 私有字段</h4><p>在 TypeScript 3.8 版本就开始支持<strong>ECMAScript 私有字段</strong>，使用方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  #name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.#name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="built_in">this</span>.#name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> semlinker = <span class="keyword">new</span> Person(<span class="string">&quot;Semlinker&quot;</span>);</span><br><span class="line"></span><br><span class="line">semlinker.#name;</span><br><span class="line"><span class="comment">//     ~~~~~</span></span><br><span class="line"><span class="comment">// Property &#x27;#name&#x27; is not accessible outside class &#x27;Person&#x27;</span></span><br><span class="line"><span class="comment">// because it has a private identifier.</span></span><br></pre></td></tr></table></figure><p>与常规属性（甚至使用 <code>private</code> 修饰符声明的属性）不同，私有字段要牢记以下规则：</p><ul><li>私有字段以 <code>#</code> 字符开头，有时我们称之为私有名称；</li><li>每个私有字段名称都唯一地限定于其包含的类；</li><li>不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；</li><li>私有字段不能在包含的类之外访问，甚至不能被检测到。</li></ul><h4 id="11-3-访问器"><a href="#11-3-访问器" class="headerlink" title="11.3 访问器"></a>11.3 访问器</h4><p>在 TypeScript 中，我们可以通过 <code>getter</code> 和 <code>setter</code> 方法来实现数据的封装和有效性校验，防止出现异常数据。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> passcode = <span class="string">&quot;Hello TypeScript&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _fullName: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">fullName</span>(): <span class="title">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._fullName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">fullName</span>(<span class="params">newName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">&quot;Hello TypeScript&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>._fullName = newName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Error: Unauthorized update of employee!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">&quot;Semlinker&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-4-类的继承"><a href="#11-4-类的继承" class="headerlink" title="11.4 类的继承"></a>11.4 类的继承</h4><p>继承（Inheritance）是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。</p><p>继承是一种 <a href="https://link.juejin.cn/?target=https://zh.wikipedia.org/wiki/Is-a">is-a </a> 关系：<br>在 TypeScript 中，我们可以通过 <code>extends</code> 关键字来实现继承：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snake</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name); <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters = <span class="number">5</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Slithering...&quot;</span>);</span><br><span class="line">    <span class="built_in">super</span>.move(distanceInMeters);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> Snake(<span class="string">&quot;Sammy the Python&quot;</span>);</span><br><span class="line">sam.move();</span><br></pre></td></tr></table></figure><h4 id="11-5-抽象类"><a href="#11-5-抽象类" class="headerlink" title="11.5 抽象类"></a>11.5 抽象类</h4><p>使用 <code>abstract</code> 关键字声明的类，我们称之为抽象类。抽象类不能被实例化，因为它里面包含一个或多个抽象方法。所谓的抽象方法，是指不包含具体实现的方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> say(words: <span class="built_in">string</span>) :<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cannot create an instance of an abstract class.(2511)</span></span><br><span class="line"><span class="keyword">const</span> lolo = <span class="keyword">new</span> Person(); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>抽象类不能被直接实例化，我们只能实例化实现了所有抽象方法的子类。具体如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 抽象方法</span></span><br><span class="line">  <span class="keyword">abstract</span> say(words: <span class="built_in">string</span>) :<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Developer</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  say(words: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> says <span class="subst">$&#123;words&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lolo = <span class="keyword">new</span> Developer(<span class="string">&quot;lolo&quot;</span>);</span><br><span class="line">lolo.say(<span class="string">&quot;I love ts!&quot;</span>); <span class="comment">// lolo says I love ts!</span></span><br></pre></td></tr></table></figure><h4 id="11-6-类方法重载"><a href="#11-6-类方法重载" class="headerlink" title="11.6 类方法重载"></a>11.6 类方法重载</h4><p>在前面的章节，我们已经介绍了函数重载。对于类的方法来说，它也支持重载。比如，在以下示例中我们重载了 <code>ProductService</code> 类的 <code>getProducts</code> 成员方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line">    getProducts(): <span class="built_in">void</span>;</span><br><span class="line">    getProducts(id: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">    <span class="function"><span class="title">getProducts</span>(<span class="params">id?: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> id === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`获取id为 <span class="subst">$&#123;id&#125;</span> 的产品信息`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`获取所有的产品信息`</span>);</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> productService = <span class="keyword">new</span> ProductService();</span><br><span class="line">productService.getProducts(<span class="number">666</span>); <span class="comment">// 获取id为 666 的产品信息</span></span><br><span class="line">productService.getProducts(); <span class="comment">// 获取所有的产品信息 </span></span><br></pre></td></tr></table></figure><h3 id="十二、TypeScript-泛型"><a href="#十二、TypeScript-泛型" class="headerlink" title="十二、TypeScript 泛型"></a>十二、TypeScript 泛型</h3><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p><p><strong>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</strong></p><p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p><p>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p><h4 id="12-1-泛型语法"><a href="#12-1-泛型语法" class="headerlink" title="12.1 泛型语法"></a>12.1 泛型语法</h4><p>对于刚接触 TypeScript 泛型的读者来说，首次看到 <code>&lt;T&gt;</code> 语法会感到陌生。其实它没有什么特别，就像传递参数一样，我们传递了我们想要用于特定函数调用的类型。</p><p><code>T</code> 代表 <strong>Type</strong>，在定义泛型时通常用作第一个类型变量名称。但实际上 <code>T</code> 可以用任何有效名称代替。除了 <code>T</code> 之外，以下是常见泛型变量代表的意思：</p><ul><li>K（Key）：表示对象中的键类型；</li><li>V（Value）：表示对象中的值类型；</li><li>E（Element）：表示元素类型。</li></ul><p>其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 <code>U</code>，用于扩展我们定义的 <code>identity</code> 函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">identity</span> &lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">value: T, message: U</span>) : <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(identity&lt;<span class="built_in">Number</span>, <span class="built_in">string</span>&gt;(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br></pre></td></tr></table></figure><p>除了为类型变量显式设定值之外，一种更常见的做法是使编译器自动选择这些类型，从而使代码更简洁。我们可以完全省略尖括号，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">identity</span> &lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">value: T, message: U</span>) : <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(identity(<span class="number">68</span>, <span class="string">&quot;Semlinker&quot;</span>));</span><br></pre></td></tr></table></figure><p>对于上述代码，编译器足够聪明，能够知道我们的参数类型，并将它们赋值给 T 和 U，而不需要开发人员显式指定它们。</p><h4 id="12-2-泛型接口"><a href="#12-2-泛型接口" class="headerlink" title="12.2 泛型接口"></a>12.2 泛型接口</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">interface</span> GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">  (arg: T): T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-3-泛型类"><a href="#12-3-泛型类" class="headerlink" title="12.3 泛型类"></a>12.3 泛型类</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  zeroValue: T;</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="12-4-泛型工具类型"><a href="#12-4-泛型工具类型" class="headerlink" title="12.4 泛型工具类型"></a>12.4 泛型工具类型</h4><p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍 Partial 工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。</p><h5 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h5><p>在 TypeScript 中，<code>typeof</code> 操作符可以用来获取一个变量声明或对象的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sem: Person = &#123; <span class="attr">name</span>: <span class="string">&#x27;semlinker&#x27;</span>, <span class="attr">age</span>: <span class="number">33</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> Sem= <span class="keyword">typeof</span> sem; <span class="comment">// -&gt; Person</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">Array</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Func = <span class="keyword">typeof</span> toArray; <span class="comment">// -&gt; (x: number) =&gt; number[]</span></span><br></pre></td></tr></table></figure><h5 id="2-keyof"><a href="#2-keyof" class="headerlink" title="2.keyof"></a>2.keyof</h5><p><code>keyof</code> 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> K1 = keyof Person; <span class="comment">// &quot;name&quot; | &quot;age&quot;</span></span><br><span class="line"><span class="keyword">type</span> K2 = keyof Person[]; <span class="comment">// &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot; </span></span><br><span class="line"><span class="keyword">type</span> K3 = keyof &#123; [x: <span class="built_in">string</span>]: Person &#125;;  <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure><p>在 TypeScript 中支持两种索引签名，数字索引和字符串索引：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  <span class="comment">// 字符串索引 -&gt; keyof StringArray =&gt; string | number</span></span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> StringArray1 &#123;</span><br><span class="line">  <span class="comment">// 数字索引 -&gt; keyof StringArray1 =&gt; number</span></span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了同时支持两种索引类型，就得要求数字索引的返回值必须是字符串索引返回值的子类。<strong>其中的原因就是当使用数值索引时，JavaScript 在执行索引操作时，会先把数值索引先转换为字符串索引</strong>。所以 <code>keyof &#123; [x: string]: Person &#125;</code> 的结果会返回 <code>string | number</code>。</p><h5 id="3-in"><a href="#3-in" class="headerlink" title="3.in"></a>3.in</h5><p><code>in</code> 用来遍历枚举类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> Keys = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Obj =  &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: <span class="built_in">any</span></span><br><span class="line">&#125; <span class="comment">// -&gt; &#123; a: any, b: any, c: any &#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-infer"><a href="#4-infer" class="headerlink" title="4.infer"></a>4.infer</h5><p>在条件类型语句中，可以用 <code>infer</code> 声明一个类型变量并且对它进行使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><p>以上代码中 <code>infer R</code> 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p><h5 id="5-extends"><a href="#5-extends" class="headerlink" title="5.extends"></a>5.extends</h5><p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(<span class="number">3</span>);  <span class="comment">// Error, number doesn&#x27;t have a .length property</span></span><br></pre></td></tr></table></figure><p>这时我们需要传入符合约束类型的值，必须包含必须的属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(&#123;<span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><h5 id="6-Partial"><a href="#6-Partial" class="headerlink" title="6.Partial"></a>6.Partial</h5><p><code>Partial&lt;T&gt;</code> 的作用就是将某个类型里的属性全部变为可选项 <code>?</code>。</p><p><strong>定义：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * node_modules/typescript/lib/lib.es5.d.ts</span></span><br><span class="line"><span class="comment"> * Make all properties in T optional</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在以上代码中，首先通过 <code>keyof T</code> 拿到 <code>T</code> 的所有属性名，然后使用 <code>in</code> 进行遍历，将值赋给 <code>P</code>，最后通过 <code>T[P]</code> 取得相应的属性值。中间的 <code>?</code> 号，用于将所有属性变为可选。</p><p><strong>示例：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  description: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTodo</span>(<span class="params">todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo1 = &#123;</span><br><span class="line">  title: <span class="string">&quot;Learn TS&quot;</span>,</span><br><span class="line">  description: <span class="string">&quot;Learn TypeScript&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo2 = updateTodo(todo1, &#123;</span><br><span class="line">  description: <span class="string">&quot;Learn TypeScript Enum&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的 <code>updateTodo</code> 方法中，我们利用 <code>Partial&lt;T&gt;</code> 工具类型，定义 <code>fieldsToUpdate</code> 的类型为 <code>Partial&lt;Todo&gt;</code>，即：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">   title?: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">   description?: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十三、TypeScript-装饰器"><a href="#十三、TypeScript-装饰器" class="headerlink" title="十三、TypeScript 装饰器"></a>十三、TypeScript 装饰器</h3><h4 id="13-1-装饰器是什么"><a href="#13-1-装饰器是什么" class="headerlink" title="13.1 装饰器是什么"></a>13.1 装饰器是什么</h4><ul><li>它是一个表达式</li><li>该表达式被执行后，返回一个函数</li><li>函数的入参分别为 target、name 和 descriptor</li><li>执行该函数后，可能返回 descriptor 对象，用于配置 target 对象</li></ul><h4 id="13-2-装饰器的分类"><a href="#13-2-装饰器的分类" class="headerlink" title="13.2 装饰器的分类"></a>13.2 装饰器的分类</h4><ul><li>类装饰器（Class decorators）</li><li>属性装饰器（Property decorators）</li><li>方法装饰器（Method decorators）</li><li>参数装饰器（Parameter decorators）</li></ul><p>需要注意的是，若要启用实验性的装饰器特性，你必须在命令行或 <code>tsconfig.json</code> 里启用 <code>experimentalDecorators</code> 编译器选项：</p><p><strong>命令行</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --target ES5 --experimentalDecorators</span><br></pre></td></tr></table></figure><p><strong>tsconfig.json</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">     <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES5&quot;</span>,</span><br><span class="line">     <span class="attr">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-3-类装饰器"><a href="#13-3-类装饰器" class="headerlink" title="13.3 类装饰器"></a>13.3 类装饰器</h4><p>类装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">declare</span> <span class="keyword">type</span> ClassDecorator = <span class="xml"><span class="tag">&lt;<span class="name">TFunction</span> <span class="attr">extends</span> <span class="attr">Function</span>&gt;</span>(</span></span><br><span class="line"><span class="xml">  target: TFunction</span></span><br><span class="line"><span class="xml">) =&gt; TFunction | void;</span></span><br></pre></td></tr></table></figure><p>类装饰器顾名思义，就是用来装饰类的。它接收一个参数：</p><ul><li>target: TFunction - 被装饰的类</li></ul><p>看完第一眼后，是不是感觉都不好了。没事，我们马上来个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">target: <span class="built_in">Function</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  target.prototype.greet = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello Semlinker!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Greeter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 内部实现</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGreeting = <span class="keyword">new</span> Greeting();</span><br><span class="line">(myGreeting <span class="keyword">as</span> <span class="built_in">any</span>).greet(); <span class="comment">// console output: &#x27;Hello Semlinker!&#x27;;</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义了 <code>Greeter</code> 类装饰器，同时我们使用了 <code>@Greeter</code> 语法糖，来使用装饰器。</p><blockquote><p>友情提示：读者可以直接复制上面的代码，在 <a href="https://link.juejin.cn/?target=https://www.typescriptlang.org/play/index.html">TypeScript Playground</a> 中运行查看结果。</p></blockquote><p>有的读者可能想问，例子中总是输出 <code>Hello Semlinker!</code> ，能自定义输出的问候语么 ？这个问题很好，答案是可以的。</p><p>具体实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">greeting: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">    target.prototype.greet = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(greeting);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Greeter</span>(<span class="string">&quot;Hello TS!&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 内部实现</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGreeting = <span class="keyword">new</span> Greeting();</span><br><span class="line">(myGreeting <span class="keyword">as</span> <span class="built_in">any</span>).greet(); <span class="comment">// console output: &#x27;Hello TS!&#x27;;</span></span><br></pre></td></tr></table></figure><h4 id="13-4-属性装饰器"><a href="#13-4-属性装饰器" class="headerlink" title="13.4 属性装饰器"></a>13.4 属性装饰器</h4><p>属性装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> PropertyDecorator = (target:<span class="built_in">Object</span>, </span><br><span class="line"> propertyKey: <span class="built_in">string</span> | symbol ) =&gt; <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>属性装饰器顾名思义，用来装饰类的属性。它接收两个参数：</p><ul><li>target: Object - 被装饰的类</li><li>propertyKey: string | symbol - 被装饰类的属性名</li></ul><p>趁热打铁，马上来个例子热热身：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">logProperty</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">delete</span> target[key];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> backingField = <span class="string">&quot;_&quot;</span> + key;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, backingField, &#123;</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// property getter</span></span><br><span class="line">  <span class="keyword">const</span> getter = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currVal = <span class="built_in">this</span>[backingField];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Get: <span class="subst">$&#123;key&#125;</span> =&gt; <span class="subst">$&#123;currVal&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> currVal;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// property setter</span></span><br><span class="line">  <span class="keyword">const</span> setter = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">this</span>: <span class="built_in">any</span>, newVal: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Set: <span class="subst">$&#123;key&#125;</span> =&gt; <span class="subst">$&#123;newVal&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">this</span>[backingField] = newVal;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create new property with getter and setter</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">    get: getter,</span><br><span class="line">    set: setter,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">  <span class="meta">@logProperty</span></span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name : <span class="built_in">string</span></span>)</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;semlinker&quot;</span>);</span><br><span class="line">p1.name = <span class="string">&quot;kakuqo&quot;</span>;</span><br></pre></td></tr></table></figure><p>以上代码我们定义了一个 <code>logProperty</code> 函数，来跟踪用户对属性的操作，当代码成功运行后，在控制台会输出以下结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set: name =&gt; semlinker</span><br><span class="line">Set: name =&gt; kakuqo</span><br></pre></td></tr></table></figure><h4 id="13-5-方法装饰器"><a href="#13-5-方法装饰器" class="headerlink" title="13.5 方法装饰器"></a>13.5 方法装饰器</h4><p>方法装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> MethodDecorator = &lt;T&gt;(target:<span class="built_in">Object</span>, <span class="attr">propertyKey</span>: <span class="built_in">string</span> | symbol,  </span><br><span class="line"> descriptor: TypePropertyDescript&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><p>方法装饰器顾名思义，用来装饰类的方法。它接收三个参数：</p><ul><li>target: Object - 被装饰的类</li><li>propertyKey: string | symbol - 方法名</li><li>descriptor: TypePropertyDescript - 属性描述符</li></ul><p>废话不多说，直接上例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> originalMethod = descriptor.value;</span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;wrapped function: before invoking &quot;</span> + propertyKey);</span><br><span class="line">    <span class="keyword">let</span> result = originalMethod.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;wrapped function: after invoking &quot;</span> + propertyKey);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">  <span class="meta">@log</span></span><br><span class="line">  runTask(arg: <span class="built_in">any</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;runTask invoked, args: &quot;</span> + arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;finished&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> task = <span class="keyword">new</span> Task();</span><br><span class="line"><span class="keyword">let</span> result = task.runTask(<span class="string">&quot;learn ts&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;result: &quot;</span> + result);</span><br></pre></td></tr></table></figure><p>以上代码成功运行后，控制台会输出以下结果：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;wrapped function: before invoking runTask&quot;</span> </span><br><span class="line"><span class="string">&quot;runTask invoked, args: learn ts&quot;</span> </span><br><span class="line"><span class="string">&quot;wrapped function: after invoking runTask&quot;</span> </span><br><span class="line"><span class="string">&quot;result: finished&quot;</span> </span><br></pre></td></tr></table></figure><p>下面我们来介绍一下参数装饰器。</p><h4 id="13-6-参数装饰器"><a href="#13-6-参数装饰器" class="headerlink" title="13.6 参数装饰器"></a>13.6 参数装饰器</h4><p>参数装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> ParameterDecorator = (target: <span class="built_in">Object</span>, <span class="attr">propertyKey</span>: <span class="built_in">string</span> | symbol, </span><br><span class="line"> parameterIndex: <span class="built_in">number</span> ) =&gt; <span class="built_in">void</span></span><br></pre></td></tr></table></figure><p>参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数：</p><ul><li>target: Object - 被装饰的类</li><li>propertyKey: string | symbol - 方法名</li><li>parameterIndex: number - 方法中参数的索引值</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Log</span>(<span class="params">target: <span class="built_in">Function</span>, key: <span class="built_in">string</span>, parameterIndex: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> functionLogged = key || target.prototype.constructor.name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`The parameter in position <span class="subst">$&#123;parameterIndex&#125;</span> at <span class="subst">$&#123;functionLogged&#125;</span> has</span></span><br><span class="line"><span class="string">been decorated`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  greeting: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="meta">@Log</span> phrase: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.greeting = phrase; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码成功运行后，控制台会输出以下结果：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;The parameter in position 0 at Greeter has been decorated&quot;</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="TypeScript" scheme="http://aiolimp.com/categories/TypeScript/"/>
    
    
    <category term="TypeScript" scheme="http://aiolimp.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt</title>
    <link href="http://aiolimp.com/2023/07/02/nuxt3/"/>
    <id>http://aiolimp.com/2023/07/02/nuxt3/</id>
    <published>2023-07-01T16:00:00.000Z</published>
    <updated>2025-04-12T11:51:33.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="nuxt"><a href="#nuxt" class="headerlink" title="nuxt"></a>nuxt</h2><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>按照官网描述的 打开一个终端，并使用以下命令创建一个新的启动项目:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm dlx nuxi init &lt;project-name&gt;</span><br></pre></td></tr></table></figure><p>进入项目终端，安装项目依赖（node版本至少v16）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install</span><br></pre></td></tr></table></figure><p>运行项目</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm dev</span><br></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>理论上一个完整的项目除了常用目录以外，还需要建立 <code>husky</code>、<code>commitlint</code>、<code>prettier</code>、<code>stylelint</code>、<code>tsconfig</code>等以便更好地规范项目。正常情况下，我们希望项目配置文件比如以上说项目规范配置文件或者是<code>build</code>工程化构建相关配置文件、环境变量等放在根目录下，而项目内容（如页面、组件等）统一放在<code>src</code>文件夹内管理。所以项目结构最终大致如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Nuxt3</span><br><span class="line">├── .husky                        # Git hooks 工具配置</span><br><span class="line">├── .vscode                       # vscode配置</span><br><span class="line">├── doc                           # 项目文档</span><br><span class="line">├── build                         # 工程化构建相关配置</span><br><span class="line">├── src</span><br><span class="line">│   ├── api                       # 接口请求服务管理</span><br><span class="line">│   │  └── modules                # 接口模块</span><br><span class="line">│   ├── assets                    # 工程化处理的静态资源</span><br><span class="line">│   ├── components                # 项目组件</span><br><span class="line">│   ├── composables               # 响应式共享状态</span><br><span class="line">│   ├── enums                     # 枚举管理</span><br><span class="line">│   ├── layouts                   # 布局组件</span><br><span class="line">│   ├── middleware                # 路由中间件</span><br><span class="line">│   ├── pages                     # 页面视图</span><br><span class="line">│   ├── plugins                   # 项目公共插件</span><br><span class="line">│   ├── public                    # 不需要工程化处理的静态资源</span><br><span class="line">│   ├── store                     # 状态管理</span><br><span class="line">│   ├── utils                     # 静态工具函数</span><br><span class="line">│   └── app.vue                   # 入口页面</span><br><span class="line">├── .commitlintrc.json            # git提交规范检查配置</span><br><span class="line">├── .editorconfig                 # 编辑器配置</span><br><span class="line">├── .env                          # 环境变量(默认/开发环境)</span><br><span class="line">├─  .env.local                    # 本地环境变量</span><br><span class="line">├── .env.pre                      # 预发布环境变量</span><br><span class="line">├── .env.prod                     # 生产环境变量</span><br><span class="line">├── .env.test                     # 测试环境变量</span><br><span class="line">├── .eslintignore                 # eslint忽略文件检查的配置</span><br><span class="line">├── .eslintrc.js                  # eslint代码规范检查配置</span><br><span class="line">├── .gitignore                    # git仓库提交忽略配置</span><br><span class="line">├── .lintstagedrc.js              # git提交代码规范检查配置</span><br><span class="line">├── .ls-lint.yml                  # 文件命名检查配置</span><br><span class="line">├── .prettierignore               # prettier忽略格式化的配置</span><br><span class="line">├── .prettierrc.js                # prettier格式化配置</span><br><span class="line">├── .stylelintignore              # 样式规范忽略检查的配置</span><br><span class="line">├── .stylelintrc.js               # 样式规范检查配置</span><br><span class="line">├── nuxt.config.ts                # Vite 构建配置入口</span><br><span class="line">├── package.json                  # 项目包管理文件</span><br><span class="line">├── pnpm-lock.yaml                # pnpm包版本管理锁定</span><br><span class="line">├── postcss.config.js             # postcss配置</span><br><span class="line">├── README.md                     # 项目说明</span><br><span class="line">├── tailwind.config.js            # tailwind配置</span><br><span class="line">└── tsconfig.json                 # TS编译的配置</span><br></pre></td></tr></table></figure><p>而 Nuxt 初始化，<code>app.vue</code>、<code>pages</code>文件等都建立在根目录下，所以我们先在根目录下建立 <code>src</code> 文件夹，并且把 <code>app.vue</code> 文件移入到 <code>src</code> 目录下，修改 <code>nuxt.config.ts</code>文件配置：</p><h3 id="nuxt-1"><a href="#nuxt-1" class="headerlink" title=".nuxt"></a>.nuxt</h3><p>Nuxt 使用.nuxt/目录在开发中生成您的Vue应用程序。</p><p>你不应该碰里面的任何文件，因为整个目录将在运行 nuxt dev 时重新创建。</p><h3 id="assets"><a href="#assets" class="headerlink" title="assets"></a>assets</h3><p>assets/ 目录用于添加构建工具(webpack或Vite)将处理的所有网站资产。</p><p>该目录通常包含以下类型的文件:</p><ul><li>Stylesheets (CSS, SASS, etc.)</li><li>Fonts</li><li>Images</li><li>Icons</li></ul><p>如果你想从服务器上提供资产，可以将文件放入 public/ 目录。</p><h3 id="components-组件"><a href="#components-组件" class="headerlink" title="components 组件"></a>components 组件</h3><h4 id="组件名策略"><a href="#组件名策略" class="headerlink" title="组件名策略"></a>组件名策略</h4><p>默认情况下，Nuxt自动导入components目录中的任何组件，组件名将基于它的路径、目录和文件名。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| components/</span><br><span class="line">--| Base</span><br><span class="line">----| Footer.vue</span><br></pre></td></tr></table></figure><p>如上，该组件名为：BaseFooter</p><p>如果只想根据组件的名称而不是路径自动导入组件，那么需要在 nuxt.config.ts 文件中将 <code>pathPrefix</code> 选项设置为false，此时与Nuxt2的命名策略相同：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineNuxtConfig(&#123;</span><br><span class="line">  components: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;~/components/&#x27;</span>,</span><br><span class="line">      pathPrefix: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| components/</span><br><span class="line"> --| Base</span><br><span class="line">----| Footer.vue</span><br></pre></td></tr></table></figure><p>如上，该组件名为：Footer</p><h4 id="绕过自动导入"><a href="#绕过自动导入" class="headerlink" title="绕过自动导入"></a>绕过自动导入</h4><ul><li>可以在 nuxt.config.ts 文件中在 components 下配置 path；只有 path 配置路径下的组件才会被自动导入</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| components/</span><br><span class="line">--| business/</span><br><span class="line">----| Count.vue</span><br><span class="line">--| <span class="keyword">public</span>/</span><br><span class="line">----| MyImg.vue</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineNuxtConfig(&#123;</span><br><span class="line">   components: [</span><br><span class="line">      &#123;</span><br><span class="line">         path: <span class="string">&#x27;~/components/public&#x27;</span>, <span class="comment">// 默认为 &#x27;~/components&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如上只有 public 目录下的组件将被注册，且自动注册的组件名为 MyImg (非 PublicMyImg)；business 目录下的组件将被忽略。</p><ul><li>可以配置 components 为 false，此时 components 下任何组件都不会被自动导入。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineNuxtConfig(&#123;</span><br><span class="line">   components: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>也可以显式地从 #components 导入组件。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">LazyMyImg</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">import</span> &#123; LazyMyImg &#125; <span class="keyword">from</span> <span class="string">&#x27;#components&#x27;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="惰性加载组件"><a href="#惰性加载组件" class="headerlink" title="惰性加载组件"></a>惰性加载组件</h4><p>要动态导入一个组件(也称为惰性加载组件)，则在组件名称前添加 <code>Lazy</code> 前缀。通过使用 <code>Lazy</code> 前缀，你可以延迟加载组件代码，直到合适的时刻</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">MyImg</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">LazyMyImg</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="composables"><a href="#composables" class="headerlink" title="composables"></a>composables</h3><p>composables 目录下的内容也将自动将 Vue 组合导入到应用中，Nuxt 只扫描 composables/ 目录的顶层文件。Composables 的主要作用是将常用逻辑和逻辑相关的代码抽象出来，以提高代码可复用性和可维护性，如：跨组件创建响应性的、对ssr友好的共享状态—— <code>useState</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* composables/counter.ts 内容</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> userCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> useState(<span class="string">&#x27;counter&#x27;</span>, <span class="function">() =&gt;</span> <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 业务组件</span><br><span class="line">**&#x2F;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  import Count from &quot;~&#x2F;components&#x2F;business&#x2F;Count.vue&quot;;</span><br><span class="line">  const counter &#x3D; userCounter();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    业务组件内容: &#123;&#123; counter &#125;&#125;</span><br><span class="line">    &lt;a-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;counter--&quot;&gt; － &lt;&#x2F;a-button&gt;</span><br><span class="line">    &lt;a-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;counter++&quot;&gt; ＋ &lt;&#x2F;a-button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* business&#x2F;Count 组件内容</span><br><span class="line">**&#x2F;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;Count组件内容：&#123;&#123; counter &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">  const counter &#x3D; userCounter();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="layouts"><a href="#layouts" class="headerlink" title="layouts"></a>layouts</h3><p>Nuxt提供了一个可定制的布局框架，可以在整个应用程序中使用，非常适合将常见的UI或代码模式提取到可重用的布局组件中。布局放在layouts/目录中，使用时将通过异步导入自动加载。</p><h4 id="默认布局"><a href="#默认布局" class="headerlink" title="默认布局"></a>默认布局</h4><p>在layouts目录下添加default.vue 布局文件。</p><p>不像其他组件，布局组件必须有一个根元素，以允许 Nuxt 在布局变化之间应用过渡-这个根元素不能是<slot />。如果你的应用只有一个布局，建议使用app.vue。</p><p>在布局文件中，布局的内容将加载在<slot />中，~/layouts/default.vue:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你使用app.vue你还需要添加 :</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">NuxtLayout</span>&gt;</span></span><br><span class="line">      // 在app.vue中没有NuxtLayout组件，内容将会不显示</span><br><span class="line">   <span class="tag">&lt;/<span class="name">NuxtLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置布局"><a href="#配置布局" class="headerlink" title="配置布局"></a>配置布局</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-| layouts/</span><br><span class="line">---| default.vue</span><br><span class="line">---| custom.vue</span><br></pre></td></tr></table></figure><p>可以在 NuxtLayout 中添加 <code>name</code> 属性来覆盖默认布局:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">NuxtLayout</span> <span class="attr">:name</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">NuxtPage</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">NuxtLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="comment">// 您可以根据API调用或登录状态来选择此选项</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">const</span> layout = <span class="string">&quot;custom&quot;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以通过 <code>definePageMeta</code> 设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">NuxtLayout</span>&gt;</span></span><br><span class="line">    巴拉巴拉小魔仙</span><br><span class="line">  <span class="tag">&lt;/<span class="name">NuxtLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line">  definePageMeta(&#123;</span><br><span class="line"><span class="javascript">    layout: <span class="string">&quot;custom&quot;</span>,</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>如果业务组件不使用 <code>&lt;NuxtLayout&gt;</code> 组件包裹，配置布局是不会生效的</strong></p><h3 id="middleware-中间件"><a href="#middleware-中间件" class="headerlink" title="middleware 中间件"></a>middleware 中间件</h3><p>Nuxt提供了一个可定制的路由中间件框架，可以在整个应用程序中使用，可以认为路由中间件就是导航守卫，因为它接收当前路由和下一个路由作为参数。</p><p>路由中间件有三种:</p><h4 id="匿名-或内联-路由中间件"><a href="#匿名-或内联-路由中间件" class="headerlink" title="匿名(或内联)路由中间件"></a>匿名(或内联)路由中间件</h4><p>直接在使用它们的页面中定义。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">   definePageMeta(&#123;</span><br><span class="line">      middleware: [</span><br><span class="line">          defineNuxtRouteMiddleware(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;匿名路由中间件&#x27;</span>, to, <span class="keyword">from</span>)</span><br><span class="line">          &#125;),</span><br><span class="line">      ],</span><br><span class="line">   &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="命名路由中间件"><a href="#命名路由中间件" class="headerlink" title="命名路由中间件"></a>命名路由中间件</h4><p>放置在middleware/ 目录中，在页面上使用时会通过异步导入自动加载。(注意:路由中间件名称被规范化为串串形式，因此someMiddleware 变成 some-middleware。)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-| middleware/</span><br><span class="line">---| auth.ts</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">   definePageMeta(&#123;</span><br><span class="line">      middleware: [<span class="string">&#x27;auth&#x27;</span>],</span><br><span class="line">   &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="全局路由中间件"><a href="#全局路由中间件" class="headerlink" title="全局路由中间件"></a>全局路由中间件</h4><p>放置在 middleware/目录中(带有<code>.global</code>后缀)，并将在每次路由更改时自动运行。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-| middleware/</span><br><span class="line">---| auth.global.ts</span><br></pre></td></tr></table></figure><blockquote><p>带 <code>.global</code> 后缀的全局路由中间件，执行顺序优先于app.vue</p></blockquote><p>Nuxt提供了两个全局可用的辅助函数，它们可以直接从中间件返回:</p><ul><li><code>navigateTo</code> 在插件或中间件中重定向到给定的路由。也可以直接调用它来执行页面导航。</li><li><code>abortNavigation</code> 终止导航，并显示一条可选的错误消息。</li></ul><p>不像 vue-router 中的导航守卫，第三个 next() 参数不会被传递，重定向或路由取消是通过从中间件返回值来处理的。可能的返回值有:</p><ul><li><code>nothing</code> 不会阻塞导航，并且会移动到下一个中间件功能(如果有的话)，或者完成路由导航</li><li><code>return navigateTo(&#39;/&#39;)</code> - 重定向到给定的路径，并将重定向代码设置为302 Found</li><li><code>return navigateTo(&#39;/&#39;, &#123; redirectCode: 301 &#125;)</code> - 重定向到给定的路径，并将重定向代码设置为301 Moved permanent</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">navigateTo(to: RouteLocationRaw | <span class="literal">undefined</span> | <span class="literal">null</span>,options?: NavigateToOptions) =&gt; </span><br><span class="line">    <span class="built_in">Promise</span>&lt;<span class="built_in">void</span> | NavigationFailure&gt; | RouteLocationRaw</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> NavigateToOptions &#123;</span><br><span class="line">  replace?: <span class="built_in">boolean</span></span><br><span class="line">  redirectCode?: <span class="built_in">number</span></span><br><span class="line">  external?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Q：默认情况下，navigateTo 将给定的路由推送到客户端 Vue Router 的实例中。</p><p>在 middleware 调用 pinia-acitons 里面的函数，函数内执行 navigateTo(url) 会失效?</p><p>A：在插件、中间件、vue 文件的 setup 里面是可以调用 navigateTo 的。但是在调用 navigateTo 时，确保 <code>await</code> 或者 <code>return</code> 作为 navigateTo 的结果，否则终端就会有报错提示(如下图)，页面跳转失败。建议默认使用 await 作为 navigateTo 的结果。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f13130c84d48445882397b51cea4762e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1994&h=262&s=329149&e=png&b=051626" alt="img"></p><h4 id="middleware-实现单点登录"><a href="#middleware-实现单点登录" class="headerlink" title="middleware 实现单点登录"></a>middleware 实现单点登录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-| middleware&#x2F;</span><br><span class="line">---| auth.global.ts</span><br><span class="line">-| enums&#x2F;</span><br><span class="line">---| auth.ts</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* enums/auth.ts</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> WhitePageEnum &#123;</span><br><span class="line">   BASE_HOME = <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">   SERVER_ERROR_PAGE = <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">   FETCH_TEST_PAGE = <span class="string">&#x27;fetch&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* middleware/auth.global.ts</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">import</span> &#123; WhitePageEnum &#125; <span class="keyword">from</span> <span class="string">&quot;~/enums/auth&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useUserStore &#125; <span class="keyword">from</span> <span class="string">&quot;~/store/modules/user&quot;</span>;</span><br><span class="line"><span class="comment">// 白名单</span></span><br><span class="line"><span class="keyword">const</span> whitePathList: WhitePageEnum[] = [</span><br><span class="line">  WhitePageEnum.BASE_HOME,</span><br><span class="line">  WhitePageEnum.SERVER_ERROR_PAGE,</span><br><span class="line">  WhitePageEnum.FETCH_TEST_PAGE,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineNuxtRouteMiddleware(<span class="keyword">async</span> (to) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> userStore = useUserStore();</span><br><span class="line">  <span class="comment">// 从 store 获取用户信息</span></span><br><span class="line">  <span class="keyword">let</span> &#123; userId &#125; = userStore.getUserInfo;</span><br><span class="line">  <span class="keyword">if</span> (!userId) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> userStore.fetchUserInfo();</span><br><span class="line">    userId = res?.userId;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!whitePathList.includes(to.name <span class="keyword">as</span> WhitePageEnum)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!userId) &#123;</span><br><span class="line">      <span class="keyword">const</span> nuxtApp = useNuxtApp();</span><br><span class="line">      <span class="keyword">const</span> &#123; _route, $login &#125; = nuxtApp;</span><br><span class="line">      <span class="keyword">await</span> $login(_route?.fullPath);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="pages-页面"><a href="#pages-页面" class="headerlink" title="pages 页面"></a>pages 页面</h3><p>页面目录。Nuxt 提供了一个基于文件的路由，使用 Vue Router 在底层创建路由。pages/index.vue 文件将被映射到应用程序 / 路由。</p><p>如果你正在使用app.vue，确保在 app.vue 使用 <code>&lt;NuxtPage/&gt;</code> 组件来显示当前页面。</p><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><p>建立页面文件时，如果命名时将任何内容放在方括号内，它将被转换为路由参数。在文件名或目录中混合和匹配多个参数。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-| pages/</span><br><span class="line">---| index.vue</span><br><span class="line">---| users-[group]/</span><br><span class="line">-----| [id].vue</span><br></pre></td></tr></table></figure><p>会生成路由：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;routes&quot;</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;users-group-id&quot;</span>,</span><br><span class="line">        <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/users-:group()/:id()&quot;</span>,</span><br><span class="line">        <span class="string">&quot;component&quot;</span>: <span class="string">&quot;~/pages/users-[group]/[id].vue&quot;</span></span><br><span class="line">     &#125;,</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的例子，你可以通过 $route 对象中的 params 访问组件中的 group &amp; idx</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;text-base text-gray-600&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        获取到的 group 是 <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;text-green-500 text-xl&quot;</span>&gt;</span>&#123;&#123; group &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        获取到的 id 是 <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;text-green-500 text-xl&quot;</span>&gt;</span>&#123;&#123; id &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="与-Nuxt2-区别"><a href="#与-Nuxt2-区别" class="headerlink" title="与 Nuxt2 区别"></a>与 Nuxt2 区别</h4><h5 id="文件命名规则"><a href="#文件命名规则" class="headerlink" title="文件命名规则"></a>文件命名规则</h5><p>Nuxt3 在 page 目录下，新建文件命名时，将任何内容放在方括号内，它将被转换为动态路由参数。还可以在文件名或目录中混合和匹配多个参数，甚至是非动态文本。如下路由，group 与 id 都是必选项。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-| pages/</span></span><br><span class="line"><span class="comment">---| users-[group]/</span></span><br><span class="line"><span class="comment">-----| [id].vue</span></span><br></pre></td></tr></table></figure><p>Nuxt2则需要创建对应的以下划线作为前缀的 Vue 文件 或 目录。如下路由，与 Nuxt3 不一样的是 id 是可选项。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-| pages/</span></span><br><span class="line"><span class="comment">---| users/</span></span><br><span class="line"><span class="comment">-----| _id.vue</span></span><br></pre></td></tr></table></figure><h5 id="Route-Validation"><a href="#Route-Validation" class="headerlink" title="Route Validation"></a>Route Validation</h5><p>Nuxt3通过 <code>definePageMeta</code> 中的 <code>validate</code> 属性在你想要验证的每个页面中提供路由验证。</p><p>validate 属性接受 route 作为参数。它返回一个布尔值，以确定这是否是要用此页呈现的有效路由。如果返回 false ，并且无法找到另一个匹配项，这将导致<code>404</code>错误。也可以直接返回一个带有 <code>statusCode/statusMessage</code>的对象，以立即响应一个错误(其他匹配不会被检查)。当 group 或者 id 为空时，页面会直接显示404错误。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  definePageMeta(&#123;</span><br><span class="line">     validate: <span class="keyword">async</span> (route) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="regexp">/^\d+$/</span>.test(route.params.id); <span class="comment">// 判断id只能是数字</span></span><br><span class="line">     &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>nuxt2 则通过 Options API 中的 <code>validate</code> 来判断 params 的准确性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">   <span class="function"><span class="title">validate</span>(<span class="params">&#123; params &#125;</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">       <span class="keyword">const</span> &#123; group, id &#125; = params;</span></span><br><span class="line"><span class="javascript">       <span class="keyword">if</span> (!group || !id) <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">       <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><p>可以使用  来显示嵌套路由。示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-| pages/</span><br><span class="line">---| parent/</span><br><span class="line">------| child.vue</span><br><span class="line">---| parent.vue</span><br></pre></td></tr></table></figure><p>这个文件树将生成这些路由:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/parent&#x27;</span>,</span><br><span class="line">    component: <span class="string">&#x27;~/pages/parent.vue&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&#x27;child&#x27;</span>,</span><br><span class="line">        component: <span class="string">&#x27;~/pages/parent/child.vue&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;parent-child&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>要显示 child.vue 组件，你必须在 pages/parent.vue 中插入 <code>&lt;NuxtPage&gt;</code> 组件:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>I am the parent view<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">NuxtPage</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- child.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text-base text-gray-600&quot;</span>&gt;</span></span><br><span class="line">      I am the child view</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="页面导航"><a href="#页面导航" class="headerlink" title="页面导航"></a>页面导航</h4><p>与 vue3.js 一样，在 setup 可以使用 useRouter、useRoute 来获取路由信息。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">const</span> route = useRoute();</span><br><span class="line">  <span class="keyword">const</span> router = useRouter();</span><br><span class="line">  <span class="keyword">const</span> &#123; id &#125; = route.params;</span><br><span class="line">      </span><br><span class="line">  <span class="built_in">console</span>.log(router.getRoutes());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handlerToHome = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    router.push(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过 router.getRoutes() 我们可以获取到当前 web 项目所有的路由，打印获取到上述动态路由的 name 和 path 如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;users-group-id&quot;</span></span><br><span class="line">   <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/users-:group()/:id()&quot;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们可以跟 vue3.js 一样，在 setup 中通过 useRouter() 对象，使用 router.push / router.replace 等对路由进行导航。也可以使用 <code>&lt;NuxtLink&gt;</code> 组件，你可以将 <code>&lt;NuxtLink&gt;</code> 看成 vue 中的 <code>&lt;routerLink&gt;</code></p><h4 id="metaData"><a href="#metaData" class="headerlink" title="metaData"></a>metaData</h4><p>如果想在应用程序中为每个路由定义元数据，可以使用definePageMeta宏来实现这一点，它将在 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line">definePageMeta(&#123;</span><br><span class="line"><span class="javascript">  title: <span class="string">&#x27;My home page&#x27;</span></span></span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="javascript"><span class="keyword">const</span> route = useRoute()</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(route.meta.title) <span class="comment">// My home page</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义路由"><a href="#自定义路由" class="headerlink" title="自定义路由"></a>自定义路由</h4><p><strong>配置~/app/router.options.ts</strong></p><p>在/src目录新增app文件夹，文件夹下建立router.options.ts文件（如果没有使用本文中的/src目录的配置，要在根目录下新增app文件夹）。该文件返回定制路由的函数来覆盖路由，如果返回 null 或 undefined， Nuxt将退回到默认路由。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; RouterConfig &#125; <span class="keyword">from</span> <span class="string">&quot;@nuxt/schema&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &lt;RouterConfig&gt;&#123;</span><br><span class="line">   routes: <span class="function">(<span class="params">_routes</span>) =&gt;</span> [</span><br><span class="line">      &#123;</span><br><span class="line">         name: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">         path: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">         component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;~/pages/index.vue&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">   ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>访问其他未定义页面路由，比如原本的 <code>/</code>，提示 <code>404</code>；原因是自定义路由完全替换了自动生成的路由。如果我们只是希望在自动导入的路由下，添加自定义路由，应该使用 <code>pages:extend</code> 钩子配置</p><p><strong>配置nuxt.config.ts</strong></p><p>使用 pages:extend 钩子配置扩展路由</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NuxtConfig &#125; <span class="keyword">from</span> <span class="string">&quot;nuxt/config&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NuxtPage &#125; <span class="keyword">from</span> <span class="string">&#x27;nuxt/schema&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineNuxtConfig(&#123;</span><br><span class="line">  hooks: &#123;</span><br><span class="line">    <span class="string">&#x27;pages:extend&#x27;</span>(pages: NuxtPage[]) &#123;</span><br><span class="line">      pages.push(&#123;</span><br><span class="line">        name: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">        path: <span class="string">&#x27;/error&#x27;</span>,</span><br><span class="line">        file: <span class="string">&#x27;~/error.vue&#x27;</span>,</span><br><span class="line">        <span class="comment">// 可以传递 props 到业务组件内</span></span><br><span class="line">        props: &#123;</span><br><span class="line">          error: &#123;</span><br><span class="line">            statusCode: <span class="string">&#x27;500&#x27;</span>,</span><br><span class="line">            statusMessage: <span class="string">&#x27;服务器开小差啦，请稍后重试&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125; <span class="keyword">as</span> NuxtConfig);</span><br></pre></td></tr></table></figure><p>这样我们就访问 /error 路径，并且业务组件能获取到我们传递的 <code>props</code> 参数</p><h3 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins 插件"></a>plugins 插件</h3><p>Nuxt自动读取 plugins 目录中的文件，并在创建 Vue 应用程序时加载它们。可以在文件名中使用<code>.server</code>或<code>.client</code>后缀来只在服务器端或客户端加载插件。</p><p>只有在plugins/目录的顶层的文件(或任何子目录中的索引文件)才会被注册为插件。</p><p>传递给插件的唯一参数是 nuxtApp。下面是注册 ant-design-vue 的 message 到 plugins 的示例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; message &#125; <span class="keyword">from</span> <span class="string">&#x27;ant-design-vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;ant-design-vue/es/message/style/css&#x27;</span>; </span><br><span class="line"><span class="comment">//vite只能用 ant-design-vue/es 而非 ant-design-vue/lib</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineNuxtPlugin(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    provide: &#123;</span><br><span class="line">      message,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 vue 文件 setup 中使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;post-id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;h-10&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;$message.info(&#x27;测试提示&#x27;)&quot;</span>&gt;</span></span><br><span class="line">        弹出 antd-message 提示</span><br><span class="line">      <span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 middleware 中使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineNuxtRouteMiddleware(<span class="keyword">async</span> (to) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> nuxtApp = useNuxtApp();</span><br><span class="line">  <span class="keyword">const</span> &#123; $message &#125; = nuxtApp;</span><br><span class="line">  $message.error(<span class="string">&#x27;服务器异常，请稍后重试&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>public/目录直接服务于服务器根目录，包含必须保留其名称的公共文件(例如：robots.txt)或可能不会更改(例如:favicon.ico)。</p><h3 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h3><p>Nuxt 3 使用 utils/ 目录在整个应用程序中使用自动导入辅助函数和其他实用程序。</p><h3 id="app-vue"><a href="#app-vue" class="headerlink" title="app.vue"></a>app.vue</h3><p>app.vue 是应用程序的主要组件，可以在组件中定义全局的样式和行为，如路由全局守卫和错误处理等。当应用程序启动时，app.vue 会被渲染为根视图组件，并且在应用程序的整个生命周期内始终存在，可以说 app.vue 是 Nuxt.js 3 应用程序的视图层的入口文件。</p><h3 id="nuxt-config-ts"><a href="#nuxt-config-ts" class="headerlink" title="nuxt.config.ts"></a>nuxt.config.ts</h3><p>Nuxt 可以用一个 nuxt.config 文件轻松配置，该文件可以有js, ts or mjs扩展名。defineNuxtConfig 辅助函数是全局可用的，无需导入。nuxt.config.ts文件位于Nuxt项目的根目录下，可以覆盖或扩展应用程序的行为。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineNuxtConfig(&#123;</span><br><span class="line">   <span class="comment">// My Nuxt config</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="app-config-ts"><a href="#app-config-ts" class="headerlink" title="app.config.ts"></a>app.config.ts</h3><p>Nuxt 3提供了一个app.config配置文件公开应用程序中的响应性配置，能够在生命周期内的运行时更新它。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineAppConfig(&#123;</span><br><span class="line">   <span class="comment">// My App config</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><h4 id="useStore"><a href="#useStore" class="headerlink" title="useStore"></a>useStore</h4><p>在目录结构 composables 中，我们介绍了 useState 可组合的功能，可以跨组件创建响应性的、对ssr友好的共享状态。useState是一个ssr友好的ref替换，它的值将使用唯一的键在所有组件之间共享。</p><blockquote><p>永远不要在 <script setup> 或 setup() 函数之外定义 const state = ref()</p><p>这样的状态将被所有访问您的网站的用户共享，并可能导致内存泄漏!</p><p>用 const useX = () =&gt; useState(‘x’) 代替</p></blockquote><h3 id="引入pinia"><a href="#引入pinia" class="headerlink" title="引入pinia"></a>引入pinia</h3><p>终端安装 @pinia/nuxt</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="keyword">add</span> <span class="variable">@pinia</span><span class="operator">/</span>nuxt</span><br></pre></td></tr></table></figure><p>需要在 nuxt.config.ts 上配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NuxtConfig &#125; <span class="keyword">from</span> <span class="string">&quot;nuxt/config&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineNuxtConfig(&#123;</span><br><span class="line">  modules: [<span class="string">&quot;@pinia/nuxt&quot;</span>],</span><br><span class="line">&#125; <span class="keyword">as</span> NuxtConfig);</span><br></pre></td></tr></table></figure><p>创建 store 目录，并在目录下创建状态管理模块，如下是用户登录信息的示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; selectByUserIdBySlient &#125; <span class="keyword">from</span> <span class="string">&quot;~/api/modules/system/user&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FecthUserInfoResp &#125; <span class="keyword">from</span> <span class="string">&quot;~/api/modules/system/model/UserType&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useUserStore = defineStore(<span class="string">&quot;user&quot;</span>, &#123;</span><br><span class="line">  state: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">  getters: &#123;</span><br><span class="line">    getUserInfo(): FecthUserInfoResp &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.userInfo || &#123;&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="keyword">async</span> fetchUserInfo(): <span class="built_in">Promise</span>&lt;FecthUserInfoResp&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> selectByUserIdBySlient();</span><br><span class="line">      <span class="keyword">if</span> ((res <span class="keyword">as</span> FecthUserInfoResp)?.userId) &#123;</span><br><span class="line">        <span class="built_in">this</span>.userInfo = res;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userInfo = &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...this.userInfo &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在项目中，我们可以这样使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useUserStore &#125; <span class="keyword">from</span> <span class="string">&quot;~/store/modules/user&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户信息</span></span><br><span class="line"><span class="keyword">const</span> userStore = useUserStore();</span><br><span class="line"><span class="keyword">let</span> &#123; userId &#125; = userStore.getUserInfo;</span><br><span class="line"><span class="keyword">if</span> (!userId) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> userStore.fetchUserInfo();</span><br><span class="line">  userId = res?.userId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(userId ? <span class="string">&quot;用户已登录&quot;</span> : <span class="string">&quot;用户未登录&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>Nuxt 3是一个全栈框架，这意味着在不同的上下文中，有几种不可避免的用户运行时错误来源:</p><ul><li>Vue渲染生命周期中的错误(SSR + SPA)</li><li>API或Nitro服务器生命周期中的错误</li><li>服务器和客户端启动错误(SSR + SPA)</li><li>下载JS块时出错</li></ul><h3 id="渲染一个Error页面"><a href="#渲染一个Error页面" class="headerlink" title="渲染一个Error页面"></a>渲染一个Error页面</h3><p>当Nuxt遇到致命错误时，无论是在服务器生命周期中，还是在呈现您的Vue应用程序(SSR和SPA)时，它都会呈现一个JSON响应(如果请求带有Accept: application/json标头)或一个HTML错误页面。我们可以通过在应用程序的源目录中app.vue旁边添加~/error.vue来自定义这个错误页面。这个页面有一个单一的prop—— error，它包含一个错误信息。具体可以参考以下自定义 error.vue 内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  &lt;a-result</span><br><span class="line">    status=&quot;error&quot;</span><br><span class="line">    :title=&quot;error.statusCode&quot;</span><br><span class="line">    :sub-title=&quot;error.message || error.statusMessage || &#x27;服务器发生错误，请联系管理员&#x27;&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">extra</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">key</span>=<span class="string">&quot;console&quot;</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>Go Console<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">key</span>=<span class="string">&quot;buy&quot;</span>&gt;</span>Buy Again<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;error.stack&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a-result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; CloseCircleOutlined &#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/icons-vue&#x27;</span>;</span></span><br><span class="line">  </span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> props = defineProps(&#123;</span></span><br><span class="line"><span class="javascript">    error: <span class="built_in">Object</span>,</span></span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> &#123; error &#125; = toRefs(props);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;less&quot;</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.desc</span> <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-bottom</span>: <span class="number">1em</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Error-辅助函数"><a href="#Error-辅助函数" class="headerlink" title="Error 辅助函数"></a>Error 辅助函数</h3><table><thead><tr><th>方法</th><th>描述</th><th>使用方式</th></tr></thead><tbody><tr><td>createError</td><td>如果你抛出一个用 createError 创建的错误: 在服务器端，它将触发一个全屏错误页面，你可以用 clearError 清除。  在客户端，它会抛出一个非致命的错误让你处理。如果你需要触发一个全屏错误页面，那么你可以通过设置 fatal: true 来实现。</td><td>function createError (err: { cause, data, message, name, stack, statusCode, statusMessage, fatal }): Error</td></tr><tr><td>showError</td><td>在客户端的任何地方调用这个函数，或者(在服务器端)直接在中间件、插件或setup()函数中调用，都将触发一个全屏错误页面，可以用clearError清除。</td><td>function showError (err: string | Error | { statusCode, statusMessage }): Error</td></tr><tr><td>clearError</td><td>这个函数将清除当前处理的Nuxt错误。它还有一个可选的重定向路径(例如，如果你想导航到一个“安全”的页面)。</td><td>function clearError (options?: { redirect?: string }): Promise</td></tr></tbody></table><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>Nuxt CLI在开发模式下以及运行 nuxi build 和 nuxi generate 时内置了 dotenv 支持。</p><p>除了任何进程环境变量外，如果您的项目根目录中有一个.env文件，它将在构建、开发和生成时自动加载，并且在 nuxt.config 文件和模块中设置的任何环境变量都将可访问。</p><p>如果您想使用不同的文件 - 例如，使用 .env.local 或 .env.prod - 我们可以在使用 nuxi 时传递–dotenv 标志来实现。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx nuxi dev --dotenv <span class="selector-class">.env</span><span class="selector-class">.local</span></span><br></pre></td></tr></table></figure><p>在开发模式下更新 .env 文件时，Nuxt 实例会自动重新启动以将新值应用于 process.env。</p><p>runtimeConfig API 向应用程序的其余部分公开了诸如环境变量之类的值。默认情况下，这些键只在服务器端可用。runtimeConfig.public 中的键也可以在客户端使用。这些值应该在 nuxt.config 中定义，并且可以使用环境变量重写。我们还可以在 app.config 定义公开变量。二者区别是：</p><ul><li>runtimeConfig：需要在使用环境变量构建后指定的私有或公共令牌。</li><li>app.config：在构建时确定的公共令牌，网站配置，如主题变量，标题和任何不敏感的项目配置。</li></ul><p>.env 文件配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># api Url</span><br><span class="line">NUXT_PUBLIC_API_BASE_URL = &#x27;https://magiccube-gateway.3weijia.com&#x27;</span><br><span class="line"></span><br><span class="line"># oss Login Url</span><br><span class="line">NUXT_PUBLIC_LOGIN_URL = &#x27;https://passport-dev.3weijia.com&#x27;</span><br><span class="line"></span><br><span class="line"># Basic Url</span><br><span class="line">NUXT_PUBLIC_LOCATION_ORIGIN_URL = &#x27;https://mall-dev.3weijia.com&#x27;</span><br></pre></td></tr></table></figure><p>nuxt.config.ts 配置：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NuxtConfig &#125; <span class="keyword">from</span> <span class="string">&quot;nuxt/config&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineNuxtConfig(&#123;</span><br><span class="line">  runtimeConfig: &#123;</span><br><span class="line">     <span class="keyword">public</span>: &#123;</span><br><span class="line">        apiBaseUrl: process.env.NUXT_PUBLIC_API_BASE_URL,</span><br><span class="line">        loginUrl: process.env.NUXT_PUBLIC_LOGIN_URL,</span><br><span class="line">        locationOriginUrl: process.env.NUXT_PUBLIC_LOCATION_ORIGIN_URL,</span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">as</span> NuxtConfig);</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> runtimeConfig = useRuntimeConfig();</span><br><span class="line"><span class="keyword">const</span> &#123; loginUrl, locationOriginUrl &#125; = runtimeConfig.public;</span><br></pre></td></tr></table></figure><h2 id="数据请求"><a href="#数据请求" class="headerlink" title="数据请求"></a>数据请求</h2><p>Nuxt提供了 useFetch, useLazyFetch, useAsyncData 和 useLazyAsyncData 来处理应用程序中的数据获取。</p><h3 id="useAsyncData"><a href="#useAsyncData" class="headerlink" title="useAsyncData"></a>useAsyncData</h3><p>在页面、组件和插件中，我们可以使用useAsyncData来访问异步解析的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;NuxtLayout&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;fetch&quot;&gt;</span><br><span class="line">      &lt;a-select</span><br><span class="line">        v-model:value&#x3D;&quot;value&quot;</span><br><span class="line">        :options&#x3D;&quot;options&quot;</span><br><span class="line">        style&#x3D;&quot;width: 200px&quot;</span><br><span class="line">        label-in-value</span><br><span class="line">        @change&#x3D;&quot;handleChange&quot;</span><br><span class="line">      &gt;&lt;&#x2F;a-select&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;NuxtLayout&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">const &#123; data: options &#125; &#x3D; await useAsyncData(</span><br><span class="line">  &quot;mountains&quot;,</span><br><span class="line">  () &#x3D;&gt; $fetch(&quot;https:&#x2F;&#x2F;yapi.3weijia.com&#x2F;mock&#x2F;1357&#x2F;api&#x2F;geography&quot;),</span><br><span class="line">  &#123;</span><br><span class="line">    pick: [&quot;data&quot;],</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const value &#x3D; ref&lt;Value&gt;();</span><br><span class="line">const handleChange &#x3D; (value: Value) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="useLazyAsyncData"><a href="#useLazyAsyncData" class="headerlink" title="useLazyAsyncData"></a>useLazyAsyncData</h3><p>默认情况下，useAsyncData 阻塞导航，直到它的 async 处理程序被解析。useLazyAsyncData 为 useAsyncData 提供了一个包装器，通过将 lazy 选项设置为 true，在处理程序解析之前触发导航。</p><h3 id="useFetch"><a href="#useFetch" class="headerlink" title="useFetch"></a>useFetch</h3><p>这个对象为 useAsyncData 和 $fetch提供了一个方便的包装。</p><p>它根据URL和获取选项自动生成一个键，根据服务器路由为请求URL提供类型提示，并推断API响应类型。</p><h3 id="useLazyFetch"><a href="#useLazyFetch" class="headerlink" title="useLazyFetch"></a>useLazyFetch</h3><p>这个可组合的行为与带有 lazy: true 选项集的 useFetch 相同。</p><p>由上可得以下关系：</p><table><thead><tr><th></th><th>useLazyFetch</th><th>useAsyncData</th><th>useLazyAsyncData</th></tr></thead><tbody><tr><td>与 useFetch 的关系</td><td>lazy 设为 true 的 useFetch</td><td>useFetch 是 useAsyncData 与 $fetch 的语法糖</td><td>useFetch 是 useAsyncData 与 $fetch 的语法糖，useLazyAsyncData 是 lazy 设为 true 的 useAsyncData</td></tr></tbody></table><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p><strong>引入less</strong></p><p>在项目中断执行安装 less</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm <span class="keyword">add</span> less <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>在assets目录下创建less全局变量文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-| assets&#x2F;</span><br><span class="line">---| styles&#x2F;</span><br><span class="line">------| index.less</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ~/assets/styles/index.less 内容</span><br><span class="line">@theme-color: #147ffa;</span><br></pre></td></tr></table></figure><p>使用 vite 打包的话，需要在 nuxt.config.ts 上配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NuxtConfig &#125; <span class="keyword">from</span> <span class="string">&quot;nuxt/config&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineNuxtConfig(&#123;</span><br><span class="line">  vite: &#123;</span><br><span class="line">    css: &#123;</span><br><span class="line">      preprocessorOptions: &#123;</span><br><span class="line">        less: &#123;</span><br><span class="line">          additionalData: <span class="string">&#x27;@import &quot;@/assets/styles/index.less&quot;;&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125; <span class="keyword">as</span> NuxtConfig);</span><br></pre></td></tr></table></figure><p>使用方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;less&quot;</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">.home &#123;</span><br><span class="line">  .blue &#123;</span><br><span class="line"><span class="css">    <span class="attribute">color</span>: @theme-color;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="遇到的问题与解决方案"><a href="#遇到的问题与解决方案" class="headerlink" title="遇到的问题与解决方案"></a>遇到的问题与解决方案</h2><h3 id="useFetch-在-onMounted-执行返回值为-null？"><a href="#useFetch-在-onMounted-执行返回值为-null？" class="headerlink" title="useFetch() 在 onMounted 执行返回值为 null？"></a>useFetch() 在 onMounted 执行返回值为 null？</h3><ul><li>场景一</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line"></span><br><span class="line"> 代码解读</span><br><span class="line">复制代码<span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; testData &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;default&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;testFetch1&quot;</span>&gt;</span>取消订单<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> testData = ref();</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> id = ref(<span class="string">&#x27;wx9d982ed41aa8b75a&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> testFetch1 = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">    useFetch(<span class="string">`https://paas-fe-dev.3weijia.com/helper/server/wechat/mp/app/<span class="subst">$&#123;id.value&#125;</span>`</span>, &#123;</span></span><br><span class="line"><span class="javascript">      key: <span class="string">&#x27;myfetch&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line">      testData.value = res.data.value;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;testData.value&#x27;</span>, process.server, testData.value);</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  onMounted(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;onMounted&#x27;</span>);</span></span><br><span class="line">    testFetch1(); </span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以通过 console.log 发现，刷新页面后，客户端执行了 testFetch1 中的 useFetch，但是返回结果为 null；而服务端没有打印日志，得出结论<strong>服务端不执行 onMounted 内容</strong>。</p><p>当我们从其他页面通过 router.push/replace 进入这个页面时，即客户端渲染时，发现接口拥有返回数据，渲染正常。</p><p>当我们在 onMounted 中添加 await nextTick()；发现接口拥有返回数据，渲染正常。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     onMounted(async () =&gt; &#123;</span><br><span class="line">        console.log(&#x27;onMounted&#x27;);</span><br><span class="line"><span class="addition">++      await nextTick();</span></span><br><span class="line">        testFetch1();</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><ul><li>场景二</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line"></span><br><span class="line"> 代码解读</span><br><span class="line">复制代码<span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; testData &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">van-button</span> <span class="attr">type</span>=<span class="string">&quot;default&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;testFetch1&quot;</span>&gt;</span>取消订单<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> testData = ref();</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> id = ref(<span class="string">&#x27;wx9d982ed41aa8b75a&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> testFetch1 = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">    useFetch(<span class="string">`https://paas-fe-dev.3weijia.com/helper/server/wechat/mp/app/<span class="subst">$&#123;id.value&#125;</span>`</span>, &#123;</span></span><br><span class="line"><span class="javascript">      key: <span class="string">&#x27;myfetch&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line">      testData.value = res.data.value;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;testData.value&#x27;</span>, process.server, testData.value);</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  testFetch1();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接在 setup 执行 useFetch，虽然页面渲染正常，接口请求正常，但是控制台有报错信息：Hydration completed but contains mismatches. ，表明服务端和客户端渲染 testData 内容不一致，如图：</p><p>终端拥有打印信息：</p><p>说明服务端、客户端都执行了 useFetch，且返回结果一致，需要解决这个报错内容有两种解决方式：</p><ol><li>使用标签将  包裹起来</li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;test&quot;&gt;</span><br><span class="line"><span class="addition">++    &lt;div&gt;</span></span><br><span class="line">        &#123;&#123; testData &#125;&#125;</span><br><span class="line"><span class="addition">++    &lt;/div&gt;</span></span><br><span class="line">      &lt;van-button type=&quot;default&quot; @click=&quot;testFetch1&quot;&gt;取消订单&lt;/van-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br></pre></td></tr></table></figure><p>但是这可能不太符合我们的预期，因为我们并不会对每个这种渲染对象都使用唯一标签包裹，那太麻烦了。</p><ol><li>将 testFetch1 改造一下，等待 testFetch2 执行完毕后再进行渲染</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> testData = ref();</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> id = ref(<span class="string">&#x27;wx9d982ed41aa8b75a&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> testFetch2 = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> useFetch(<span class="string">`https://paas-fe-dev.3weijia.com/helper/server/wechat/mp/app/<span class="subst">$&#123;id.value&#125;</span>`</span>);</span></span><br><span class="line">    testData.value = data.value;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="javascript">  <span class="keyword">await</span> testFetch2();</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>服务端不执行onMounted内容；<br>如果onMounted内需执行useFetch，应该放在await nextTick之后，否则会返回null；<br>在setup内(onMounted外)执行useFetch，服务端和客户端都执行，为了避免渲染时useFetch未执行完毕，尽量使用await而不是then方法；</p></blockquote><p>后面在官方文档翻到这句话，可能就是客户端在没有激活之前，放在onMounted的useFetch返回null的原因吧 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a52be1663704e2dadbba187c5b0e869~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1596&h=236&s=118436&e=png&b=fdf4e8" alt="image.png"></p><h3 id="composables定义了某变量并赋值，浏览器刷新后服务端获取该变量还是旧值？"><a href="#composables定义了某变量并赋值，浏览器刷新后服务端获取该变量还是旧值？" class="headerlink" title="composables定义了某变量并赋值，浏览器刷新后服务端获取该变量还是旧值？"></a>composables定义了某变量并赋值，浏览器刷新后服务端获取该变量还是旧值？</h3><ul><li>场景<br>我们在composables文件夹下新建文件useTest.ts，里面包含一个变量tcc与useTest组合方法，useTest获取某cookie值保存到tcc变量中，原本设想是，改变量若是有值，就不再重新获取的。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tcc: <span class="built_in">string</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useTest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!tcc) &#123;</span><br><span class="line">    <span class="keyword">const</span> tccRef = useCookie(<span class="string">&#x27;tcc&#x27;</span>);</span><br><span class="line">    tcc = tccRef.value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tcc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在vue文件的setup执行该方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;useTest()&#x27;</span>, useTest());</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器cookie添加tcc参数值为「PC_MALL」，刷新浏览器后，发现客户端与服务端都打印了useTest()值为「PC_MALL」</p><p>然后我们修改浏览器cookie中tcc参数值为「H5_MALL」，刷新浏览器发现客户端打印了新的cookie值，但是服务端还是旧值</p><p>这感觉看上去像是composables下定义的组合文件内容在服务端只执行一次，不知道nuxt这样设计的原因，只能要求开发的时候注意啦~</p><blockquote><p>在组合中尽量不定义变量保存客户端信息（如cookie、storage等）</p></blockquote><h3 id="某些DOM节点渲染了两遍"><a href="#某些DOM节点渲染了两遍" class="headerlink" title="某些DOM节点渲染了两遍"></a>某些DOM节点渲染了两遍</h3><ul><li>场景</li></ul><p>打包之后，在APP内预览发现页面异常，有些DOM节点渲染了两遍。其中第一次渲染的DOM不能点击，第二次渲染的DOM可以点击。</p><p>经过多番测试，发现是我在setup初始化写了路由的重定向。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">await</span> router.replace(&#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;index&#x27;</span>,</span></span><br><span class="line">  query: &#123;</span><br><span class="line">    floor: activeFloorId.value,</span><br><span class="line">    spu: activeSpuId.value,</span><br><span class="line">    sku: activeSkuId.value,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我把 router.replace 放在 onMounted 里面执行依旧会出现此问题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">onMounted(<span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">await</span> router.replace(&#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&#x27;index&#x27;</span>,</span></span><br><span class="line">    query: &#123;</span><br><span class="line">      floor: activeFloorId.value,</span><br><span class="line">      spu: activeSpuId.value,</span><br><span class="line">      sku: activeSkuId.value,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是在onMounted添加nextTick之后，显示正常</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    onMounted(async () =&gt; &#123;</span><br><span class="line"><span class="addition">++    await nextTick();</span></span><br><span class="line">      await router.replace(&#123;</span><br><span class="line">        name: &#x27;index&#x27;,</span><br><span class="line">        query: &#123;</span><br><span class="line">          floor: activeFloorId.value,</span><br><span class="line">          spu: activeSpuId.value,</span><br><span class="line">          sku: activeSkuId.value,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>查阅资料后初步判定是ssr引起的。为了部分DOM能ssr渲染，又能在客户端保留vdom的优势，vue的做法是在ssr生成的html的基础上，再同时生成一个js文件。<br> js文件里同时保存在客户端能再现渲染的js版本，js版本里是通过vdom进行渲染的操作函数，而html是ssr后的结果。<br> 当浏览器拿到这两个东西之后，就开始重新执行一遍vdom的生成过程，并在此基础上去执行客户端动态操作。那一旦出现不匹配的情况，那dom渲染就会出问题，部分界面组件会重复渲染。<br> 所以初始化的时候我们可以认为第一次渲染的DOM节点是服务端的首屏的静态HTML，点击无效。第二次渲染的DOM节点是属于客户端渲染的结果。</p><h3 id="如何设置页面客户端渲染"><a href="#如何设置页面客户端渲染" class="headerlink" title="如何设置页面客户端渲染"></a>如何设置页面客户端渲染</h3><p>这个问题是在评论中发现的，就一起记录了。</p><ul><li>场景一：关闭项目所有页面的ssr 对于不需要索引或用户经常访问的高度交互式web应用程序，可以在nuxt.config.ts中使用Nuxt启用仅客户端渲染：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineNuxtConfig(&#123; <span class="attr">ssr</span>: <span class="literal">false</span> &#125;)</span><br></pre></td></tr></table></figure><ul><li><p>场景二：仅对个别页面关闭ssr</p><p>使用路由规则：从Nuxt 3开始随着公测rc. 12 版本发布，支持路由规则和混合渲染。使用路由规则，您可以为一组nuxt路由定义规则，改变呈现模式或分配基于路由的缓存策略。</p><ul><li><code>redirect</code> - 重定向。</li><li><code>ssr</code> - 禁用应用程序部分的服务器端渲染，并使用<code>ssr: false</code>使它们仅用于spa。</li><li><code>cors</code> - 自动添加带有<code>cors: true</code>的cors报头-你可以通过用<code>headers</code>覆盖自定义输出</li><li><code>headers</code> - 为站点的各个部分添加特定的标题</li><li><code>static</code> and <code>swr</code> - <code>static</code>支持单个(按需)构建;<code>swr</code>启用静态构建，该构建持续一个可配置的TTL。<br><strong>配置ssr示例:</strong></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineNuxtConfig(&#123;</span><br><span class="line">  routeRules: &#123;</span><br><span class="line">    <span class="string">&#x27;/admin/**&#x27;</span>: &#123; <span class="attr">ssr</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如果确实使用<code>ssr:false</code>，还应该在/src目录新增app文件夹，文件夹下建立spa-loading-template.html文件（如果没有使用本文中的/src目录的配置，要在根目录下新增app文件夹），html文件中包含一些我们想用来渲染加载页面的HTML。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Nuxt" scheme="http://aiolimp.com/categories/Nuxt/"/>
    
    
    <category term="Nuxt" scheme="http://aiolimp.com/tags/Nuxt/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数据类型</title>
    <link href="http://aiolimp.com/2023/03/05/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://aiolimp.com/2023/03/05/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2023-03-05T13:32:12.207Z</published>
    <updated>2023-03-05T13:32:12.207Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h2><p>JavaScript一共有8种数据类型，其中有7种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol（es6新增，表示独一无二的值）和BigInt（es10新增）；</p><p>1种引用数据类型——Object（Object本质上是由一组无序的名值对组成的）。里面包含 function、Array、Date等。JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。</p><p>原始数据类型：直接存储在<strong>栈</strong>（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p><p>引用数据类型：同时存储在<strong>栈</strong>（stack）和<strong>堆</strong>（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><h3 id="1、-Undefined类型"><a href="#1、-Undefined类型" class="headerlink" title="1、 Undefined类型"></a>1、 Undefined类型</h3><p><code>Undefined</code>类型只有一个值，即特殊的<code>undefined</code>，一个变量在声明后未初始化时，这个变量的值就是<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br><span class="line">alert(message);<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>需要注意的是声明了但未初始化的变量与未声明的变量是不一样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg;</span><br><span class="line">alert(msg);<span class="comment">// 声明了未初始化（即赋值），默认值为&quot;undefined&quot;</span></span><br><span class="line">alert(a);<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>但使用<code>typeof</code>操作符来检测上面两个变量时，都会返回<code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg;</span><br><span class="line"><span class="comment">// var a</span></span><br><span class="line">alert(<span class="keyword">typeof</span> msg);<span class="comment">// &quot;undefined&quot;</span></span><br><span class="line">alert( <span class="keyword">typeof</span> a);<span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><p>这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。</p><blockquote><p>未初始化的变量会自动被赋予 undefined 值，没有必要将变量显式的设置为<code>undefined</code>，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当 <code>typeof</code> 操作符返回”undefined”值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。</p></blockquote><h3 id="2、Null类型"><a href="#2、Null类型" class="headerlink" title="2、Null类型"></a>2、Null类型</h3><p><code>Null</code> 类型是第二个只有一个值的数据类型，这个特殊的值是 <code>null</code>。<code>null</code> 值表示一个空对象指针，使用 <code>typeof</code> 操作符检测 null 值时会返回<code>&quot;object&quot;</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jake = <span class="literal">null</span>; </span><br><span class="line">alert(<span class="keyword">typeof</span> jake ); <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>虽然 <code>typeof null</code> 会输出 <code>object</code>，但这只是 <code>JS</code> 存在的一个悠久 <code>Bug</code>。在 <code>JS</code> 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 <code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code> 。 <code>null</code>值的主要作用是如果定义的变量在将来用于保存对象，那么最好将该变量初始化为<code>null</code>值。</p><h3 id="3、Boolean类型"><a href="#3、Boolean类型" class="headerlink" title="3、Boolean类型"></a>3、Boolean类型</h3><p><code>Boolean</code>类型是<code>JavaScript</code>中使用最多的一种基本数据类型，只有两个值<code>true</code>和<code>false</code>（全为小写）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span>  b = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>虽然<code>Boolean</code>类型只有两个值，但<code>JavaScript</code>中所有类型的值都有与这两个<code>Boolean</code>值等价的值，可以调用转型函数<code>Boolean()</code>将其他类型的值转化为<code>Boolean</code>值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  msg = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">var</span>  magBoolean = <span class="built_in">Boolean</span>(msg);</span><br></pre></td></tr></table></figure><p>根据转换值的数据类型及其实际值，返回一个<code>Boolean</code>值。各种数据类型及其对应的转换规则如下表：</p><table><thead><tr><th>数据类型</th><th>转为true</th><th>转为false</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>任何非空字符串</td><td>“ “（空字符串）</td></tr><tr><td>Number</td><td>任何非零数字（包括无穷大）</td><td>0和NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>not applicable（不适用）</td><td>undefined</td></tr></tbody></table><h3 id="4、Number类型"><a href="#4、Number类型" class="headerlink" title="4、Number类型"></a>4、Number类型</h3><p><code>Number</code>类型算是<code>JavaScript</code>中最复杂也最令人关注的基本数据类型了，<code>Number</code>可以同时表示整数和浮点数值，同时也支持各种进制和科学计数法。具体如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intNum = <span class="number">55</span>; <span class="comment">// 整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数</span></span><br><span class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">var</span> floatNum2 = <span class="number">0.1</span>; </span><br><span class="line"><span class="keyword">var</span> floatNum3 = <span class="number">.1</span>; <span class="comment">// 有效，但不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 科学计数法</span></span><br><span class="line"><span class="keyword">var</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于 31250000 相当于 3.125*10的7次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制（以O开头),数字序列(0~7)</span></span><br><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">070</span>; <span class="comment">// 八进制的 56</span></span><br><span class="line"><span class="keyword">var</span> octalNum2 = <span class="number">079</span>; <span class="comment">// 无效的八进制数值——解析为 79</span></span><br><span class="line"><span class="keyword">var</span> octalNum3 = <span class="number">08</span>; <span class="comment">// 无效的八进制数值——解析为 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制(以Ox开头),数字序列(0~9及A~F)，字母大小写同等</span></span><br><span class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0xA</span>; <span class="comment">// 十六进制的 10</span></span><br><span class="line"><span class="keyword">var</span> hexNum2 = <span class="number">0x1f</span>; <span class="comment">// 十六进制的 31</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>JavaScript</code>能够表示的最小数值保存在 <code>Number.MIN_VALUE</code> 中——在大多数浏览器中，这个值是 <code>5e-324</code>；能够表示的最大数值保存在<code>Number.MAX_VALUE</code> 中——在大多数浏览器中，这个值是 <code>1.7976931348623157e+308</code>。如果某次计算的结果得到了一个超出 <code>JavaScript</code> 数值范围的值，那么这个数值将被自动转换成特殊的 <code>Infinity</code> 值(有正负)。 这里要特别说明一下，浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 + 0.2的结果不是 0.3，而是 0.30000000000000004。这是因为0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0000000000000004。所以上面提到的BigInt就应运而生。</p><blockquote><p>关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家；其他使用相同数值格式的语言也存在这个问题。</p></blockquote><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p><code>NaN（Not a Number)</code>，即非数值，用于表示一个本来要返回数值的操作数未返回数值的情况。 <code>NaN</code>有两个非同寻常的特点：</p><ol><li>任何涉及<code>NaN</code>的操作(例如<code>NaN/10</code>)都会返回<code>NaN</code>；</li><li><code>NaN</code>与任何值都不相等，包括<code>NaN</code>本身。</li></ol><p>针对这两个特点，<code>JavaScript</code>定义了<code>isNaN()</code>函数。这个函数接受一个参数，该参数可以是任何类型。<code>isNaN()</code>在接收到一个值后，会尝试将这个值转换为数值，而任何不能被转换为数值的值都会导致函数返回<code>true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">//true </span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="number">10</span>)); <span class="comment">//false（10 是一个数值）</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>)); <span class="comment">//false（可以被转换成数值 10）</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>)); <span class="comment">//true（不能转换成数值）</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="literal">true</span>)); <span class="comment">//false（可以被转换成数值 1）</span></span><br></pre></td></tr></table></figure><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><p><code>JavaScript</code>提供3个函数可以把非数值转换为数值：</p><ul><li><code>Number()</code>可以用于任何数据类型</li><li><code>parseInt()</code>和<code>parseFloat()</code>专门用于把字符串转换为数值</li></ul><p><strong>Number()</strong> <code>Number()</code>函数的转换规则很多，这里直接引用红宝书里的描述：</p><blockquote><p>如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。</p><p>如果是数字值，只是简单的传入和返回。</p><p>如果是 null 值，返回 0。  如果是 undefined，返回 NaN。</p><p>如果是字符串，遵循下列规则：</p><p>a、中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即”1” 会变成 1，”123”会变成 123，而”011”会变成 11（注意：前导的零被忽略了）；</p><p>b、串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值（同样，也会忽 略前导零）；</p><p>c、字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的十进制整 数值；</p><p>d、字符串是空的（不包含任何字符），则将其转换为 0；  如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。</p><p>如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换 的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符 串值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="string">&quot;Hello world!&quot;</span>); <span class="comment">//NaN </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="string">&quot;&quot;</span>); <span class="comment">//0 </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">Number</span>(<span class="string">&quot;000011&quot;</span>); <span class="comment">//11 </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>); <span class="comment">//1 </span></span><br><span class="line">NumberExample04.html</span><br></pre></td></tr></table></figure><p><strong>parseInt()</strong> <code>parseInt()</code>函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字 符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，<code>parseInt()</code> 就会返回 <code>NaN</code>；也就是说，用 <code>parseInt()</code>转换空字符串会返回 <code>NaN</code>（<code>Number()</code>对空字符返回 <code>0</code>）。如 果第一个字符是数字字符，<code>parseInt()</code>会继续解析第二个字符，直到解析完所有后续字符或者遇到了 一个非数字字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>); <span class="comment">// 1234 </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// NaN </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>); <span class="comment">// 10（十六进制数）</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>); <span class="comment">// 22 </span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">&quot;070&quot;</span>); <span class="comment">// 56（八进制数）</span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">&quot;70&quot;</span>); <span class="comment">// 70（十进制数）</span></span><br><span class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xf&quot;</span>); <span class="comment">// 15（十六进制数）</span></span><br></pre></td></tr></table></figure><p>在使用 <code>parseInt()</code>解析像八进制字面量的字符串时，<code>ECMAScript 3</code> 和 <code>5</code> 存在分歧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ECMAScript 3 认为是 56（八进制），ECMAScript 5 认为是 70（十进制）</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="string">&quot;070&quot;</span>);</span><br></pre></td></tr></table></figure><p>因此<code>parseInt()</code>引入第二个参数：转换时使用的基数，以解决上述困惑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">2</span>); <span class="comment">//2 （按二进制解析）</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">8</span>); <span class="comment">//8 （按八进制解析）</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">10</span>); <span class="comment">//10 （按十进制解析）</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">16</span>); <span class="comment">//16 （按十六进制解析）</span></span><br></pre></td></tr></table></figure><p><strong>parseFloat()</strong> 与 <code>parseInt()</code>函数类似，<code>parseFloat()</code>也是从第一个字符（位置 0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">&quot;1234blue&quot;</span>); <span class="comment">//1234 （整数）</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>); <span class="comment">//0 </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.5&quot;</span>); <span class="comment">//22.5 </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.34.5&quot;</span>); <span class="comment">//22.34 第二个小数点无效</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0908.5&quot;</span>); <span class="comment">//908.5 </span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">&quot;3.125e7&quot;</span>); <span class="comment">//31250000</span></span><br></pre></td></tr></table></figure><h3 id="5、String类型"><a href="#5、String类型" class="headerlink" title="5、String类型"></a>5、String类型</h3><p><code>String</code>，即字符串，由一对双引号或单引号表示(单双引号没有区别)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;JakeZhang&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>JavaScript</code>中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>   name  = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line">name = name + <span class="string">&quot;Zhang&quot;</span>;</span><br></pre></td></tr></table></figure><p>实现这个操作的过程如下：首先创建一个能容纳 10 个字符的新字符串，然后在这个字符串中填充”Jake”和”Zhang”，最后一步是销毁原来的字符串”Jake”和字符串”Zhang”，因为这两个字符串已经没用了(这个过程是在后台发生的)。</p><p>实际开发中经常为方便存储，经常需要将值转换为字符串。要把一个值转换为一个字符串有两种方式：</p><p><strong>1、toString()</strong> 除了<code>null</code>和<code>undefined</code>值没有<code>tostring()</code>方法，其他值都有这个方法，该方法返回字符串的一个副本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">11</span>; </span><br><span class="line"><span class="keyword">var</span> ageAsString = age.toString(); <span class="comment">// 字符串&quot;11&quot; </span></span><br><span class="line"><span class="keyword">var</span> found = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">var</span> foundAsString = found.toString(); <span class="comment">// 字符串&quot;true&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>toString()</code>可以传入一个参数：输出数值的基数。可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。下面给出几个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>; </span><br><span class="line">alert(num.toString()); <span class="comment">// &quot;10&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">2</span>)); <span class="comment">// &quot;1010&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">8</span>)); <span class="comment">// &quot;12&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">10</span>)); <span class="comment">// &quot;10&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">16</span>)); <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p><strong>2、使用+”  “</strong> 即可以通过**要转换的值 + 空字符串(“  “)**，也可以实现转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> numAsString = num + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="keyword">var</span> boolean = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> booleanAsString = boolean + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a ;</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;undefined &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> d = c + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;null &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">   valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="keyword">var</span> m = o + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;-1 &quot;</span></span><br></pre></td></tr></table></figure><h3 id="6、Symbol"><a href="#6、Symbol" class="headerlink" title="6、Symbol"></a>6、Symbol</h3><p><code>Symbol</code>是<code>es6</code>新增的一种原始数据类型，表示独一无二的值，是一种唯一标识符。<code>Symbol</code>值通过<code>Symbol()</code>函数生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;jake&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>Symbol</code>的主要特点是如上所说的唯一性，可用作对象的唯一属性名，即使是用同一个变量生成的值也不相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;jake&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> id2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;jake&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(id1 == id2);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>但我们不排除希望能够多次使用同一个<code>symbol</code>值的情况。官方提供的<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <code>Symbol</code> 值。如果有，就返回这个 <code>Symbol</code> 值，否则就新建一个以该字符串为名称的 <code>Symbol</code> 值，并将其注册到全局。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//检测到未创建后新建</span></span><br><span class="line"><span class="keyword">let</span> name2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//检测到已创建后返回</span></span><br><span class="line"><span class="built_in">console</span>.log(name1 === name2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Symbol</code>的另一特点是隐藏性，<code>Symbol</code> 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in、for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"> [id]:<span class="string">&#x27;symbol&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> option <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj[option]); <span class="comment">//空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是也有能够访问的方法：<code>Object.getOwnPropertySymbols</code> 该方法会返回一个数组，成员是当前对象的所有用作属性名的<code>Symbol</code>值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [id]:<span class="string">&#x27;symbol&#x27;</span></span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">let</span> array = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"> <span class="built_in">console</span>.log(array); <span class="comment">//[Symbol(id)]</span></span><br><span class="line"> <span class="built_in">console</span>.log(obj[array[<span class="number">0</span>]]);  <span class="comment">//&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure><p>关于<code>Symbol</code>这个新的数据类型更多的知识点可以参考阮神的文章—&gt;<a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/symbol">传送门</a></p><h3 id="7、BigInt类型"><a href="#7、BigInt类型" class="headerlink" title="7、BigInt类型"></a>7、BigInt类型</h3><blockquote><p><code>BigInt</code>是什么? <code>BigInt</code>是<code>JavaScript</code>中一种可以用来表示任意精度整数的基本数据类型</p><p><code>BigInt</code>可以用来表示任意精度整数的特性为<code>JavaScript</code>解锁了更多的骚操作，使用<code>BigInt</code>可以告别过去因为整数运算导致溢出的痛苦。特别是金融方面因为涉及大量的数据运算，比如高精度时间戳，或者数值过大的ID，这些是无法安全的用Number类型去存储的，所以退而求其次使用String类型去存储，有了BigInt类型后就可以安全的将其存储为数值类型。</p><p>另外<code>BigInt</code>的实现也为实现<code>BigDecimal</code>打下坚实基础，那将对于以十进制精度表示货币金额并对其进行精确运算（也就是0.10 + 0.20 !== 0.30问题）非常有帮助</p></blockquote><h3 id="8、引用数据类型——Object类型"><a href="#8、引用数据类型——Object类型" class="headerlink" title="8、引用数据类型——Object类型"></a>8、引用数据类型——Object类型</h3><p><code>Object</code>类型是<code>JavaScript</code>中最庞大而复杂的引用数据类型，本文只做简单介绍，后续的文章会做<code>Object</code>的详细介绍。 <code>Object</code>，即对象，是一组数据和功能的集合。对象可以通过执行<code>new</code>操作符后跟要创建 的对象类型的名称来创建。而创建 <code>Object</code> 类型的实例并为其添加属性和（或）方法，就可以创建自定 义对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">person.name = <span class="string">&quot;Jake&quot;</span>; </span><br><span class="line">person.age = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;&#125;; <span class="comment">//与 new Object()相同</span></span><br><span class="line">person2.name = <span class="string">&quot;Jake&quot;</span>; </span><br><span class="line">perso2.age = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字面量的创建方式</span></span><br><span class="line"><span class="keyword">var</span> person3 = &#123;</span><br><span class="line">name:<span class="string">&quot;jakezhang&quot;</span>,<span class="comment">//name如果是保留字、有连接符/空格，则要&#x27;name-p&#x27;，即使用字符串</span></span><br><span class="line">age:<span class="number">23</span>,</span><br><span class="line">action:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上任意一种方式都可以创建一个对象实例，当然更多的写法和设计思想以后的文章再做体现。在实际的开发中我们用的最多的是字面量的方式，因为这种语法要求的代码量少，而且能够给人封装数据的感觉。这里引用一个红宝书的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayInfo</span>(<span class="params">args</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">var</span> output = <span class="string">&quot;&quot;</span>; </span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> args.name == <span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line"> output += <span class="string">&quot;Name: &quot;</span> + args.name + <span class="string">&quot;\n&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> args.age == <span class="string">&quot;number&quot;</span>) &#123; </span><br><span class="line"> output += <span class="string">&quot;Age: &quot;</span> + args.age + <span class="string">&quot;\n&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> alert(output); </span><br><span class="line">&#125; </span><br><span class="line">displayInfo(&#123; </span><br><span class="line"> name: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> age: <span class="number">29</span> </span><br><span class="line">&#125;); </span><br><span class="line">displayInfo(&#123; </span><br><span class="line"> name: <span class="string">&quot;Greg&quot;</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代码相信都看得懂~</p><p><strong>Object 的每个实例都具有下列属性和方法：</strong></p><ul><li><code>constructor</code>：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（<code>constructor</code>）就是 <code>Object()</code>。</li><li><code>hasOwnProperty(propertyName)</code>：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（<code>propertyName</code>）必须以字符串形式指定（例如：<code>o.hasOwnProperty(&quot;name&quot;)</code>）。</li><li><code>isPrototypeOf(object)</code>：用于检查传入的对象是否是传入对象的原型。</li><li><code>propertyIsEnumerable(propertyName</code>)：用于检查给定的属性是否能够使用 for-in 语句来枚举。与<code>hasOwnProperty()</code>方法一样，作为参数的属性名必须以字符串形式指定。</li><li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串与执行环境的地区对应。</li><li><code>toString()</code>：返回对象的字符串表示。</li><li><code>valueOf()</code>：返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。</li></ul><p>由于在 ECMAScript 中 Object 是所有对象的基础，因此所有对象都具有这些基本的属性和方法。</p><h3 id="9、基本数据类型和引用类型值的比较"><a href="#9、基本数据类型和引用类型值的比较" class="headerlink" title="9、基本数据类型和引用类型值的比较"></a>9、基本数据类型和引用类型值的比较</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h4><ol><li><strong>值是不可变的</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Jake Zhang&quot;</span>;</span><br><span class="line">name.toUpperCase();<span class="comment">//输出 JAKE ZHANG</span></span><br><span class="line"><span class="built_in">console</span>.log(name);<span class="comment">// 输出 Jake Zhang</span></span><br></pre></td></tr></table></figure><p>由以上代码可看出基本数据类型的值是不可变的。</p><ol><li><strong>存放在栈区</strong> 基本类型值指的是简单的数据段，按值访问，可操作保存在变量中的实际的值，其占据空间小、大小固定，属于被频繁使用的数据，所以放入栈（<code>stack</code>）中存储。</li><li><strong>值的比较</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> m = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(n == m);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(n === m);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>“==”：只进行值的比较，会进行数据类型转换；</p><p>“===”：不会转换数据类型。</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ol><li><strong>值是可变的</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">&#x27;jake&#x27;</span>,</span><br><span class="line">        age:<span class="number">22</span>,</span><br><span class="line">        action:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;do something!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">person.age = <span class="number">23</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.age)<span class="comment">// 23</span></span><br></pre></td></tr></table></figure><p>有上面的代码可看出引用数据 类型可以拥有一个或多个属性和方法，而且是可以动态修改的。</p><ol><li><strong>同时存放在栈内存和堆内存</strong> 引用数据类型是存放在堆（heap）中的对象，占据空间大、大小不固定，如果存放在栈中，会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。（有关js中栈和堆的详解可参考文章[(<a href="https://link.juejin.cn/?target=https://www.cnblogs.com/heioray/p/9487093.html">www.cnblogs.com/heioray/p/9…</a>)）</li><li><strong>值的比较</strong> 当从一个变量向另一个变量赋引用类型的值时，同样也会将存储在变量中的对象的值复制一份到位新变量分配的空间中。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  age:<span class="number">20</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">var</span> person2 = person1;</span><br><span class="line">person2.age = <span class="number">23</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.age = person2.age)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>前面讲到基本数据类型和引用数据类型存储于内存中的位置不一样，引用数据类型存储在堆中的对象，与此同时，在栈中存储了指针，而这个指针的指向正是堆中实体的起始位置。变量person1初始化时，person1指针指向该对象{age：20}的地址，将person1赋给person2后，person2又指向该对象{age：20}的地址，这两个变量指向了同一个对象。因此改变其中任何一个变量，都会相互影响。</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/9/16e50425886c10a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="ZJK"></p><p>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">age</span>:<span class="number">22</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">//&#123;age:22&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，a和b指向同一个对象，然后a的值变为1，这时不会对b产生影响，b还是指向原来的那个对象。</p><h3 id="10-Symbol的使用"><a href="#10-Symbol的使用" class="headerlink" title="10.Symbol的使用"></a>10.Symbol的使用</h3><ul><li>Symbol是一种基本类型，由Symbol函数生成</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line">a.mySymbol = <span class="string">&#x27;hello&#x27;</span>  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><ul><li>不能new，会报错，返回一个值，不是对象</li><li>Symbol 函数可以接受一个字符串作为参数</li><li>instanceof 的结果为 false</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>Symbol 值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a[mySymbol]); <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回</p></li><li><p>使用同一个 Symbol 值，可以使用 Symbol.for</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>使用<br>当需要区分形状，正方形，圆形，菱形 会使用 const shape = { triangle: ‘triangle’, circle: ‘circle’},不优雅，可以使用<br>const shape = { triangle: Symbol(), circle: Symbol()},</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>three.js物体基本操作</title>
    <link href="http://aiolimp.com/2022/11/01/three/"/>
    <id>http://aiolimp.com/2022/11/01/three/</id>
    <published>2022-11-01T08:57:49.000Z</published>
    <updated>2023-03-05T14:18:03.286Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="three-js物体基本操作"><a href="#three-js物体基本操作" class="headerlink" title="three.js物体基本操作"></a>three.js物体基本操作</h2><ul><li><a href="#%E4%B8%80%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAthreejs%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BD%91%E7%AB%99">一、本地搭建Threejs官方文档网站</a></li><li><a href="#%E4%BA%8C%E4%BD%BF%E7%94%A8parcel%E6%90%AD%E5%BB%BAthreejs%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">二、使用parcel搭建three.js开发环境</a></li><li><a href="#%E4%B8%89threejs%E6%B8%B2%E6%9F%93%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9C%BA%E6%99%AF%E5%92%8C%E7%89%A9%E4%BD%93">三、Threejs渲染第一个场景和物体</a></li><li><a href="#%E5%9B%9Bthreejs%E8%BD%A8%E9%81%93%E6%8E%A7%E5%88%B6%E5%99%A8%E6%9F%A5%E7%9C%8B%E7%89%A9%E4%BD%93">四、Threejs轨道控制器查看物体</a></li><li><a href="#%E4%BA%94threejs%E6%8E%A7%E5%88%B6%E7%89%A9%E4%BD%93%E7%A7%BB%E5%8A%A8">五、Threejs控制物体移动</a></li><li><a href="#%E5%85%ADthreejs%E6%B7%BB%E5%8A%A0%E5%9D%90%E6%A0%87%E8%BD%B4%E8%BE%85%E5%8A%A9%E5%99%A8">六、Threejs添加坐标轴辅助器</a></li><li><a href="#%E4%B8%83threejs%E7%89%A9%E4%BD%93%E7%BC%A9%E6%94%BE%E4%B8%8E%E6%97%8B%E8%BD%AC">七、Threejs物体缩放与旋转</a></li><li><a href="#%E5%85%ABthreejs%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E5%8A%A8%E7%94%BB%E8%BF%90%E5%8A%A8">八、Threejs正确处理动画运动</a></li><li><a href="#%E4%B9%9Dthreejs%E4%B8%ADclock%E8%B7%9F%E8%B8%AA%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%8A%A8%E7%94%BB">九、Threejs中Clock跟踪时间处理动画</a></li><li><a href="#%E5%8D%81gsap%E5%8A%A8%E7%94%BB%E5%BA%93%E4%BD%BF%E7%94%A8">十、Gsap动画库使用</a></li><li><a href="#%E5%8D%81%E4%B8%80%E7%94%BB%E5%B8%83%E8%87%AA%E9%80%82%E5%BA%94%E5%B1%8F%E5%B9%95%E5%A4%A7%E5%B0%8F%E4%B8%8E%E5%85%A8%E5%B1%8F">十一、画布自适应屏幕大小与全屏</a></li><li><a href="#%E5%8D%81%E4%BA%8C%E5%BA%94%E7%94%A8%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E6%9B%B4%E6%94%B9%E5%8F%98%E9%87%8F">十二、应用图形用户界面更改变量</a></li></ul><h2 id="一、本地搭建Threejs官方文档网站"><a href="#一、本地搭建Threejs官方文档网站" class="headerlink" title="一、本地搭建Threejs官方文档网站"></a>一、本地搭建Threejs官方文档网站</h2><p>因为Three.js官网是国外的服务器，所以为了方便学习和快速的查阅文档，我们可以自己搭建Three.js官网和文档，方便随时查看案例和文档内容进行学习。</p><p><strong>1、首先进入threejs库GitHub地址：<a href="https://github.com/mrdoob/three.js">https://github.com/mrdoob/three.js</a></strong></p><p><strong>2、下载完整代码</strong></p><p><img src="https://i0.hdslb.com/bfs/article/48fcf222da2afa75e20a3e6e5292a854bebabb01.png@942w_474h_progressive.webp" alt="img"></p><p><strong>3、项目文件解压缩</strong></p><p><img src="https://i0.hdslb.com/bfs/article/064d111714e45ec2f3ca076377539f869641ff9f.png@942w_998h_progressive.webp" alt="img"></p><p><strong>4、命令行安装依赖</strong></p><p>一般安装可以用npm、yarn等包管理工具，课程以yarn举例，如果没有安装可以用npm install yarn -g进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/629b6eb8813a49a70866a39614d525bfbf32e241.png@942w_345h_progressive.webp" alt="img"></p><p><strong>5、启动项目</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/69aca9f2b22bd1b2a473e82fc9911888210026ee.png@942w_321h_progressive.webp" alt="img"></p><p>浏览器访问即可：<a href="http://localhost:8080/">http://localhost:8080</a></p><p><strong>6、文档目录介绍</strong></p><p><img src="https://i0.hdslb.com/bfs/article/f06ea28ece3bf4966884d12f31ae3ef2fa21b198.png@942w_639h_progressive.webp" alt="img"></p><p><strong>build目录：</strong></p><p><img src="https://i0.hdslb.com/bfs/article/2eaf352481ba76ff7b60cf55e0b19074c99d0556.png@654w_333h_progressive.webp" alt="img"></p><p><strong>docs文档：</strong></p><p>选择中文，查看中文文档。</p><p><img src="https://i0.hdslb.com/bfs/article/b3ac7dbfef00f80cf43c0875b0706a9a5ee601b8.png@942w_569h_progressive.webp" alt="img"></p><p><strong>examples案例：</strong></p><p><img src="https://i0.hdslb.com/bfs/article/d0bf8aea2caa58cd11ae82a9aa0a8d2029c097fb.png@942w_483h_progressive.webp" alt="img"></p><p>可以通过网址，找到具体的案例代码，如此处的文件名称是：webgl_animation_keyframes。因此可以在文件夹找到对应的代码文件</p><p><img src="https://i0.hdslb.com/bfs/article/ee61b8caef44caf66dc54719ed3ddac4480f39ff.png@942w_288h_progressive.webp" alt="img"></p><p><strong>editor目录：</strong></p><p>官方提供的可视化编辑器，可以直接导入模型，修改材质，添加光照效果等等。</p><p><img src="https://i0.hdslb.com/bfs/article/2a94f42e1f19fdbf31bde24cd3640926ae03ca65.png@942w_410h_progressive.webp" alt="img"></p><h2 id="二、使用parcel搭建three-js开发环境"><a href="#二、使用parcel搭建three-js开发环境" class="headerlink" title="二、使用parcel搭建three.js开发环境"></a>二、使用parcel搭建three.js开发环境</h2><p>为了方便模块化进行three.js项目的学习和开发，又不用学习太多的配置，增加学习成本，所以就使用Parcel这个web应用打包工具。</p><p>Parcel官网：<a href="https://v2.parceljs.cn/getting-started/webapp/">https://v2.parceljs.cn/getting-started/webapp/</a></p><h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><p>在开始之前，您需要安装 Node 和 Yarn 或 npm，并为您的项目创建一个目录。然后，使用 Yarn 将 Parcel 安装到您的应用程序中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev parcel</span><br></pre></td></tr></table></figure><p>或者在使用 npm 运行时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev parcel</span><br></pre></td></tr></table></figure><h3 id="2、项目设置"><a href="#2、项目设置" class="headerlink" title="2、项目设置"></a>2、项目设置</h3><p>现在已经安装了 Parcel，让我们为我们的应用程序创建一些源文件。Parcel 接受任何类型的文件作为入口点，但 HTML 文件是一个很好的起点。Parcel 将从那里遵循您的所有依赖项来构建您的应用程序。</p><p>创建src文件夹，并且创建index.html文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./assets/css/style.css&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main/main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/a1ca45e07ba3ee682df2e98d6e3c66e8b84c6335.png@942w_359h_progressive.webp" alt="img"></p><h3 id="设置1个css文件"><a href="#设置1个css文件" class="headerlink" title="设置1个css文件"></a>设置1个css文件</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/41d22c3b03134b6e21022d2a639de44dd7d4e6b5.png@942w_462h_progressive.webp" alt="img"></p><h3 id="创建一个main-js"><a href="#创建一个main-js" class="headerlink" title="创建一个main.js"></a>创建一个main.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(THREE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标：了解three.js最基本的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line">renderer.render(scene, camera);</span><br></pre></td></tr></table></figure><h3 id="3、打包脚本"><a href="#3、打包脚本" class="headerlink" title="3、打包脚本"></a>3、打包脚本</h3><p>到目前为止，我们一直在parcel直接运行 CLI，但在您的package.json文件中创建一些脚本以简化此操作会很有用。我们还将设置一个脚本来使用该命令构建您的应用程序以进行生产。parcel build最后，您还可以使用该字段在一个地方声明您的条目source，这样您就不需要在每个parcel命令中重复它们。</p><p>package.json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;01-three_basic&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;parcel src/index.html&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;parcel build src/index.html&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;parcel&quot;</span>: <span class="string">&quot;^2.4.1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dat.gui&quot;</span>: <span class="string">&quot;^0.7.9&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;gsap&quot;</span>: <span class="string">&quot;^3.10.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;three&quot;</span>: <span class="string">&quot;^0.139.2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>安装依赖package.json设置的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure><p>现在您可以运行yarn build以构建您的生产项目并yarn dev启动开发服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn dev </span><br></pre></td></tr></table></figure><h2 id="三、Threejs渲染第一个场景和物体"><a href="#三、Threejs渲染第一个场景和物体" class="headerlink" title="三、Threejs渲染第一个场景和物体"></a>三、Threejs渲染第一个场景和物体</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h3><p>三维的物体要渲染在二维的屏幕上。首先要创建一个场景来放置物体，那么最终怎么显示三维的内容，就应该找一个相机，将相机放在场景的某个位置，然后想要显示就要把相机拍的内容渲染出来。所以就引出三个基本概念：场景、相机、渲染器。</p><h4 id="1-1-场景"><a href="#1-1-场景" class="headerlink" title="1.1 场景"></a>1.1 场景</h4><p>three.js创建场景非常的简单。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br></pre></td></tr></table></figure><h4 id="1-2-相机"><a href="#1-2-相机" class="headerlink" title="1.2 相机"></a>1.2 相机</h4><p>three.js创建相机对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>); </span><br></pre></td></tr></table></figure><p>three.js里有几种不同的相机，在这里，我们使用的是<strong>PerspectiveCamera</strong>（透视摄像机）。</p><p>第一个参数是<strong>视野角度（FOV</strong>）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的单位是角度(与弧度区分开)。</p><p>第二个参数是<strong>长宽比（aspect ratio</strong>）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p><p>接下来的两个参数是<strong>近截面</strong>（near）和远截面（far）。 当物体某些部分比摄像机的<strong>远截面</strong>远或者比<strong>近截面</strong>近的时候，该这些部分将不会被渲染到场景中。或许现在你不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p><p>下图椎体就是上面设置视野角度、长宽比、近截面和远截面的演示的相机透视椎体。</p><p><img src="https://i0.hdslb.com/bfs/article/11c2c2d27b322c07ee20b70018cd0df551eaea2e.png@597w_402h_progressive.webp" alt="img"></p><h4 id="1-3-渲染器"><a href="#1-3-渲染器" class="headerlink" title="1.3 渲染器"></a>1.3 渲染器</h4><p>接下来是渲染器。这里是施展魔法的地方。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line">renderer.render(scene, camera);</span><br></pre></td></tr></table></figure><p>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用<code>setSize</code>传入一个较小的值，例如<code>window.innerWidth/2</code>和<code>window.innerHeight/2</code>，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</p><p>接下来将<code>renderer</code>（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。渲染器用来显示场景给我们看的<canvas>元素。</p><p>最后就是对将相机对场景进行拍照渲染啦。这一句就可以将画面渲染到canvas上显示出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderer.render(scene, camera);</span><br></pre></td></tr></table></figure><h4 id="1-4-加入立方体"><a href="#1-4-加入立方体" class="headerlink" title="1.4 加入立方体"></a>1.4 加入立方体</h4><p>要创建一个立方体，我们需要一个<strong>BoxGeometry</strong>（立方体）对象. 这个对象包含了一个立方体中所有的顶点（<strong>vertices</strong>）和面（<strong>faces</strong>）。</p><p>接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。这里我们使用的是<strong>MeshBasicMaterial</strong>。所有的材质都存有应用于他们的属性的对象。为了简单起见，我们只设置一个color属性，值为<strong>0x00ff00</strong>，也就是绿色。这里和CSS或者Photoshop中使用十六进制(<strong>hex colors</strong>)颜色格式来设置颜色的方式一致。</p><p>第三步，我们需要一个<strong>Mesh</strong>（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p><p>默认情况下，当我们调用**scene.add()<strong>的时候，物体将会被添加到</strong>(0,0,0)**坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br></pre></td></tr></table></figure><h3 id="2-综合上述代码"><a href="#2-综合上述代码" class="headerlink" title="2 综合上述代码"></a>2 综合上述代码</h3><p><strong>在前面创建的项目中的main.js文件写入代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(THREE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标：了解three.js最基本的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line">renderer.render(scene, camera);</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="https://i0.hdslb.com/bfs/article/0b50a12934a7e62acc12251115c3448d85ffa1a7.png@704w_416h_progressive.webp" alt="img"></p><h2 id="四、Threejs轨道控制器查看物体"><a href="#四、Threejs轨道控制器查看物体" class="headerlink" title="四、Threejs轨道控制器查看物体"></a>四、Threejs轨道控制器查看物体</h2><h3 id="1-如何360度的查看立方体"><a href="#1-如何360度的查看立方体" class="headerlink" title="1 如何360度的查看立方体"></a>1 如何360度的查看立方体</h3><p>使用控制控制器，让相机围绕立方体运动，就像地球围绕太阳一样运动，去观察立方体。</p><p><img src="https://i0.hdslb.com/bfs/article/46eb73b99d98da462440cad79aa34795a2294ef4.gif@489w_282h_progressive.webp" alt="img"></p><h4 id="1-1-创建轨道控制器"><a href="#1-1-创建轨道控制器" class="headerlink" title="1.1 创建轨道控制器"></a>1.1 创建轨道控制器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建轨道控制器</span></span><br><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> OrbitControls(camera, renderer.domElement);</span><br></pre></td></tr></table></figure><p><strong>必须传入2个参数：</strong></p><ol><li><p>相机，让哪一个相机围绕目标运动。默认目标是原点。立方体在原点处。</p></li><li><p>渲染的画布dom对象，用于监听鼠标事件控制相机的围绕运动。</p></li></ol><h4 id="1-2-每一帧根据控制器更新画面"><a href="#1-2-每一帧根据控制器更新画面" class="headerlink" title="1.2 每一帧根据控制器更新画面"></a>1.2 每一帧根据控制器更新画面</h4><p>因为控制器监听鼠标事件之后，要根据鼠标的拖动，来控制相机围绕目标运动，并根据运动之后的效果，显示出画面来。为了保证画面流畅渲染，选择使用请求动画帧requestAnimationFrame，在屏幕渲染下一帧画面时触发回调函数来执行画面的渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//如果后期需要控制器带有阻尼效果，或者自动旋转等效果，就需要加入controls.update()</span></span><br><span class="line">  controls.update()</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h5 id="1-2-1-requestAnimationFrame"><a href="#1-2-1-requestAnimationFrame" class="headerlink" title="1.2.1 requestAnimationFrame"></a>1.2.1 requestAnimationFrame</h5><p>是HTML5的新特性，区别于<code>setTimeout</code>和<code>setInterval</code>。<code>requestAnimationFrame</code>比后两者精确，采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p><p><code>requestAnimationFrame</code>是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。</p><p>因此屏幕每一帧都刷新一次画面，就需要执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h3 id="2-综合上述代码-1"><a href="#2-综合上述代码-1" class="headerlink" title="2 综合上述代码"></a>2 综合上述代码</h3><p><strong>在前面创建的项目中的main.js文件写入代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"><span class="comment">// 导入轨道控制器</span></span><br><span class="line"><span class="keyword">import</span> &#123; OrbitControls &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/controls/OrbitControls&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(THREE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标：使用控制器查看3d物体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line"><span class="comment">// renderer.render(scene, camera);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建轨道控制器</span></span><br><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> OrbitControls(camera, renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加坐标轴辅助器</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">5</span>);</span><br><span class="line">scene.add(axesHelper);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="https://i0.hdslb.com/bfs/article/46eb73b99d98da462440cad79aa34795a2294ef4.gif@489w_282h_progressive.webp" alt="img"></p><h2 id="五、Threejs控制物体移动"><a href="#五、Threejs控制物体移动" class="headerlink" title="五、Threejs控制物体移动"></a>五、Threejs控制物体移动</h2><h3 id="1-控制物体移动"><a href="#1-控制物体移动" class="headerlink" title="1. 控制物体移动"></a>1. 控制物体移动</h3><p><img src="https://i0.hdslb.com/bfs/article/a35394deeabd8745cb7306363341f4d7e71fe513.gif@489w_282h_progressive.webp" alt="img"></p><p>为了让物体移动起来。我们可以设置它的<code>position</code>属性进行位置的设置。</p><p>相机和立方体都是物体。每个物体都是1个对象。</p><p>在官方文档里，我们可以看到相机<code>camera</code>和物体<code>mesh</code>都继承<code>Object3D</code>类。所以<code>camera</code>、<code>mesh</code>都属于3d对象。从3d对象的官方文档里，我们可以找到<code>position</code>属性，并且该属性一个<code>vector3</code>对象。因此通过官方<code>vector3</code>类的文档，我们可以简单使用下面2种方式来修改<code>position</code>位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置该向量的x、y 和 z 分量。</span></span><br><span class="line">mesh.position.set(x,y,z);</span><br><span class="line"><span class="comment">//直接设置position的x,y,z属性</span></span><br><span class="line">mesh.position.x = x;</span><br><span class="line">mesh.position.y = y;</span><br><span class="line">mesh.position.z = z;</span><br></pre></td></tr></table></figure><p>官方文档：<a href="https://threejs.org/docs/index.html?q=vect#api/zh/math/Vector3">https://threejs.org/docs/index.html?q=vect#api/zh/math/Vector3</a></p><p><img src="https://i0.hdslb.com/bfs/article/daedc9f76ed4fc5800af96f60ff560843806e3ed.png@909w_251h_progressive.webp" alt="img"></p><p><img src="https://i0.hdslb.com/bfs/article/daedc9f76ed4fc5800af96f60ff560843806e3ed.png@909w_251h_progressive.webp" alt="img"></p><p><img src="https://i0.hdslb.com/bfs/article/b1d8877a6b77718e509e95c59ce4cf22cc7db0cc.png@798w_147h_progressive.webp" alt="img"></p><h4 id="1-1-每一帧修改一点位置形成动画"><a href="#1-1-每一帧修改一点位置形成动画" class="headerlink" title="1.1 每一帧修改一点位置形成动画"></a>1.1 每一帧修改一点位置形成动画</h4><p>例如，每一帧让立方体向右移动0.01，并且当位置大于5时，从0开始。那么可以这么设置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  cube.position.x += <span class="number">0.01</span>;</span><br><span class="line">  <span class="keyword">if</span> (cube.position.x &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    cube.position.x = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h3 id="2-综合上述代码-2"><a href="#2-综合上述代码-2" class="headerlink" title="2 综合上述代码"></a>2 综合上述代码</h3><p><strong>在前面创建的项目中的main.js文件写入代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"><span class="comment">// 导入轨道控制器</span></span><br><span class="line"><span class="keyword">import</span> &#123; OrbitControls &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/controls/OrbitControls&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(THREE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标：控制3d物体移动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改物体的位置</span></span><br><span class="line"><span class="comment">// cube.position.set(5, 0, 0);</span></span><br><span class="line">cube.position.x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line"><span class="comment">// renderer.render(scene, camera);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建轨道控制器</span></span><br><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> OrbitControls(camera, renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加坐标轴辅助器</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">5</span>);</span><br><span class="line">scene.add(axesHelper);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  cube.position.x += <span class="number">0.01</span>;</span><br><span class="line">  <span class="keyword">if</span> (cube.position.x &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    cube.position.x = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="https://i0.hdslb.com/bfs/article/a35394deeabd8745cb7306363341f4d7e71fe513.gif@489w_282h_progressive.webp" alt="img"></p><h2 id="六、Threejs添加坐标轴辅助器"><a href="#六、Threejs添加坐标轴辅助器" class="headerlink" title="六、Threejs添加坐标轴辅助器"></a>六、Threejs添加坐标轴辅助器</h2><h3 id="1-坐标轴辅助器"><a href="#1-坐标轴辅助器" class="headerlink" title="1. 坐标轴辅助器"></a>1. 坐标轴辅助器</h3><p>一般我们在开发阶段，添加物体和设置物体位置，都需要参考一下坐标轴，方便查看是否放置到对应位置。所以一般添加坐标轴辅助器来作为参考，辅助器简单模拟3个坐标轴的对象。红色代表 X 轴. 绿色代表 Y 轴. 蓝色代表 Z 轴。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper( <span class="number">5</span> );</span><br><span class="line">scene.add( axesHelper );</span><br></pre></td></tr></table></figure><h3 id="2-ArrowHelper箭头辅助器"><a href="#2-ArrowHelper箭头辅助器" class="headerlink" title="2. ArrowHelper箭头辅助器"></a>2. ArrowHelper箭头辅助器</h3><p><strong>用于模拟方向的3维箭头对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dir = <span class="keyword">new</span> THREE.Vector3( <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//normalize the direction vector (convert to vector of length 1)</span></span><br><span class="line">dir.normalize();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> origin = <span class="keyword">new</span> THREE.Vector3( <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line"><span class="keyword">const</span> length = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> hex = <span class="number">0xffff00</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrowHelper = <span class="keyword">new</span> THREE.ArrowHelper( dir, origin, length, hex );</span><br><span class="line">scene.add( arrowHelper )</span><br></pre></td></tr></table></figure><p><strong>构造函数</strong><br>ArrowHelper(dir : Vector3, origin : Vector3, length : Number, hex : Number, headLength : Number, headWidth : Number )</p><p><code>dir</code> – 基于箭头原点的方向. 必须为单位向量.<br><code>origin </code>– 箭头的原点.<br><code>length </code>– 箭头的长度. 默认为 1.<br><code>hex </code>– 定义的16进制颜色值. 默认为 0xffff00.<br><code>headLength </code>– 箭头头部(锥体)的长度. 默认为箭头长度的0.2倍(0.2 * length).<br><code>headWidth </code>– The width of the head of the arrow. Default is 0.2 * headLength. </p><h2 id="七、Threejs物体缩放与旋转"><a href="#七、Threejs物体缩放与旋转" class="headerlink" title="七、Threejs物体缩放与旋转"></a>七、Threejs物体缩放与旋转</h2><h3 id="1-scale设置缩放"><a href="#1-scale设置缩放" class="headerlink" title="1. scale设置缩放"></a>1. scale设置缩放</h3><p>因为物体的scale属性是vector3对象，因此按照vector的属性和方法，设置x/y/z轴方向的缩放大小。</p><p><img src="https://i0.hdslb.com/bfs/article/6787f2503d0cf27e1c4b9d672f5a5484131f8a4f.png@690w_171h_progressive.webp" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如设置x轴放大3倍、y轴方向放大2倍、z轴方向不变</span></span><br><span class="line">cube.scale.set(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//单独设置某个轴的缩放</span></span><br><span class="line">cube.scale.x = <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="2-rotation设置旋转"><a href="#2-rotation设置旋转" class="headerlink" title="2.  rotation设置旋转"></a>2.  rotation设置旋转</h3><p>因为的旋转通过设置rotation属性，该属性是Euler类的实例，因此可以通过Euler类的方法进行设置旋转角度。</p><p><img src="https://i0.hdslb.com/bfs/article/ff0425e4f2395e403eaec39d9bc0b797e65df7a2.png@426w_128h_progressive.webp" alt="img"></p><p>因此可以通过以下方式设置旋转物体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接设置旋转属性，例如围绕x轴旋转90度</span></span><br><span class="line">cube.rotation.x = -<span class="built_in">Math</span>.PI/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//围绕x轴旋转45度</span></span><br><span class="line">cube.rotation.set(-<span class="built_in">Math</span>.PI / <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;XZY&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>set方法，每个参数具体定义:</strong></p><p>.set ( x : Float, y : Float, z : Float, order : String ) : this</p><p>x - 用弧度表示x轴旋转量。<br>y - 用弧度表示y轴旋转量。<br>z - 用弧度表示z轴旋转量。<br>order - (optional) 表示旋转顺序的字符串。</p><h4 id="2-1-旋转动画"><a href="#2-1-旋转动画" class="headerlink" title="2.1 旋转动画"></a>2.1 旋转动画</h4><p>每一帧旋转弧度制的0.01角度，实现动画代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  cube.position.x += <span class="number">0.01</span>;</span><br><span class="line">  cube.rotation.x += <span class="number">0.01</span>;</span><br><span class="line">  <span class="keyword">if</span> (cube.position.x &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    cube.position.x = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-综合上述代码"><a href="#3-综合上述代码" class="headerlink" title="3.综合上述代码"></a>3.综合上述代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"><span class="comment">// 导入轨道控制器</span></span><br><span class="line"><span class="keyword">import</span> &#123; OrbitControls &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/controls/OrbitControls&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(THREE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标：控制3d物体移动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改物体的位置</span></span><br><span class="line"><span class="comment">// cube.position.set(5, 0, 0);</span></span><br><span class="line">cube.position.x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line"><span class="comment">// renderer.render(scene, camera);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建轨道控制器</span></span><br><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> OrbitControls(camera, renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加坐标轴辅助器</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">5</span>);</span><br><span class="line">scene.add(axesHelper);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  cube.position.x += <span class="number">0.01</span>;</span><br><span class="line">  <span class="keyword">if</span> (cube.position.x &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    cube.position.x = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="https://i0.hdslb.com/bfs/article/8d96d25daeaf34e6608bf5a6e695bb72e873ea46.gif@830w_543h_progressive.webp" alt="img"></p><h2 id="八、Threejs正确处理动画运动"><a href="#八、Threejs正确处理动画运动" class="headerlink" title="八、Threejs正确处理动画运动"></a>八、Threejs正确处理动画运动</h2><p>为了最好的利用性能和渲染效果，那么我们只需要在绘制每一帧画面的时候，计算需要渲染的画面即可。这个时候就可以使用window.requestAnimationFrame方法。</p><p><img src="https://i0.hdslb.com/bfs/article/30598fa39925444ccd5284764b35499960fd9699.gif@761w_543h_progressive.webp" alt="img"></p><h3 id="1-使用方式"><a href="#1-使用方式" class="headerlink" title="1. 使用方式"></a>1. 使用方式</h3><p><strong>window.requestAnimationFrame()</strong> 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//下一帧渲染画面前，需要执行处理的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(callback);</span><br></pre></td></tr></table></figure><h3 id="1-请求动画帧间隔不固定"><a href="#1-请求动画帧间隔不固定" class="headerlink" title="1. 请求动画帧间隔不固定"></a>1. 请求动画帧间隔不固定</h3><p>当你准备更新动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数 (即你的回调函数)。回调函数执行次数通常是每秒 60 次，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。因此具体回调函数执行的间隔时间跟屏幕刷新次数、当前页面运行时负荷等因素有关。</p><h4 id="1-2-1-解决确保不同帧率的画面运行速度一致"><a href="#1-2-1-解决确保不同帧率的画面运行速度一致" class="headerlink" title="1.2.1 解决确保不同帧率的画面运行速度一致"></a>1.2.1 解决确保不同帧率的画面运行速度一致</h4><p>回调函数会被传入<code>DOMHighResTimeStamp</code>参数，<code>DOMHighResTimeStamp</code>指示当前被 <code>requestAnimationFrame() </code>排序的回调函数被触发的时间。</p><p>请确保总是使用第一个参数 (或其它获得当前时间的方法) 计算每次调用之间的时间间隔，否则动画在高刷新率的屏幕中会运行得更快。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> preTime;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//第一次调用render函数，没有上一帧的时间</span></span><br><span class="line">  <span class="keyword">if</span> (preTime === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    preTime = time;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算每帧画面的间隔时间，单位毫秒</span></span><br><span class="line">  <span class="keyword">const</span> deltaTime = time - preTime;</span><br><span class="line">  <span class="built_in">console</span>.log(deltaTime)</span><br><span class="line">  <span class="comment">//保留当前时间作为上一帧时间，用于下一帧计算2帧间隔</span></span><br><span class="line">  preTime = time;</span><br><span class="line">  <span class="comment">//renderer.render(scene, camera);</span></span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>代码执行后，我们通过输出可以看出，每一帧间隔非常相近，但又不同。</p><p><img src="https://i0.hdslb.com/bfs/article/f02caef1668448e3e4f9ca0668897e1b77461ce6.png@306w_113h_progressive.webp" alt="img"></p><p>为了确保不同时间间隔，运动的速度一致，那么应该按照</p><p>移动距离 = 速度 * 时间</p><p>那么如果想要1m/s的速度远离原点的匀速运动，那么就按照这么编写代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> preTime;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//第一次调用render函数，没有上一帧的时间</span></span><br><span class="line">  <span class="keyword">if</span> (preTime === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    preTime = time;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算每帧画面的间隔时间，单位毫秒，当前时间减去上一帧的时间，即为2帧直接的间隔时间</span></span><br><span class="line">  <span class="keyword">const</span> deltaTime = time - preTime;</span><br><span class="line">  <span class="built_in">console</span>.log(deltaTime)</span><br><span class="line"></span><br><span class="line">  preTime = time;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//cube物体允许运动</span></span><br><span class="line">  <span class="comment">//elapsedTime/1000是将毫秒改为秒</span></span><br><span class="line">  <span class="comment">//1m/s的速度* 时间（秒）= 移动的距离</span></span><br><span class="line">  <span class="comment">//将当前位置+=移动的距离，即为最后的距离</span></span><br><span class="line">  cube.position.x += <span class="number">1</span> * (deltaTime/<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//renderer.render(scene, camera);</span></span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h3 id="2-综合上述代码-3"><a href="#2-综合上述代码-3" class="headerlink" title="2 综合上述代码"></a>2 综合上述代码</h3><p><strong>在前面创建的项目中的main.js文件写入代码，实现每5秒，即从原点出发匀速在x轴进行1m/s的匀速运动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import * as THREE from &quot;three&quot;;</span><br><span class="line">&#x2F;&#x2F; 导入轨道控制器</span><br><span class="line">import &#123; OrbitControls &#125; from &quot;three&#x2F;examples&#x2F;jsm&#x2F;controls&#x2F;OrbitControls&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; console.log(THREE);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 目标：requestAnimationFrame 时间参数 控制物体动画</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1、创建场景</span><br><span class="line">const scene &#x3D; new THREE.Scene();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、创建相机</span><br><span class="line">const camera &#x3D; new THREE.PerspectiveCamera(</span><br><span class="line">  75,</span><br><span class="line">  window.innerWidth &#x2F; window.innerHeight,</span><br><span class="line">  0.1,</span><br><span class="line">  1000</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置相机位置</span><br><span class="line">camera.position.set(0, 0, 10);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加物体</span><br><span class="line">&#x2F;&#x2F; 创建几何体</span><br><span class="line">const cubeGeometry &#x3D; new THREE.BoxGeometry(1, 1, 1);</span><br><span class="line">const cubeMaterial &#x3D; new THREE.MeshBasicMaterial(&#123; color: 0xffff00 &#125;);</span><br><span class="line">&#x2F;&#x2F; 根据几何体和材质创建物体</span><br><span class="line">const cube &#x3D; new THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改物体的位置</span><br><span class="line">&#x2F;&#x2F; cube.position.set(5, 0, 0);</span><br><span class="line">&#x2F;&#x2F; cube.position.x &#x3D; 3;</span><br><span class="line">&#x2F;&#x2F; 缩放</span><br><span class="line">&#x2F;&#x2F; cube.scale.set(3, 2, 1);</span><br><span class="line">&#x2F;&#x2F; cube.scale.x &#x3D; 5;</span><br><span class="line">&#x2F;&#x2F; 旋转</span><br><span class="line">cube.rotation.set(Math.PI &#x2F; 4, 0, 0, &quot;XZY&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将几何体添加到场景中</span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line">console.log(cube);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化渲染器</span><br><span class="line">const renderer &#x3D; new THREE.WebGLRenderer();</span><br><span class="line">&#x2F;&#x2F; 设置渲染的尺寸大小</span><br><span class="line">renderer.setSize(window.innerWidth, window.innerHeight);</span><br><span class="line">&#x2F;&#x2F; console.log(renderer);</span><br><span class="line">&#x2F;&#x2F; 将webgl渲染的canvas内容添加到body</span><br><span class="line">document.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#x2F;&#x2F; 使用渲染器，通过相机将场景渲染进来</span><br><span class="line">&#x2F;&#x2F; renderer.render(scene, camera);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建轨道控制器</span><br><span class="line">const controls &#x3D; new OrbitControls(camera, renderer.domElement);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加坐标轴辅助器</span><br><span class="line">const axesHelper &#x3D; new THREE.AxesHelper(5);</span><br><span class="line">scene.add(axesHelper);</span><br><span class="line"></span><br><span class="line">function render(time) &#123;</span><br><span class="line"></span><br><span class="line">  let t &#x3D; (time &#x2F; 1000) % 5;</span><br><span class="line">  cube.position.x &#x3D; t * 1;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  &#x2F;&#x2F;   渲染下一帧的时候就会调用render函数</span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="https://i0.hdslb.com/bfs/article/30598fa39925444ccd5284764b35499960fd9699.gif@761w_543h_progressive.webp" alt="img"></p><h2 id="九、Threejs中Clock跟踪时间处理动画"><a href="#九、Threejs中Clock跟踪时间处理动画" class="headerlink" title="九、Threejs中Clock跟踪时间处理动画"></a>九、Threejs中Clock跟踪时间处理动画</h2><h3 id="1-Clock"><a href="#1-Clock" class="headerlink" title="1. Clock"></a>1. Clock</h3><p>该对象用于跟踪时间。如果<code>performance.now</code>可用，则 <code>Clock </code>对象通过该方法实现，否则回落到使用略欠精准的<code>Date.now</code>来实现。</p><p>实例化<code>clock</code>对象，<code>new Clock( autoStart : Boolean )</code>，autoStart — (可选) 是否要在第一次调用 .<code>getDelta() </code>时自动开启时钟。默认值是 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化时钟</span></span><br><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br></pre></td></tr></table></figure><h4 id="1-1-获取运行当前帧的时间"><a href="#1-1-获取运行当前帧的时间" class="headerlink" title="1.1 获取运行当前帧的时间"></a>1.1 获取运行当前帧的时间</h4><p><strong>getElapsedTime ()获取自时钟启动后的秒数。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置时钟</span></span><br><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取时钟运行的总时长</span></span><br><span class="line">  <span class="keyword">let</span> time = clock.getElapsedTime();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;时钟运行总时长：&quot;</span>, time);</span><br><span class="line"></span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p><strong>getDelta () 获取2帧之间的时间间隔。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置时钟</span></span><br><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取2帧之间的时间间隔</span></span><br><span class="line">  <span class="keyword">let</span> deltaTime = clock.getElapsedTime();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;2帧之间的时间间隔：&quot;</span>, deltaTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>注意：getDelta、getElapsedTime请勿同时用于同一帧，会导致getDelta计时不准。因为每次调用这2个函数，都会对oldTime属性进行重置，所以getDelta计算出来的就不是上一帧的时间。</p><h3 id="2-综合上述代码-4"><a href="#2-综合上述代码-4" class="headerlink" title="2 综合上述代码"></a>2 综合上述代码</h3><p>在前面创建的项目中的main.js文件写入代码，实现每5秒，即从原点出发匀速在x轴进行1m/s的匀速运动</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"><span class="comment">// 导入轨道控制器</span></span><br><span class="line"><span class="keyword">import</span> &#123; OrbitControls &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/controls/OrbitControls&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(THREE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标：Clock该对象用于跟踪时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改物体的位置</span></span><br><span class="line"><span class="comment">// cube.position.set(5, 0, 0);</span></span><br><span class="line"><span class="comment">// cube.position.x = 3;</span></span><br><span class="line"><span class="comment">// 缩放</span></span><br><span class="line"><span class="comment">// cube.scale.set(3, 2, 1);</span></span><br><span class="line"><span class="comment">// cube.scale.x = 5;</span></span><br><span class="line"><span class="comment">// 旋转</span></span><br><span class="line">cube.rotation.set(<span class="built_in">Math</span>.PI / <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;XZY&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line"><span class="comment">// renderer.render(scene, camera);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建轨道控制器</span></span><br><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> OrbitControls(camera, renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加坐标轴辅助器</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">5</span>);</span><br><span class="line">scene.add(axesHelper);</span><br><span class="line"><span class="comment">// 设置时钟</span></span><br><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取时钟运行的总时长</span></span><br><span class="line">  <span class="keyword">let</span> time = clock.getElapsedTime();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;时钟运行总时长：&quot;</span>, time);</span><br><span class="line">  <span class="comment">//   let deltaTime = clock.getDelta();</span></span><br><span class="line">  <span class="comment">//     console.log(&quot;两次获取时间的间隔时间：&quot;, deltaTime);</span></span><br><span class="line">  <span class="keyword">let</span> t = time % <span class="number">5</span>;</span><br><span class="line">  cube.position.x = t * <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="https://i0.hdslb.com/bfs/article/30598fa39925444ccd5284764b35499960fd9699.gif@761w_543h_progressive.webp" alt="img"></p><h2 id="十、Gsap动画库使用"><a href="#十、Gsap动画库使用" class="headerlink" title="十、Gsap动画库使用"></a>十、Gsap动画库使用</h2><p>GSAP 是一个强大的 JavaScript 工具集，让大家秒变动画大佬。构建适用于所有主流浏览器的高性能动画。动画 CSS、SVG、画布、React、Vue、WebGL、颜色、字符串、运动路径、通用对象…… JavaScript 可以触摸的任何东西！GSAP 的ScrollTrigger插件让您可以用最少的代码创建令人瞠目结舌的滚动动画。</p><h3 id="1-安装GSAP模块"><a href="#1-安装GSAP模块" class="headerlink" title="1 安装GSAP模块"></a>1 安装GSAP模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gsap</span><br></pre></td></tr></table></figure><h3 id="2-创建动画"><a href="#2-创建动画" class="headerlink" title="2 创建动画"></a>2 创建动画</h3><p>例如，如果html元素创建动画，将 ‘.box’ 类的元素设置1秒时间水平移动 200px 的动画。可以这么编写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入动画库</span></span><br><span class="line"><span class="keyword">import</span> gsap <span class="keyword">from</span> <span class="string">&quot;gsap&quot;</span>;</span><br><span class="line">gsap.to(<span class="string">&quot;.box&quot;</span>, &#123; <span class="attr">x</span>: <span class="number">200</span> &#125;)</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/bf128cad580f9386046607041ddd42a2ef7ad705.gif@638w_303h_progressive.webp" alt="img"></p><p>在three.js中如果我们想要将物体，例如立方体移动设置1秒时间水平移动 200px 的动画。可以这么编写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入动画库</span></span><br><span class="line"><span class="keyword">import</span> gsap <span class="keyword">from</span> <span class="string">&quot;gsap&quot;</span>;</span><br><span class="line">gsap.to(cube.position, &#123; <span class="attr">x</span>: <span class="number">200</span> &#125;)</span><br></pre></td></tr></table></figure><p><code>gsap.to() -</code> 这是最常见的补间类型。是设置当前元素或者变量的状态，到设置的状态的补间动画。所谓的补间动画，就是2个关键帧（即2种物体的状态）有了，框架自带计算出中间某个时刻的状态，从而填补2个状态间，动画的空白时刻，从而实现完整动画。</p><p><code>gsap.to</code>有2个参数，第一个是目标元素或者变量。如果传入的是.box之类的css字符串选择器，GSAP 在后台使用document.querySelectorAll()选中页面的匹配的元素。当第一个目标是对象时，GSAP就会对其属性值进行修改来实现补间动画。</p><h3 id="3-GSAP设置动画的属性"><a href="#3-GSAP设置动画的属性" class="headerlink" title="3 GSAP设置动画的属性"></a>3 GSAP设置动画的属性</h3><p>如何是html元素，可以设置的属性有</p><p><img src="https://i0.hdslb.com/bfs/article/6fe9a5204d47e41dbbde6b7407d97aec71b276ef.png@242w_758h_progressive.webp" alt="img"></p><p>对应CSS样式属性</p><p><img src="https://i0.hdslb.com/bfs/article/729c19134fa8c4499934502561074c9164a8cf4b.png@647w_657h_progressive.webp" alt="img"></p><p>下面演示向右水平移动+旋转.box元素的效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gsap.to(<span class="string">&quot;.box&quot;</span>, &#123;</span><br><span class="line">  duration: <span class="number">2</span>,</span><br><span class="line">  x: <span class="number">200</span>,</span><br><span class="line">  rotation: <span class="number">360</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/b1aa9500c48d8dcb9cfcb706663ac9b4f6aa4435.gif@638w_303h_progressive.webp" alt="img"></p><p>默认情况下，GSAP 将使用 px 和度数进行变换，但您可以使用其他单位，例如 vw、弧度，甚至可以进行自己的 JS 计算或相对值！</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x : <span class="number">200</span> , <span class="comment">// 使用 px 的默认值</span></span><br><span class="line">x : <span class="string">&quot;+=200&quot;</span> <span class="comment">// 相对值</span></span><br><span class="line">x : <span class="string">&#x27;40vw&#x27;</span> , <span class="comment">// 或者传入一个具有不同单位的字符串以供 GSAP 解析</span></span><br><span class="line">x : <span class="function">() =&gt;</span> <span class="built_in">window</span> 。innerWidth / <span class="number">2</span> , <span class="comment">// 你甚至可以使用函数值进行计算！</span></span><br><span class="line">rotation：<span class="number">360</span> <span class="comment">// 使用默认的度数</span></span><br><span class="line">rotation：“<span class="number">1.</span>25rad” <span class="comment">// 使用弧度</span></span><br></pre></td></tr></table></figure><p>如果第一个参数目标不是html元素，也可以是对象。。您可以针对任何对象的任何属性，甚至是您创建的任意属性，如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">myNum</span>: <span class="number">10</span>, <span class="attr">myColor</span>: <span class="string">&quot;red&quot;</span> &#125;;</span><br><span class="line">gsap.to(obj, &#123;</span><br><span class="line">  myNum: <span class="number">200</span>,</span><br><span class="line">  myColor: <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">  onUpdate: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(obj.myNum, obj.myColor)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里可以让obj.myNum值从10变化到200，也可以让颜色myColor的值从红色变化到蓝色。每一次更新值的时候，执行onUpdate所设置的回调函数。</p><h3 id="4-GSAP特殊属性控制动画"><a href="#4-GSAP特殊属性控制动画" class="headerlink" title="4 GSAP特殊属性控制动画"></a>4 GSAP特殊属性控制动画</h3><p><code>duration</code>：动画持续时间（秒） 默认值：0.5</p><p><code>delay</code>：动画开始前的延迟量（秒）</p><p><code>repeat</code>：动画应该重复多少次。-1为一直重复</p><p><code>yoyo</code>：如果为 true，则每隔一个重复，补间将沿相反方向运行。（像悠悠球一样）默认值：false</p><p><code>ease</code>：控制动画期间的变化率。</p><p><code>onComplete</code>：动画完成时调用的函数</p><p><code>onUpdate</code>：动画值更新时调用的函数</p><p><strong>ease动画属性设置</strong><br>缓动可能是动作设计中最重要的部分。精心挑选的轻松将为您的动画增添个性并注入活力。</p><p>在下面的演示中看看 no ease 和bounce ease 之间的区别！绿色盒子以匀速的速度旋转，而紫色盒子带有“反弹”旋转动画，感觉就不一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gsap.to(<span class="string">&quot;.green&quot;</span>, &#123; <span class="attr">rotation</span>: <span class="number">360</span>, <span class="attr">duration</span>: <span class="number">2</span>, <span class="attr">ease</span>: <span class="string">&quot;none&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">gsap.to(<span class="string">&quot;.purple&quot;</span>, &#123; <span class="attr">rotation</span>: <span class="number">360</span>, <span class="attr">duration</span>: <span class="number">2</span>, <span class="attr">ease</span>: <span class="string">&quot;bounce.out&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/feb4ece2328520705c6108b135f560fdc80fcee0.gif@942w_246h_progressive.webp" alt="img"></p><p>在引擎内部，“ease”是一种数学计算，用于控制补间期间的变化率。但不用担心，框架会为您做所有的数学计算！您只需坐下来选择最适合我们的动画的效果即可。</p><p>对于大多数效果，分为三种类型in、out、inOut。这些控制了轻松过程中的动量。</p><p>像这样的 设置ease：”power1.out” 是 UI 过渡的最佳选择；它们启动速度很快，这有助于 UI 感觉反应灵敏，然后它们在接近尾声时放松，给人一种自然的摩擦感。</p><p>理解ease的最好方法是玩转ease配置的可视化工具！</p><p>地址：<a href="https://greensock.com/get-started/#greenSockEaseVisualizer">https://greensock.com/get-started/#greenSockEaseVisualizer</a></p><p>效果：</p><p><img src="https://i0.hdslb.com/bfs/article/571505cca304e007f8f140f8ac404c23f4cfbfc5.gif@942w_872h_progressive.webp" alt="img"></p><p><strong>Staggers交错</strong><br>这是我们最喜欢的技巧之一！如果补间有多个目标，您可以轻松地在每个动画的开始之间添加一些交错效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">gsap.from(<span class="string">&quot;.box&quot;</span>, &#123;</span><br><span class="line">  duration: <span class="number">2</span>,</span><br><span class="line">  scale: <span class="number">0.5</span>,</span><br><span class="line">  opacity: <span class="number">0</span>,</span><br><span class="line">  delay: <span class="number">0.5</span>,</span><br><span class="line">  stagger: <span class="number">0.2</span>,</span><br><span class="line">  ease: <span class="string">&quot;elastic&quot;</span>,</span><br><span class="line">  force3D: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.box&quot;</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">box</span>) </span>&#123;</span><br><span class="line">  box.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gsap.to(<span class="string">&quot;.box&quot;</span>, &#123;</span><br><span class="line">      duration: <span class="number">0.5</span>,</span><br><span class="line">      opacity: <span class="number">0</span>,</span><br><span class="line">      y: -<span class="number">100</span>,</span><br><span class="line">      stagger: <span class="number">0.1</span>,</span><br><span class="line">      ease: <span class="string">&quot;back.in&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/06690133d728fa622024e5958e8b7408d1919715.gif@942w_171h_progressive.webp" alt="img"></p><p>这里<code>stagger</code>设置0.2，即为将.box选中多个元素设置为每隔0.2秒开始运动1个元素实现效果。</p><p><strong>时间线-Timelines</strong><br>时间线是创建易于调整、有弹性的动画序列的关键。当您将补间添加到时间线时，默认情况下，它们会按照添加的顺序一个接一个地播放。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建时间线动画</span></span><br><span class="line"><span class="keyword">let</span> tl = gsap.timeline()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在用tl代替以前的gsap来设置动画即可。</span></span><br><span class="line">tl.to(<span class="string">&quot;.green&quot;</span>, &#123; <span class="attr">x</span>: <span class="number">600</span>, <span class="attr">duration</span>: <span class="number">2</span> &#125;);</span><br><span class="line">tl.to(<span class="string">&quot;.purple&quot;</span>, &#123; <span class="attr">x</span>: <span class="number">600</span>, <span class="attr">duration</span>: <span class="number">1</span> &#125;);</span><br><span class="line">tl.to(<span class="string">&quot;.orange&quot;</span>, &#123; <span class="attr">x</span>: <span class="number">600</span>, <span class="attr">duration</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/1bab035b89eb2ef011aed574f7937065fba17e14.gif@942w_447h_progressive.webp" alt="img"></p><h3 id="5-Threejs场景种应用"><a href="#5-Threejs场景种应用" class="headerlink" title="5 Threejs场景种应用"></a>5 Threejs场景种应用</h3><p>设置立方体旋转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gsap.to(</span><br><span class="line">  cube.rotation,</span><br><span class="line">  &#123;</span><br><span class="line">    x: <span class="number">2</span> * <span class="built_in">Math</span>.PI,</span><br><span class="line">    duration: <span class="number">5</span>,</span><br><span class="line">    ease: <span class="string">&quot;power1.inOut&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>设置立方体来回往返运动</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置动画</span></span><br><span class="line"><span class="keyword">var</span> animate1 = gsap.to(cube.position, &#123;</span><br><span class="line">  x: <span class="number">5</span>,</span><br><span class="line">  duration: <span class="number">5</span>,</span><br><span class="line">  ease: <span class="string">&quot;power1.inOut&quot;</span>,</span><br><span class="line">  <span class="comment">//   设置重复的次数，无限次循环-1</span></span><br><span class="line">  repeat: -<span class="number">1</span>,</span><br><span class="line">  <span class="comment">//   往返运动</span></span><br><span class="line">  yoyo: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">//   delay，延迟2秒运动</span></span><br><span class="line">  delay: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// 当动画完成时，执行回调函数</span></span><br><span class="line">  onComplete: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;动画完成&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//当动画开始时，执行回调函数</span></span><br><span class="line">  onStart: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;动画开始&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>让双击画面，控制立方体动画暂停和恢复动画，前面创建的animate1这个动画实例，有isActive方法，可以用来获取当前动画是暂停还是播放状态，播放状态时isActive方法返回为true，暂停时为false，根据这个状态来调用pause方法来暂停动画和恢复动画。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;dblclick&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//   console.log(animate1);</span></span><br><span class="line">  <span class="keyword">if</span> (animate1.isActive()) &#123;</span><br><span class="line">    <span class="comment">//   暂停</span></span><br><span class="line">    animate1.pause();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//   恢复</span></span><br><span class="line">    animate1.resume();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="6-综合上述代码"><a href="#6-综合上述代码" class="headerlink" title="6 综合上述代码"></a>6 综合上述代码</h3><p><strong>在前面创建的项目中的main.js文件写入代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"><span class="comment">// 导入轨道控制器</span></span><br><span class="line"><span class="keyword">import</span> &#123; OrbitControls &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/controls/OrbitControls&quot;</span>;</span><br><span class="line"><span class="comment">// 导入动画库</span></span><br><span class="line"><span class="keyword">import</span> gsap <span class="keyword">from</span> <span class="string">&quot;gsap&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(THREE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标：掌握gsap设置各种动画效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改物体的位置</span></span><br><span class="line"><span class="comment">// cube.position.set(5, 0, 0);</span></span><br><span class="line"><span class="comment">// cube.position.x = 3;</span></span><br><span class="line"><span class="comment">// 缩放</span></span><br><span class="line"><span class="comment">// cube.scale.set(3, 2, 1);</span></span><br><span class="line"><span class="comment">// cube.scale.x = 5;</span></span><br><span class="line"><span class="comment">// 旋转</span></span><br><span class="line">cube.rotation.set(<span class="built_in">Math</span>.PI / <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;XZY&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line"><span class="comment">// renderer.render(scene, camera);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建轨道控制器</span></span><br><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> OrbitControls(camera, renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加坐标轴辅助器</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">5</span>);</span><br><span class="line">scene.add(axesHelper);</span><br><span class="line"><span class="comment">// 设置时钟</span></span><br><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置动画</span></span><br><span class="line"><span class="keyword">var</span> animate1 = gsap.to(cube.position, &#123;</span><br><span class="line">  x: <span class="number">5</span>,</span><br><span class="line">  duration: <span class="number">5</span>,</span><br><span class="line">  ease: <span class="string">&quot;power1.inOut&quot;</span>,</span><br><span class="line">  <span class="comment">//   设置重复的次数，无限次循环-1</span></span><br><span class="line">  repeat: -<span class="number">1</span>,</span><br><span class="line">  <span class="comment">//   往返运动</span></span><br><span class="line">  yoyo: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">//   delay，延迟2秒运动</span></span><br><span class="line">  delay: <span class="number">2</span>,</span><br><span class="line">  onComplete: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;动画完成&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  onStart: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;动画开始&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">gsap.to(cube.rotation, &#123; <span class="attr">x</span>: <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="attr">duration</span>: <span class="number">5</span>, <span class="attr">ease</span>: <span class="string">&quot;power1.inOut&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;dblclick&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//   console.log(animate1);</span></span><br><span class="line">  <span class="keyword">if</span> (animate1.isActive()) &#123;</span><br><span class="line">    <span class="comment">//   暂停</span></span><br><span class="line">    animate1.pause();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//   恢复</span></span><br><span class="line">    animate1.resume();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h2 id="十一、画布自适应屏幕大小与全屏"><a href="#十一、画布自适应屏幕大小与全屏" class="headerlink" title="十一、画布自适应屏幕大小与全屏"></a>十一、画布自适应屏幕大小与全屏</h2><p><img src="https://i0.hdslb.com/bfs/article/983a66c2cfbc4f101ae88c9f6691ff19ec666de9.gif@827w_480h_progressive.webp" alt="img"></p><h3 id="1-1-自适应屏幕大小"><a href="#1-1-自适应屏幕大小" class="headerlink" title="1.1 自适应屏幕大小"></a>1.1 自适应屏幕大小</h3><p>你会发现，我们前面写好的代码，在页面尺寸发生改变的时候，并不能自适应的改变尺寸，而出现空白或者滚动条突出的情况。所以监听屏幕大小的改变，来重新设置相机的宽高比例和渲染器的尺寸大小，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听画面变化，更新渲染画面</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//   console.log(&quot;画面变化了&quot;);</span></span><br><span class="line">  <span class="comment">// 更新摄像头</span></span><br><span class="line">  camera.aspect = <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight;</span><br><span class="line">  <span class="comment">//   更新摄像机的投影矩阵</span></span><br><span class="line">  camera.updateProjectionMatrix();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//   更新渲染器</span></span><br><span class="line">  renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line">  <span class="comment">//   设置渲染器的像素比</span></span><br><span class="line">  renderer.setPixelRatio(<span class="built_in">window</span>.devicePixelRatio);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>aspect属性是设置摄像机视锥体的长宽比，通常是使用画布的宽/画布的高。camera.updateProjectionMatrix()用于更新摄像机投影矩阵，相机任何参数被改变以后必须被调用</p><h3 id="1-2-控制场景全屏"><a href="#1-2-控制场景全屏" class="headerlink" title="1.2 控制场景全屏"></a>1.2 控制场景全屏</h3><p>经常我们需要全屏的展示三维场景。例如，我们想要双击，实现全屏效果，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;dblclick&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fullScreenElement = <span class="built_in">document</span>.fullscreenElement;</span><br><span class="line">  <span class="keyword">if</span> (!fullScreenElement) &#123;</span><br><span class="line">    <span class="comment">//   双击控制屏幕进入全屏，退出全屏</span></span><br><span class="line">    <span class="comment">// 让画布对象全屏</span></span><br><span class="line">    renderer.domElement.requestFullscreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//   退出全屏，使用document对象</span></span><br><span class="line">    <span class="built_in">document</span>.exitFullscreen();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>fullscreenElement</code>只读属性返回当前在此文档中以全屏模式显示的元素。</p><p>如果文档当前未使用全屏模式，则返回值为null。</p><p>使用<code>element.requestFullscreen()</code>方法以全屏模式查看元素，<code>exitFullscreen</code>方法退出全屏。 </p><h2 id="十二、应用图形用户界面更改变量"><a href="#十二、应用图形用户界面更改变量" class="headerlink" title="十二、应用图形用户界面更改变量"></a>十二、应用图形用户界面更改变量</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用图形用户界面更改变量</span></span><br><span class="line"><span class="keyword">const</span> gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改物体移动位置</span></span><br><span class="line">gui.add(cube.position, <span class="string">&quot;x&quot;</span>)</span><br><span class="line">    .min(<span class="number">0</span>) <span class="comment">// 最小值</span></span><br><span class="line">    .max(<span class="number">5</span>) <span class="comment">// 最大值</span></span><br><span class="line">    .step(<span class="number">0.01</span>) <span class="comment">// 每次移动的变量值</span></span><br><span class="line">    .name(<span class="string">&quot;移动x轴&quot;</span>) <span class="comment">// 变量名称</span></span><br><span class="line">    .onChange(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;值被修改：&quot;</span>, value)</span><br><span class="line">    &#125;).onFinishChange(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;完全停下来的值：&quot;</span>, value)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> params = &#123;</span><br><span class="line">    color: <span class="string">&quot;#ffff00&quot;</span>,</span><br><span class="line">    <span class="comment">// 控制物体运动</span></span><br><span class="line">    fn: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        gsap.to(cube.position, &#123; <span class="attr">x</span>: <span class="number">5</span>, <span class="attr">duration</span>: <span class="number">3</span>, <span class="attr">yoyo</span>: <span class="literal">true</span>, <span class="attr">repeat</span>: - <span class="number">1</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改物体颜色</span></span><br><span class="line">gui.addColor(params, <span class="string">&quot;color&quot;</span>).onChange(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;颜色被修改了&quot;</span>, value)</span><br><span class="line">    cube.material.color.set(value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 设置物体是否显示</span></span><br><span class="line">gui.add(cube, <span class="string">&quot;visible&quot;</span>).name(<span class="string">&quot;是否显示&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置按钮点击触发某个事件</span></span><br><span class="line">gui.add(params,<span class="string">&quot;fn&quot;</span>).name(<span class="string">&quot;物体运动&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件夹,</span></span><br><span class="line"><span class="keyword">const</span> folder = gui.addFolder(<span class="string">&quot;设置物体&quot;</span>)</span><br><span class="line">folder.add(cube.material,<span class="string">&quot;wireframe&quot;</span>)</span><br><span class="line">folder.add(params,<span class="string">&quot;fn&quot;</span>).name(<span class="string">&quot;物体运动&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Three.js" scheme="http://aiolimp.com/categories/Three-js/"/>
    
    
    <category term="Three.js" scheme="http://aiolimp.com/tags/Three-js/"/>
    
  </entry>
  
  <entry>
    <title>Less</title>
    <link href="http://aiolimp.com/2022/10/21/Less/"/>
    <id>http://aiolimp.com/2022/10/21/Less/</id>
    <published>2022-10-21T08:57:49.000Z</published>
    <updated>2023-03-05T14:20:02.440Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">使用方式</a></li><li><a href="#api">API</a><ul><li><a href="#%E5%8F%98%E9%87%8F">变量</a></li><li><a href="#%E5%B5%8C%E5%A5%97">嵌套</a></li><li><a href="#%E6%B7%B7%E5%90%88%E6%96%B9%E6%B3%95">混合方法</a></li><li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li><li><a href="#%E5%AF%BC%E5%85%A5">导入</a></li><li><a href="#%E5%87%BD%E6%95%B0">函数</a></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a></li></ul></li></ul><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>使用 Less 有两种方式</p><ol><li>在页面中 引入 Less.js</li></ol><ul><li><p>可在<a href="https://link.juejin.cn/?target=http://lesscss.org/">官网</a>下载</p></li><li><p>或使用CDN</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/less.js/2.7.2/less.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，link 标签一定要在 Less.js 之前引入，并且 link 标签的 rel 属性要设置为stylesheet/less。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet/less&quot; href=&quot;style.less&quot;&gt;</span><br><span class="line">&lt;script src=&quot;less.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>在命令行 使用npm安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g less</span><br></pre></td></tr></table></figure><p>具体使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lessc styles.less &gt; styles.css</span><br></pre></td></tr></table></figure></li></ol><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>我们常常在 CSS 中 看到同一个值重复多次，这样难易于代码维护。 理想状态，应是下面这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const bgColor=&quot;skyblue&quot;;</span><br><span class="line">$(&quot;.post-content&quot;).css(&quot;background-color&quot;,bgColor);</span><br><span class="line">$(&quot;#wrap&quot;).css(&quot;background-color&quot;,bgColor);</span><br><span class="line">$(&quot;.arctive&quot;).css(&quot;background-color&quot;,bgColor);</span><br></pre></td></tr></table></figure><p>只要我们修改 <code>bgColor</code>这一个变量， 整个页面的背景颜色都会随之改变。</p><p>而 Less 中的变量十分强大，可化万物，值得一提的是，其变量是常量 ，所以只能定义一次，不能重复使用。</p><ol><li><p><strong>值变量</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@color: #999;</span><br><span class="line">@bgColor: skyblue;//不要添加引号</span><br><span class="line">@width: 50%;</span><br><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: @color;</span><br><span class="line">  <span class="attribute">background</span>: @bgColor;</span><br><span class="line">  <span class="attribute">width</span>: @width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">background</span>: skyblue;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以 <code>@</code> 开头 定义变量，并且使用时 直接 键入 <code>@</code>名称。</p><p>在平时工作中，我们就可以把 常用的变量 封装到一个文件中，这样利于代码组织维护。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@lightPrimaryColor: #c5cae9;</span><br><span class="line">@textPrimaryColor: #fff;</span><br><span class="line">@accentColor: rgb(99, 137, 185);</span><br><span class="line">@primaryTextColor: #646464;</span><br><span class="line">@secondaryTextColor: #000;</span><br><span class="line">@dividerColor: #b6b6b6;</span><br><span class="line">@borderColor: #dadada;</span><br></pre></td></tr></table></figure></li><li><p><strong>选择器变量</strong></p><p>让 选择器 变成 动态</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@mySelector: #wrap;</span><br><span class="line">@Wrap: wrap;</span><br><span class="line">@&#123;mySelector&#125;&#123; //变量名 必须使用大括号包裹</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line">.@&#123;Wrap&#125;&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line">#@&#123;Wrap&#125;&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#666</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>属性变量</strong></p><p>可减少代码书写量</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@borderStyle: border-style;</span><br><span class="line">@Soild:solid;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  @&#123;borderStyle&#125;: @Soild;//变量名 必须使用大括号包裹</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">border-style</span>:solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>url 变量</strong></p><p>项目结构改变时，修改其变量即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@images: &quot;../img&quot;;//需要加引号</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;@&#123;images&#125;/dog.png&quot;</span>);//变量名 必须使用大括号包裹</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;../img/dog.png&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>声明变量</strong></p><p>有点类似于 下面的 混合方法</p><ul><li>结构: @name: { 属性: 值 ;};</li><li>使用：@name();</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@background: &#123;background:red;&#125;;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="keyword">@background</span>();</span><br><span class="line">&#125;</span><br><span class="line">@Rules:&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">1px</span> red;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="selector-id">#con</span>&#123;</span><br><span class="line">  <span class="keyword">@Rules</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#con</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> red;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>变量运算</strong></p><p>不得不提的是，Less 的变量运算完全超出我的期望，十分强大。</p><ul><li>加减法时 以第一个数据的单位为基准</li><li>乘除法时 注意单位一定要统一</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@width:300px;</span><br><span class="line">@color:#222;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:@width-<span class="number">20</span>;</span><br><span class="line">  <span class="attribute">height</span>:@width-<span class="number">20</span>*<span class="number">5</span>;</span><br><span class="line">  <span class="attribute">margin</span>:(@width-<span class="number">20</span>)*<span class="number">5</span>;</span><br><span class="line">  <span class="attribute">color</span>:@color*<span class="number">2</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:@color + <span class="number">#111</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">280px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">1400px</span>;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#444</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>变量作用域</strong></p><p>一句话理解就是：<strong>就近原则</strong>，不要跟我提闭包。</p><p><em>借助官网的Demo</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@var: @a;</span><br><span class="line">@a: 100%;</span><br><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: @var;</span><br><span class="line">  @a: 9%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">9%</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>用变量去定义变量</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@fnord:  &quot;I am fnord.&quot;;</span><br><span class="line">@var:    &quot;fnord&quot;;</span><br><span class="line"><span class="selector-id">#wrap</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: @@var; //将<span class="keyword">@var</span>替换为其值 <span class="attribute">content</span>:@fnord;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;I am fnord.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ol><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><ol><li><p><strong>&amp; 的妙用</strong></p><p>&amp; ：代表的上一层选择器的名字，此例便是<code>header</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-id">#header</span>&#123;</span><br><span class="line">  &amp;:after&#123;</span><br><span class="line">    content:<span class="string">&quot;Less is more!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.title</span>&#123;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;_content&#123;//理解方式：直接把 &amp; 替换成 <span class="selector-id">#header</span></span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">20px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#header</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&quot;Less is more!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header</span> <span class="selector-class">.title</span>&#123; //嵌套了</span><br><span class="line">  <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header_content</span>&#123;//没有嵌套！</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>媒体查询</strong></p><p>在以往的工作中，我们使用 媒体查询，都要把一个元素 分开写</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">768px</span>)&#123;</span><br><span class="line">  <span class="selector-id">#wrap</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>Less 提供了一个十分便捷的方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    //something...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@media</span> screen&#123;</span><br><span class="line">        <span class="keyword">@media</span> (<span class="attribute">max-width</span>:<span class="number">768px</span>)&#123;</span><br><span class="line">          <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@media</span> tv &#123;</span><br><span class="line">      <span class="attribute">width</span>:<span class="number">2000px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">maxwidth</span>:<span class="number">768px</span>)&#123;</span><br><span class="line">  <span class="selector-id">#main</span>&#123;</span><br><span class="line">      <span class="attribute">width</span>:<span class="number">100px</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> tv&#123;</span><br><span class="line">  <span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">2000px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>唯一的缺点就是 每一个元素都会编译出自己 <code>@media</code> 声明，并不会合并。</p></li><li><p><strong>实战技巧</strong></p><p>可以借助 Less 在元素中，去定义自己的私有样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  // something..</span><br><span class="line">  &amp;<span class="selector-class">.show</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.show</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const main = document.getElementById(&quot;main&quot;);</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.classList</span><span class="selector-class">.add</span>(&quot;show&quot;);</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span><span class="selector-class">.show</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.show</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:none; //会被覆盖。</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ol><h3 id="混合方法"><a href="#混合方法" class="headerlink" title="混合方法"></a>混合方法</h3><ol><li><p><strong>无参数方法</strong></p><p>方法犹如 声明的集合，使用时 直接键入名称即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.card</span> &#123; // 等价于 <span class="selector-class">.card</span>()</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f6f6f6</span>;</span><br><span class="line">    -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">151</span>, <span class="number">151</span>, <span class="number">151</span>, .<span class="number">58</span>);</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">151</span>, <span class="number">151</span>, <span class="number">151</span>, .<span class="number">58</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="selector-class">.card</span>;//等价于<span class="selector-class">.card</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f6f6f6</span>;</span><br><span class="line">  -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">151</span>, <span class="number">151</span>, <span class="number">151</span>, .<span class="number">58</span>);</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">151</span>, <span class="number">151</span>, <span class="number">151</span>, .<span class="number">58</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>其中 <code>.card</code> 与 <code>.card()</code> 是等价的。 个人建议，为了避免 代码混淆，应写成 :</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span>()&#123;</span><br><span class="line">  //something...</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="selector-class">.card</span>();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>要点：</p><ul><li><code>.</code> 与 <code>#</code> 皆可作为 方法前缀。</li><li>方法后写不写 <code>()</code> 看个人习惯。</li></ul></li><li><p><strong>默认参数方法</strong></p><ul><li>Less 可以使用默认参数，如果 没有传参数，那么将使用默认参数。</li><li><code>@arguments</code> 犹如 JS 中的 <code>arguments</code> 指代的是 全部参数。</li><li>传的参数中 必须带着单位。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">.border(@a:10px,@b:50px,@c:30px,@color:#000)&#123;</span><br><span class="line">    <span class="attribute">border</span>:solid <span class="number">1px</span> @color;</span><br><span class="line">    <span class="attribute">box-shadow</span>: @arguments;//指代的是 全部参数</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="selector-class">.border</span>(<span class="number">0px</span>,<span class="number">5px</span>,<span class="number">30px</span>,red);//必须带着单位</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">    <span class="selector-class">.border</span>(<span class="number">0px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content</span>&#123;</span><br><span class="line">  <span class="selector-class">.border</span>;//等价于 <span class="selector-class">.border</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:solid <span class="number">1px</span> red;</span><br><span class="line">    <span class="attribute">box-shadow</span>:<span class="number">0px</span>,<span class="number">5px</span>,<span class="number">30px</span>,red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:solid <span class="number">1px</span> <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">50px</span> <span class="number">30px</span> <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:solid <span class="number">1px</span> <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">10px</span> <span class="number">50px</span> <span class="number">30px</span> <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>方法的匹配模式</strong></p><p>与 面向对象中的多态 很相似</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">.triangle(top,@width:20px,@color:#000)&#123;</span><br><span class="line">    <span class="attribute">border-color</span>:transparent  transparent @color transparent ;</span><br><span class="line">&#125;</span><br><span class="line">.triangle(right,@width:20px,@color:#000)&#123;</span><br><span class="line">    <span class="attribute">border-color</span>:transparent @color transparent  transparent ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.triangle(bottom,@width:20px,@color:#000)&#123;</span><br><span class="line">    <span class="attribute">border-color</span>:@color transparent  transparent  transparent ;</span><br><span class="line">&#125;</span><br><span class="line">.triangle(left,@width:20px,@color:#000)&#123;</span><br><span class="line">    <span class="attribute">border-color</span>:transparent  transparent  transparent @color;</span><br><span class="line">&#125;</span><br><span class="line">.triangle(@_,@width:20px,@color:#000)&#123;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-width</span>: @width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="selector-class">.triangle</span>(<span class="attribute">left</span>, <span class="number">50px</span>, <span class="selector-id">#999</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">border-color</span>:transparent  transparent  transparent <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>要点</p><ul><li>第一个参数 <code>left</code> 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。</li><li>如果匹配的参数 是变量，则将会匹配，如 <code>@_</code> 。</li></ul></li><li><p><strong>方法的命名空间</strong></p><p>让方法更加规范</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-id">#card</span>()&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#723232</span>;</span><br><span class="line">    .d(@w:300px)&#123;</span><br><span class="line">        <span class="attribute">width</span>: @w;</span><br><span class="line">        </span><br><span class="line">        #a(@h:300px)&#123;</span><br><span class="line">            <span class="attribute">height</span>: @h;//可以使用上一层传进来的方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">    <span class="selector-id">#card</span> &gt; <span class="selector-class">.d</span> &gt; <span class="selector-id">#a</span>(<span class="number">100px</span>); // 父元素不能加 括号</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="selector-id">#card</span> <span class="selector-class">.d</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#con</span>&#123;</span><br><span class="line">    //不得单独使用命名空间的方法</span><br><span class="line">    //<span class="selector-class">.d</span>() 如果前面没有引入命名空间 <span class="selector-id">#card</span> ，将会报错</span><br><span class="line">    </span><br><span class="line">    <span class="selector-id">#card</span>; // 等价于 <span class="selector-id">#card</span>();</span><br><span class="line">    <span class="selector-class">.d</span>(<span class="number">20px</span>); //必须先引入 <span class="selector-id">#card</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#con</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>要点</p><ul><li>在 CSS 中<code>&gt;</code> 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。</li><li>在引入命令空间时，如使用 <code>&gt;</code> 选择器，父元素不能加 括号。</li><li>不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。</li><li>子方法 可以使用上一层传进来的方法</li></ul></li><li><p><strong>方法的条件筛选</strong></p><p>Less 没有 if else，可是它有 <code>when</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-id">#card</span>&#123;</span><br><span class="line">    </span><br><span class="line">    // and 运算符 ，相当于 与运算 &amp;&amp;，必须条件全部符合才会执行</span><br><span class="line">    <span class="selector-class">.border</span>(<span class="keyword">@width</span>,<span class="keyword">@color</span>,<span class="keyword">@style</span>) when (@<span class="attribute">width</span>&gt;<span class="number">100px</span>) <span class="keyword">and</span>(@<span class="attribute">color</span>=#<span class="number">999</span>)&#123;</span><br><span class="line">        <span class="attribute">border</span>:@style @color @width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // not 运算符，相当于 非运算 !，条件为 不符合才会执行</span><br><span class="line">    <span class="selector-class">.background</span>(<span class="keyword">@color</span>) when <span class="keyword">not</span> (@<span class="attribute">color</span>&gt;=#<span class="number">222</span>)&#123;</span><br><span class="line">        <span class="attribute">background</span>:@color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行</span><br><span class="line">    .font(@size:20px) when (@size&gt;50px) , (@size&lt;100px)&#123;</span><br><span class="line">        <span class="attribute">font-size</span>: @size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="selector-id">#card</span>&gt;<span class="selector-class">.border</span>(<span class="number">200px</span>,<span class="selector-id">#999</span>,solid);</span><br><span class="line">    <span class="selector-id">#card</span> <span class="selector-class">.background</span>(<span class="selector-id">#111</span>);</span><br><span class="line">    <span class="selector-id">#card</span> &gt; <span class="selector-class">.font</span>(<span class="number">40px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>:solid <span class="number">#999</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>:<span class="number">#111</span>;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>要点</p><ul><li>比较运算有： &gt; &gt;= = =&lt; &lt;。</li><li>= 代表的是等于</li><li>除去关键字 true 以外的值都被视为 false：</li></ul></li><li><p><strong>数量不定的参数</strong></p><p>如果你希望你的方法接受数量不定的参数，你可以使用… ，犹如 ES6 的扩展运算符。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.boxShadow</span>(...)&#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: @arguments;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.textShadow</span>(<span class="keyword">@a</span>,...)&#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: @arguments;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="selector-class">.boxShadow</span>(<span class="number">1px</span>,<span class="number">4px</span>,<span class="number">30px</span>,red);</span><br><span class="line">    <span class="selector-class">.textShadow</span>(<span class="number">1px</span>,<span class="number">4px</span>,<span class="number">30px</span>,red);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">4px</span> <span class="number">30px</span> red;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">1px</span> <span class="number">4px</span> <span class="number">30px</span> red;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>方法使用important！</strong></p><p>使用方法 非常简单，在方法名后 加上关键字即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.border</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">1px</span> red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="selector-class">.border</span>() !important;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">1px</span> red <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>循环方法</strong></p><p>Less 并没有提供 for 循环功能，但这也难不倒 聪明的程序员，使用递归去实现。 下面是官网中的一个 Demo，模拟了生成栅格系统。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.generate-columns</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.generate-columns</span>(<span class="keyword">@n</span>, @<span class="attribute">i</span>: <span class="number">1</span>) when (@i =&lt; @n) &#123;</span><br><span class="line">  <span class="selector-class">.column-</span>@&#123;<span class="selector-tag">i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">width</span>: (@i * <span class="number">100%</span> / @n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.generate-columns</span>(<span class="keyword">@n</span>, (@i + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-class">.column-1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column-2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column-3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">75%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column-4</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>属性拼接方法</strong></p><p><code>+_</code> 代表的是 空格；<code>+</code> 代表的是 逗号。</p><ul><li>逗号</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.boxShadow</span>() &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>+: inset <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">#555</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="selector-class">.boxShadow</span>();</span><br><span class="line">  <span class="attribute">box-shadow</span>+: <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">#555</span>, <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> black;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><ul><li>空格</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.Animation</span>() &#123;</span><br><span class="line">  <span class="attribute">transform</span>+_: <span class="built_in">scale</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="selector-class">.Animation</span>();</span><br><span class="line">  <span class="attribute">transform</span>+_: <span class="built_in">rotate</span>(<span class="number">15deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>) <span class="built_in">rotate</span>(<span class="number">15deg</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>实战技巧</strong></p><p>下面是官网中的一个非常赞的 Demo</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.average</span>(<span class="keyword">@x</span>, @y) &#123;</span><br><span class="line">  @average: ((@x + @y) / 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.average</span>(<span class="number">16px</span>, <span class="number">50px</span>); // 调用 方法</span><br><span class="line">  <span class="attribute">padding</span>: @average;    // 使用返回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">33px</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ol><p>可以说 Less 是一门优雅编程语言。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。</p><ol><li><p><strong>extend 关键字的使用</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.animation</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span> ease-out;</span><br><span class="line">    <span class="selector-class">.hide</span>&#123;</span><br><span class="line">      <span class="attribute">transform</span>:<span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    &amp;:<span class="built_in">extend</span>(.animation);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#con</span>&#123;</span><br><span class="line">    &amp;:<span class="built_in">extend</span>(.animation .hide);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-class">.animation</span>,<span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">3s</span> ease-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.animation</span> <span class="selector-class">.hide</span> , <span class="selector-id">#con</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>all 全局搜索替换</strong></p><p>使用选择器匹配到的 全部声明。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  &amp;:after &#123;</span><br><span class="line">    content:<span class="string">&quot;Less is good!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>:<span class="built_in">extend</span>(#main all) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>,<span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>:after, #wrap:after &#123;</span><br><span class="line">    content: <span class="string">&quot;Less is good!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>减少代码的重复性</strong></p><p>从表面 看来，extend 与 方法 最大的差别，就是 extend 是同个选择器共用同一个声明，而 方法 是使用自己的声明，这无疑 增加了代码的重复性。</p><p>方法示例 与上面的 extend 进行对比：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.Method</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &amp;:after &#123;</span><br><span class="line">      content:<span class="string">&quot;Less is good!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="selector-class">.Method</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="selector-class">.Method</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &amp;:after&#123;</span><br><span class="line">    content:<span class="string">&quot;Less is good!&quot;</span>;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &amp;:after&#123;</span><br><span class="line">    content:<span class="string">&quot;Less is good!&quot;</span>;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>要点</strong></p><p><em>翻译官网</em></p><ul><li>选择器和扩展之间 是允许有空格的：pre:hover :extend(div pre).</li><li>可以有多个扩展: pre:hover:extend(div pre):extend(.bucket tr) - 注意这与 pre:hover:extend(div pre, .bucket tr)一样。</li><li>这是不可以的，扩展必须在最后 : pre:hover:extend(div pre).nth-child(odd)。</li><li>如果一个规则集包含多个选择器，所有选择器都可以使用extend关键字。</li></ul><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><ol><li>导入 less 文件 可省略后缀</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &quot;<span class="selector-tag">main</span>&quot;; </span><br><span class="line">//等价于</span><br><span class="line">import &quot;<span class="selector-tag">main</span><span class="selector-class">.less</span>&quot;;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><ol><li><code>@import</code> 的位置可随意放置</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;style&quot;</span>;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>reference</strong></p><p>Less 中 最强大的特性 使用 引入的 Less 文件，但不会 编译它。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="keyword">@import</span> (reference) <span class="string">&quot;bootstrap.less&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="selector-id">#wrap</span>:<span class="built_in">extend</span>(.navbar all)&#123;&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>翻译官网：</p><blockquote><p>使用@import (reference)导入外部文件，但不会添加 把导入的文件 编译到最终输出中，只引用。</p></blockquote></li><li><p><strong>once</strong></p><blockquote><p>@import语句的默认行为。这表明相同的文件只会被导入一次，而随后的导入文件的重复代码都不会解析。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> (once) <span class="string">&quot;foo.less&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> (once) <span class="string">&quot;foo.less&quot;</span>; // this statement will be ignored</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>multiple</strong></p><blockquote><p>使用@import (multiple)允许导入多个同名文件。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"></span><br><span class="line">// file: foo.less</span><br><span class="line">.a &#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line">// file: main.less</span><br><span class="line">@import (multiple) <span class="string">&quot;foo.less&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> (multiple) <span class="string">&quot;foo.less&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol><li><p><strong>判断类型</strong></p><ul><li>isnumber</li></ul><blockquote><p>判断给定的值 是否 是一个数字。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">isnumber(<span class="selector-id">#ff0</span>);     // false</span><br><span class="line">isnumber(blue);     // false</span><br><span class="line">isnumber(&quot;string&quot;); // false</span><br><span class="line">isnumber(<span class="number">1234</span>);     // true</span><br><span class="line">isnumber(<span class="number">56px</span>);     // true</span><br><span class="line">isnumber(<span class="number">7.8%</span>);     // true</span><br><span class="line">isnumber(keyword);  // false</span><br><span class="line">isnumber(url(...)); // false</span><br><span class="line">  </span><br></pre></td></tr></table></figure><ul><li>iscolor</li></ul><blockquote><p>判断给定的值 是否 是一个颜色。</p></blockquote><ul><li>isurl</li></ul><blockquote><p>判断给定的值 是否 是一个 url 。</p></blockquote></li><li><p><strong>颜色操作</strong></p><ul><li>saturate</li></ul><blockquote><p>增加一定数值的颜色饱和度。</p></blockquote><ul><li>lighten</li></ul><blockquote><p>增加一定数值的颜色亮度。</p></blockquote><ul><li>darken</li></ul><blockquote><p>降低一定数值的颜色亮度。</p></blockquote><ul><li>fade</li></ul><blockquote><p>给颜色设定一定数值的透明度。</p></blockquote><ul><li>mix</li></ul><blockquote><p>根据比例混合两种颜色。</p></blockquote></li><li><p><strong>数学函数</strong></p><ul><li>ceil</li></ul><blockquote><p>向上取整。</p></blockquote><ul><li>floor</li></ul><blockquote><p>向下取整。</p></blockquote><ul><li>percentage</li></ul><blockquote><p>将浮点数转换为百分比字符串。</p></blockquote><ul><li>round</li></ul><blockquote><p>四舍五入。</p></blockquote><ul><li>sqrt</li></ul><blockquote><p>计算一个数的平方根。</p></blockquote><ul><li>abs</li></ul><blockquote><p>计算数字的绝对值，原样保持单位。</p></blockquote><ul><li>pow</li></ul><blockquote><p>计算一个数的乘方。</p></blockquote></li></ol><p>由于 文章 篇幅有限，所以 只能介绍一些 使用效率高的函数。</p><p>如果你想了解更多，可以去官网的<a href="https://link.juejin.cn/?target=http://lesscss.cn/functions/">函数链接</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><p><strong>注释</strong></p><ul><li>/* */ CSS原生注释，会被编译在 CSS 文件中。</li><li>/  / Less提供的一种注释，不会被编译在 CSS 文件中。</li></ul></li><li><p><strong>避免编译</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:~<span class="string">&#x27;calc(300px-30px)&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="built_in">calc</span>(<span class="number">300px</span>-<span class="number">30px</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>结构： <code>~&#39; 值 &#39;</code></p></li><li><p><strong>变量拼串</strong></p><p>在平时工作中，这种需求 太常见了。 在下面例子中， 实现了不同的 transtion-delay、animation、@keyframes</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.judge</span>(<span class="keyword">@i</span>) when(@i=<span class="number">1</span>)&#123;</span><br><span class="line">  @size:15px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.judge</span>(<span class="keyword">@i</span>) when(@i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">  @size:16px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.loopAnimation</span>(<span class="keyword">@i</span>) when (@i&lt;<span class="number">16</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="selector-class">.circle</span><span class="selector-pseudo">:nth-child</span>(@&#123;<span class="selector-tag">i</span>&#125;)&#123;</span><br><span class="line">      <span class="selector-class">.judeg</span>(<span class="keyword">@i</span>);</span><br><span class="line">      <span class="attribute">border-radius</span>:@size @size <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">animation</span>: ~<span class="string">&quot;circle-@&#123;i&#125;&quot;</span> @duration infinite @ease;</span><br><span class="line">      <span class="attribute">transition-delay</span>:~<span class="string">&quot;@&#123;i&#125;ms&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@keyframes</span> ~<span class="string">&quot;circle-@&#123;i&#125;&quot;</span> &#123;</span><br><span class="line">      // do something...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.loopAnimation</span>(<span class="keyword">@i</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>结构： <code>~&quot;字符@&#123;变量&#125;字符&quot;</code>;</p></li><li><p><strong>使用 JS</strong></p><p>因为 Less 是由 JS 编写，所以 Less 有一得天独厚的特性：代码中使用 Javascript 。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@content:`&quot;aaa&quot;.toUpperCase()`;</span><br><span class="line"><span class="selector-id">#randomColor</span>&#123;</span><br><span class="line">  @randomColor: ~&quot;rgb(`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`)&quot;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: ~<span class="string">&quot;`Math.round(Math.random() * 100)`px&quot;</span>;</span><br><span class="line">  &amp;:after&#123;</span><br><span class="line">      content:@content;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">height</span>: ~<span class="string">&quot;`window.innerHeight`px&quot;</span>;</span><br><span class="line">  alert:~<span class="string">&quot;`alert(1)`&quot;</span>;</span><br><span class="line">  <span class="selector-id">#randomColor</span>();</span><br><span class="line">  <span class="attribute">background-color</span>: @randomColor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"></span><br><span class="line">// 弹出 <span class="number">1</span></span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: 随机值（<span class="number">0</span>~<span class="number">100</span>）px;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">743px</span>;//由电脑而异</span><br><span class="line">  <span class="attribute">background</span>: 随机颜色;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&quot;AAA&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="CSS" scheme="http://aiolimp.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://aiolimp.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://aiolimp.com/2022/08/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://aiolimp.com/2022/08/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-12T08:57:49.000Z</published>
    <updated>2025-04-12T11:53:34.632Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="单例模式的实现思路"><a href="#单例模式的实现思路" class="headerlink" title="单例模式的实现思路"></a>单例模式的实现思路</h2><p>现在我们先不考虑单例模式的应用场景，单看它的实现，思考这样一个问题：如何才能保证一个类仅有一个实例？<br>一般情况下，当我们创建了一个类（本质是构造函数）后，可以通过new关键字调用构造函数进而生成任意多的实例对象。像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleDog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我是一个单例对象&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> SingleDog()</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> SingleDog()</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">s1 === s2</span><br></pre></td></tr></table></figure><p>楼上我们先 new 了一个 s1，又 new 了一个 s2，很明显 s1 和 s2 之间没有任何瓜葛，两者是相互独立的对象，各占一块内存空间。而单例模式想要做到的是，<strong>不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例</strong>。</p><p>要做到这一点，就需要构造函数<strong>具备判断自己是否已经创建过一个实例</strong>的能力。我们现在把这段判断逻辑写成一个静态方法(其实也可以直接写入构造函数的函数体里）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleDog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我是一个单例对象&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经new过1个实例</span></span><br><span class="line">        <span class="keyword">if</span> (!SingleDog.instance) &#123;</span><br><span class="line">            <span class="comment">// 若这个唯一的实例不存在，那么先创建它</span></span><br><span class="line">            SingleDog.instance = <span class="keyword">new</span> SingleDog()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果这个唯一的实例已经存在，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> SingleDog.instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = SingleDog.getInstance()</span><br><span class="line"><span class="keyword">const</span> s2 = SingleDog.getInstance()</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">s1 === s2</span><br></pre></td></tr></table></figure><p>除了楼上这种实现方式之外，getInstance的逻辑还可以用<strong>闭包</strong>来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SingleDog.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义自由变量instance，模拟私有变量</span></span><br><span class="line">    <span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 判断自由变量是否为null</span></span><br><span class="line">        <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">            <span class="comment">// 如果为null则new出唯一实例</span></span><br><span class="line">            instance = <span class="keyword">new</span> SingleDog()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>可以看出，在getInstance方法的判断和拦截下，我们不管调用多少次，SingleDog都只会给我们返回一个实例，s1和s2现在都指向这个唯一的实例。</p><h2 id="生产实践：Vuex中的单例模式"><a href="#生产实践：Vuex中的单例模式" class="headerlink" title="生产实践：Vuex中的单例模式"></a>生产实践：Vuex中的单例模式</h2><p>近年来，基于 Flux 架构的状态管理工具层出不穷，其中应用最广泛的要数 Redux 和 Vuex。无论是 Redux 和 Vuex，它们都实现了一个全局的 Store 用于存储应用的所有状态。这个 Store 的实现，正是单例模式的典型应用。这里我们以 Vuex 为例，研究一下单例模式是怎么发光发热的：</p><h3 id="理解-Vuex-中的-Store"><a href="#理解-Vuex-中的-Store" class="headerlink" title="理解 Vuex 中的 Store"></a>理解 Vuex 中的 Store</h3><blockquote><p>Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 ——Vuex官方文档</p></blockquote><p>在Vue中，组件之间是独立的，组件间通信最常用的办法是 props（限于父组件和子组件之间的通信），稍微复杂一点的（比如兄弟组件间的通信）我们通过自己实现简单的事件监听函数也能解决掉。</p><p>但当组件非常多、组件间关系复杂、且嵌套层级很深的时候，这种原始的通信方式会使我们的逻辑变得复杂难以维护。这时最好的做法是将共享的数据抽出来、放在全局，供组件们按照一定的的规则去存取数据，保证状态以一种可预测的方式发生变化。于是便有了 Vuex，这个用来存放共享数据的唯一数据源，就是 Store。</p><p>关于 Vuex 的细节，大家可以参考<a href="https://link.juejin.cn/?target=https://vuex.vuejs.org/zh/">Vuex的官方文档</a>，此处提及 Vuex，除了为了拓宽大家的知识面，更重要的是为了说明单例模式在生产实践中广泛的应用和不可或缺的地位。如果对 Vuex 没有兴趣，那么大家只需关注“一个 Vue 实例只能对应一个 Store”这一点即可。</p><h3 id="Vuex如何确保Store的唯一性"><a href="#Vuex如何确保Store的唯一性" class="headerlink" title="Vuex如何确保Store的唯一性"></a>Vuex如何确保Store的唯一性</h3><p>我们先来看看如何在项目中引入 Vuex：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装vuex插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将store注入到Vue实例中</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过调用<code>Vue.use()</code>方法，我们安装了 Vuex 插件。Vuex 插件是一个对象，它在内部实现了一个 install 方法，这个方法会在插件安装时被调用，从而把 Store 注入到Vue实例里去。也就是说每 install 一次，都会尝试给 Vue 实例注入一个 Store。</p><p>在 install 方法里，有一段逻辑和我们楼上的 <code>getInstance</code> 非常相似的逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue <span class="comment">// 这个Vue的作用和楼上的instance作用一样</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断传入的Vue实例对象是否已经被install过Vuex插件（是否有了唯一的state）</span></span><br><span class="line">  <span class="keyword">if</span> (Vue &amp;&amp; _Vue === Vue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(</span><br><span class="line">        <span class="string">&#x27;[vuex] already installed. Vue.use(Vuex) should be called only once.&#x27;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 若没有，则为这个Vue实例对象install一个唯一的Vuex</span></span><br><span class="line">  Vue = _Vue</span><br><span class="line">  <span class="comment">// 将Vuex的初始化逻辑写进Vue的钩子函数里</span></span><br><span class="line">  applyMixin(Vue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>楼上便是 Vuex 源码中单例模式的实现办法了，套路可以说和我们的<code>getInstance</code>如出一辙。通过这种方式，可以保证一个 Vue 实例（即一个 Vue 应用）只会被 install 一次 Vuex 插件，所以每个 Vue 实例只会拥有一个全局的 Store。</p><h2 id="实现一个-Storage"><a href="#实现一个-Storage" class="headerlink" title="实现一个 Storage"></a>实现一个 Storage</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><blockquote><p>实现Storage，使得该对象为单例，基于 localStorage 进行封装。实现方法 setItem(key,value) 和 getItem(key)。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>拿到单例模式相关的面试题，大家首先要做的是回忆我们上个小节的“基本思路”部分——至少要记起来<code>getInstance</code>方法和<code>instance</code>这个变量是干啥的。</p><p>具体实现上，把判断逻辑写入静态方法或者构造函数里都没关系，最好能把闭包的版本也写出来，多多益善。</p><p>总之有了上节的基础，这个题简直是默写！</p><blockquote><p>实现：静态方法版</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Storage</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经new过1个实例</span></span><br><span class="line">        <span class="keyword">if</span> (!Storage.instance) &#123;</span><br><span class="line">            <span class="comment">// 若这个唯一的实例不存在，那么先创建它</span></span><br><span class="line">            Storage.instance = <span class="keyword">new</span> Storage()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果这个唯一的实例已经存在，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> Storage.instance</span><br><span class="line">    &#125;</span><br><span class="line">    getItem (key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">localStorage</span>.getItem(key)</span><br><span class="line">    &#125;</span><br><span class="line">    setItem (key, value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">localStorage</span>.setItem(key, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage1 = Storage.getInstance()</span><br><span class="line"><span class="keyword">const</span> storage2 = Storage.getInstance()</span><br><span class="line"></span><br><span class="line">storage1.setItem(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;李雷&#x27;</span>)</span><br><span class="line"><span class="comment">// 李雷</span></span><br><span class="line">storage1.getItem(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// 也是李雷</span></span><br><span class="line">storage2.getItem(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回true</span></span><br><span class="line">storage1 === storage2</span><br></pre></td></tr></table></figure><blockquote><p>实现： 闭包版</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先实现一个基础的StorageBase类，把getItem和setItem方法放在它的原型链上</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StorageBase</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">StorageBase.prototype.getItem = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">localStorage</span>.getItem(key)</span><br><span class="line">&#125;</span><br><span class="line">StorageBase.prototype.setItem = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">localStorage</span>.setItem(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以闭包的形式创建一个引用自由变量的构造函数</span></span><br><span class="line"><span class="keyword">const</span> Storage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断自由变量是否为null</span></span><br><span class="line">        <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">            <span class="comment">// 如果为null则new出唯一实例</span></span><br><span class="line">            instance = <span class="keyword">new</span> StorageBase()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里其实不用 new Storage 的形式调用，直接 Storage() 也会有一样的效果 </span></span><br><span class="line"><span class="keyword">const</span> storage1 = <span class="keyword">new</span> Storage()</span><br><span class="line"><span class="keyword">const</span> storage2 = <span class="keyword">new</span> Storage()</span><br><span class="line"></span><br><span class="line">storage1.setItem(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;李雷&#x27;</span>)</span><br><span class="line"><span class="comment">// 李雷</span></span><br><span class="line">storage1.getItem(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// 也是李雷</span></span><br><span class="line">storage2.getItem(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回true</span></span><br><span class="line">storage1 === storage2</span><br></pre></td></tr></table></figure><h2 id="实现一个全局的模态框"><a href="#实现一个全局的模态框" class="headerlink" title="实现一个全局的模态框"></a>实现一个全局的模态框</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><blockquote><p>实现一个全局唯一的Modal弹框</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题比较经典，基本上所有讲单例模式的文章都会以此为例，同时它也是早期单例模式在前端领域的最集中体现。</p><p>万变不离其踪，记住<code>getInstance</code>方法、记住<code>instance</code>变量、记住闭包和静态方法，这个题除了要多写点 HTML 和 CSS 之外，对大家来说完全不成问题。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>完整代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>单例模式弹框<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    #modal &#123;</span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">line-height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="css">        <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&#x27;open&#x27;</span>&gt;</span>打开弹框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&#x27;close&#x27;</span>&gt;</span>关闭弹框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 核心逻辑，这里采用了闭包思路来实现单例模式</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> Modal = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> modal = <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            if(!modal) &#123;</span><br><span class="line"><span class="javascript">            modal = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="javascript">            modal.innerHTML = <span class="string">&#x27;我是一个全局唯一的Modal&#x27;</span></span></span><br><span class="line"><span class="javascript">            modal.id = <span class="string">&#x27;modal&#x27;</span></span></span><br><span class="line"><span class="javascript">            modal.style.display = <span class="string">&#x27;none&#x27;</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.appendChild(modal)</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> modal</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// 点击打开按钮展示模态框</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;open&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> modal = <span class="keyword">new</span> Modal()</span></span><br><span class="line"><span class="javascript">    modal.style.display = <span class="string">&#x27;block&#x27;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// 点击关闭按钮隐藏模态框</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;close&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> modal = <span class="keyword">new</span> Modal()</span></span><br><span class="line">    if(modal) &#123;</span><br><span class="line"><span class="javascript">        modal.style.display = <span class="string">&#x27;none&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="设计模式" scheme="http://aiolimp.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://aiolimp.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现栈结构（Stack）</title>
    <link href="http://aiolimp.com/2022/07/11/JavaScript%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%BB%93%E6%9E%84%EF%BC%88Stack%EF%BC%89/"/>
    <id>http://aiolimp.com/2022/07/11/JavaScript%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%BB%93%E6%9E%84%EF%BC%88Stack%EF%BC%89/</id>
    <published>2022-07-11T02:23:20.000Z</published>
    <updated>2023-03-05T14:22:44.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript实现栈结构（Stack）"><a href="#JavaScript实现栈结构（Stack）" class="headerlink" title="JavaScript实现栈结构（Stack）"></a>JavaScript实现栈结构（Stack）</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><h4 id="1-1-什么是数据结构？"><a href="#1-1-什么是数据结构？" class="headerlink" title="1.1.什么是数据结构？"></a>1.1.什么是数据结构？</h4><p>数据结构就是在计算机中，存储和组织数据的方式。</p><p>例如：图书管理，怎样摆放图书才能既能放很多书，也方便取？</p><p>主要需要考虑两个问题：</p><ul><li>操作一：新书怎么插入？</li><li>操作二：怎么找到某本指定的书？</li></ul><p><strong>常见的数据结构：</strong></p><ul><li><strong>数组</strong>（Aarray）</li><li><strong>栈</strong>（Stack）</li><li><strong>链表</strong>（Linked List）</li><li><strong>图</strong>（Graph）</li><li><strong>散列表</strong>（Hash）</li><li><strong>队列</strong>（Queue）</li><li><strong>树</strong>（Tree）</li><li><strong>堆</strong>（Heap）</li></ul><p><strong>注意</strong>：数据结构与算法与语言无关，常见的编程语言都有<strong>直接或间接</strong>的使用上述常见的数据结构</p><h4 id="1-2-什么是算法？"><a href="#1-2-什么是算法？" class="headerlink" title="1.2.什么是算法？"></a>1.2.什么是算法？</h4><p>算法（Algorithm）的定义</p><ul><li>一个有限指令集，每条指令的描述不依赖于语言；</li><li>接收一些输入（有些情况下不需要输入）；</li><li>产生输入；</li><li>一定在有限步骤之后终止；</li></ul><p>算法通俗理解：解决问题的办法/步骤逻辑。数据结构的实现，离不开算法。</p><h3 id="二、栈结构（Stack）"><a href="#二、栈结构（Stack）" class="headerlink" title="二、栈结构（Stack）"></a>二、栈结构（Stack）</h3><h4 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1.简介"></a>2.1.简介</h4><p>数组是一个线性结构，并且可以在数组的<strong>任意位置</strong>插入和删除元素。而<strong>栈和队列</strong>就是比较常见的<strong>受限的线性结构</strong>。如下图所示：</p><p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/1.png" alt="image-20200226131817102"></p><p>栈的特点为<strong>先进后出，后进先出</strong>（LIFO：last in first out）。</p><p><strong>程序中的栈结构：</strong></p><ul><li><strong>函数调用栈</strong>：A（B（C（D（））））：即A函数中调用B，B调用C，C调用D；在A执行的过程中会将A压入栈，随后B执行时B也被压入栈，函数C和D执行时也会被压入栈。所以当前栈的顺序为：A-&gt;B-&gt;C-&gt;D（栈顶）；函数D执行完之后，会弹出栈被释放，弹出栈的顺序为D-&gt;C-&gt;B-&gt;A;</li><li><strong>递归</strong>：为什么没有停止条件的递归会造成栈溢出？比如函数A为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数A压入栈，最后造成<strong>栈溢出</strong>（Stack Overfloat）</li></ul><p>3.练习：题目：有6个元素6，5，4，3，2，1按顺序进栈，问下列哪一个不是合法的出栈顺序？</p><ul><li>A：5 4 3 6 1 2 （√）</li><li>B：4 5 3 2 1 6 （√）</li><li>C：3 4 6 5 2 1 （×）</li><li>D：2 3 4 1 5 6 （√）</li></ul><p>题目所说的按顺序进栈指的不是一次性全部进栈，而是有进有出，进栈顺序为6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。</p><p>解析：</p><ul><li>A答案：65进栈，5出栈，4进栈出栈，3进栈出栈，6出栈，21进栈，1出栈，2出栈（整体入栈顺序符合654321）;</li><li>B答案：654进栈，4出栈，5出栈，3进栈出栈，2进栈出栈，1进栈出栈，6出栈（整体的入栈顺序符合654321）;</li><li>C答案：6543进栈，3出栈，4出栈，之后应该5出栈而不是6，所以错误；</li><li>D答案：65432进栈，2出栈，3出栈，4出栈，1进栈出栈，5出栈，6出栈。符合入栈顺序；</li></ul><p><strong>栈常见的操作：</strong></p><ul><li>push（element）：添加一个新元素到栈顶位置；</li><li>pop（）：移除栈顶的元素，同时返回被移除的元素；</li><li>peek（）：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）；</li><li>isEmpty（）：如果栈里没有任何元素就返回true，否则返回false；</li><li>size（）：返回栈里的元素个数。这个方法和数组的length属性类似；</li><li>toString（）：将栈结构的内容以字符串的形式返回。</li></ul><h4 id="2-2-封装栈类"><a href="#2-2-封装栈类" class="headerlink" title="2.2.封装栈类"></a>2.2.封装栈类</h4><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装栈类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 栈中的属性</span></span><br><span class="line">  <span class="built_in">this</span>.items =[]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 栈的相关操作</span></span><br><span class="line">  <span class="comment">// 1.push():将元素压入栈</span></span><br><span class="line">  <span class="comment">//方式一(不推荐)：给对象添加方法，其他对象不能复用</span></span><br><span class="line">  <span class="comment">// this.push = () =&gt; &#123;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//方式二(推荐)：给Stack类添加方法，能够多对象复用</span></span><br><span class="line">  Stack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 利用数组item的push方法实现Stack类的pop方法</span></span><br><span class="line">    <span class="built_in">this</span>.items.push(element)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.pop():从栈中取出元素</span></span><br><span class="line">  Stack.prototype.pop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 利用数组item的pop方法实现Stack类的pop方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.pop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.peek():查看一下栈顶元素</span></span><br><span class="line">  Stack.prototype.peek = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.items.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.isEmpty():判断栈是否为空</span></span><br><span class="line">  Stack.prototype.isEmpty = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 两个小时的教训啊不是this.length(不是Stack对象的length，Stack类没有length属性啊)，而是Stack类中定义的数组items才有length属性呀</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.length == <span class="number">0</span> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.size():获取栈中元素的个数</span></span><br><span class="line">  Stack.prototype.size = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.toString():以字符串形式输出栈内数据</span></span><br><span class="line">  Stack.prototype.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//希望输出的形式：20 10 12 8 7</span></span><br><span class="line">    <span class="keyword">let</span> resultString = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="built_in">this</span>.items)&#123;</span><br><span class="line">      resultString += i + <span class="string">&#x27; &#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈的使用</span></span><br><span class="line">   <span class="keyword">let</span>  s = <span class="keyword">new</span> Stack()</span><br><span class="line">   s.push(<span class="number">20</span>)</span><br><span class="line">   s.push(<span class="number">10</span>)</span><br><span class="line">   s.push(<span class="number">100</span>)</span><br><span class="line">   s.push(<span class="number">77</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(s)<span class="comment">//65</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(s.pop());<span class="comment">//68</span></span><br><span class="line">   <span class="built_in">console</span>.log(s.pop());<span class="comment">//69</span></span><br><span class="line">   </span><br><span class="line">   <span class="built_in">console</span>.log(s.peek());<span class="comment">//71</span></span><br><span class="line"><span class="built_in">console</span>.log(s.isEmpty());<span class="comment">//72</span></span><br><span class="line">  </span><br><span class="line">   <span class="built_in">console</span>.log(s.size());<span class="comment">//74</span></span><br><span class="line">   <span class="built_in">console</span>.log(s.toString());</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/2.png" alt="image-20200305205050816"></p><p><strong>栈结构的简单应用：</strong></p><p>利用栈结构的特点封装十进至转换为二进至的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单应用：</span></span><br><span class="line"><span class="comment">//封装函数：将十进制转成二进制(十转二的运算最后倒叙取余的特点符合栈&#x27;先进后出&#x27;)</span></span><br><span class="line"><span class="keyword">let</span> dec2bin = <span class="function"><span class="params">decNumber</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.定义一个栈对象，保存余数</span></span><br><span class="line">  <span class="keyword">var</span>  stack = <span class="keyword">new</span> Stack()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.循环操作</span></span><br><span class="line">  <span class="keyword">while</span>(decNumber &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 2.1.获取余数并放入栈中</span></span><br><span class="line">    stack.push(decNumber % <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 2.2.获取整除后的结果作为下一次运算的数字(floor:向下取整)</span></span><br><span class="line">    decNumber = <span class="built_in">Math</span>.floor(decNumber / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.从栈中取出0和1</span></span><br><span class="line">  <span class="keyword">let</span>  binaryString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> a = stack.items.length</span><br><span class="line"> <span class="keyword">while</span>(stack.items.length != <span class="number">0</span>)&#123;</span><br><span class="line">    binaryString += stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> binaryString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="built_in">console</span>.log(dec2bin(<span class="number">10</span>));<span class="comment">//103</span></span><br><span class="line"><span class="built_in">console</span>.log(dec2bin(<span class="number">100</span>));<span class="comment">//104</span></span><br><span class="line"><span class="built_in">console</span>.log(dec2bin(<span class="number">1000</span>));<span class="comment">//105</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/3.png" alt="image-20200305205547226"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://aiolimp.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://aiolimp.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>树结构简介</title>
    <link href="http://aiolimp.com/2022/07/10/JavaScript%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    <id>http://aiolimp.com/2022/07/10/JavaScript%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%BB%93%E6%9E%84/</id>
    <published>2022-07-10T02:23:20.000Z</published>
    <updated>2023-03-05T14:22:34.187Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、树结构简介"><a href="#一、树结构简介" class="headerlink" title="一、树结构简介"></a>一、树结构简介</h2><h4 id="1-1-简单了解树结构"><a href="#1-1-简单了解树结构" class="headerlink" title="1.1.简单了解树结构"></a>1.1.简单了解树结构</h4><p><strong>什么是树？</strong></p><p>真实的树：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/1.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/1.png" alt="image-20200229205530929"></a></p><p><strong>树的特点：</strong></p><ul><li>树一般都有一个<strong>根</strong>，连接着根的是<strong>树干</strong>；</li><li>树干会发生分叉，形成许多<strong>树枝</strong>，树枝会继续分化成更小的<strong>树枝</strong>；</li><li>树枝的最后是<strong>叶子</strong>；</li></ul><p>现实生活中很多结构都是树的抽象，模拟的树结构相当于旋转<code>180°</code>的树。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/2.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/2.png" alt="image-20200229205630945"></a></p><p><strong>树结构对比于数组/链表/哈希表有哪些优势呢：</strong></p><p><strong>数组：</strong></p><ul><li>优点：可以通过<strong>下标值访问</strong>，效率高；</li><li>缺点：查找数据时需要先对数据进行<strong>排序</strong>，生成<strong>有序数组</strong>，才能提高查找效率；并且在插入和删除元素时，需要大量的<strong>位移操作</strong>；</li></ul><p><strong>链表：</strong></p><ul><li>优点：数据的插入和删除操作效率都很高；</li><li>缺点：<strong>查找</strong>效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。</li></ul><p><strong>哈希表：</strong></p><ul><li>优点：哈希表的插入/查询/删除效率都非常高；</li><li>缺点：<strong>空间利用率不高</strong>，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是<strong>无序</strong>的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中<strong>最大值或最小值</strong>这些特殊值。</li></ul><p><strong>树结构：</strong></p><p>优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。</p><p>总的来说：<strong>每种数据结构都有自己特定的应用场景</strong></p><p><strong>树结构：</strong></p><ul><li><strong>树（Tree）</strong>:由 n（n ≥ 0）个节点构成的<strong>有限集合</strong>。当 n = 0 时，称为<strong>空树</strong>。</li></ul><p>对于任一棵非空树（n &gt; 0），它具备以下性质：</p><ul><li>数中有一个称为<strong>根（Root）</strong>的特殊节点，用 **r **表示；</li><li>其余节点可分为 m（m &gt; 0）个互不相交的有限集合 T1，T2，…，Tm，其中每个集合本身又是一棵树，称为原来树的<strong>子树（SubTree）</strong>。</li></ul><p><strong>树的常用术语：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/3.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/3.png" alt="image-20200229221126468"></a></p><ul><li><strong>节点的度（Degree）</strong>：节点的<strong>子树个数</strong>，比如节点B的度为2；</li><li><strong>树的度</strong>：树的所有节点中<strong>最大的度数</strong>，如上图树的度为2；</li><li><strong>叶节点（Leaf）</strong>：<strong>度为0的节点</strong>（也称为叶子节点），如上图的H，I等；</li><li><strong>父节点（Parent）</strong>：度不为0的节点称为父节点，如上图节点B是节点D和E的父节点；</li><li><strong>子节点（Child）</strong>：若B是D的父节点，那么D就是B的子节点；</li><li><strong>兄弟节点（Sibling）</strong>：具有同一父节点的各节点彼此是兄弟节点，比如上图的B和C，D和E互为兄弟节点；</li><li><strong>路径和路径长度</strong>：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如A-&gt;H的路径长度为3；</li><li><strong>节点的层次（Level）</strong>：规定<strong>根节点在1层</strong>，其他任一节点的层数是其父节点的<strong>层数加1</strong>。如B和C节点的层次为2；</li><li><strong>树的深度（Depth）</strong>：树种所有节点中的<strong>最大层次</strong>是这棵树的深度，如上图树的深度为4；</li></ul><h4 id="1-2-树结构的表示方式"><a href="#1-2-树结构的表示方式" class="headerlink" title="1.2.树结构的表示方式"></a>1.2.树结构的表示方式</h4><ul><li><strong>最普通的表示方法</strong>：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/4.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/4.png" alt="image-20200229230417613"></a></p><p>如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点A需要3个引用，分别指向子节点B，C，D；B节点需要2个引用，分别指向子节点E和F；K节点由于没有子节点，所以不需要引用。</p><p>这种方法缺点在于我们无法确定某一结点的引用数。</p><ul><li><strong>儿子-兄弟表示法</strong>：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/5.png" alt="image-20200229232805477"></a></p><p>这种表示方法可以完整地记录每个节点的数据，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点A</span></span><br><span class="line">Node&#123;</span><br><span class="line">  <span class="comment">//存储数据</span></span><br><span class="line">  <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span></span><br><span class="line">  <span class="comment">//统一只记录左边的子节点</span></span><br><span class="line">  <span class="keyword">this</span>.leftChild = B</span><br><span class="line">  <span class="comment">//统一只记录右边的第一个兄弟节点</span></span><br><span class="line">  <span class="keyword">this</span>.rightSibling = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点B</span></span><br><span class="line">Node&#123;</span><br><span class="line">  <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span></span><br><span class="line">  <span class="keyword">this</span>.leftChild = E</span><br><span class="line">  <span class="keyword">this</span>.rightSibling = C</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点F</span></span><br><span class="line">Node&#123;</span><br><span class="line">  <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span></span><br><span class="line">  <span class="keyword">this</span>.leftChild = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">this</span>.rightSibling = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种表示法的优点在于每一个节点中引用的数量都是确定的。</p><ul><li><strong>儿子-兄弟表示法旋转</strong></li></ul><p>以下为儿子-兄弟表示法组成的树结构：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/6.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/6.png" alt="image-20200229234549049"></a></p><p>将其顺时针旋转45°之后：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/7.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/7.png" alt="image-20200229235549522"></a></p><p>这样就成为了一棵<strong>二叉树</strong>，由此我们可以得出结论：<strong>任何树都可以通过二叉树进行模拟</strong>。但是这样父节点不是变了吗？其实，父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可。</p><h2 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h2><h4 id="2-1-二叉树简介"><a href="#2-1-二叉树简介" class="headerlink" title="2.1.二叉树简介"></a>2.1.二叉树简介</h4><p><strong>二叉树的概念</strong>：如果树中的每一个节点最多只能由<strong>两个子节点</strong>，这样的树就称为<strong>二叉树</strong>；</p><p>二叉树十分重要，不仅仅是因为简单，更是因为几乎所有的树都可以表示成二叉树形式。</p><p><strong>二叉树的组成</strong>：</p><ul><li>二叉树可以为空，也就是没有节点；</li><li>若二叉树不为空，则它由根节点和称为其左子树TL和右子树TR的两个不相交的二叉树组成；</li></ul><p><strong>二叉树的五种形态</strong>：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/8.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/8.png" alt="image-20200301001718079"></a></p><p>上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树TL的二叉树、只有右子树TR的二叉树和有左右两个子树的二叉树。</p><p><strong>二叉树的特性</strong>：</p><ul><li>一个二叉树的第 i 层的最大节点树为：2(i-1)，i &gt;= 1；</li><li>深度为k的二叉树的最大节点总数为：2k - 1 ，k &gt;= 1；</li><li>对任何非空二叉树，若 n0 表示叶子节点的个数，n2表示度为2的非叶子节点个数，那么两者满足关系：n0 = n2 + 1；如下图所示：H，E，I，J，G为叶子节点，总数为5；A，B，C，F为度为2的非叶子节点，总数为4；满足n0 = n2 + 1的规律。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/9.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/9.png" alt="image-20200301092140211"></a></p><h4 id="2-2-特殊的二叉树"><a href="#2-2-特殊的二叉树" class="headerlink" title="2.2.特殊的二叉树"></a>2.2.特殊的二叉树</h4><p><strong>完美二叉树</strong></p><p>完美二叉树（Perfect Binary Tree）也成为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有2个子节点，这就构成了完美二叉树。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/10.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/10.png" alt="image-20200301093237681"></a></p><p><strong>完全二叉树</strong></p><p>完全二叉树（Complete Binary Tree）:</p><ul><li>除了二叉树最后一层外，其他各层的节点数都达到了最大值；</li><li>并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点；</li><li>完美二叉树是特殊的完全二叉树；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/11.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/11.png" alt="image-20200301093659373"></a></p><p>在上图中，由于H缺失了右子节点，所以它不是完全二叉树。</p><h4 id="2-3-二叉树的数据存储"><a href="#2-3-二叉树的数据存储" class="headerlink" title="2.3.二叉树的数据存储"></a>2.3.二叉树的数据存储</h4><p>常见的二叉树存储方式为<strong>数组</strong>和<strong>链表</strong>：</p><p><strong>使用数组：</strong></p><ul><li><strong>完全二叉树</strong>：按从上到下，从左到右的方式存储数据。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/12.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/12.png" alt="image-20200301094919588"></a></p><p>image-20200301094919588</p><table><thead><tr><th>节点</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>H</th></tr></thead><tbody><tr><td><strong>序号</strong></td><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>3</strong></td><td><strong>4</strong></td><td><strong>5</strong></td><td><strong>6</strong></td><td><strong>7</strong></td><td><strong>8</strong></td></tr></tbody></table><p>使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 * 2，右子节点的序号等于父节点序号 * 2 + 1 。</p><ul><li><strong>非完全二叉树</strong>：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/13.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/13.png" alt="image-20200301100043636"></a></p><table><thead><tr><th>节点</th><th>A</th><th>B</th><th>C</th><th>^</th><th>^</th><th>F</th><th>^</th><th>^</th><th>^</th><th>^</th><th>^</th><th>^</th><th>M</th></tr></thead><tbody><tr><td><strong>序号</strong></td><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>3</strong></td><td><strong>4</strong></td><td><strong>5</strong></td><td><strong>6</strong></td><td><strong>7</strong></td><td><strong>8</strong></td><td><strong>9</strong></td><td><strong>10</strong></td><td><strong>11</strong></td><td><strong>12</strong></td><td><strong>13</strong></td></tr></tbody></table><p><strong>使用链表</strong></p><p>二叉树最常见的存储方式为<strong>链表</strong>：每一个节点封装成一个Node，Node中包含存储的数据、左节点的引用和右节点的引用。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/14.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/14.png" alt="image-20200301100616105"></a></p><h2 id="三、二叉搜索树"><a href="#三、二叉搜索树" class="headerlink" title="三、二叉搜索树"></a>三、二叉搜索树</h2><h4 id="3-1-认识二叉搜索树"><a href="#3-1-认识二叉搜索树" class="headerlink" title="3.1.认识二叉搜索树"></a>3.1.认识二叉搜索树</h4><p><strong>二叉搜索树</strong>（<strong>BST</strong>，Binary Search Tree），也称为<strong>二叉排序树</strong>和<strong>二叉查找树</strong>。</p><p>二叉搜索树是一棵二叉树，可以为空；</p><p>如果不为空，则满足以下<strong>性质</strong>：</p><ul><li>条件1：非空左子树的<strong>所有</strong>键值<strong>小于</strong>其根节点的键值。比如三中节点6的所有非空左子树的键值都小于6；</li><li>条件2：非空右子树的<strong>所有</strong>键值<strong>大于</strong>其根节点的键值；比如三中节点6的所有非空右子树的键值都大于6；</li><li>条件3：左、右子树本身也都是二叉搜索树；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/15.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/15.png" alt="image-20200301103139916"></a></p><p>如上图所示，树二和树三符合3个条件属于二叉树，树一不满足条件3所以不是二叉树。</p><p><strong>总结：</strong>二叉搜索树的特点主要是<strong>较小的值</strong>总是保存在<strong>左节点</strong>上，相对<strong>较大的值</strong>总是保存在<strong>右节点</strong>上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中”搜索”的来源。</p><h4 id="3-2-二叉搜索树应用举例"><a href="#3-2-二叉搜索树应用举例" class="headerlink" title="3.2.二叉搜索树应用举例"></a>3.2.二叉搜索树应用举例</h4><p>下面是一个二叉搜索树：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/16.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/16.png" alt="image-20200301111718686"></a></p><p>若想在其中查找数据10，只需要查找4次，查找效率非常高。</p><ul><li>第1次：将10与根节点9进行比较，由于10 &gt; 9，所以10下一步与根节点9的右子节点13比较；</li><li>第2次：由于10 &lt; 13，所以10下一步与父节点13的左子节点11比较；</li><li>第3次：由于10 &lt; 11，所以10下一步与父节点11的左子节点10比较；</li><li>第4次：由于10 = 10，最终查找到数据10 。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/17.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/17.png" alt="image-20200301111751041"></a></p><p>同样是15个数据，在排序好的数组中查询数据10，需要查询10次：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/18.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/18.png" alt="image-20200301115348138"></a></p><p>其实：如果是排序好的数组，可以通过二分查找：第一次找9，第二次找13，第三次找15…。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是<strong>二叉搜索树</strong>。这就是数组二分法查找效率之所以高的原因。</p><h2 id="四、二叉搜索树的封装"><a href="#四、二叉搜索树的封装" class="headerlink" title="四、二叉搜索树的封装"></a>四、二叉搜索树的封装</h2><p><strong>二叉树搜索树的基本属性</strong>：</p><p>如图所示：二叉搜索树有四个最基本的属性：指向节点的<strong>根</strong>（root），节点中的<strong>键</strong>（key）、<strong>左指针</strong>（right）、<strong>右指针</strong>（right）。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/1.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/1.png" alt="image-20200301162706755"></a></p><p>所以，二叉搜索树中除了定义root属性外，还应定义一个节点内部类，里面包含每个节点中的left、right和key三个属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//封装二叉搜索树</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.key = key</span><br><span class="line">      <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">      <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉搜索树的常见操作：</strong></p><ul><li>insert（key）：向树中插入一个新的键；</li><li>search（key）：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false；</li><li>inOrderTraverse：通过中序遍历方式遍历所有节点；</li><li>preOrderTraverse：通过先序遍历方式遍历所有节点；</li><li>postOrderTraverse：通过后序遍历方式遍历所有节点；</li><li>min：返回树中最小的值/键；</li><li>max：返回树中最大的值/键；</li><li>remove（key）：从树中移除某个键；</li></ul><h4 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1.插入数据"></a>1.插入数据</h4><p><strong>实现思路：</strong></p><ul><li>首先根据传入的key创建节点对象；</li><li>然后判断根节点是否存在，不存在时通过：this.root = newNode，直接把新节点作为二叉搜索树的根节点。</li><li>若存在根节点则重新定义一个内部方法insertNode（）用于查找插入点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insert方法:对外向用户暴露的方法</span></span><br><span class="line"> BinarySearchTree.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.根据key创建节点</span></span><br><span class="line">   <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(key)</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//2.判断根节点是否存在</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="built_in">this</span>.root = newNode</span><br><span class="line">     <span class="comment">//根节点存在时</span></span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, newNode)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>内部方法insertNode（）的实现思路</strong>:</p><p>根据比较传入的两个节点，一直查找新节点适合插入的位置，直到成功插入新节点为止。</p><p>当newNode.key &lt; node.key向左查找:</p><ul><li>情况1：当node无左子节点时，直接插入：</li><li>情况2：当node有左子节点时，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/2.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/2.png" alt="image-20200301191640632"></a></p><p>当newNode.key &gt;= node.key向右查找，与向左查找类似：</p><ul><li>情况1：当node无右子节点时，直接插入：</li><li>情况2：当node有右子节点时，依然递归调用insertNode(),直到遇到传入insertNode方法的node无右子节点成功插入newNode为止：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/3.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/3.png" alt="image-20200301191507181"></a></p><p><strong>insertNode()代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//内部使用的insertNode方法:用于比较节点从左边插入还是右边插入</span></span><br><span class="line">      BinarySearchTree.prototype.insertNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, newNode</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//当newNode.key &lt; node.key向左查找</span></span><br><span class="line"><span class="comment">/*----------------------分支1:向左查找--------------------------*/</span>      </span><br><span class="line">        <span class="keyword">if</span>(newNode.key &lt; node.key)&#123;</span><br><span class="line">          <span class="comment">//情况1：node无左子节点，直接插入</span></span><br><span class="line"><span class="comment">/*----------------------分支1.1--------------------------*/</span></span><br><span class="line">          <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.left = newNode</span><br><span class="line">          <span class="comment">//情况2：node有左子节点，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。</span></span><br><span class="line"><span class="comment">/*----------------------分支1.2--------------------------*/</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.insertNode(node.left, newNode)</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//当newNode.key &gt;= node.key向右查找</span></span><br><span class="line"><span class="comment">/*-----------------------分支2:向右查找--------------------------*/</span>        </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//情况1：node无右子节点，直接插入</span></span><br><span class="line"><span class="comment">/*-----------------------分支2.1--------------------------*/</span> </span><br><span class="line">          <span class="keyword">if</span>(node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            node.right == newNode</span><br><span class="line">          <span class="comment">//情况2：node有右子节点，依然递归调用insertNode(),直到遇到无右子节点成功插入newNode为止</span></span><br><span class="line"><span class="comment">/*-----------------------分支2.2--------------------------*/</span> </span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.insertNode(node.right, newNode)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>为了更好理解以下列二叉搜索树为例：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/4.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/4.png" alt="image-20200301193104003"></a></p><p>想要上述的二叉搜索树（蓝色）中插入数据10：</p><ul><li>先把key = 10 传入insert方法，由于存在根节点 9，所以直接调用insetNode方法，传入的参数：node = 9，newNode = 10；</li><li>由于10 &gt; 9，进入分支2，向右查找适合插入的位置；</li><li>由于根节点 9 的右子节点存在且为 13 ，所以进入分支2.2，递归调用insertNode方法，传入的参数：node = 13，newNode = 10；</li><li>由于 10 &lt; 13 ，进入分支1，向左查找适合插入的位置；</li><li>由于父节点 13 的左子节点存在且为11，所以进入分支1.2，递归调用insertNode方法，传入的参数：node = 11，newNode = 10；</li><li>由于 10 &lt; 11，进入分支1，向左查找适合插入的位置；</li><li>由于父节点 11 的左子节点不存在，所以进入分支1.1，成功插入节点 10 。由于不符合分支1.2的条件所以不会继续调用insertNode方法，递归停止。</li></ul><p><strong>测试代码：</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   //测试代码</span><br><span class="line">   //<span class="number">1.</span>创建BinarySearchTree</span><br><span class="line">   let <span class="keyword">bst</span> = new BinarySearchTree()</span><br><span class="line"></span><br><span class="line">   //<span class="number">2.</span>插入数据</span><br><span class="line">   <span class="keyword">bst</span>.insert(<span class="number">11</span>)<span class="comment">;</span></span><br><span class="line">   <span class="keyword">bst</span>.insert(<span class="number">7</span>)<span class="comment">;</span></span><br><span class="line">   <span class="keyword">bst</span>.insert(<span class="number">15</span>)<span class="comment">;</span></span><br><span class="line">   <span class="keyword">bst</span>.insert(<span class="number">5</span>)<span class="comment">;</span></span><br><span class="line">   <span class="keyword">bst</span>.insert(<span class="number">9</span>)<span class="comment">;</span></span><br><span class="line">console.log(<span class="keyword">bst</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>应得到下图所示的二叉搜索树：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/5.png" alt="image-20200302002708576"></a></p><p><strong>测试结果</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/6.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/6.png" alt="image-20200302002409735"></a></p><h4 id="2-遍历数据"><a href="#2-遍历数据" class="headerlink" title="2.遍历数据"></a>2.遍历数据</h4><p>这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为：</p><ul><li>先序遍历；</li><li>中序遍历；</li><li>后序遍历；</li></ul><p>还有层序遍历，使用较少。</p><h5 id="2-1-先序遍历"><a href="#2-1-先序遍历" class="headerlink" title="2.1.先序遍历"></a>2.1.先序遍历</h5><p>先序遍历的过程为：</p><ul><li>首先，遍历根节点；</li><li>然后，遍历其左子树；</li><li>最后，遍历其右子树；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/7.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/7.png" alt="image-20200301213506159"></a></p><p>如上图所示，二叉树的节点遍历顺序为：A -&gt; B -&gt; D -&gt; H -&gt; I -&gt; E -&gt; C -&gt; F -&gt; G。</p><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//先序遍历</span></span><br><span class="line">      <span class="comment">//掺入一个handler函数方便之后对得到的key进行处理</span></span><br><span class="line">      BinarySearchTree.prototype.preOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.preOrderTraversalNode(<span class="built_in">this</span>.root, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//封装内部方法，对某个节点进行遍历</span></span><br><span class="line">      BinarySearchTree.prototype.preOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//1.处理经过的节点</span></span><br><span class="line">          handler(node.key)</span><br><span class="line"><span class="comment">/*----------------------递归1----------------------------*/</span></span><br><span class="line">          <span class="comment">//2.遍历左子树中的节点</span></span><br><span class="line">          <span class="built_in">this</span>.preOrderTraversalNode(node.left, handler)</span><br><span class="line"><span class="comment">/*----------------------递归2----------------------------*/</span></span><br><span class="line">          <span class="comment">//3.遍历右子树中的节点</span></span><br><span class="line">          <span class="built_in">this</span>.preOrderTraversalNode(node.right, handler)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>以遍历以下二叉搜索树为例：</p><p>[<img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/8.png" alt="image-20200301221450001">](<a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/8.png">https://gitee.com/ahuntsun/BlogImgs/raw/master/数据结构与算法/树二/8.png</a></p><p>首先调用preOrderTraversal方法，在方法里再调用preOrderTraversalNode方法用于遍历二叉搜索树。在preOrderTraversalNode方法中，递归1负责遍历左子节点，递归2负责遍历右子节点。先执行递归1，执行过程如下图所示：</p><blockquote><p><strong>记：preOrderTraversalNode() 为 A()</strong></p></blockquote><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/9.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/9.png" alt="image-20200302000248291"></a></p><p>可以看到一共递归调用了4次方法A，分别传入11、7、5、3，最后遇到null不满足 node != null 条件结束递归1；注意此时只是执行完最开始的递归1，并没有执行递归2，并且递归1执行到null停止后要一层层地往上返回，按顺序将调用的函数压出函数调用栈。</p><p>关于函数调用栈：之前的四次递归共把4个函数压入了函数调用栈，现在递归执行完了一层层地把函数压出栈。</p><p>值得注意的是：每一层函数都只是执行完了递归1，当返回到该层函数时，比如A（3）要继续执行递归2遍历二叉搜索树中的右子节点；</p><p>在执行递归2的过程中会不断调用方法A，并依次执行递归1和递归2，以此类推直到遇到null不满足 node != null 条件为止，才停止递归并一层层返回，如此循环。同理A（5）层、A（7）层、A（11）层都要经历上述循环，直到将二叉搜索树中的节点全部遍历完为止。</p><p>具体过程如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/10.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/10.png" alt="image-20200302000007414"></a></p><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"><span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">bst.insert(<span class="number">11</span>);</span><br><span class="line">bst.insert(<span class="number">7</span>);</span><br><span class="line">bst.insert(<span class="number">15</span>);</span><br><span class="line">bst.insert(<span class="number">5</span>);</span><br><span class="line">bst.insert(<span class="number">3</span>);</span><br><span class="line">bst.insert(<span class="number">9</span>);</span><br><span class="line">bst.insert(<span class="number">8</span>);</span><br><span class="line">bst.insert(<span class="number">10</span>);</span><br><span class="line">bst.insert(<span class="number">13</span>);</span><br><span class="line">bst.insert(<span class="number">12</span>);</span><br><span class="line">bst.insert(<span class="number">14</span>);</span><br><span class="line">bst.insert(<span class="number">20</span>);</span><br><span class="line">bst.insert(<span class="number">18</span>);</span><br><span class="line">bst.insert(<span class="number">25</span>);</span><br><span class="line">bst.insert(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试遍历</span></span><br><span class="line"><span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">//掺入处理节点值的处理函数</span></span><br><span class="line">bst.preOrderTraversal(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">  resultString += key + <span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(resultString)</span><br></pre></td></tr></table></figure><p>应输出这样的顺序：11 -&gt; 7 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 9 -&gt; 8 -&gt; 10 -&gt; 15 -&gt; 13 -&gt;12 -&gt; 14 -&gt; 20 -&gt; 18 -&gt; 25 。</p><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/11.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/11.png" alt="image-20200302003244874"></a></p><h5 id="2-2-中序遍历"><a href="#2-2-中序遍历" class="headerlink" title="2.2.中序遍历"></a>2.2.中序遍历</h5><p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p><ul><li>首先，遍历其左子树；</li><li>然后，遍历根（父）节点；</li><li>最后，遍历其右子树；</li></ul><p><strong>代码实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;中序遍历</span><br><span class="line">BinarySearchTree.prototype.midOrderTraversal &#x3D; function(handler)&#123;</span><br><span class="line">  this.midOrderTraversalNode(this.root, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinarySearchTree.prototype.midOrderTraversalNode &#x3D; function(node, handler)&#123;</span><br><span class="line">  if (node !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F;1.遍历左子树中的节点</span><br><span class="line">    this.midOrderTraversalNode(node.left, handler)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;2.处理节点</span><br><span class="line">    handler(node.key)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;3.遍历右子树中的节点</span><br><span class="line">    this.midOrderTraversalNode(node.right, handler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>遍历的顺序应如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/12.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/12.png" alt="image-20200302112920295"></a></p><p>首先调用midOrderTraversal方法，在方法里再调用midOrderTraversalNode方法用于遍历二叉搜索树。先使用递归1遍历左子树中的节点；然后，处理父节点；最后，遍历右子树中的节点。</p><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">  <span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line">  <span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.插入数据</span></span><br><span class="line">  bst.insert(<span class="number">11</span>);</span><br><span class="line">  bst.insert(<span class="number">7</span>);</span><br><span class="line">  bst.insert(<span class="number">15</span>);</span><br><span class="line">  bst.insert(<span class="number">5</span>);</span><br><span class="line">  bst.insert(<span class="number">3</span>);</span><br><span class="line">  bst.insert(<span class="number">9</span>);</span><br><span class="line">  bst.insert(<span class="number">8</span>);</span><br><span class="line">  bst.insert(<span class="number">10</span>);</span><br><span class="line">  bst.insert(<span class="number">13</span>);</span><br><span class="line">  bst.insert(<span class="number">12</span>);</span><br><span class="line">  bst.insert(<span class="number">14</span>);</span><br><span class="line">  bst.insert(<span class="number">20</span>);</span><br><span class="line">  bst.insert(<span class="number">18</span>);</span><br><span class="line">  bst.insert(<span class="number">25</span>);</span><br><span class="line">  bst.insert(<span class="number">6</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3.测试中序遍历</span></span><br><span class="line">  <span class="keyword">let</span> resultString2 =<span class="string">&quot;&quot;</span></span><br><span class="line">  bst.midOrderTraversal(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    resultString2 += key + <span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  alert(resultString2)</span><br></pre></td></tr></table></figure><p>输出节点的顺序应为：3 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13 -&gt; 14 -&gt; 15 -&gt; 18 -&gt; 20 -&gt; 25 。</p><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/13.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/13.png" alt="image-20200302112326786"></a></p><h5 id="2-3-后续遍历"><a href="#2-3-后续遍历" class="headerlink" title="2.3.后续遍历"></a>2.3.后续遍历</h5><p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p><ul><li>首先，遍历其左子树；</li><li>然后，遍历其右子树；</li><li>最后，遍历根（父）节点；</li></ul><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line">BinarySearchTree.prototype.postOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.postOrderTraversalNode(<span class="built_in">this</span>.root, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinarySearchTree.prototype.postOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, handler</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//1.遍历左子树中的节点</span></span><br><span class="line">    <span class="built_in">this</span>.postOrderTraversalNode(node.left, handler)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.遍历右子树中的节点</span></span><br><span class="line">    <span class="built_in">this</span>.postOrderTraversalNode(node.right, handler)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.处理节点</span></span><br><span class="line">    handler(node.key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>遍历的顺序应如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/14.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/14.png" alt="image-20200302120246366"></a></p><p>首先调用postOrderTraversal方法，在方法里再调用postOrderTraversalNode方法用于遍历二叉搜索树。先使用递归1遍历左子树中的节点；然后，遍历右子树中的节点；最后，处理父节点。</p><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"><span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">bst.insert(<span class="number">11</span>);</span><br><span class="line">bst.insert(<span class="number">7</span>);</span><br><span class="line">bst.insert(<span class="number">15</span>);</span><br><span class="line">bst.insert(<span class="number">5</span>);</span><br><span class="line">bst.insert(<span class="number">3</span>);</span><br><span class="line">bst.insert(<span class="number">9</span>);</span><br><span class="line">bst.insert(<span class="number">8</span>);</span><br><span class="line">bst.insert(<span class="number">10</span>);</span><br><span class="line">bst.insert(<span class="number">13</span>);</span><br><span class="line">bst.insert(<span class="number">12</span>);</span><br><span class="line">bst.insert(<span class="number">14</span>);</span><br><span class="line">bst.insert(<span class="number">20</span>);</span><br><span class="line">bst.insert(<span class="number">18</span>);</span><br><span class="line">bst.insert(<span class="number">25</span>);</span><br><span class="line">bst.insert(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试后序遍历</span></span><br><span class="line"><span class="keyword">let</span> resultString3 =<span class="string">&quot;&quot;</span></span><br><span class="line">bst.postOrderTraversal(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">  resultString3 += key + <span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(resultString3)</span><br></pre></td></tr></table></figure><p>输出节点的顺序应为：3 -&gt; 6 -&gt; 5 -&gt; 8 -&gt; 10 -&gt; 9 -&gt; 7 -&gt; 12 -&gt; 14 -&gt; 13 -&gt; 18 -&gt; 25 -&gt; 20 -&gt; 15 -&gt; 11 。</p><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/15.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/15.png" alt="image-20200302115446608"></a></p><p><strong>总结：</strong>以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。</p><h4 id="3-查找数据"><a href="#3-查找数据" class="headerlink" title="3.查找数据"></a>3.查找数据</h4><h5 id="3-1-查找最大值-amp-最小值"><a href="#3-1-查找最大值-amp-最小值" class="headerlink" title="3.1.查找最大值&amp;最小值"></a>3.1.查找最大值&amp;最小值</h5><p>在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左/右查找就能得到最值，如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/16.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/16.png" alt="image-20200302125521501"></a></p><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找最大值</span></span><br><span class="line">BinarySearchTree.prototype.max = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//1.获取根节点</span></span><br><span class="line">  <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line">  <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span></span><br><span class="line">  <span class="comment">//3.依次向右不断查找，直到节点为null</span></span><br><span class="line">  <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    key = node.key</span><br><span class="line">    node = node.right</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找最小值</span></span><br><span class="line">BinarySearchTree.prototype.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.获取根节点</span></span><br><span class="line">   <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line">  <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span></span><br><span class="line">  <span class="comment">//3.依次向左不断查找，直到节点为null</span></span><br><span class="line">  <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    key = node.key</span><br><span class="line">    node = node.left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"> <span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"> <span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.插入数据</span></span><br><span class="line"> bst.insert(<span class="number">11</span>);</span><br><span class="line"> bst.insert(<span class="number">7</span>);</span><br><span class="line"> bst.insert(<span class="number">15</span>);</span><br><span class="line"> bst.insert(<span class="number">5</span>);</span><br><span class="line"> bst.insert(<span class="number">3</span>);</span><br><span class="line"> bst.insert(<span class="number">9</span>);</span><br><span class="line"> bst.insert(<span class="number">8</span>);</span><br><span class="line"> bst.insert(<span class="number">10</span>);</span><br><span class="line"> bst.insert(<span class="number">13</span>);</span><br><span class="line"> bst.insert(<span class="number">12</span>);</span><br><span class="line"> bst.insert(<span class="number">14</span>);</span><br><span class="line"> bst.insert(<span class="number">20</span>);</span><br><span class="line"> bst.insert(<span class="number">18</span>);</span><br><span class="line"> bst.insert(<span class="number">25</span>);</span><br><span class="line"> bst.insert(<span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//4.测试最值</span></span><br><span class="line"> <span class="built_in">console</span>.log(bst.max());</span><br><span class="line"> <span class="built_in">console</span>.log(bst.min());</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/17.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/17.png" alt="image-20200302133028801"></a></p><h5 id="3-2-查找特定值"><a href="#3-2-查找特定值" class="headerlink" title="3.2.查找特定值"></a>3.2.查找特定值</h5><p>查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的key值与之比较，若<strong>node.key &lt; root**则向左查找，若**node.key &gt; root</strong>就向右查找，直到找到或查找到null为止。这里可以使用递归实现，也可以采用循环来实现。</p><p><strong>实现代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找特定的key</span></span><br><span class="line"> BinarySearchTree.prototype.search = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.获取根节点</span></span><br><span class="line">   <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.循环搜索key</span></span><br><span class="line">   <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">       <span class="comment">//小于根(父)节点就往左边找</span></span><br><span class="line">       node = node.left</span><br><span class="line">       <span class="comment">//大于根(父)节点就往右边找</span></span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; node.key)&#123;</span><br><span class="line">       node = node.right</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"><span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">bst.insert(<span class="number">11</span>);</span><br><span class="line">bst.insert(<span class="number">7</span>);</span><br><span class="line">bst.insert(<span class="number">15</span>);</span><br><span class="line">bst.insert(<span class="number">5</span>);</span><br><span class="line">bst.insert(<span class="number">3</span>);</span><br><span class="line">bst.insert(<span class="number">9</span>);</span><br><span class="line">bst.insert(<span class="number">8</span>);</span><br><span class="line">bst.insert(<span class="number">10</span>);</span><br><span class="line">bst.insert(<span class="number">13</span>);</span><br><span class="line">bst.insert(<span class="number">12</span>);</span><br><span class="line">bst.insert(<span class="number">14</span>);</span><br><span class="line">bst.insert(<span class="number">20</span>);</span><br><span class="line">bst.insert(<span class="number">18</span>);</span><br><span class="line">bst.insert(<span class="number">25</span>);</span><br><span class="line">bst.insert(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试搜索方法</span></span><br><span class="line"><span class="built_in">console</span>.log(bst.search(<span class="number">24</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(bst.search(<span class="number">13</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(bst.search(<span class="number">2</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/18.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/18.png" alt="image-20200302141031370"></a></p><h4 id="4-删除数据"><a href="#4-删除数据" class="headerlink" title="4.删除数据"></a>4.删除数据</h4><p><strong>实现思路：</strong></p><p><strong>第一步：</strong>先找到需要删除的节点，若没找到，则不需要删除；</p><p>首先定义变量current用于保存需要删除的节点、变量parent用于保存它的父节点、变量isLeftChild保存current是否为parent的左节点，这样方便之后删除节点时改变相关节点的指向。</p><p><strong>实现代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.1.定义变量</span></span><br><span class="line">     <span class="keyword">let</span> current = <span class="built_in">this</span>.root</span><br><span class="line">     <span class="keyword">let</span> parent = <span class="literal">null</span></span><br><span class="line">     <span class="keyword">let</span> isLeftChild = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//1.2.开始寻找删除的节点</span></span><br><span class="line">     <span class="keyword">while</span> (current.key != key) &#123;</span><br><span class="line">       parent = current</span><br><span class="line">       <span class="comment">// 小于则往左查找</span></span><br><span class="line">       <span class="keyword">if</span> (key &lt; current.key) &#123;</span><br><span class="line">         isLeftChild = <span class="literal">true</span></span><br><span class="line">         current = current.left</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">         isLeftChild = <span class="literal">false</span></span><br><span class="line">         current = current.rigth</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//找到最后依然没有找到相等的节点</span></span><br><span class="line">       <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//结束while循环后：current.key = key</span></span><br></pre></td></tr></table></figure><p><strong>第二步：</strong>删除找到的指定节点，后分3种情况：</p><ul><li>删除叶子节点；</li><li>删除只有一个子节点的节点；</li><li>删除有两个子节点的节点；</li></ul><h5 id="4-1-情况1：没有子节点"><a href="#4-1-情况1：没有子节点" class="headerlink" title="4.1.情况1：没有子节点"></a>4.1.情况1：没有子节点</h5><p>没有子节点时也有两种情况：</p><p>当该叶子节点为根节点时，如下图所示，此时<strong>current == this.root</strong>，直接通过：<strong>this.root = null</strong>，删除根节点。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/19.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/19.png" alt="image-20200302154316749"></a></p><p>当该叶子节点不为根节点时也有两种情况，如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/20.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/20.png" alt="image-20200302154019653"></a></p><p>若current = 8，可以通过：parent.left = null，删除节点8；</p><p>若current = 10，可以通过：parent.right = null，删除节点10；</p><p><strong>代码实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;情况1：删除的是叶子节点(没有子节点)</span><br><span class="line">if (current.left &#x3D;&#x3D; null &amp;&amp; current.right &#x3D;&#x3D;null) &#123;</span><br><span class="line">  if (current &#x3D;&#x3D; this.root) &#123;</span><br><span class="line">    this.root &#x3D; null</span><br><span class="line">  &#125;else if(isLeftChild)&#123;</span><br><span class="line">    parent.left &#x3D; null</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    parent.right &#x3D;null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-情况2：有一个子节点"><a href="#4-2-情况2：有一个子节点" class="headerlink" title="4.2.情况2：有一个子节点"></a>4.2.情况2：有一个子节点</h5><p>有六种情况分别是：</p><p>当current存在左子节点时（current.right == null）：</p><ul><li>情况1：current为根节点（current == this.root），如节点11，此时通过：this.root = current.left，删除根节点11；</li><li>情况2：current为父节点parent的左子节点（isLeftChild == true），如节点5，此时通过：parent.left = current.left，删除节点5；</li><li>情况3：current为父节点parent的右子节点（isLeftChild == false），如节点9，此时通过：parent.right = current.left，删除节点9；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/21.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/21.png" alt="image-20200302172806401"></a></p><p>当current存在右子节点时（current.left = null）：</p><ul><li>情况4：current为根节点（current == this.root），如节点11，此时通过：this.root = current.right，删除根节点11。</li><li>情况5：current为父节点parent的左子节点（isLeftChild == true），如节点5，此时通过：parent.left = current.right，删除节点5；</li><li>情况6：current为父节点parent的右子节点（isLeftChild == false），如节点9，此时通过：parent.right = current.right，删除节点9；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/22.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/22.png" alt="image-20200302172527722"></a></p><p><strong>实现代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//情况2：删除的节点有一个子节点</span></span><br><span class="line">  <span class="comment">//当current存在左子节点时</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(current.right == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = current.left</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">          parent.left = current.left</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          parent.right = current.left</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//当current存在右子节点时</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(current.left == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = current.rigth</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">          parent.left = current.right</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          parent.right = current.right</span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-3-情况3：有两个子节点"><a href="#4-3-情况3：有两个子节点" class="headerlink" title="4.3.情况3：有两个子节点"></a>4.3.情况3：有两个子节点</h5><p>这种情况<strong>十分复杂</strong>，首先依据以下二叉搜索树，讨论这样的问题：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/23.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/23.png" alt="image-20200302181849832"></a></p><p><strong>删除节点9</strong></p><p>在保证删除节点9后原二叉树仍为二叉搜索树的前提下，有两种方式：</p><ul><li>方式1：从节点9的左子树中选择一合适的节点替代节点9，可知节点8符合要求；</li><li>方式2：从节点9的右子树中选择一合适的节点替代节点9，可知节点10符合要求；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/24.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/24.png" alt="image-20200302190601622"></a></p><p><strong>删除节点7</strong></p><p>在保证删除节点7后原二叉树仍为二叉搜索树的前提下，也有两种方式：</p><ul><li>方式1：从节点7的左子树中选择一合适的节点替代节点7，可知节点5符合要求；</li><li>方式2：从节点7的右子树中选择一合适的节点替代节点7，可知节点8符合要求；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/25.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/25.png" alt="image-20200302183058326"></a></p><p><strong>删除节点15</strong></p><p>在保证删除节点15后原树二叉树仍为二叉搜索树的前提下，同样有两种方式：</p><ul><li>方式1：从节点15的左子树中选择一合适的节点替代节点15，可知节点14符合要求；</li><li>方式2：从节点15的右子树中选择一合适的节点替代节点15，可知节点18符合要求；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/26.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/26.png" alt="image-20200302184038470"></a></p><p>相信你已经发现其中的规律了！</p><p><strong>规律总结：</strong>如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点<strong>下面的子节点中找到一个合适的节点</strong>，来替换当前的节点。</p><p>若用current表示需要删除的节点，则合适的节点指的是：</p><ul><li>current左子树中比current<strong>小一点点的节点</strong>，即current<strong>左子树</strong>中的<strong>最大值</strong>；</li><li>current右子树中比current<strong>大一点点的节点</strong>，即current<strong>右子树</strong>中的<strong>最小值</strong>；</li></ul><p><strong>前驱&amp;后继</strong></p><p>在二叉搜索树中，这两个特殊的节点有特殊的名字：</p><ul><li>比current小一点点的节点，称为current节点的<strong>前驱</strong>。比如下图中的节点5就是节点7的前驱；</li><li>比current大一点点的节点，称为current节点的<strong>后继</strong>。比如下图中的节点8就是节点7的后继；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/27.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/27.png" alt="image-20200302210841453"></a></p><p><strong>代码实现：</strong></p><ul><li>查找需要被删除的节点current的后继时，需要在current的<strong>右子树</strong>中查找<strong>最小值</strong>，即在current的<strong>右子树</strong>中一直<strong>向左遍历</strong>查找；</li><li>查找前驱时，则需要在current的<strong>左子树</strong>中查找<strong>最大值</strong>，即在current的<strong>左子树</strong>中一直<strong>向右</strong>遍历查找。</li></ul><p>下面只讨论查找current后继的情况，查找前驱的原理相同，这里暂不讨论。</p><h5 id="4-4-完整实现"><a href="#4-4-完整实现" class="headerlink" title="4.4.完整实现"></a>4.4.完整实现</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//删除节点</span></span><br><span class="line">      BinarySearchTree.prototype.remove = function(key)&#123;</span><br><span class="line"><span class="comment">/*------------------------------1.寻找要删除的节点---------------------------------*/</span></span><br><span class="line">        <span class="comment">//1.1.定义变量current保存删除的节点，parent保存它的父节点。isLeftChild保存current是否为parent的左节点</span></span><br><span class="line">        let current = <span class="keyword">this</span>.root</span><br><span class="line">        let parent = <span class="literal">null</span></span><br><span class="line">        let isLeftChild = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.2.开始寻找删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (current.key != key) &#123;</span><br><span class="line">          parent = current</span><br><span class="line">          <span class="comment">// 小于则往左查找</span></span><br><span class="line">          <span class="keyword">if</span> (key &lt; current.key) &#123;</span><br><span class="line">            isLeftChild = <span class="literal">true</span></span><br><span class="line">            current = current.left</span><br><span class="line">          &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            isLeftChild = <span class="literal">false</span></span><br><span class="line">            current = current.right</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//找到最后依然没有找到相等的节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束while循环后：current.key = key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------2.根据对应情况删除节点------------------------------*/</span></span><br><span class="line">        <span class="comment">//情况1：删除的是叶子节点(没有子节点)</span></span><br><span class="line">        <span class="keyword">if</span> (current.left == <span class="literal">null</span> &amp;&amp; current.right ==<span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">            parent.left = <span class="literal">null</span></span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right =<span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//情况2：删除的节点有一个子节点</span></span><br><span class="line">        <span class="comment">//当current存在左子节点时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">              <span class="keyword">this</span>.root = current.left</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.left</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.left</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//当current存在右子节点时</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(current.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">              <span class="keyword">this</span>.root = current.right</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.right</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.right</span><br><span class="line">            &#125; </span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//情况3：删除的节点有两个子节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//1.获取后继节点</span></span><br><span class="line">          let successor = <span class="keyword">this</span>.getSuccessor(current)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//2.判断是否根节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = successor</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">            parent.left = successor</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = successor</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.将后继的左子节点改为被删除节点的左子节点</span></span><br><span class="line">          successor.left = current.left</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//封装查找后继的方法</span></span><br><span class="line">      BinarySearchTree.prototype.getSuccessor = function(delNode)&#123;</span><br><span class="line">        <span class="comment">//1.定义变量,保存找到的后继</span></span><br><span class="line">        let successor = delNode</span><br><span class="line">        let current = delNode.right</span><br><span class="line">        let successorParent = delNode</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.循环查找current的右子树节点</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">          successorParent = successor</span><br><span class="line">          successor = current</span><br><span class="line">          current = current.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断寻找到的后继节点是否直接就是删除节点的right节点</span></span><br><span class="line">        <span class="keyword">if</span>(successor != delNode.right)&#123;</span><br><span class="line">          successorParent.left = successor.right</span><br><span class="line">          successor.right = delNode.right </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"> <span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"> <span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.插入数据</span></span><br><span class="line"> bst.insert(<span class="number">11</span>);</span><br><span class="line"> bst.insert(<span class="number">7</span>);</span><br><span class="line"> bst.insert(<span class="number">15</span>);</span><br><span class="line"> bst.insert(<span class="number">5</span>);</span><br><span class="line"> bst.insert(<span class="number">3</span>);</span><br><span class="line"> bst.insert(<span class="number">9</span>);</span><br><span class="line"> bst.insert(<span class="number">8</span>);</span><br><span class="line"> bst.insert(<span class="number">10</span>);</span><br><span class="line"> bst.insert(<span class="number">13</span>);</span><br><span class="line"> bst.insert(<span class="number">12</span>);</span><br><span class="line"> bst.insert(<span class="number">14</span>);</span><br><span class="line"> bst.insert(<span class="number">20</span>);</span><br><span class="line"> bst.insert(<span class="number">18</span>);</span><br><span class="line"> bst.insert(<span class="number">25</span>);</span><br><span class="line"> bst.insert(<span class="number">6</span>);</span><br><span class="line"> bst.insert(<span class="number">19</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3.测试删除代码</span></span><br><span class="line"> <span class="comment">//删除没有子节点的节点</span></span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">3</span>)</span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">8</span>)</span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//删除有一个子节点的节点</span></span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">5</span>)</span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//删除有两个子节点的节点</span></span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">9</span>)</span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">7</span>)</span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//遍历二叉搜索树并输出</span></span><br><span class="line"> <span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span></span><br><span class="line"> bst.midOrderTraversal(function(key)&#123;</span><br><span class="line">   resultString += key + <span class="string">&quot;-&gt;&quot;</span></span><br><span class="line"> &#125;)</span><br><span class="line"> alert(resultString)</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/28.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/28.png" alt="image-20200302225943296"></a></p><p>image-20200302225943296</p><p>可见三种情况的节点都被成功删除了。</p><h4 id="5-二叉搜索树完整封装"><a href="#5-二叉搜索树完整封装" class="headerlink" title="5.二叉搜索树完整封装"></a>5.二叉搜索树完整封装</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//封装二叉搜索树</span></span><br><span class="line">    function BinarySearchTree()&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//节点内部类</span></span><br><span class="line">      function Node(key)&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">this</span>.right = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//属性</span></span><br><span class="line">      <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//方法</span></span><br><span class="line">      <span class="comment">//一.插入数据：insert方法:对外向用户暴露的方法</span></span><br><span class="line">      BinarySearchTree.prototype.insert = function(key)&#123;</span><br><span class="line">        <span class="comment">//1.根据key创建节点</span></span><br><span class="line">        let newNode = new Node(key)</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//2.判断根节点是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.root = newNode</span><br><span class="line">          <span class="comment">//根节点存在时</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.insertNode(<span class="keyword">this</span>.root, newNode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//内部使用的insertNode方法:用于比较节点从左边插入还是右边插入</span></span><br><span class="line">      BinarySearchTree.prototype.insertNode = function(node, newNode)&#123;</span><br><span class="line">        <span class="comment">//当newNode.key &lt; node.key向左查找</span></span><br><span class="line">        <span class="keyword">if</span>(newNode.key &lt; node.key)&#123;</span><br><span class="line">          <span class="comment">//情况1：node无左子节点，直接插入</span></span><br><span class="line">          <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.left = newNode</span><br><span class="line">          <span class="comment">//情况2：node有左子节点，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.insertNode(node.left, newNode)</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//当newNode.key &gt;= node.key向右查找</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//情况1：node无右子节点，直接插入</span></span><br><span class="line">          <span class="keyword">if</span>(node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            node.right = newNode</span><br><span class="line">          <span class="comment">//情况2：node有右子节点，依然递归调用insertNode(),直到遇到无右子节点成功插入newNode为止</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.insertNode(node.right, newNode)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//二.树的遍历</span></span><br><span class="line">      <span class="comment">//1.先序遍历</span></span><br><span class="line">      <span class="comment">//掺入一个handler函数对得到的key进行处理</span></span><br><span class="line">      BinarySearchTree.prototype.preOrderTraversal = function(handler)&#123;</span><br><span class="line">        <span class="keyword">this</span>.preOrderTraversalNode(<span class="keyword">this</span>.root, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//封装内部方法，对某个节点进行遍历</span></span><br><span class="line">      BinarySearchTree.prototype.preOrderTraversalNode = function(node,handler)&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//1.处理经过的节点</span></span><br><span class="line">          handler(node.key)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//2.遍历经过节点的左子节点</span></span><br><span class="line">          <span class="keyword">this</span>.preOrderTraversalNode(node.left, handler)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.遍历经过节点的右子节点</span></span><br><span class="line">          <span class="keyword">this</span>.preOrderTraversalNode(node.right, handler)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.中序遍历</span></span><br><span class="line">      BinarySearchTree.prototype.midOrderTraversal = function(handler)&#123;</span><br><span class="line">        <span class="keyword">this</span>.midOrderTraversalNode(<span class="keyword">this</span>.root, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BinarySearchTree.prototype.midOrderTraversalNode = function(node, handler)&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//1.遍历左子树中的节点</span></span><br><span class="line">          <span class="keyword">this</span>.midOrderTraversalNode(node.left, handler)</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//2.处理节点</span></span><br><span class="line">          handler(node.key)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.遍历右子树中的节点</span></span><br><span class="line">          <span class="keyword">this</span>.midOrderTraversalNode(node.right, handler)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.后序遍历</span></span><br><span class="line">      BinarySearchTree.prototype.postOrderTraversal = function(handler)&#123;</span><br><span class="line">        <span class="keyword">this</span>.postOrderTraversalNode(<span class="keyword">this</span>.root, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BinarySearchTree.prototype.postOrderTraversalNode = function(node, handler)&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//1.遍历左子树中的节点</span></span><br><span class="line">          <span class="keyword">this</span>.postOrderTraversalNode(node.left, handler)</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//2.遍历右子树中的节点</span></span><br><span class="line">          <span class="keyword">this</span>.postOrderTraversalNode(node.right, handler)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.处理节点</span></span><br><span class="line">          handler(node.key)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//三.寻找最值</span></span><br><span class="line">      <span class="comment">//寻找最大值</span></span><br><span class="line">      BinarySearchTree.prototype.max = function () &#123;</span><br><span class="line">        <span class="comment">//1.获取根节点</span></span><br><span class="line">        let node = <span class="keyword">this</span>.root</span><br><span class="line">        <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">        let key = <span class="literal">null</span></span><br><span class="line">        <span class="comment">//3.依次向右不断查找，直到节点为null</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          key = node.key</span><br><span class="line">          node = node.right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//寻找最小值</span></span><br><span class="line">      BinarySearchTree.prototype.min = function()&#123;</span><br><span class="line">         <span class="comment">//1.获取根节点</span></span><br><span class="line">         let node = <span class="keyword">this</span>.root</span><br><span class="line">        <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">        let key = <span class="literal">null</span></span><br><span class="line">        <span class="comment">//3.依次向左不断查找，直到节点为null</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          key = node.key</span><br><span class="line">          node = node.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//查找特定的key</span></span><br><span class="line">      BinarySearchTree.prototype.search = function(key)&#123;</span><br><span class="line">        <span class="comment">//1.获取根节点</span></span><br><span class="line">        let node = <span class="keyword">this</span>.root</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.循环搜索key</span></span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">            <span class="comment">//小于根(父)节点就往左边找</span></span><br><span class="line">            node = node.left</span><br><span class="line">            <span class="comment">//大于根(父)节点就往右边找</span></span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; node.key)&#123;</span><br><span class="line">            node = node.right</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//四.删除节点</span></span><br><span class="line">      BinarySearchTree.prototype.remove = function(key)&#123;</span><br><span class="line"><span class="comment">/*------------------------------1.寻找要删除的节点---------------------------------*/</span></span><br><span class="line">        <span class="comment">//1.1.定义变量current保存删除的节点，parent保存它的父节点。isLeftChild保存current是否为parent的左节点</span></span><br><span class="line">        let current = <span class="keyword">this</span>.root</span><br><span class="line">        let parent = <span class="literal">null</span></span><br><span class="line">        let isLeftChild = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.2.开始寻找删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (current.key != key) &#123;</span><br><span class="line">          parent = current</span><br><span class="line">          <span class="comment">// 小于则往左查找</span></span><br><span class="line">          <span class="keyword">if</span> (key &lt; current.key) &#123;</span><br><span class="line">            isLeftChild = <span class="literal">true</span></span><br><span class="line">            current = current.left</span><br><span class="line">          &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            isLeftChild = <span class="literal">false</span></span><br><span class="line">            current = current.right</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//找到最后依然没有找到相等的节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束while循环后：current.key = key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------2.根据对应情况删除节点------------------------------*/</span></span><br><span class="line">        <span class="comment">//情况1：删除的是叶子节点(没有子节点)</span></span><br><span class="line">        <span class="keyword">if</span> (current.left == <span class="literal">null</span> &amp;&amp; current.right ==<span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">            parent.left = <span class="literal">null</span></span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right =<span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//情况2：删除的节点有一个子节点</span></span><br><span class="line">        <span class="comment">//当current存在左子节点时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">              <span class="keyword">this</span>.root = current.left</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.left</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.left</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//当current存在右子节点时</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(current.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">              <span class="keyword">this</span>.root = current.right</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.right</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.right</span><br><span class="line">            &#125; </span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//情况3：删除的节点有两个子节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//1.获取后继节点</span></span><br><span class="line">          let successor = <span class="keyword">this</span>.getSuccessor(current)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//2.判断是否根节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = successor</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">            parent.left = successor</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = successor</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.将后继的左子节点改为被删除节点的左子节点</span></span><br><span class="line">          successor.left = current.left</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//封装查找后继的方法</span></span><br><span class="line">      BinarySearchTree.prototype.getSuccessor = function(delNode)&#123;</span><br><span class="line">        <span class="comment">//1.定义变量,保存找到的后继</span></span><br><span class="line">        let successor = delNode</span><br><span class="line">        let current = delNode.right</span><br><span class="line">        let successorParent = delNode</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.循环查找current的右子树节点</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">          successorParent = successor</span><br><span class="line">          successor = current</span><br><span class="line">          current = current.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断寻找到的后继节点是否直接就是删除节点的right节点</span></span><br><span class="line">        <span class="keyword">if</span>(successor != delNode.right)&#123;</span><br><span class="line">          successorParent.left = successor.right</span><br><span class="line">          successor.right = delNode.right </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="五、平衡树"><a href="#五、平衡树" class="headerlink" title="五、平衡树"></a>五、平衡树</h2><p><strong>二叉搜索树的缺陷：</strong></p><p>当插入的数据是有序的数据，就会造成二叉搜索树的深度过大。比如原二叉搜索树右 11 7 15 组成，如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/29.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/29.png" alt="image-20200302231503639"></a></p><p>当插入一组有序数据：6 5 4 3 2就会变成深度过大的搜索二叉树，会严重影响二叉搜索树的性能。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/30.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/30.png" alt="image-20200302231745864"></a></p><p><strong>非平衡树</strong></p><ul><li>比较好的二叉搜索树，它的数据应该是<strong>左右均匀分布</strong>的；</li><li>但是插入<strong>连续数据</strong>后，二叉搜索树中的数据分布就变得<strong>不均匀</strong>了，我们称这种树为<strong>非平衡树</strong>；</li><li>对于一棵<strong>平衡二叉树</strong>来说，插入/查找等操作的效率是<strong>O（logN）</strong>；</li><li>而对于一棵<strong>非平衡二叉树</strong>来说，相当于编写了一个链表，查找效率变成了<strong>O（N）</strong>;</li></ul><p><strong>树的平衡性</strong></p><p>为了能以<strong>较快的时间O（logN）</strong>来操作一棵树，我们需要<strong>保证树总是平衡</strong>的：</p><ul><li>起码大部分是平衡的，此时的时间复杂度也是接近O（logN）的；</li><li>这就要求树中<strong>每个节点左边的子孙节点</strong>的个数，应该尽可能地等于<strong>右边的子孙节点</strong>的个数；</li></ul><p><strong>常见的平衡树</strong></p><ul><li><strong>AVL树</strong>：是最早的一种平衡树，它通过在每个节点多存储一个额外的数据来保持树的平衡。由于AVL树是平衡树，所以它的时间复杂度也是O（logN）。但是它的整体效率不如红黑树，开发中比较少用。</li><li><strong>红黑树</strong>：同样通过<strong>一些特性</strong>来保持树的平衡，时间复杂度也是O（logN）。进行插入/删除等操作时，性能优于AVL树，所以平衡树的应用基本都是红黑树。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://aiolimp.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://aiolimp.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现排序算法</title>
    <link href="http://aiolimp.com/2022/07/09/JavaScript%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://aiolimp.com/2022/07/09/JavaScript%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-07-09T02:23:20.000Z</published>
    <updated>2023-03-05T14:22:22.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JavaScript实现排序算法"><a href="#JavaScript实现排序算法" class="headerlink" title="JavaScript实现排序算法"></a>JavaScript实现排序算法</h2><h3 id="一、大O表示法"><a href="#一、大O表示法" class="headerlink" title="一、大O表示法"></a>一、大O表示法</h3><p><strong>大O表示法：</strong></p><ul><li>在计算机中采用<strong>粗略的度量</strong>来描述计算机算法的<strong>效率</strong>，这种方法被称为<strong>“大O”表示法</strong></li><li>在<strong>数据项个数</strong>发生改变时，<strong>算法的效率</strong>也会跟着改变。所以说算法A比算法B快两倍，这样的比较是<strong>没有意义</strong>的。</li><li>因此我们通常使用<strong>算法的速度</strong>随着<strong>数据量的变化</strong>会如何变化的方式来表示算法的效率，大O表示法就是方式之一。</li></ul><p><strong>常见的大O表示形式</strong></p><table><thead><tr><th>符号</th><th>名称</th></tr></thead><tbody><tr><td>O（1）</td><td>常数</td></tr><tr><td>O（log(n)）</td><td>对数</td></tr><tr><td>O（n）</td><td>线性</td></tr><tr><td>O（nlog(n)）</td><td>线性和对数乘积</td></tr><tr><td>O（n²）</td><td>平方</td></tr><tr><td>O（2n）</td><td>指数</td></tr></tbody></table><p><strong>不同大O形式的时间复杂度：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png" alt="image-20200304164951223"></a></p><p>可以看到效率从大到小分别是：O（1）&gt; O（logn）&gt; O（n）&gt; O（nlog(n)）&gt; O（n²）&gt; O（2n）</p><p><strong>推导大O表示法的三条规则：</strong></p><ul><li><strong>规则一</strong>：用常量1取代运行时间中所有的加法常量。如7 + 8 = 15，用1表示运算结果15，大O表示法表示为O（1）；</li><li><strong>规则二</strong>：运算中只保留最高阶项。如N^3 + 3n +1，大O表示法表示为：O（N3）;</li><li><strong>规则三</strong>：若最高阶项的常数不为1，可将其省略。如4N2，大O表示法表示为：O（N2）;</li></ul><h3 id="二、排序算法"><a href="#二、排序算法" class="headerlink" title="二、排序算法"></a>二、排序算法</h3><p>这里主要介绍几种简单排序和高级排序：</p><ul><li><strong>简单排序：</strong>冒泡排序、选择排序、插入排序；</li><li><strong>高级排序：</strong>希尔排序、快速排序；</li></ul><p>此处创建一个列表类ArrayList并添加一些属性和方法，用于存放这些排序方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建列表类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="built_in">this</span>.array = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="comment">//封装将数据插入到数组中方法</span></span><br><span class="line">  ArrayList.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.array.push(item)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//toString方法</span></span><br><span class="line">  ArrayList.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.array.join(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//交换两个位置的数据</span></span><br><span class="line">  ArrayList.prototype.swap = <span class="function"><span class="keyword">function</span>(<span class="params">m, n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp  = <span class="built_in">this</span>.array[m]</span><br><span class="line">    <span class="built_in">this</span>.array[m] = <span class="built_in">this</span>.array[n]</span><br><span class="line">    <span class="built_in">this</span>.array[n] = temp</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><p><strong>冒泡排序的思路：</strong></p><ul><li>对未排序的各元素<strong>从头到尾</strong>依次比较<strong>相邻的两个元素</strong>大小关系；</li><li>如果<strong>左边的人员高</strong>，则将两人<strong>交换位置</strong>。比如1比2矮，不交换位置；</li><li>向<strong>右移动一位</strong>，继续比较2和3，最后比较 length - 1 和 length - 2这两个数据；</li><li>当到达<strong>最右端</strong>时，<strong>最高的人</strong>一定被放在了<strong>最右边</strong>；</li><li>按照这个思路，从最左端重新开始时，只需要走到<strong>倒数第二个位置</strong>即可；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.png" alt="image-20200304191223265"></a></p><p><strong>实现思路：</strong></p><p>两层循环：</p><ul><li>外层循环控制冒泡趟数：<ul><li>第一次：j = length - 1，比较到倒数第一个位置 ；</li><li>第二次：j = length - 2，比较到倒数第二个位置 ；</li></ul></li><li>内层循环控制每趟比较的次数：<ul><li>第一次比较： i = 0，比较 0 和 1 位置的两个数据；</li><li>最后一次比较：i = length - 2,比较length - 2和 length - 1两个数据；</li></ul></li></ul><p>详细过程如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.png" alt="image-20200304210611689"></a></p><p>动态过程：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/4.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/4.gif" alt="img"></a></p><p><strong>代码实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;冒泡排序</span><br><span class="line">ArrayList.prototype.bubblesor &#x3D; function()&#123;</span><br><span class="line">  &#x2F;&#x2F;1.获取数组的长度</span><br><span class="line">  let length &#x3D; this.array.length</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;外层循环控制冒泡趟数</span><br><span class="line">  for(let j &#x3D; length - 1; j &gt;&#x3D; 0; j--)&#123;</span><br><span class="line">    &#x2F;&#x2F;内层循环控制每趟比较的次数</span><br><span class="line">    for(let i &#x3D; 0; i &lt; j; i++)&#123;</span><br><span class="line">    if (this.array[i] &gt; this.array[i+1]) &#123;</span><br><span class="line">      &#x2F;&#x2F;交换两个数据</span><br><span class="line">      let temp  &#x3D; this.array[i]</span><br><span class="line">  this.array[i] &#x3D; this.array[i+1]</span><br><span class="line">  this.array[i+1] &#x3D; temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line">let list = new ArrayList()</span><br><span class="line"></span><br><span class="line">//插入元素</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">66</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">88</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">12</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">87</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">100</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">5</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">566</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">//验证冒泡排序</span><br><span class="line">list.bubblesor()</span><br><span class="line">console.<span class="built_in">log</span>(list);</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong><br><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5.png" alt="image-20200304210433388"></a></p><p><strong>冒泡排序的效率：</strong></p><ul><li>上面所讲的对于7个数据项，比较次数为：6 + 5 + 4 + 3 + 2 + 1;</li><li>对于N个数据项，<strong>比较次数</strong>为：(N - 1) + (N - 2) + (N - 3) + … + 1 = N * (N - 1) / 2；如果两次比较交换一次，那么<strong>交换次数</strong>为：N * (N - 1) / 4；</li><li>使用大O表示法表示比较次数和交换次数分别为：O（ N * (N - 1) / 2）和O（ N * (N - 1) / 4），根据大O表示法的三条规则都化简为：<strong>O（N^2）</strong>;</li></ul><h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h4><p><strong>选择排序改进了冒泡排序：</strong></p><ul><li>将<strong>交换次数</strong>由<strong>O（N^2）</strong>减小到<strong>O（N）</strong>；</li><li>但是<strong>比较次数</strong>依然是<strong>O（N^2）</strong>；</li></ul><p><strong>选择排序的思路：</strong></p><ul><li>选定<strong>第一个索引的位置</strong>比如1，然后依次和后面的元素<strong>依次进行比较</strong>；</li><li>如果后面的元素，<strong>小于</strong>索引1位置的元素，则<strong>交换位置</strong>到索引1处；</li><li>经过一轮的比较之后，可以确定一开始指定的索引1位置的元素是<strong>最小的</strong>；</li><li>随后使用同样的方法除索引1意外<strong>逐个比较剩下的元素</strong>即可；</li><li>可以看出选择排序，<strong>第一轮</strong>会选出<strong>最小值</strong>，<strong>第二轮</strong>会选出<strong>第二小的值</strong>，直到完成排序。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/6.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/6.png" alt="image-20200304213253241"></a></p><p><strong>实现思路：</strong></p><p>两层循环：</p><ul><li>外层循环控制指定的索引：<ul><li>第一次：j = 0，指定第一个元素 ；</li><li>最后一次：j = length - 1，指定最后一个元素 ；</li></ul></li><li>内层循环负责将指定索引（i）的元素与剩下（i - 1）的元素进行比较；</li></ul><p>动态过程：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/7.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/7.gif" alt="img"></a></p><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line">ArrayList.prototype.selectionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">let</span> length = <span class="built_in">this</span>.array.length</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.外层循环：从0开始获取元素</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">    <span class="keyword">let</span> min = j</span><br><span class="line">    <span class="comment">//内层循环：从i+1位置开始，和后面的元素进行比较</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = min + <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.array[min] &gt; <span class="built_in">this</span>.array[i]) &#123;</span><br><span class="line">      min = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.swap(min, j)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line">let list = new ArrayList()</span><br><span class="line"></span><br><span class="line">//插入元素</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">66</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">88</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">12</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">87</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">100</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">5</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">566</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">//验证选择排序</span><br><span class="line">list.selectionSort()</span><br><span class="line">console.<span class="built_in">log</span>(list);</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8.png" alt="image-20200304222224801"></a></p><p><strong>选择排序的效率：</strong></p><ul><li>选择排序的<strong>比较次数</strong>为：N * (N - 1) / 2，用大O表示法表示为：<strong>O（N^2）</strong>;</li><li>选择排序的<strong>交换次数</strong>为：(N - 1) / 2，用大O表示法表示为：<strong>O（N）</strong>;</li><li>所以选择排序的效率高于冒泡排序；</li></ul><h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h4><p>插入排序是简单排序中效率<strong>最高</strong>的一种排序。</p><p><strong>插入排序的思路：</strong></p><ul><li>插入排序思想的核心是<strong>局部有序</strong>。如图所示，X左边的人称为<strong>局部有序</strong>；</li><li>首先指定一数据X（从第一个数据开始），并将数据X的左边变成局部有序状态；</li><li>随后将X右移一位，再次达到局部有序之后，继续右移一位，重复前面的操作直至X移至最后一个元素。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/9.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/9.png" alt="image-20200304231400959"></a></p><p>插入排序的详细过程：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/10.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/10.png" alt="image-20200304231643777"></a></p><p>动态过程：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/11.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/11.gif" alt="img"></a></p><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line">ArrayList.prototype.insertionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">let</span> length = <span class="built_in">this</span>.array.length</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.外层循环:从第二个数据开始，向左边的已经局部有序数据进行插入</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">    <span class="comment">//3.内层循环：获取i位置的元素，使用while循环(重点)与左边的局部有序数据依次进行比较</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">this</span>.array[i]</span><br><span class="line">    <span class="keyword">let</span> j = i</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.array[j - <span class="number">1</span>] &gt; temp &amp;&amp; j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.array[j] = <span class="built_in">this</span>.array[j - <span class="number">1</span>]<span class="comment">//大的数据右移</span></span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.while循环结束后，index = j左边的数据变为局部有序且array[j]最大。此时将array[j]重置为排序前的数据array[i]，方便下一次for循环</span></span><br><span class="line">    <span class="built_in">this</span>.array[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line"> let list = new ArrayList()</span><br><span class="line"></span><br><span class="line"> //插入元素</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">66</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">88</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">12</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">87</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">100</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">5</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">566</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">23</span>)</span><br><span class="line"> // console.<span class="built_in">log</span>(list);</span><br><span class="line"></span><br><span class="line"> //验证插入排序</span><br><span class="line"> list.insertionSort()</span><br><span class="line"> console.<span class="built_in">log</span>(list);</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/12.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/12.png" alt="image-20200304235529516"></a></p><p><strong>插入排序的效率：</strong></p><ul><li><strong>比较次数：</strong>第一趟时，需要的最大次数为1；第二次最大为2；以此类推，最后一趟最大为N-1；所以，插入排序的总比较次数为N * (N - 1) / 2；但是，实际上每趟发现插入点之前，平均只有全体数据项的一半需要进行比较，所以比较次数为：<strong>N * (N - 1) / 4</strong>；</li><li><strong>交换次数：</strong>指定第一个数据为X时交换0次，指定第二个数据为X最多需要交换1次，以此类推，指定第N个数据为X时最多需要交换N - 1次，所以一共需要交换N * (N - 1) / 2次，平局次数为<strong>N * (N - 1) / 2</strong>；</li><li>虽然用大O表示法表示插入排序的效率也是<strong>O（N^2）</strong>，但是插入排序整体操作次数更少，因此，在简单排序中，插入排序<strong>效率最高</strong>；</li></ul><h4 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h4><p><strong>希尔排序</strong>是<strong>插入排序</strong>的一种高效的<strong>改进版</strong>，效率比插入排序要<strong>高</strong>。</p><p><strong>希尔排序的历史背景：</strong></p><ul><li>希尔排序按其设计者希尔（Donald Shell）的名字命名，该算法由<strong>1959年公布</strong>；</li><li>希尔算法首次突破了计算机界一直认为的<strong>算法的时间复杂度都是O（N^2）</strong>的大关，为了纪念该算法里程碑式</li></ul><p>的意义，用<strong>Shell</strong>来命名该算法；</p><p><strong>插入排序的问题：</strong></p><ul><li>假设一个<strong>很小的数据项</strong>在<strong>很靠近右端的位置</strong>上，这里本应该是<strong>较大的数据项的位置</strong>；</li><li>将这个<strong>小数据项移动到左边</strong>的正确位置，所有的<strong>中间数据项都必须向右移动一位</strong>，这样效率非常低；</li><li>如果通过<strong>某种方式</strong>，不需要<strong>一个个移动所有中间的数据项</strong>，就能把较小的数据项移到左边，那么这个算法的执行速度就会有很大的改进。</li></ul><p><strong>希尔排序的实现思路：</strong></p><ul><li>希尔排序主要通过对数据进行<strong>分组</strong>实现快速排序；</li><li>根据设定的增量（gap）将数据分为gap个组（<strong>组数等于gap</strong>），再在每个分组中进行局部排序；</li></ul><blockquote><p>假如有数组有10个数据，第1个数据为黑色，增量为5。那么第二个为黑色的数据index=5，第3个数据为黑色的数据index = 10（不存在）。所以黑色的数据每组只有2个，10 / 2 = 5一共可分5组，即<strong>组数等于增量gap</strong>。</p></blockquote><ul><li>排序之后，减小增量，继续分组，再次进行局部排序，直到增量gap=1为止。随后只需进行微调就可完成数组的排序；</li></ul><p>具体过程如下：</p><ul><li>排序之前的，储存10个数据的原始数组为：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/13.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/13.png" alt="image-20200305102330304"></a></p><ul><li>设初始增量gap = length / 2 = 5，即数组被分为了5组，如图所示分别为：[8, 3]、[9, 5]、[1, 4]、[7, 6]、[2, 0]：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/14.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/14.png" alt="image-20200305104914438"></a></p><ul><li>随后分别在每组中对数据进行局部排序，5组的顺序如图所示，变为：[3, 8]、[5, 9]、[1, 4]、[6, 7]、[0, 2]：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/15.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/15.png" alt="image-20200305103136251"></a></p><ul><li>然后缩小增量gap = 5 / 2 = 2，即数组被分为了2组，如图所示分别为：[3，1，0，9，7]、[5，6，8，4，2]：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/16.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/16.png" alt="image-20200305104933858"></a></p><ul><li>随后分别在每组中对数据进行局部排序，两组的顺序如图所示，变为：[0，1，3，7，9]、[2，4，5，6，8]：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/17.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/17.png" alt="image-20200305103815262"></a></p><ul><li>然后然后缩小增量gap = 2 / 1 = 1，即数组被分为了1组，如图所示为：[0，2，1，4，3，5，7，6，9，8]：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/18.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/18.png" alt="image-20200305104847458"></a></p><ul><li>最后只需要对该组数据进行插入排序即可完成整个数组的排序：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/19.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/19.png" alt="image-20200305104707789"></a></p><p>动态过程：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20.gif" alt="img"></a></p><p>图中d表示增量gap。</p><p><strong>增量的选择：</strong></p><ul><li><strong>原稿</strong>中希尔建议的初始间距为<strong>N / 2</strong>，比如对于N = 100的数组，增量序列为：50，25，12，6，3，1，可以发现不能整除时向下取整。</li><li><strong>Hibbard增量序列：</strong>增量序列算法为：2^k - 1，即1，3，5，7… …等；这种情况的最坏复杂度为*<em>O（N3/2）*</em>,平均复杂度为**O（N5/4）**但未被证明；</li><li><strong>Sedgewcik增量序列：</strong></li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/21.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/21.png" alt="image-20200305110724309"></a></p><p>以下代码实现中采用希尔排序原稿中建议的增量即<strong>N / 2</strong> 。</p><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line">ArrayList.prototype.shellSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">let</span> length = <span class="built_in">this</span>.array.length</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.初始化增量</span></span><br><span class="line">  <span class="keyword">let</span> gap = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.第一层循环：while循环(使gap不断减小)</span></span><br><span class="line">  <span class="keyword">while</span>(gap &gt;= <span class="number">1</span> )&#123;</span><br><span class="line">    <span class="comment">//4.第二层循环：以gap为增量，进行分组，对分组进行插入排序</span></span><br><span class="line">    <span class="comment">//重点为：将index = gap作为选中的第一个数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = gap; i &lt; length; i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> temp = <span class="built_in">this</span>.array[i]</span><br><span class="line">      <span class="keyword">let</span> j = i</span><br><span class="line">      <span class="comment">//5.第三层循环:寻找正确的插入位置</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="built_in">this</span>.array[j - gap] &gt; temp &amp;&amp; j &gt; gap - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.array[j] = <span class="built_in">this</span>.array[j - gap]</span><br><span class="line">        j -= gap</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//6.将j位置的元素设置为temp</span></span><br><span class="line">    <span class="built_in">this</span>.array[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释一下上述代码中的三层循环：</p><ul><li><strong>第一层循环：</strong>while循环，控制gap递减到1；</li><li><strong>第二层循环：</strong>分别取出根据g增量gap分成的gap组数据：将index = gap的数据作为选中的第一个数据，如下图所示，gap=5，则index = gap的数据为3，index = gap - 1的数据为8，两个数据为一组。随后gap不断加1右移，直到gap &lt; length，此时实现了将数组分为5组。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/21.5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/21.5.png" alt="image-20200305104914438"></a></p><ul><li><strong>第三层循环：</strong>对每一组数据进行插入排序；</li></ul><p><strong>测试代码：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line"> let list = new ArrayList()</span><br><span class="line"></span><br><span class="line"> //插入元素</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">66</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">88</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">12</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">87</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">100</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">5</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">566</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">23</span>)</span><br><span class="line"> // console.<span class="built_in">log</span>(list);</span><br><span class="line"></span><br><span class="line"> //验证希尔排序</span><br><span class="line"> list.shellSort()</span><br><span class="line"> console.<span class="built_in">log</span>(list);</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/22.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/22.png" alt="image-20200305114934209"></a></p><p><strong>希尔排序的效率：</strong></p><ul><li>希尔排序的效率和增量有直接关系，即使使用原稿中的增量效率都高于简单排序。</li></ul><h4 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.快速排序"></a>5.快速排序</h4><p>快速排序的介绍：</p><ul><li><strong>快速排序</strong>可以说是<strong>目前所有排序算法</strong>中，<strong>最快</strong>的一种排序算法。当然，没有任何一种算法是在任意情况下都是最优的。但是，大多数情况下快速排序是比较好的选择。</li><li><strong>快速排序</strong>其实是<strong>冒泡排序</strong>的升级版；</li></ul><p>快速排序的核心思想是<strong>分而治之</strong>，先选出一个数据（比如65），将比其小的数据都放在它的左边，将比它大的数据都放在它的右边。这个数据称为<strong>枢纽</strong></p><p>和冒泡排序的不同：</p><ul><li>我们选择的65可以一次性将它放在最正确的位置，之后就不需要做任何移动；</li><li>而冒泡排序即使已经找到最大值，也需要继续移动最大值，直到将它移动到最右边；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/23.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/23.png" alt="image-20200305154504624"></a></p><p><strong>快速排序的枢纽：</strong></p><ul><li><strong>第一种方案：</strong>直接选择第一个元素作为枢纽。但是，当第一个元素就是最小值的情况下，效率不高；</li><li><strong>第二种方案：</strong>使用随机数。随机数本身十分消耗性能，不推荐；</li><li><strong>优秀的解决方法：</strong>取index为头、中、位的三个数据排序后的中位数；如下图所示，按下标值取出的三个数据为：92，31，0，经排序后变为：0，31，92，取其中的中位数31作为<strong>枢纽</strong>（当（length-1）/2不整除时可向下或向上取整）：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/24.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/24.png" alt="image-20200305182934710"></a></p><p><strong>实现枢纽选择：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换两个位置的数据</span></span><br><span class="line"><span class="keyword">let</span> swap = <span class="function"><span class="keyword">function</span>(<span class="params">arr, m, n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp  = arr[m]</span><br><span class="line">    arr[m] = arr[n]</span><br><span class="line">    arr[n] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//1.选择枢纽</span></span><br><span class="line"><span class="keyword">let</span> median = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.取出中间的位置</span></span><br><span class="line">  <span class="keyword">let</span> center = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> right = arr.length - <span class="number">1</span> </span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.判断大小并进行交换</span></span><br><span class="line">  <span class="keyword">if</span> (arr[left] &gt; arr[center]) &#123;</span><br><span class="line">    swap(arr, left, center)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[center] &gt; arr[right])&#123;</span><br><span class="line">    swap(arr, center, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[left] &gt; arr[right]) &#123;</span><br><span class="line">    swap(arr, left, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.返回枢纽</span></span><br><span class="line">  <span class="keyword">return</span> center</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组经过获取枢纽函数操作之后，选出的3个下标值对应的数据位置变为：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/25.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/25.png" alt="image-20200320091750654"></a></p><p><strong>动态过程：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/26.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/26.gif" alt="img"></a></p><p><strong>快速排序代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.快速排序</span></span><br><span class="line"><span class="keyword">let</span> QuickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> center = median(arr)</span><br><span class="line">  <span class="keyword">let</span> c = arr.splice(center, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> l = []</span><br><span class="line">  <span class="keyword">let</span> r = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; c) &#123;</span><br><span class="line">        l.push(arr[i])</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r.push(arr[i])</span><br><span class="line">      &#125;        </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> QuickSort(l).concat(c, QuickSort(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的巧妙之处在于通过:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QuickSort(l)<span class="selector-class">.concat</span>(c, QuickSort(r))</span><br></pre></td></tr></table></figure><p>递归调用<code>QuickSort</code>函数实现了枢纽<code>Center</code>左边数据<code>l</code>和右边数据<code>r</code>的排序；</p><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">13</span>, <span class="number">81</span>, <span class="number">43</span>, <span class="number">31</span>, <span class="number">27</span>, <span class="number">56</span>, <span class="number">92</span>]</span><br><span class="line"><span class="built_in">console</span>.log(QuickSort(arr));</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/28.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/28.png" alt="image-20200320092254048"></a></p><p><strong>快速排序的效率：</strong></p><ul><li>快速排序最坏情况下的效率：每次选择的枢纽都是最左边或最右边的数据，此时效率等同于冒泡排序，时间复杂度为<strong>O（n2）</strong>。可根据不同的枢纽选择避免这一情况；</li><li>快速排序的平均效率：为<strong>O（N*logN）</strong>，虽然其他算法效率也可达到O（N*logN），但是其中快速排序是<strong>最好的</strong>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://aiolimp.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://aiolimp.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现队列结构（Queue）</title>
    <link href="http://aiolimp.com/2022/07/08/JavaScript%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%EF%BC%88Queue%EF%BC%89/"/>
    <id>http://aiolimp.com/2022/07/08/JavaScript%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%EF%BC%88Queue%EF%BC%89/</id>
    <published>2022-07-08T02:23:20.000Z</published>
    <updated>2023-03-05T14:22:03.761Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JavaScript实现队列结构（Queue）"><a href="#JavaScript实现队列结构（Queue）" class="headerlink" title="JavaScript实现队列结构（Queue）"></a>JavaScript实现队列结构（Queue）</h2><h3 id="一、队列简介"><a href="#一、队列简介" class="headerlink" title="一、队列简介"></a>一、队列简介</h3><p>队列是是一种受限的线性表，特点为<strong>先进先出</strong>（<strong>FIFO</strong>：first in first out）</p><ul><li>受限之处在于它只允许在表的<strong>前端</strong>（front）进行删除操作；</li><li>在表的<strong>后端</strong>（rear）进行插入操作；<a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/1.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/1.png" alt="image-20200226171659886"></a></li></ul><p>相当于排队买票，先来的先买票，后来的后买票。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/2.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/2.png" alt="image-20200226171449228"></a></p><p><strong>队列的应用：</strong></p><ul><li>打印队列：计算机打印多个文件的时候，需要排队打印；</li><li>线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待CPU处理</li></ul><p><strong>队列类的实现：</strong></p><p>队列的实现和栈一样，有两种方案：</p><ul><li>基于数组实现；</li><li>基于链表实现；</li></ul><p><strong>队列的常见操作：</strong></p><ul><li>enqueue（element）：向队列尾部添加一个（或多个）新的项；</li><li>dequeue（）：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素；</li><li>front（）：返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与Stack类的peek方法非常类似）；</li><li>isEmpty（）：如果队列中不包含任何元素，返回true，否则返回false；</li><li>size（）：返回队列包含的元素个数，与数组的length属性类似；</li><li>toString（）：将队列中的内容，转成字符串形式；</li></ul><h3 id="二、封装队列类"><a href="#二、封装队列类" class="headerlink" title="二、封装队列类"></a>二、封装队列类</h3><h4 id="2-1-代码实现"><a href="#2-1-代码实现" class="headerlink" title="2.1.代码实现"></a>2.1.代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于数组封装队列类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 属性</span></span><br><span class="line">  <span class="built_in">this</span>.items = []</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="comment">// 1.enqueue():将元素加入到队列中</span></span><br><span class="line">Queue.prototype.enqueue = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.items.push(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.dequeue():从队列中删除前端元素</span></span><br><span class="line">Queue.prototype.dequeue = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.items.shift()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.front():查看前端的元素</span></span><br><span class="line">Queue.prototype.front = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.isEmpty:查看队列是否为空</span></span><br><span class="line">Queue.prototype.isEmpty = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.items.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.size():查看队列中元素的个数</span></span><br><span class="line">Queue.prototype.size = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.items.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.toString():将队列中元素以字符串形式输出</span></span><br><span class="line">Queue.prototype.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> resultString = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="built_in">this</span>.items)&#123;</span><br><span class="line">      resultString += i + <span class="string">&#x27; &#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line">  let queue = <span class="keyword">new</span>  <span class="built_in">Queue</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将元素加入到队列中</span></span><br><span class="line">  queue.<span class="built_in">enqueue</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  queue.<span class="built_in">enqueue</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  queue.<span class="built_in">enqueue</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">  queue.<span class="built_in">enqueue</span>(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">  console.<span class="built_in">log</span>(queue);<span class="comment">//58</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从队列中删除元素</span></span><br><span class="line">  queue.<span class="built_in">dequeue</span>()</span><br><span class="line">  console.<span class="built_in">log</span>(queue);<span class="comment">//62</span></span><br><span class="line">  queue.<span class="built_in">dequeue</span>()</span><br><span class="line">  console.<span class="built_in">log</span>(queue);<span class="comment">//64</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//front</span></span><br><span class="line">  console.<span class="built_in">log</span>(queue.<span class="built_in">front</span>()); <span class="comment">//67</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 验证其他方法</span></span><br><span class="line">  console.<span class="built_in">log</span>(queue.<span class="built_in">isEmpty</span>()); <span class="comment">//70</span></span><br><span class="line">  console.<span class="built_in">log</span>(queue.<span class="built_in">size</span>()); <span class="comment">//71</span></span><br><span class="line">  console.<span class="built_in">log</span>(queue.<span class="built_in">toString</span>()); <span class="comment">//72</span></span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/3.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/3.png" alt="image-20200305211334015"></a></p><h4 id="2-2-队列的应用"><a href="#2-2-队列的应用" class="headerlink" title="2.2.队列的应用"></a>2.2.队列的应用</h4><p>使用队列实现小游戏：击鼓传花，传入一组数据和设定的数字num，循环遍历数组内元素，遍历到的元素为指定数字num时将该元素删除，直至数组剩下一个元素。</p><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列应用：面试题：击鼓传花</span></span><br><span class="line"><span class="keyword">let</span> passGame = <span class="function">(<span class="params">nameList, num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.创建队列结构</span></span><br><span class="line">  <span class="keyword">let</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.将所有人依次加入队列</span></span><br><span class="line">  <span class="comment">// 这是ES6的for循环写法，i相当于nameList[i]</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> nameList)&#123;</span><br><span class="line">    queue.enqueue(i)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.开始数数</span></span><br><span class="line"> <span class="keyword">while</span>(queue.size() &gt; <span class="number">1</span>)&#123;<span class="comment">//队列中只剩1个人就停止数数</span></span><br><span class="line">  <span class="comment">// 不是num的时候，重新加入队列末尾</span></span><br><span class="line">  <span class="comment">// 是num的时候，将其从队列中删除</span></span><br><span class="line">  <span class="comment">// 3.1.num数字之前的人重新放入队列的末尾(把队列前面删除的加到队列最后)</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; num-<span class="number">1</span>; i++ )&#123;</span><br><span class="line">    queue.enqueue(queue.dequeue())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3.2.num对应这个人，直接从队列中删除</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路是这样的，由于队列没有像数组一样的下标值不能直接取到某一元素，所以采用，把num前面的num-1个元素先删除后添加到队列末尾，这样第num个元素就排到了队列的最前面，可以直接使用dequeue方法进行删除</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  queue.dequeue()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4.获取剩下的那个人</span></span><br><span class="line">  <span class="built_in">console</span>.log(queue.size());<span class="comment">//104</span></span><br><span class="line">  <span class="keyword">let</span> endName = queue.front()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;最终剩下的人：&#x27;</span> + endName);   <span class="comment">//106</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> nameList.indexOf(endName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.测试击鼓传花</span></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">&#x27;lily&#x27;</span>, <span class="string">&#x27;lucy&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lilei&#x27;</span>, <span class="string">&#x27;Tony&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(passGame(names, <span class="number">3</span>));<span class="comment">//113</span></span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/4.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/4.png" alt="image-20200305212021550"></a></p><h3 id="三、优先队列"><a href="#三、优先队列" class="headerlink" title="三、优先队列"></a>三、优先队列</h3><p>优先级队列主要考虑的问题为：</p><ul><li>每个元素不再只是一个数据，还包含数据的优先级；</li><li>在添加数据过程中，根据优先级放入到正确位置；</li></ul><h4 id="3-1-优先级队列的实现"><a href="#3-1-优先级队列的实现" class="headerlink" title="3.1.优先级队列的实现"></a>3.1.优先级队列的实现</h4><p><strong>代码实现：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装优先级队列</span></span><br><span class="line">function PriorityQueue() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//内部类：在类里面再封装一个类;表示带优先级的数据</span></span><br><span class="line">  function QueueElement(element, priority) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">    <span class="keyword">this</span>.priority = priority;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装属性</span></span><br><span class="line">  <span class="keyword">this</span>.items = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.实现按照优先级插入方法</span></span><br><span class="line">  PriorityQueue.prototype.enqueue = (element, priority) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 1.1.创建QueueElement对象</span></span><br><span class="line">    let queueElement = new QueueElement(element, priority)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2.判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.items.length == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">this</span>.items.push(queueElement)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 定义一个变量记录是否成功添加了新元素</span></span><br><span class="line">      let added = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">for</span>(let i of <span class="keyword">this</span>.items)&#123;</span><br><span class="line">        <span class="comment">// 让新插入的元素与原有元素进行优先级比较(priority越小，优先级越大)</span></span><br><span class="line">        <span class="keyword">if</span>(queueElement.priority &lt; i.priority)&#123;</span><br><span class="line">          <span class="keyword">this</span>.items.splice(i, <span class="number">0</span>, queueElement)</span><br><span class="line">          added = <span class="literal">true</span></span><br><span class="line">          <span class="comment">// 新元素已经找到插入位置了可以使用break停止循环</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 新元素没有成功插入，就把它放在队列的最前面</span></span><br><span class="line">      <span class="keyword">if</span>(!added)&#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push(queueElement)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.dequeue():从队列中删除前端元素</span></span><br><span class="line">  PriorityQueue.prototype.dequeue = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.shift()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.front():查看前端的元素</span></span><br><span class="line">  PriorityQueue.prototype.front = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.isEmpty():查看队列是否为空</span></span><br><span class="line">  PriorityQueue.prototype.isEmpty = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.size():查看队列中元素的个数</span></span><br><span class="line">  PriorityQueue.prototype.size = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.toString():以字符串形式输出队列中的元素</span></span><br><span class="line">  PriorityQueue.prototype.toString = () =&gt; &#123;</span><br><span class="line">    let resultString = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="keyword">for</span> (let i of <span class="keyword">this</span>.items)&#123;</span><br><span class="line">        resultString += i.element + <span class="string">&#x27;-&#x27;</span> + i.priority + <span class="string">&#x27; &#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> pq = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">pq.enqueue(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">111</span>);</span><br><span class="line">pq.enqueue(<span class="string">&#x27;Hellen&#x27;</span>,<span class="number">200</span>);</span><br><span class="line">pq.enqueue(<span class="string">&#x27;Mary&#x27;</span>,<span class="number">30</span>);</span><br><span class="line">pq.enqueue(<span class="string">&#x27;Gogo&#x27;</span>,<span class="number">27</span>);</span><br><span class="line"><span class="comment">// 打印修改过后的优先队列对象</span></span><br><span class="line"><span class="built_in">console</span>.log(pq);</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/5.png" alt="image-20200226223314535"></a></p><h4 id="3-2-注意点"><a href="#3-2-注意点" class="headerlink" title="3.2.注意点"></a>3.2.注意点</h4><p><strong>关于数组方法splice用法</strong>：</p><ul><li>splice（1，0，’Tom’）：表示在索引为1的元素前面插入元素’Tom‘（也可以理解为从索引为1的元素开始删除，删除0个元素，再在索引为1的元素前面添加元素’Tom’）；</li><li>splice（1，1，’Tom’）：表示从索引为1的元素开始删除（包括索引为1的元素），共删除1个元素，并添加元素’Tom’。即把索引为1的元素替换为元素’Tom’。</li></ul><p><strong>数组的push方法在数组、栈和队列中的形式：</strong></p><ul><li><strong>数组</strong>：在数组[0，1，2]中，pop(3)，结果为[0，1，2，3]；</li><li><strong>栈</strong>：执行pop(0)，pop(1)，pop(2)，pop(3)，从栈底到栈顶的元素分别为：0，1，2，3；如果看成数组，可写为[0，1，2，3]，但是索引为3的元素3其实是栈顶元素；所以说栈的push方法是向栈顶添加元素（但在数组的视角下为向数组尾部添加元素）；</li><li><strong>队列</strong>：enqueue方法可以由数组的push方法实现，与数组相同，相当于在数组尾部添加元素。</li></ul><p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/6.png" alt="image-20200226231025462"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://aiolimp.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://aiolimp.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现单向链表</title>
    <link href="http://aiolimp.com/2022/07/07/JavaScript%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://aiolimp.com/2022/07/07/JavaScript%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2022-07-07T02:23:20.000Z</published>
    <updated>2023-03-05T14:21:44.625Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JavaScript实现单向链表"><a href="#JavaScript实现单向链表" class="headerlink" title="JavaScript实现单向链表"></a>JavaScript实现单向链表</h2><h3 id="一、单向链表简介"><a href="#一、单向链表简介" class="headerlink" title="一、单向链表简介"></a>一、单向链表简介</h3><p>链表和数组一样，可以用于<strong>存储一系列的元素</strong>，但是链表和数组的<strong>实现机制完全不同</strong>。链表的每个元素由一个存储<strong>元素本身的节点</strong>和一个<strong>指向下一个元素的引用</strong>（有的语言称为指针或连接）组成。类似于火车头，一节车厢载着乘客（数据），通过节点连接另一节车厢。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/1.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/1.png" alt="image-20200227110656733"></a></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/2.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/2.png" alt="image-20200227110626750"></a></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/3.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/3.png" alt="image-20200226233942344"></a></p><ul><li>head属性指向链表的第一个节点；</li><li>链表中的最后一个节点指向null；</li><li>当链表中一个节点也没有的时候，head直接指向null；</li></ul><p><strong>数组存在的缺点：</strong></p><ul><li>数组的创建通常需要申请一段<strong>连续的内存空间</strong>（一整块内存），并且大小是固定的。所以当原数组<strong>不能满足容量需求</strong>时，需要<strong>扩容</strong>（一般情况下是申请一个更大的数组，比如2倍，然后将原数组中的元素复制过去）。</li><li>在数组的开头或中间位置插入数据的成本很高，需要进行大量元素的位移。</li></ul><p><strong>链表的优势：</strong></p><ul><li>链表中的元素在内存中<strong>不必是连续的空间</strong>，可以充分利用计算机的内存，实现灵活的<strong>内存动态管理</strong>。</li><li>链表不必在创建时就<strong>确定大小</strong>，并且大小可以<strong>无限地延伸</strong>下去。</li><li>链表在<strong>插入和删除</strong>数据时，<strong>时间复杂度</strong>可以达到O(1)，相对数组效率高很多。</li></ul><p><strong>链表的缺点：</strong></p><ul><li>链表访问任何一个位置的元素时，都需要<strong>从头开始访问</strong>（无法跳过第一个元素访问任何一个元素）。</li><li>无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。</li><li>虽然可以轻松地到达<strong>下一个节点</strong>，但是回到<strong>前一个节点</strong>是很难的。</li></ul><p><strong>链表中的常见操作：</strong></p><ul><li>append（element）：向链表尾部添加一个新的项；</li><li>insert（position，element）：向链表的特定位置插入一个新的项；</li><li>get（position）：获取对应位置的元素；</li><li>indexOf（element）：返回元素在链表中的索引。如果链表中没有该元素就返回-1；</li><li>update（position，element）：修改某个位置的元素；</li><li>removeAt（position）：从链表的特定位置移除一项；</li><li>remove（element）：从链表中移除一项；</li><li>isEmpty（）：如果链表中不包含任何元素，返回trun，如果链表长度大于0则返回false；</li><li>size（）：返回链表包含的元素个数，与数组的length属性类似；</li><li>toString（）：由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值；</li></ul><p>首先需要弄清楚：下文中的position指的是两个节点之间，并且与index的关系如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/4.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/4.png" alt="image-20200306101534508"></a></p><p>position的值一般表示position所指位置的下一个节点。当position的值与index的值相等时，比如position = index = 1，那么它们都表示Node2。</p><h3 id="二、封装单向链表类"><a href="#二、封装单向链表类" class="headerlink" title="二、封装单向链表类"></a>二、封装单向链表类</h3><h4 id="2-0-创建单向链表类"><a href="#2-0-创建单向链表类" class="headerlink" title="2.0.创建单向链表类"></a>2.0.创建单向链表类</h4><p>先创建单向链表类Linklist，并添加基本属性，再实现单向链表的常用方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装单向链表类</span></span><br><span class="line">function LinkList()&#123;</span><br><span class="line">  <span class="comment">// 封装一个内部类：节点类</span></span><br><span class="line">  function Node(<span class="keyword">data</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="comment">// 属性head指向链表的第一个节点</span></span><br><span class="line">  <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-append-element"><a href="#2-1-append-element" class="headerlink" title="2.1.append(element)"></a>2.1.append(element)</h4><p><strong>代码实现：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一.实现append方法</span></span><br><span class="line">LinkList.prototype.append = <span class="keyword">data</span> =&gt; &#123;</span><br><span class="line">  <span class="comment">//1.创建新节点</span></span><br><span class="line">  let newNode = new Node(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.添加新节点</span></span><br><span class="line">  <span class="comment">//情况1：只有一个节点时候</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.length == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = newNode</span><br><span class="line">  <span class="comment">//情况2：节点数大于1，在链表的最后添加新节点  </span></span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;              </span><br><span class="line">    <span class="comment">//让变量current指向第一个节点</span></span><br><span class="line">    let current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="comment">//当current.next(下一个节点不为空)不为空时，一直循环，直到current指向最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (current.next)&#123;</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后节点的next指向新的节点</span></span><br><span class="line">    current.next = newNode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.添加完新结点之后length+1</span></span><br><span class="line">  <span class="keyword">this</span>.length += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><ul><li>首先让current指向第一个节点：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/5.png" alt="image-20200227145315369"></a></p><ul><li>通过while循环使current指向最后一个节点，最后通过current.next = newNode，让最后一个节点指向新节点newNode：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/6.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/6.png" alt="image-20200227145453380"></a></p><p><strong>测试代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建LinkList</span></span><br><span class="line">let list = <span class="built_in">new</span> LinkList()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.测试append方法</span></span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line">console.log(list);  </span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/7.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/7.png" alt="image-20200305234828061"></a></p><h4 id="2-2-toString"><a href="#2-2-toString" class="headerlink" title="2.2.toString()"></a>2.2.toString()</h4><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现toString方法</span></span><br><span class="line">LinkList.prototype.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 1.定义变量</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="built_in">this</span>.head</span><br><span class="line">  <span class="keyword">let</span> listString = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.循环获取一个个的节点</span></span><br><span class="line">  <span class="keyword">while</span>(current)&#123; </span><br><span class="line">    listString += current.data + <span class="string">&quot; &quot;</span></span><br><span class="line">    current = current.next<span class="comment">//千万不要忘了拼接完一个节点数据之后，让current指向下一个节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  listString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建LinkList</span></span><br><span class="line">let list = <span class="built_in">new</span> LinkList()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试toString方法</span></span><br><span class="line">console.log(list.toString());</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/8.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/8.png" alt="image-20200305235437934"></a></p><h4 id="2-3-insert-position-element"><a href="#2-3-insert-position-element" class="headerlink" title="2.3.insert(position,element)"></a>2.3.insert(position,element)</h4><p><strong>代码实现：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现insert方法</span></span><br><span class="line">LinkList.prototype.insert = (position, <span class="keyword">data</span>) =&gt; &#123;</span><br><span class="line"><span class="comment">//理解positon的含义：position=0表示新界点插入后要成为第1个节点，position=2表示新界点插入后要成为第3个节点</span></span><br><span class="line">  <span class="comment">//1.对position进行越界判断:要求传入的position不能是负数且不能超过LinkList的length</span></span><br><span class="line">  <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; <span class="keyword">this</span>.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.根据data创建newNode</span></span><br><span class="line">  let newNode = new Node(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.插入新节点</span></span><br><span class="line">  <span class="comment">//情况1：插入位置position=0</span></span><br><span class="line">  <span class="keyword">if</span>(position == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 让新节点指向第一个节点</span></span><br><span class="line">    newNode.next = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="comment">// 让head指向新节点</span></span><br><span class="line">    <span class="keyword">this</span>.head = newNode</span><br><span class="line">  <span class="comment">//情况2：插入位置position&gt;0(该情况包含position=length)</span></span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    let index = <span class="number">0</span></span><br><span class="line">    let previous = <span class="literal">null</span></span><br><span class="line">    let current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="comment">//步骤1：通过while循环使变量current指向position位置的后一个节点(注意while循环的写法)</span></span><br><span class="line">    <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">    <span class="comment">//步骤2：在current指向下一个节点之前，让previous指向current当前指向的节点</span></span><br><span class="line">      previous = current</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步骤3：通过变量current(此时current已经指向position位置的后一个节点)，使newNode指向position位置的后一个节点</span></span><br><span class="line">    newNode.next = current</span><br><span class="line">    <span class="comment">//步骤4：通过变量previous，使position位置的前一个节点指向newNode</span></span><br><span class="line">    previous.next = newNode</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      启示：</span></span><br><span class="line"><span class="comment">      1.我们无法直接操作链表中的节点，但是可以通过变量指向这些节点，以此间接地操作节点(替身使者)；</span></span><br><span class="line"><span class="comment">      比如current指向节点3，想要节点3指向节点4只需要：current.next = 4即可。</span></span><br><span class="line"><span class="comment">      2.两个节点间是双向的，想要节点2的前一个节点为节点1，可以通过：1.next=2，来实现；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4.新节点插入后要length+1</span></span><br><span class="line">  <span class="keyword">this</span>.length += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>inset方法实现的过程：根据插入节点位置的不同可分为多种情况：</p><ul><li><strong>情况1：position = 0</strong>：</li></ul><p>通过： newNode.next = this.head，建立连接1；</p><p>通过： this.head = newNode，建立连接2；（不能先建立连接2，否则this.head不再指向Node1）</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/9.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/9.png" alt="image-20200306103312580"></a></p><ul><li><strong>情况2：position &gt; 0</strong>：</li></ul><p>首先定义两个变量previous和curent分别指向需要插入位置pos = X的前一个节点和后一个节点；</p><p>然后，通过：newNode.next = current，改变指向3；</p><p>最后，通过：previous.next = newNode，改变指向4；</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/10.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/10.png" alt="image-20200306103541674"></a></p><ul><li><strong>情况2的特殊情形：position = length</strong>：</li></ul><p>情况2也包含了pos = length的情况，该情况下current和newNode.next都指向null；建立连接3和连接4的方式与情况2相同。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/11.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/11.png" alt="image-20200306103646576"></a></p><p><strong>测试代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建LinkList</span></span><br><span class="line">let list = <span class="built_in">new</span> LinkList()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试insert方法</span></span><br><span class="line">list.insert(<span class="number">0</span>, <span class="string">&#x27;在链表最前面插入节点&#x27;</span>);</span><br><span class="line">list.insert(<span class="number">2</span>, <span class="string">&#x27;在链表中第二个节点后插入节点&#x27;</span>);</span><br><span class="line">list.insert(<span class="number">5</span>, <span class="string">&#x27;在链表最后插入节点&#x27;</span>);</span><br><span class="line">alert(list);</span><br><span class="line">console.log(list);</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/12.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/12.png" alt="image-20200305235710063"></a></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/13.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/13.png" alt="image-20200305235756962"></a></p><h4 id="2-4-get-position"><a href="#2-4-get-position" class="headerlink" title="2.4.get(position)"></a>2.4.get(position)</h4><p><strong>代码实现：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现get方法</span></span><br><span class="line">LinkList.prototype.<span class="keyword">get</span> = (position) =&gt; &#123;</span><br><span class="line">  <span class="comment">//1.越界判断</span></span><br><span class="line">  <span class="comment">// 当position = length时，取到的是null所以0 =&lt; position &lt; length</span></span><br><span class="line">  <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.获取指定的positon位置的后一个节点的data</span></span><br><span class="line">  <span class="comment">//同样使用一个变量间接操作节点</span></span><br><span class="line">  let current = <span class="keyword">this</span>.head</span><br><span class="line">  let index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">    current = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current.<span class="keyword">data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>get方法的实现过程：以获取position = 2为例，如下图所示：</p><ul><li>首先使current指向第一个节点，此时index=0；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/14.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/14.png" alt="image-20200227164308939"></a></p><ul><li>通过while循环使current循环指向下一个节点，注意循环终止的条件index++ &lt; position，即当index=position时停止循环，此时循环了1次，current指向第二个节点(Node2)，最后通过current.data返回Node2节点的数据；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/15.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/15.png" alt="image-20200227164351066"></a></p><p><strong>测试代码：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">   <span class="comment">//1.创建LinkList</span></span><br><span class="line">   <span class="keyword">let</span> list = <span class="keyword">new</span> LinkList()</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.插入数据</span></span><br><span class="line">   list.append(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">   list.append(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">   list.append(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试get方法</span></span><br><span class="line">   console.log(list.<span class="keyword">get</span>(<span class="number">0</span>));</span><br><span class="line">   console.log(list.<span class="keyword">get</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/16.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/16.png" alt="image-20200306000211073"></a></p><h4 id="2-5-indexOf-element"><a href="#2-5-indexOf-element" class="headerlink" title="2.5.indexOf(element)"></a>2.5.indexOf(element)</h4><p><strong>代码实现：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现indexOf方法</span></span><br><span class="line">LinkList.prototype.indexOf = <span class="keyword">data</span> =&gt; &#123;</span><br><span class="line">  <span class="comment">//1.定义变量</span></span><br><span class="line">  let current = <span class="keyword">this</span>.head</span><br><span class="line">  let index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.开始查找:只要current不指向null就一直循环</span></span><br><span class="line">  <span class="keyword">while</span>(current)&#123;</span><br><span class="line">    <span class="keyword">if</span>(current.<span class="keyword">data</span> == <span class="keyword">data</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> index</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.遍历完链表没有找到，返回-1</span></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>indexOf方法的实现过程：</p><ul><li>使用变量current记录当前指向的节点，使用变量index记录当前节点的索引值（注意index = node数-1）：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/17.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/17.png" alt="image-20200227155230599"></a></p><p><strong>测试代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">   <span class="comment">//1.创建LinkList</span></span><br><span class="line">   let list = <span class="built_in">new</span> LinkList()</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.插入数据</span></span><br><span class="line">   list.<span class="built_in">append</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">   list.<span class="built_in">append</span>(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">   list.<span class="built_in">append</span>(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3.测试indexOf方法</span></span><br><span class="line">   console.log(list.indexOf(<span class="string">&#x27;aaa&#x27;</span>));</span><br><span class="line">   console.log(list.indexOf(<span class="string">&#x27;ccc&#x27;</span>));</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/18.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/18.png" alt="image-20200306000424189"></a></p><h4 id="2-6-update-position-element"><a href="#2-6-update-position-element" class="headerlink" title="2.6.update(position,element)"></a>2.6.update(position,element)</h4><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现update方法</span></span><br><span class="line">LinkList.prototype.update = <span class="function">(<span class="params">position, newData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.越界判断</span></span><br><span class="line">  <span class="comment">//因为被修改的节点不能为null，所以position不能等于length</span></span><br><span class="line">  <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.查找正确的节点</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="built_in">this</span>.head</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">    current = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.将position位置的后一个节点的data修改成newData</span></span><br><span class="line">  current.data = newData</span><br><span class="line">  <span class="comment">//返回true表示修改成功</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">   <span class="comment">//1.创建LinkList</span></span><br><span class="line">   let list = <span class="built_in">new</span> LinkList()</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.插入数据</span></span><br><span class="line">   list.<span class="built_in">append</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">   list.<span class="built_in">append</span>(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">   list.<span class="built_in">append</span>(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3.测试update方法</span></span><br><span class="line">   list.update(<span class="number">0</span>, <span class="string">&#x27;修改第一个节点&#x27;</span>)</span><br><span class="line">   list.update(<span class="number">1</span>, <span class="string">&#x27;修改第二个节点&#x27;</span>)</span><br><span class="line">   console.log(list);</span><br><span class="line">   console.log(list.update(<span class="number">3</span>, <span class="string">&#x27;能修改么&#x27;</span>));</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/19.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/19.png" alt="image-20200306000700656"></a></p><h4 id="2-7-removeAt-position"><a href="#2-7-removeAt-position" class="headerlink" title="2.7.removeAt(position)"></a>2.7.removeAt(position)</h4><p><strong>代码实现：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现removeAt方法</span></span><br><span class="line">LinkList.prototype.removeAt = position =&gt; &#123;</span><br><span class="line">  <span class="comment">//1.越界判断</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length) &#123;<span class="comment">//position不能为length</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.删除元素</span></span><br><span class="line">  <span class="comment">//情况1：position = 0时(删除第一个节点)</span></span><br><span class="line">  let current = <span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">if</span> (position ==<span class="number">0</span> ) &#123;</span><br><span class="line">  <span class="comment">//情况2：position &gt; 0时</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    let index = <span class="number">0</span></span><br><span class="line">    let previous = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">      previous = current</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环结束后，current指向position后一个节点，previous指向current前一个节点</span></span><br><span class="line">    <span class="comment">//再使前一个节点的next指向current的next即可</span></span><br><span class="line">    previous.next = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3，length-1</span></span><br><span class="line">  <span class="keyword">this</span>.length -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回被删除节点的data，为此current定义在最上面</span></span><br><span class="line">  <span class="keyword">return</span> current.<span class="keyword">data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>removeAt方法的实现过程：删除节点时存在多种情况：</p><ul><li><strong>情况1：position = 0</strong>，即移除第一个节点（Node1）。</li></ul><p>通过：this.head = this.head.next，改变指向1即可；</p><p>虽然Node1的next仍指向Node2，但是没有引用指向Node1，则Node1会被垃圾回收器自动回收，所以不用处理Node1指向Node2的引用next。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/20.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/20.png" alt="image-20200306110518877"></a></p><ul><li><strong>情况2：positon &gt; 0</strong>，比如pos = 2即移除第三个节点（Node3）。</li></ul><p><strong>注意：</strong>position = length时position后一个节点为null不能删除，因此position != length；</p><p>首先，定义两个变量previous和curent分别指向需要删除位置pos = x的前一个节点和后一个节点；</p><p>然后，通过：previous.next = current.next，改变指向1即可；</p><p>随后，没有引用指向Node3，Node3就会被自动回收，至此成功删除Node3 。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/21.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/21.png" alt="image-20200306104624457"></a></p><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//测试代码</span></span><br><span class="line">  <span class="comment">//1.创建LinkList</span></span><br><span class="line">  <span class="keyword">let</span> list = <span class="keyword">new</span> LinkList()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2.插入数据</span></span><br><span class="line">  list.append(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">  list.append(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">  list.append(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试removeAt方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(list.removeAt(<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(list.removeAt(<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(list);</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/22.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/22.png" alt="image-20200306000839608"></a></p><h4 id="2-8-其他方法"><a href="#2-8-其他方法" class="headerlink" title="2.8.其他方法"></a>2.8.其他方法</h4><p>其他方法包括：<strong>remove(element)、isEmpty()、size()</strong></p><p><strong>代码实现：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------其他方法的实现--------------*/</span></span><br><span class="line">      <span class="comment">//一.实现remove方法</span></span><br><span class="line">      LinkList.prototype.remove = (<span class="keyword">data</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//1.获取data在列表中的位置</span></span><br><span class="line">        let position = <span class="keyword">this</span>.indexOf(<span class="keyword">data</span>)</span><br><span class="line">        <span class="comment">//2.根据位置信息，删除结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(position)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//二.实现isEmpty方法</span></span><br><span class="line">      LinkList.prototype.isEmpty = () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length == <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//三.实现size方法</span></span><br><span class="line">      LinkList.prototype.size = () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//测试代码</span></span><br><span class="line">    <span class="comment">//1.创建LinkList</span></span><br><span class="line">    <span class="keyword">let</span> list = <span class="keyword">new</span> LinkList()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.插入数据</span></span><br><span class="line">    list.append(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    list.append(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">    list.append(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------其他方法测试----------------*/</span></span><br><span class="line">  <span class="comment">//remove方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(list.remove(<span class="string">&#x27;aaa&#x27;</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(list);</span><br><span class="line">  <span class="comment">//isEmpty方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(list.isEmpty());</span><br><span class="line">  <span class="comment">//size方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(list.size());</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/23.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/23.png" alt="image-20200306001247346"></a></p><h4 id="2-9-完整实现"><a href="#2-9-完整实现" class="headerlink" title="2.9.完整实现"></a>2.9.完整实现</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 封装链表类</span></span><br><span class="line">    function LinkList()&#123;</span><br><span class="line">      <span class="comment">// 封装一个内部类：节点类</span></span><br><span class="line">      function Node(<span class="keyword">data</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 属性</span></span><br><span class="line">      <span class="comment">// 属性head指向链表的第一个节点</span></span><br><span class="line">      <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 一.实现append方法</span></span><br><span class="line">      LinkList.prototype.append = <span class="keyword">data</span> =&gt; &#123;</span><br><span class="line">        <span class="comment">//1.创建新节点</span></span><br><span class="line">        let newNode = new Node(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加新节点</span></span><br><span class="line">        <span class="comment">//情况1：只有一个节点时候</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.length == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">this</span>.head = newNode</span><br><span class="line">        <span class="comment">//情况2：节点数大于1，在链表的最后添加新节点  </span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;              </span><br><span class="line">          <span class="comment">//让变量current指向第一个节点</span></span><br><span class="line">          let current = <span class="keyword">this</span>.head</span><br><span class="line">          <span class="comment">//当current.next(下一个节点不为空)不为空时，一直循环，直到current指向最后一个节点</span></span><br><span class="line">          <span class="keyword">while</span> (current.next)&#123;</span><br><span class="line">            current = current.next</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 最后节点的next指向新的节点</span></span><br><span class="line">          current.next = newNode</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.添加完新结点之后length+1</span></span><br><span class="line">        <span class="keyword">this</span>.length += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 二.实现toString方法</span></span><br><span class="line">      LinkList.prototype.toString = () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 1.定义变量</span></span><br><span class="line">        let current = <span class="keyword">this</span>.head</span><br><span class="line">        let listString = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.循环获取一个个的节点</span></span><br><span class="line">        <span class="keyword">while</span>(current)&#123; </span><br><span class="line">          listString += current.<span class="keyword">data</span> + <span class="string">&quot; &quot;</span></span><br><span class="line">          current = current.next<span class="comment">//千万不要忘了拼接完一个节点数据之后，让current指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  listString</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 三.实现insert方法</span></span><br><span class="line">      LinkList.prototype.insert = (position, <span class="keyword">data</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">//理解positon的含义：position=0表示新界点插入后要成为第1个节点，position=2表示新界点插入后要成为第3个节点</span></span><br><span class="line">        <span class="comment">//1.对position进行越界判断:要求传入的position不能是负数且不能超过LinkList的length</span></span><br><span class="line">        <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; <span class="keyword">this</span>.length)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.根据data创建newNode</span></span><br><span class="line">        let newNode = new Node(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.插入新节点</span></span><br><span class="line">        <span class="comment">//情况1：插入位置position=0</span></span><br><span class="line">        <span class="keyword">if</span>(position == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">// 让新节点指向第一个节点</span></span><br><span class="line">          newNode.next = <span class="keyword">this</span>.head</span><br><span class="line">          <span class="comment">// 让head指向新节点</span></span><br><span class="line">          <span class="keyword">this</span>.head = newNode</span><br><span class="line">        <span class="comment">//情况2：插入位置position&gt;0(该情况包含position=length)</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          let index = <span class="number">0</span></span><br><span class="line">          let previous = <span class="literal">null</span></span><br><span class="line">          let current = <span class="keyword">this</span>.head</span><br><span class="line">          <span class="comment">//步骤1：通过while循环使变量current指向position位置的后一个节点(注意while循环的写法)</span></span><br><span class="line">          <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">          <span class="comment">//步骤2：在current指向下一个节点之前，让previous指向current当前指向的节点</span></span><br><span class="line">            previous = current</span><br><span class="line">            current = current.next</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 步骤3：通过变量current(此时current已经指向position位置的后一个节点)，使newNode指向position位置的后一个节点</span></span><br><span class="line">          newNode.next = current</span><br><span class="line">          <span class="comment">//步骤4：通过变量previous，使position位置的前一个节点指向newNode</span></span><br><span class="line">          previous.next = newNode</span><br><span class="line">          </span><br><span class="line"><span class="comment">//我们无法直接操作链表中的节点，但是可以通过变量指向这些节点，以此间接地操作节点；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.新节点插入后要length+1</span></span><br><span class="line">        <span class="keyword">this</span>.length += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//四.实现get方法</span></span><br><span class="line">      LinkList.prototype.<span class="keyword">get</span> = (position) =&gt; &#123;</span><br><span class="line">        <span class="comment">//1.越界判断</span></span><br><span class="line">        <span class="comment">// 当position = length时，取到的是null所以0 =&lt; position &lt; length</span></span><br><span class="line">        <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.获取指定的positon位置的后一个节点的data</span></span><br><span class="line">        <span class="comment">//同样使用一个变量间接操作节点</span></span><br><span class="line">        let current = <span class="keyword">this</span>.head</span><br><span class="line">        let index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">          current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.<span class="keyword">data</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//五.实现indexOf方法</span></span><br><span class="line">      LinkList.prototype.indexOf = <span class="keyword">data</span> =&gt; &#123;</span><br><span class="line">        <span class="comment">//1.定义变量</span></span><br><span class="line">        let current = <span class="keyword">this</span>.head</span><br><span class="line">        let index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.开始查找:只要current不指向null就一直循环</span></span><br><span class="line">        <span class="keyword">while</span>(current)&#123;</span><br><span class="line">          <span class="keyword">if</span>(current.<span class="keyword">data</span> == <span class="keyword">data</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">          &#125;</span><br><span class="line">          current = current.next</span><br><span class="line">          index += <span class="number">1</span></span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.遍历完链表没有找到，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//六.实现update方法</span></span><br><span class="line">      LinkList.prototype.update = (position, newData) =&gt; &#123;</span><br><span class="line">        <span class="comment">//1.越界判断</span></span><br><span class="line">        <span class="comment">//因为被修改的节点不能为null，所以position不能等于length</span></span><br><span class="line">        <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.查找正确的节点</span></span><br><span class="line">        let current = <span class="keyword">this</span>.head</span><br><span class="line">        let index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">          current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.将position位置的后一个节点的data修改成newData</span></span><br><span class="line">        current.<span class="keyword">data</span> = newData</span><br><span class="line">        <span class="comment">//返回true表示修改成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//七.实现removeAt方法</span></span><br><span class="line">      LinkList.prototype.removeAt = position =&gt; &#123;</span><br><span class="line">        <span class="comment">//1.越界判断</span></span><br><span class="line">        <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line">        <span class="comment">//情况1：position = 0时(删除第一个节点)</span></span><br><span class="line">        let current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">if</span> (position ==<span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">//情况2：position &gt; 0时</span></span><br><span class="line">          <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          let index = <span class="number">0</span></span><br><span class="line">          let previous = <span class="literal">null</span></span><br><span class="line">          <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">            previous = current</span><br><span class="line">            current = current.next</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//循环结束后，current指向position后一个节点，previous指向current前一个节点</span></span><br><span class="line">          <span class="comment">//再使前一个节点的next指向current的next即可</span></span><br><span class="line">          previous.next = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3，length-1</span></span><br><span class="line">        <span class="keyword">this</span>.length -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回被删除节点的data，为此current定义在最上面</span></span><br><span class="line">        <span class="keyword">return</span> current.<span class="keyword">data</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------其他方法的实现--------------*/</span></span><br><span class="line">      <span class="comment">//八.实现remove方法</span></span><br><span class="line">      LinkList.prototype.remove = (<span class="keyword">data</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//1.获取data在列表中的位置</span></span><br><span class="line">        let position = <span class="keyword">this</span>.indexOf(<span class="keyword">data</span>)</span><br><span class="line">        <span class="comment">//2.根据位置信息，删除结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(position)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//九.实现isEmpty方法</span></span><br><span class="line">      LinkList.prototype.isEmpty = () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length == <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//十.实现size方法</span></span><br><span class="line">      LinkList.prototype.size = () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考资料:<a href="https://www.bilibili.com/video/BV1x7411L7Q7?from=search&seid=3912456004602554239">JavaScript数据结构与算法</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://aiolimp.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://aiolimp.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>IM聊天</title>
    <link href="http://aiolimp.com/2021/08/21/IM%E8%81%8A%E5%A4%A9/"/>
    <id>http://aiolimp.com/2021/08/21/IM%E8%81%8A%E5%A4%A9/</id>
    <published>2021-08-21T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.206Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="IM聊天"><a href="#IM聊天" class="headerlink" title="IM聊天"></a>IM聊天</h2><p>耗时三个月终于在公司完成了一个聊天系统的需求，过程很麻烦，但是经过自己的不断探索还是成功开发出来并且完美上线。这算是自己接触的一个比较完整的利用前端API进行的开发，所以在这里也做一个总结。</p><p>IM聊天主要利用的是腾讯云的<a href="https://cloud.tencent.com/document/product/269">即时通讯</a>进行消息功能实现。里面的<code>SDK</code>文档相当详细，也有不错的demo供开发者学习，能实现消息的发送、接收功能其实并不难和后端做好数据上的处理基本都可以实现，主要是公司的聊天系统需求比较复杂，一直在进行不断的迭代更新，包括后期实现的智能客服聊天系统、聊天远程控制功能等等。总体来说还是比较复杂，这里主要针对开发进行一个大致的总结，详细的可以在我的github看看<a href="https://github.com/Aiolimp/IM-VisitorMessage">源代码</a>以作参考。</p><p>项目主要针对web端实现IM聊天，可以看看<a href="https://cloud.tencent.com/document/product/269/37411">官方文档</a>提供的教程。</p><p><strong>聊天界面：</strong></p><p>客服端：</p><p><img src="https://img-blog.csdnimg.cn/55af7f5e2f03458caf85583696eeffe6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>访客端：</p><h3 id="初始化TIM"><a href="#初始化TIM" class="headerlink" title="初始化TIM"></a><strong>初始化TIM</strong></h3><p>接入前，您需要在 <a href="https://console.cloud.tencent.com/avc">云通信控制台</a> 中创建一个云通信应用，并取得 <code>SDKAppID</code>。</p><table><thead><tr><th align="left">API</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn//TIM.html#.create">create</a></td><td align="left">创建 SDK 实例。</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/utils/tim.js</span></span><br><span class="line"><span class="keyword">import</span> TIM <span class="keyword">from</span> <span class="string">&#x27;tim-js-sdk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> COS <span class="keyword">from</span> <span class="string">&quot;cos-js-sdk-v5&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tim</span> (<span class="params">SDKAppID</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> options = &#123;</span><br><span class="line">    SDKAppID: SDKAppID <span class="comment">// 接入时需要将0替换为您的即时通信 IM 应用的 SDKAppID</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 创建 SDK 实例，`TIM.create()`方法对于同一个 `SDKAppID` 只会返回同一份实例</span></span><br><span class="line">  <span class="keyword">let</span> tim = TIM.create(options); <span class="comment">// SDK 实例通常用 tim 表示</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置 SDK 日志输出级别，详细分级请参见 setLogLevel 接口的说明</span></span><br><span class="line">  tim.setLogLevel(<span class="number">1</span>); <span class="comment">// 普通级别，日志量较多，接入时建议使用</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注册 COS SDK 插件</span></span><br><span class="line">  tim.registerPlugin(&#123;<span class="string">&#x27;cos-js-sdk&#x27;</span>: COS&#125;);</span><br><span class="line">  <span class="keyword">return</span> tim</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> tim</span><br></pre></td></tr></table></figure><p><strong>在main.js中全局挂载：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  router</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./routes/routes&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Antd <span class="keyword">from</span> <span class="string">&quot;ant-design-vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./api/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> tim <span class="keyword">from</span> <span class="string">&#x27;./utils/tim&#x27;</span></span><br><span class="line"><span class="keyword">import</span> TIM <span class="keyword">from</span> <span class="string">&#x27;tim-js-sdk&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.tim = tim</span><br><span class="line">Vue.prototype.TIM = TIM</span><br><span class="line">Vue.prototype.$bus = <span class="keyword">new</span> Vue() <span class="comment">// event Bus 用于无关系组件间的通信。</span></span><br><span class="line">Vue.use(Antd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="登录相关"><a href="#登录相关" class="headerlink" title="登录相关"></a>登录相关</h3><p>1.首先初始化签名</p><p>使用 用户ID(userID) 和 签名串(userSig) 登录即时通信 IM，登录流程有若干个异步执行的步骤，使用返回的 Promise 对象处理登录成功或失败。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">login</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> promise = tim.login(&#123;</span><br><span class="line">       userID: <span class="string">&quot;your userID&quot;</span>,</span><br><span class="line">       userSig: <span class="string">&quot;your userSig&quot;</span>,</span><br><span class="line">     &#125;);</span><br><span class="line">     promise</span><br><span class="line">       .then(<span class="function"><span class="keyword">function</span> (<span class="params">imResponse</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(imResponse.data); <span class="comment">// 登录成功</span></span><br><span class="line">         <span class="keyword">if</span> (imResponse.data.repeatLogin === <span class="literal">true</span>) &#123;</span><br><span class="line">           /</span><br><span class="line">           <span class="built_in">console</span>.log(imResponse.data.errorInfo);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">       .catch(<span class="function"><span class="keyword">function</span> (<span class="params">imError</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.warn(<span class="string">&quot;login error:&quot;</span>, imError); <span class="comment">// 登录失败的相关信息</span></span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>2.登录成功后会触发 SDK_READY 事件，该事件触发后，可正常使用 SDK 接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">initListener</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 登录成功后会触发 SDK_READY 事件，该事件触发后，可正常使用 SDK 接口</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.SDK_READY,</span><br><span class="line">      <span class="built_in">this</span>.onReadyStateUpdate,</span><br><span class="line">      <span class="built_in">this</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// SDK NOT READT</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.SDK_NOT_READY,</span><br><span class="line">      <span class="built_in">this</span>.onReadyStateUpdate,</span><br><span class="line">      <span class="built_in">this</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 被踢出</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.KICKED_OUT,</span><br><span class="line">      <span class="built_in">this</span>.onKickOut</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// SDK内部出错</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(<span class="built_in">this</span>.TIM.EVENT.ERROR, <span class="built_in">this</span>.onError);</span><br><span class="line">    <span class="comment">// 收到新消息</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.MESSAGE_RECEIVED,</span><br><span class="line">      <span class="built_in">this</span>.onReceiveMessage</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 会话列表更新</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.CONVERSATION_LIST_UPDATED,</span><br><span class="line">      <span class="built_in">this</span>.onUpdateConversationList,</span><br><span class="line">      <span class="built_in">this</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>3.登出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">logout</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 若有当前会话，在退出登录时已读上报</span></span><br><span class="line">  <span class="keyword">if</span> (context.rootState.conversation.currentConversation.conversationID) &#123;</span><br><span class="line">    tim(store.state.basic.imInfo.sdkAppID).setMessageRead(&#123; <span class="attr">conversationID</span>:               context.rootState.conversation.currentConversation.conversationID &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  tim(store.state.basic.imInfo.sdkAppID).logout().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    context.commit(<span class="string">&#x27;toggleIsLogin&#x27;</span>)</span><br><span class="line">    context.commit(<span class="string">&#x27;stopComputeCurrent&#x27;</span>)</span><br><span class="line">    context.commit(<span class="string">&#x27;reset&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>消息类型主要分为自定义消息和普通消息。</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210818161849499.png" alt="image-20210818161849499"></p><h4 id="自定义消息："><a href="#自定义消息：" class="headerlink" title="自定义消息："></a><strong>自定义消息：</strong></h4><p>创建自定义消息实例的接口，此接口返回一个消息实例，当 SDK 提供的能力不能满足您的需求时，可以使用自定义消息进行个性化定制。</p><p>自定义消息需要和后端沟通定义子消息类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访客端发送自定义消息</span></span><br><span class="line">   <span class="function"><span class="title">sendCustomMessage</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> data1 = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">this</span>.sessionObj.serviceImAccount&amp;&amp;data1) &#123;</span><br><span class="line">       <span class="keyword">let</span> message = <span class="built_in">this</span>.tim(<span class="built_in">this</span>.imInfo.sdkAppID).createCustomMessage(&#123;</span><br><span class="line">         to: <span class="built_in">this</span>.sessionObj.serviceImAccount,</span><br><span class="line">         conversationType: <span class="built_in">this</span>.currentConversationType</span><br><span class="line">           ? <span class="built_in">this</span>.currentConversationType</span><br><span class="line">           : <span class="string">&quot;C2C&quot;</span>,</span><br><span class="line">         payload: &#123;</span><br><span class="line">           data: data1,</span><br><span class="line">           description: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           extension: <span class="string">&quot;&quot;</span>,</span><br><span class="line">         &#125;,</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="built_in">this</span>.tim(<span class="built_in">this</span>.imInfo.sdkAppID)</span><br><span class="line">         .sendMessage(message)</span><br><span class="line">         .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.$store.commit(<span class="string">&quot;pushCurrentMessageList&quot;</span>, message);</span><br><span class="line">         &#125;)</span><br><span class="line">         .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>利用自定义消息可以实现腾讯云文档中不包含的消息类型根据业务需求发送消息，比如实现智能客服自定义消息类型，远程消息类型等等。</p><h4 id="普通消息："><a href="#普通消息：" class="headerlink" title="普通消息："></a><strong>普通消息：</strong></h4><p>腾讯云接口文档有提供消息api,可以根据api进行消息的发送。</p><table><thead><tr><th align="left">API</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createTextMessage">createTextMessage</a></td><td align="left">创建文本消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createTextAtMessage">createTextAtMessage</a></td><td align="left">创建可以附带 @ 提醒功能的文本消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createImageMessage">createImageMessage</a></td><td align="left">创建图片消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createAudioMessage">createAudioMessage</a></td><td align="left">创建音频消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createVideoMessage">createVideoMessage</a></td><td align="left">创建视频消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createCustomMessage">createCustomMessage</a></td><td align="left">创建自定义消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createFaceMessage">createFaceMessage</a></td><td align="left">创建表情消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createFileMessage">createFileMessage</a></td><td align="left">创建文件消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createMergerMessage">createMergerMessage</a></td><td align="left">创建合并消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#downloadMergerMessage">downloadMergerMessage</a></td><td align="left">下载合并消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#sendMessage">sendMessage</a></td><td align="left">发送消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#revokeMessage">revokeMessage</a></td><td align="left">撤回消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#resendMessage">resendMessage</a></td><td align="left">重发消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#deleteMessage">deleteMessage</a></td><td align="left">删除消息。</td></tr></tbody></table><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><h4 id="获取消息列表。"><a href="#获取消息列表。" class="headerlink" title="获取消息列表。"></a>获取消息列表。</h4><p>分页拉取指定会话的消息列表的接口，当用户进入会话首次渲染消息列表或者用户“下拉查看更多消息”时，需调用该接口。</p><p>我这里做了点击’获取更多’获取历史消息，当前页面一次只加载20条消息，提升页面加载速度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法放在了vuex里，页面需要获取更多历史消息，调用vuex里的异步方法获取数据</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取消息列表</span></span><br><span class="line"><span class="comment">    * 调用时机：打开某一会话时或下拉获取历史消息时</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">conversationID</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="title">getMessageList</span>(<span class="params">context, conversationID</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (context.state.isCompleted) &#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">const</span> &#123;</span><br><span class="line">       nextReqMessageID,</span><br><span class="line">       currentMessageList</span><br><span class="line">     &#125; = context.state</span><br><span class="line">     tim(store.state.basic.imInfo.sdkAppID).getMessageList(&#123;</span><br><span class="line">       conversationID,</span><br><span class="line">       nextReqMessageID,</span><br><span class="line">       count: <span class="number">15</span></span><br><span class="line">     &#125;).then(<span class="function"><span class="params">imReponse</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&quot;getMessageList&quot;</span>, imReponse);</span><br><span class="line">       <span class="comment">// 更新messageID，续拉时要用到</span></span><br><span class="line">       context.state.nextReqMessageID = imReponse.data.nextReqMessageID</span><br><span class="line">       context.state.isCompleted = imReponse.data.isCompleted</span><br><span class="line">       <span class="comment">// 更新当前消息列表，从头部插入</span></span><br><span class="line">       context.state.currentMessageList = [...imReponse.data.messageList, ...currentMessageList]</span><br><span class="line">       context.state.pageList = [...imReponse.data.messageList]</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h4 id="获取会话列表。"><a href="#获取会话列表。" class="headerlink" title="获取会话列表。"></a>获取会话列表。</h4><p>获取会话列表的接口，该接口会尝试同步最新的100条会话，在同步完成后返回 SDK 内部维护的会话列表。 调用时机：需要刷新会话列表时</p><p>注意：会话保存时长跟会话最后一条消息保存时间一致，消息默认保存7天，即会话默认保存7天。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拉取会话列表</span></span><br><span class="line"><span class="keyword">let</span> promise = tim.getConversationList();</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">imResponse</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> conversationList = imResponse.data.conversationList; <span class="comment">// 会话列表，用该列表覆盖原有的会话列表</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">imError</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">&#x27;getConversationList error:&#x27;</span>, imError); <span class="comment">// 获取会话列表失败的相关信息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="获取会话资料。"><a href="#获取会话资料。" class="headerlink" title="获取会话资料。"></a>获取会话资料。</h4><p>获取会话资料的接口，当点击会话列表中的某个会话时，调用该接口获取会话的详细信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = tim.getConversationProfile(conversationID);promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">imResponse</span>) </span>&#123;  <span class="comment">// 获取成功  console.log(imResponse.data.conversation); // 会话资料&#125;).catch(function(imError) &#123;  console.warn(&#x27;getConversationProfile error:&#x27;, imError); // 获取会话资料失败的相关信息&#125;);</span></span><br></pre></td></tr></table></figure><h3 id="界面消息类型"><a href="#界面消息类型" class="headerlink" title="界面消息类型"></a>界面消息类型</h3><p>消息框中可以实现表情、图片、视频、文档消息发送。</p><p><img src="https://img-blog.csdnimg.cn/46b2b15f2ecf4ddaa7475cea0dac34df.png" alt="在这里插入图片描述"> </p><p><img src="https://img-blog.csdnimg.cn/641e00c18d43411fa315ed93729c4038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在<code>message-item</code>中定义每一条消息的发送样式，包括头像是否显示、是否是系统消息等等。通过组件的方式，给每一种消息类型定义不同的样式。</p><p><img src="https://img-blog.csdnimg.cn/9504060c07a44a51b91f97ac06f6a886.png" alt="在这里插入图片描述"> </p><p><img src="https://img-blog.csdnimg.cn/37c7815a691045f2956e6ded65acb666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/fe9d4a9ec1e8490bb87e052aded2b439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">avatar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.currentConversation.type === <span class="string">&quot;C2C&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isMine) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sessionObj.guestAvatar;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sessionObj.serviceAvatar;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.currentConversation.type === <span class="string">&quot;GROUP&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.isMine</span><br><span class="line">        ? <span class="built_in">this</span>.currentUserProfile.avatar</span><br><span class="line">        : <span class="built_in">this</span>.message.avatar;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">currentConversationType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.currentConversation.type;</span><br><span class="line">  &#125;,<span class="comment">//头像</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">isMine</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(this.message.from,this.imInfo.userID,this.message.from == this.imInfo.userID)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.message.from == <span class="built_in">this</span>.sessionObj.guestImAccount;</span><br><span class="line">  &#125;,<span class="comment">//是否是自己发的消息</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">messagePosition</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      [<span class="string">&quot;TIMGroupTipElem&quot;</span>, <span class="string">&quot;TIMGroupSystemNoticeElem&quot;</span>].includes(</span><br><span class="line">        <span class="built_in">this</span>.message.type</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;position-center&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.message.type == <span class="string">&quot;TIMCustomElem&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="built_in">this</span>.message.payload.data.subMsgType == <span class="string">&quot;prompts&quot;</span> ||</span><br><span class="line">        <span class="built_in">this</span>.message.payload.data.subMsgType == <span class="string">&quot;transfer&quot;</span> ||</span><br><span class="line">        <span class="built_in">this</span>.message.payload.data.subMsgType == <span class="string">&quot;reception&quot;</span> ||</span><br><span class="line">        <span class="built_in">this</span>.message.payload.data.subMsgType == <span class="string">&quot;stopsession&quot;</span> ||</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;position-center&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.message.isRevoked) &#123;</span><br><span class="line">      <span class="comment">// 撤回消息</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;position-center&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isMine) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;position-right&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;position-left&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,    <span class="comment">//消息位置</span></span><br></pre></td></tr></table></figure><h3 id="智能客服会话"><a href="#智能客服会话" class="headerlink" title="智能客服会话"></a>智能客服会话</h3><p>在<code>message-item</code>中定义定义自定义消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 智能客服自定义热度问题 --&gt;</span><br><span class="line">&lt;custom-heatquestion</span><br><span class="line">  v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">&quot;message.subMsgType === &#x27;heatquestion&#x27;&quot;</span></span><br><span class="line">  :isMine=<span class="string">&quot;isMine&quot;</span></span><br><span class="line">  :payload=<span class="string">&quot;message.msgContent&quot;</span></span><br><span class="line">  :message=<span class="string">&quot;message&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;!-- 智能客服自定义相似问题 --&gt;</span><br><span class="line">&lt;custom-similarquestion</span><br><span class="line">  v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">&quot;message.subMsgType === &#x27;similarquestion&#x27;&quot;</span></span><br><span class="line">  :isMine=<span class="string">&quot;isMine&quot;</span></span><br><span class="line">  :payload=<span class="string">&quot;message.msgContent&quot;</span></span><br><span class="line">  :message=<span class="string">&quot;message&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;!-- 智能客服自定义查看指定问题 --&gt;</span><br><span class="line">&lt;custom-specifiedquestion</span><br><span class="line">  v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">&quot;message.subMsgType === &#x27;specifiedquestion&#x27;&quot;</span></span><br><span class="line">  :isMine=<span class="string">&quot;isMine&quot;</span></span><br><span class="line">  :payload=<span class="string">&quot;message.msgContent&quot;</span></span><br><span class="line">  :message=<span class="string">&quot;message&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>界面上判断是否开启智能客服，通过维护知识库内容实现点击问题进行回答：</p><p><img src="https://img-blog.csdnimg.cn/75b09b5a991a43bea705315d8afedf29.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/021c2af7ae084281a07423fa7a549dfd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>点击<strong>转人工</strong>按钮可以接通人工客服。</p><h3 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h3><p>远程控制功能主要以客户端插件的方式实现客服控制访客桌面，进行远程控制。</p><p>这里采用了向日葵的远程插件，使用者需要先申请创建<code>APPID</code> 和<code> APP KEY</code>。</p><p>大致流程图：</p><p>远程控制主要是客服端向访客发起，访客可以选择接受或者拒绝，并且和实时系统消息进行关联，分为远程开始、进行中、结束以及访客拒绝。</p><p><img src="https://img-blog.csdnimg.cn/c5cd062ace4843f6a5593dc6a6bf29ff.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/677770e93c0d46148455176133d0c6f5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/fc0d9a80cb0a440cad593258efbf39f3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/7846ceb741364702a89a5b6e35f9e4e1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>远程进行中会进行轮巡判断当前远程是否进行，否则关闭远程。</p><p>这里主要也是以自定义消息进行远程会话，然后调用客户端方法打开插件。源码中使用了<code>external.calld</code>的方法都是调用了后端的客户端方法，需要实现的小伙伴需要和后端进行沟通。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="IM聊天" scheme="http://aiolimp.com/categories/IM%E8%81%8A%E5%A4%A9/"/>
    
    
    <category term="IM聊天" scheme="http://aiolimp.com/tags/IM%E8%81%8A%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>module、chunk和bundle</title>
    <link href="http://aiolimp.com/2021/08/12/module%E3%80%81chunk%E5%92%8Cbundle/"/>
    <id>http://aiolimp.com/2021/08/12/module%E3%80%81chunk%E5%92%8Cbundle/</id>
    <published>2021-08-12T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.212Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="module、chunk和bundle"><a href="#module、chunk和bundle" class="headerlink" title="module、chunk和bundle"></a>module、chunk和bundle</h1><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>先看看<code>webpack</code>官方对<code>module</code>的解读：</p><blockquote><p><code>Module</code>是离散功能块，相比于完整程序提供了更小的接触面。精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。</p></blockquote><p>其实简单来说，<code>module</code>模块就是我们编写的代码文件，比如<code>JavaScript</code>文件、<code>CSS</code>文件、<code>Image</code>文件、<code>Font</code>文件等等，它们都是属于<code>module</code>模块。而<code>module</code>模块的一个特点，就是可以被引入使用。</p><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>同样的先看看官方解读：</p><blockquote><p>此 <code>webpack</code> 特定术语在内部用于管理捆绑过程。输出束（bundle）由块组成，其中有几种类型（例如 <code>entry</code> 和 <code>child</code> ）。通常，块直接与输出束 (<code>bundle</code>）相对应，但是，有些配置不会产生一对一的关系</p></blockquote><p>其实<code>chunk</code>是<code>webpack</code>打包过程的中间产物，<code>webpack</code>会根据文件的引入关系生成<code>chunk</code>，也就是说一个<code>chunk</code>是由一个<code>module</code>或多个<code>module</code>组成的，这取决于有没有引入其他的<code>module</code>。</p><h3 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h3><p>先看看官方解读：</p><blockquote><p><code>bundle</code> 由许多不同的模块生成，包含已经经过加载和编译过程的源文件的最终版本。</p></blockquote><p><code>bundle</code>其实是<code>webpack</code>的最终产物，通常来说，一个<code>bundle</code>对应这一个<code>chunk</code>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实<code>module</code>、<code>chunk</code>和<code>bundle</code>可以说是同一份代码在不同转换场景的不同名称：</p><ul><li>我们编写的是<code>module</code></li><li><code>webpack</code>处理时时<code>chunk</code></li><li>最终生成供使用的是<code>bundle</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="webpack" scheme="http://aiolimp.com/categories/webpack/"/>
    
    
    <category term="webpack" scheme="http://aiolimp.com/tags/webpack/"/>
    
  </entry>
  
</feed>
