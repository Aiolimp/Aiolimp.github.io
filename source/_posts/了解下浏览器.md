---
title: 了解下浏览器
date: 2021-04-12 12:23:57
top_img: https://static001.geekbang.org/resource/image/82/af/823ef28a64096b4ffce19bca16a573af.jpg
cover: https://static001.geekbang.org/resource/image/82/af/823ef28a64096b4ffce19bca16a573af.jpg
tags:
- 浏览器
categories:
- 浏览器
aplayer: true
---

# 浏览器

### 渲染引擎

**渲染引擎**又名**浏览器内核**，指负责对网页语法解析并渲染成一张可视化页面的解析器。它是浏览器最核心最重要的部位，不同内核对网页语法的解析也有不同，因此同一网页语法在不同内核的浏览器中的渲染效果也可能不同，这就是常说的**浏览器差异性**。

上述提到的世界五大浏览器，在自身的发展过程中都使用了一种或多种浏览器内核作为自身的渲染引擎。

-  **Google Chrome**：Webkit(前期)、Blink(后期)
-  **Apple Safari**：Webkit
-  **Mozilla Firefox**：Gecko
-  **ASA Opera**：Presto(前期)、Blink(后期)
-  **Microsoft IExplorer**：Trident
-  **Microsoft Edge**：Trident(前期)、Blink(后期)

因此20多年的浏览器发展史里，被大规模使用的浏览器内核也就这五个。

-  **Blink内核**：由谷歌公司和欧朋公司合作自研的内核，同时谷歌公司也将其作为开源内核架构`Chromium`的一部分发布，在`Chrome 28+`和`Opear 15+`中被使用。
-  **Webkit内核**：由苹果公司自研的内核，同时也是`Blink内核`的原型，在`Chrome 1 ~ 28`和`Safari 1+`中被使用。
-  **Gecko内核**：由网景公司自研的内核，先期在`Navigator`中使用，后期推广到`Firefox`上，在`Firefox 1+`中被使用。
-  **Presto内核**：由欧朋公司自研的内核，其渲染性能达到极致但牺牲了兼容性，目前已经废弃，在`Opear 7 ~ 14`中被使用。
-  **Trident内核**：由微软公司自研的内核，由于其被包含在全世界使用率最高的`Windows操作系统`中，导致十多年时间里一直称霸浏览器内核界，在`IExplorer 4+`中被使用。

### 渲染过程

要了解浏览器页面的渲染过程，首先得知道`关键渲染路径`。**关键渲染路径**指浏览器从最初接收请求得到HTML、CSS、JS等资源，然后解析、构建、渲染、布局、绘制、合成，到最后呈现在用户眼前界面的整个过程。

笔者将关键渲染路径划分理解，页面的渲染过程分为以下几部分。

- **解析文件**
  - 将`html文件`转换为DOM树
  - 将`css文件`转换为CSSOM树
  - 将DOM树和CSSOM树合并生成渲染树
- **绘制图层**
  - 根据渲染树生成布局渲染树(`回流`)
  - 根据布局渲染树生成绘制渲染树(`重绘`)
- **合成图层**：根据绘制渲染树合成图层显示在屏幕上

##### 解析文件

HTML文档描述一个页面的结构，浏览器通过`HTML解析器`将HTML解析成`DOM树`结构。HTML文档中所有内容皆为节点，各节点间拥有层级关系，彼此相连，构成DOM树。构建`DOM树`的过程：读取HTML文档的**字节**(Bytes)，将字节转换成**字符**(Chars)，依据字符确定**标签**(Tokens)，将标签转换成**节点**(Nodes)，以节点为基准构建**DOM树**。

CSS文档描述一个页面的表现，浏览器通过`CSS解析器`将CSS解析成`CSSOM树`结构，与DOM树结构比较像。CSS文档中所有内容皆为节点，与HTML文档中的节点一一对应，各节点间拥有层级关系，彼此相连，构成CSSOM树。构建`CSSOM树`的过程：读取CSS文档的**字节**(Bytes)，将字节转换成**字符**(Chars)，依据字符确定**标签**(Tokens)，将标签转换成**节点**(Nodes)，以节点为基准构建**CSSOM树**。与DOM树的构建过程完全一致。

在构建DOM树的过程中，当`HTML解析器`遇到``时会立即阻塞DOM树的构建，将控制权移交给浏览器的`JS引擎`，等到`JS引擎`运行完毕，浏览器才会从中断的地方恢复DOM树的构建。``的脚本加载完成后，`JS引擎`通过`DOM API`和`CSSOM API`操作DOM树和CSSOM树。为何会产生**渲染阻塞**呢？其根本原因在于：JS操作DOM后，浏览器无法预测未来DOM的具体内容，为了防止无效操作和节省资源，只能阻塞DOM树的构建。

![1619766148465](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1619766148465.png)

 浏览器的`渲染引擎`将DOM树和CSSOM树合并生成渲染树，只渲染需显示的节点及其样式。**DOM树**、**CSSOM树**和**渲染树**三者的构建并无`先后条件`和`先后顺序`，并非完全独立而是会有交叉并行构建的情况。因此会形成一边加载，一边解析，一边渲染的工作现象。 

##### 绘制图层

进入绘制阶段，遍历渲染树，调用渲染器的`paint()`在屏幕上绘制内容。根据渲染树布局计算样式，即每个节点在页面中的布局、尺寸等几何属性。HTML默认是流式布局，CSS和JS会打破这种布局，改变DOM的几何属性和外观属性。在绘制过程中，根据渲染树布局，再根据布局绘制，这就是常听常说的**回流重绘**。

在此涉及到两个核心概念：**回流**、**重绘**。笔者用两句精简的话分别概括它们。

- **回流**：几何属性需改变的渲染
- **重绘**：更改外观属性而不影响几何属性的渲染

当生成渲染树后，至少会渲染一次。在后续交互过程中，还会不断地重新渲染。这时只会`回流重绘`或`只有重绘`。因此引出一个定向法则：**回流必定引发重绘，重绘不一定引发回流**。

在下一章中，笔者会安排整章篇幅讲解**回流重绘**以及如何让回流重绘的影响最小化。相信下一章提及的**属性排序**应该比较少同学了解过或使用过，敬请期待。

##### 合成图层

将回流重绘生成的图层逐张合并并显示在屏幕上。上述几个步骤并不是一次性顺序完成的，若DOM或CSSOM被修改，上述过程会被重复执行。实际上，CSS和JS往往会多次修改DOM或CSSOM，简单来说就是用户的交互操作引发了网页的重渲染。

### 兼容性

 **兼容性**又名`网站兼容性`或`网页兼容性`，指网页在各种浏览器上的显示效果可能不同而产生浏览器和网页间的兼容问      题。 

 处理CSS兼容性的三种方式 :

##### 磨平浏览器默认样式

 每个浏览器的CSS默认样式不尽相同，所以最简单最有效的方式就是`对其默认样式初始化` 。

```css
* {
    margin: 0;
    padding: 0;
}
```

 可以接入其他`css文件`前将其导入 ，也可以自定义默认样式。

##### 插入浏览器私有属性

 通常编写CSS都会在一些CSS3属性前加入`-webkit-`、`-moz-`、`-ms-`或`-o-`，这些奇形怪状写到手软的东西就是**浏览器私有属性** 。

```css
/* Chrome、Safari、New Opera、New Edge */
-webkit-transform: translate(10px, 10px);
/* Firefox */
-moz-transform: translate(10px, 10px);
/* IExplorer、Old Edge */
-ms-transform: translate(10px, 10px);
/* Old Opera */
-o-transform: translate(10px, 10px);
/* 标准 */
transform: translate(10px, 10px);
```

 每个CSS3属性都编写这么一堆兼容性代码，无疑是对生命最大的浪费。在使用Webpack打包项目代码的过程中，可接入[postcss-loader](https://github.com/postcss/postcss-loader)和[postcss-preset-env](https://github.com/csstools/postcss-preset-env)，`postcss-preset-env`内置了`autoprefixer`，它会依据`Caniuse`所提供的数据对代码里的CSS3属性批量添加私有属性。 

##### CSS Hack

 **CSS Hack**指针对不同浏览器编写不同CSS，让它能够同时兼容不同浏览器，在不同浏览器中渲染想要的效果。当然也可反过来利用`CSS Hack`为不同版本的浏览器定制不同效果。 (现在不推荐使用)

```
.elem {
    background-color: #f66; /* IExplorer 8+ */
    *background-color: #f66; /* IExplorer 7 */
    _background-color: #f66; /* IExplorer 6 */
}
```


