---
title: 回流和重绘
date: 2021-03-23 16:57:49
top_img: https://static001.geekbang.org/resource/image/7a/30/7a9547384cffa039f063db1fc7669a30.jpg
cover: https://static001.geekbang.org/resource/image/7a/30/7a9547384cffa039f063db1fc7669a30.jpg
tags:
- CSS
categories:
- CSS
aplayer: true
---
# 回流和重绘

在浏览器的渲染过程里的**回流**和**重绘**是CSS中很重要的概念。了解和认识它们，可编写出性能更好的CSS代码。 

### 回流

**回流**又名**重排**，指`几何属性`需改变的渲染。但感觉回流这个词比较高大上，后续统称回流吧。

可理解成，将整个网页填白，对内容重新渲染一次。只不过以人眼的感官速度去看浏览器回流是不会有任何变化的，若你拥有`闪电侠`的感官速度去看浏览器回流(`实质是将时间调慢`)，就会发现每次回流都会将页面清空，再从左上角第一个像素点从左到右从上到下这样一点一点渲染，直至右下角最后一个像素点。每次回流都会呈现该过程，只是感受不到而已。

渲染树的节点发生改变，影响了该节点的几何属性，导致该节点位置发生变化，此时就会触发浏览器回流并重新生成渲染树。回流意味着节点的几何属性改变，需重新计算并生成渲染树，导致渲染树的全部或部分发生变化。

### 重绘

**重绘**指更改`外观属性`而不影响`几何属性`的渲染。相比回流，重绘在两者中会温和一些，后续谈到的CSS性能优化就会基于该特点展开。

渲染树的节点发生改变，但不影响该节点的几何属性。由此可见，回流对浏览器性能的消耗是高于重绘的，而且回流一定会伴随重绘，重绘却不一定伴随回流。

为何回流一定会伴随重绘呢？整个节点的位置都变了，肯定要重新渲染它的外观属性啊！

### 属性分类

-  几何属性：包括布局、尺寸等可用数学几何衡量的属性
   - 布局：`display`、`float`、`position`、`list`、`table`、`flex`、`columns`、`grid`
   - 尺寸：`margin`、`padding`、`border`、`width`、`height`
-  外观属性：包括界面、文字等可用状态向量描述的属性
   - 界面：`appearance`、`outline`、`background`、`mask`、`box-shadow`、`box-reflect`、`filter`、`opacity`、`clip`
   - 文字：`text`、`font`、`word`

### 性能优化

 **回流重绘**在操作节点样式时频繁出现，同时也存在很大程度上的性能问题。`回流成本比重绘成本高得多`，一个节点的回流很有可能导致子节点、兄弟节点或祖先节点的回流。在一些高性能电脑上也许无什么影响，但回流发生在手机上，就会`减缓加载速度`和`增加电量消耗`。 

 **回流必定引发重绘，重绘不一定引发回流**，可利用该法则解决一些因为回流重绘而引发的性能问题。 

- 改变窗口大小
- 修改盒模型
- 增删样式
- 重构布局
- 重设尺寸
- 改变字体
- 改动文字

 回流重绘其实与浏览器的**事件循环**有关。

- 浏览器刷新频率为`60Hz`，即每`16.6ms`更新一次
- `事件循环`执行完成`微任务`
- 判断`document`是否需更新
- 判断`resize/scroll`事件是否存在，存在则触发事件
- 判断`Media Query`是否触发
- 更新动作并发送事件
- 判断`document.isFullScreen`是否为`true`(全屏)
- 执行`requestAnimationFrame`回调
- 执行`IntersectionObserver`回调
- 更新界面

上述就是浏览器每一帧中可能会做到的事情，若在一帧中有空闲时间，就会执行`requestIdleCallback`回调。

 通过定向法则**回流必定引发重绘，重绘不一定引发回流**可知道，尽量减少回流重绘，就是CSS性能优化中一个很好的指标。 

###  如何减少和避免回流重绘 

#### 使用visibility:hidden替换display:none

对比`display:none`和`visibility:hidden`：

- 占位表现
  - `display:none`不占据空间
  - `visibility:hidden`占据空间
- 触发影响
  - `display:none`触发回流重绘
  - `visibility:hidden`触发重绘
- 过渡影响
  - `display:none`影响过渡不影响动画
  - `visibility:hidden`不影响过渡不影响动画
- 株连效果
  - `display:none`后自身及其子节点全都不可见
  - `visibility:hidden`后自身及其子节点全都不可见但可声明子节点`visibility:visible`单独显示

两者的`占位表现`、`触发影响`和`株连效果`就能说明`visibility:hidden`代替`display:none`的好处，从两者区别中就能找出恰当的答案了。

#### 使用transform代替top

`top`是几何属性，操作`top`会改变节点位置从而引发回流，使用`transform:translate3d(x,0,0)`代替`top`，只会引发图层重绘，还会间接启动GPU加速。

#### 避免使用Table布局

`牵一发而动全身`用在Table布局身上就很适合了，可能很小的一个改动就会造成整个回流，

通常可用``、``和``等标签取代``系列标签生成表格。

#### 避免规则层级过多

浏览器的`CSS解析器`解析`css文件`时，对CSS规则是从右到左匹配查找，样式层级过多会影响回流重绘效率，建议保持CSS规则在`3层`左右。

#### 避免节点属性值放在循环里当成循环变量

```javascript
for (let i = 0; i < 10000; i++) {
    const top = document.getElementById("css").style.top;
    console.log(top);
}
```

 每次循环操作DOM都会发生回流，应该在循环外使用变量保存一些不会变化的DOM映射值。 

```javascript
const top = document.getElementById("css").style.top;
for (let i = 0; i < 10000; i++) {
    console.log(top);
}
```

#### 动态改变类而不改变样式

不要尝试每次操作DOM去改变节点样式，这样会频繁触发回流。

更好的方式是使用新的类名预定义节点样式，在执行逻辑操作时收集并确认最终更换的类名集合，在适合时机一次性动态替换原来的类名集合。（可以使用方法[classList](https://www.runoob.com/jsref/prop-element-classlist.html)）

