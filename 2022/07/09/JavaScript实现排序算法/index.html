<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>JavaScript实现排序算法 | Aiolimp</title><meta name="author" content="Aiolimp"><meta name="copyright" content="Aiolimp"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaScript实现排序算法一、大O表示法大O表示法：  在计算机中采用粗略的度量来描述计算机算法的效率，这种方法被称为“大O”表示法 在数据项个数发生改变时，算法的效率也会跟着改变。所以说算法A比算法B快两倍，这样的比较是没有意义的。 因此我们通常使用算法的速度随着数据量的变化会如何变化的方式来表示算法的效率，大O表示法就是方式之一。  常见的大O表示形式    符号 名称    O（1）">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript实现排序算法">
<meta property="og:url" content="http://aiolimp.com/2022/07/09/JavaScript%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Aiolimp">
<meta property="og:description" content="JavaScript实现排序算法一、大O表示法大O表示法：  在计算机中采用粗略的度量来描述计算机算法的效率，这种方法被称为“大O”表示法 在数据项个数发生改变时，算法的效率也会跟着改变。所以说算法A比算法B快两倍，这样的比较是没有意义的。 因此我们通常使用算法的速度随着数据量的变化会如何变化的方式来表示算法的效率，大O表示法就是方式之一。  常见的大O表示形式    符号 名称    O（1）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/9f/28/9f68cbdfd275739a1cd3a4dfa85ead28.jpg">
<meta property="article:published_time" content="2022-07-09T02:23:20.000Z">
<meta property="article:modified_time" content="2023-03-05T14:22:22.214Z">
<meta property="article:author" content="Aiolimp">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/9f/28/9f68cbdfd275739a1cd3a4dfa85ead28.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://aiolimp.com/2022/07/09/JavaScript%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript实现排序算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-05 22:22:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Aiolimp" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-archive"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-folder-open"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-link"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Aiolimp"><span class="site-name">Aiolimp</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-archive"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-folder-open"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-link"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JavaScript实现排序算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-09T02:23:20.000Z" title="发表于 2022-07-09 10:23:20">2022-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-05T14:22:22.214Z" title="更新于 2023-03-05 22:22:22">2023-03-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript实现排序算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="JavaScript实现排序算法"><a href="#JavaScript实现排序算法" class="headerlink" title="JavaScript实现排序算法"></a>JavaScript实现排序算法</h2><h3 id="一、大O表示法"><a href="#一、大O表示法" class="headerlink" title="一、大O表示法"></a>一、大O表示法</h3><p><strong>大O表示法：</strong></p>
<ul>
<li>在计算机中采用<strong>粗略的度量</strong>来描述计算机算法的<strong>效率</strong>，这种方法被称为<strong>“大O”表示法</strong></li>
<li>在<strong>数据项个数</strong>发生改变时，<strong>算法的效率</strong>也会跟着改变。所以说算法A比算法B快两倍，这样的比较是<strong>没有意义</strong>的。</li>
<li>因此我们通常使用<strong>算法的速度</strong>随着<strong>数据量的变化</strong>会如何变化的方式来表示算法的效率，大O表示法就是方式之一。</li>
</ul>
<p><strong>常见的大O表示形式</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>O（1）</td>
<td>常数</td>
</tr>
<tr>
<td>O（log(n)）</td>
<td>对数</td>
</tr>
<tr>
<td>O（n）</td>
<td>线性</td>
</tr>
<tr>
<td>O（nlog(n)）</td>
<td>线性和对数乘积</td>
</tr>
<tr>
<td>O（n²）</td>
<td>平方</td>
</tr>
<tr>
<td>O（2n）</td>
<td>指数</td>
</tr>
</tbody></table>
<p><strong>不同大O形式的时间复杂度：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png" alt="image-20200304164951223"></a></p>
<p>可以看到效率从大到小分别是：O（1）&gt; O（logn）&gt; O（n）&gt; O（nlog(n)）&gt; O（n²）&gt; O（2n）</p>
<p><strong>推导大O表示法的三条规则：</strong></p>
<ul>
<li><strong>规则一</strong>：用常量1取代运行时间中所有的加法常量。如7 + 8 = 15，用1表示运算结果15，大O表示法表示为O（1）；</li>
<li><strong>规则二</strong>：运算中只保留最高阶项。如N^3 + 3n +1，大O表示法表示为：O（N3）;</li>
<li><strong>规则三</strong>：若最高阶项的常数不为1，可将其省略。如4N2，大O表示法表示为：O（N2）;</li>
</ul>
<h3 id="二、排序算法"><a href="#二、排序算法" class="headerlink" title="二、排序算法"></a>二、排序算法</h3><p>这里主要介绍几种简单排序和高级排序：</p>
<ul>
<li><strong>简单排序：</strong>冒泡排序、选择排序、插入排序；</li>
<li><strong>高级排序：</strong>希尔排序、快速排序；</li>
</ul>
<p>此处创建一个列表类ArrayList并添加一些属性和方法，用于存放这些排序方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建列表类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="built_in">this</span>.array = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="comment">//封装将数据插入到数组中方法</span></span><br><span class="line">  ArrayList.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.array.push(item)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//toString方法</span></span><br><span class="line">  ArrayList.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.array.join(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//交换两个位置的数据</span></span><br><span class="line">  ArrayList.prototype.swap = <span class="function"><span class="keyword">function</span>(<span class="params">m, n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp  = <span class="built_in">this</span>.array[m]</span><br><span class="line">    <span class="built_in">this</span>.array[m] = <span class="built_in">this</span>.array[n]</span><br><span class="line">    <span class="built_in">this</span>.array[n] = temp</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><p><strong>冒泡排序的思路：</strong></p>
<ul>
<li>对未排序的各元素<strong>从头到尾</strong>依次比较<strong>相邻的两个元素</strong>大小关系；</li>
<li>如果<strong>左边的人员高</strong>，则将两人<strong>交换位置</strong>。比如1比2矮，不交换位置；</li>
<li>向<strong>右移动一位</strong>，继续比较2和3，最后比较 length - 1 和 length - 2这两个数据；</li>
<li>当到达<strong>最右端</strong>时，<strong>最高的人</strong>一定被放在了<strong>最右边</strong>；</li>
<li>按照这个思路，从最左端重新开始时，只需要走到<strong>倒数第二个位置</strong>即可；</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.png" alt="image-20200304191223265"></a></p>
<p><strong>实现思路：</strong></p>
<p>两层循环：</p>
<ul>
<li>外层循环控制冒泡趟数：<ul>
<li>第一次：j = length - 1，比较到倒数第一个位置 ；</li>
<li>第二次：j = length - 2，比较到倒数第二个位置 ；</li>
</ul>
</li>
<li>内层循环控制每趟比较的次数：<ul>
<li>第一次比较： i = 0，比较 0 和 1 位置的两个数据；</li>
<li>最后一次比较：i = length - 2,比较length - 2和 length - 1两个数据；</li>
</ul>
</li>
</ul>
<p>详细过程如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.png" alt="image-20200304210611689"></a></p>
<p>动态过程：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/4.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/4.gif" alt="img"></a></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;冒泡排序</span><br><span class="line">ArrayList.prototype.bubblesor &#x3D; function()&#123;</span><br><span class="line">  &#x2F;&#x2F;1.获取数组的长度</span><br><span class="line">  let length &#x3D; this.array.length</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;外层循环控制冒泡趟数</span><br><span class="line">  for(let j &#x3D; length - 1; j &gt;&#x3D; 0; j--)&#123;</span><br><span class="line">    &#x2F;&#x2F;内层循环控制每趟比较的次数</span><br><span class="line">    for(let i &#x3D; 0; i &lt; j; i++)&#123;</span><br><span class="line">    if (this.array[i] &gt; this.array[i+1]) &#123;</span><br><span class="line">      &#x2F;&#x2F;交换两个数据</span><br><span class="line">      let temp  &#x3D; this.array[i]</span><br><span class="line">  	this.array[i] &#x3D; this.array[i+1]</span><br><span class="line">  	this.array[i+1] &#x3D; temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试代码：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line">let list = new ArrayList()</span><br><span class="line"></span><br><span class="line">//插入元素</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">66</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">88</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">12</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">87</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">100</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">5</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">566</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">//验证冒泡排序</span><br><span class="line">list.bubblesor()</span><br><span class="line">console.<span class="built_in">log</span>(list);</span><br></pre></td></tr></table></figure>

<p><strong>测试结果：</strong><br><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5.png" alt="image-20200304210433388"></a></p>
<p><strong>冒泡排序的效率：</strong></p>
<ul>
<li>上面所讲的对于7个数据项，比较次数为：6 + 5 + 4 + 3 + 2 + 1;</li>
<li>对于N个数据项，<strong>比较次数</strong>为：(N - 1) + (N - 2) + (N - 3) + … + 1 = N * (N - 1) / 2；如果两次比较交换一次，那么<strong>交换次数</strong>为：N * (N - 1) / 4；</li>
<li>使用大O表示法表示比较次数和交换次数分别为：O（ N * (N - 1) / 2）和O（ N * (N - 1) / 4），根据大O表示法的三条规则都化简为：<strong>O（N^2）</strong>;</li>
</ul>
<h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h4><p><strong>选择排序改进了冒泡排序：</strong></p>
<ul>
<li>将<strong>交换次数</strong>由<strong>O（N^2）</strong>减小到<strong>O（N）</strong>；</li>
<li>但是<strong>比较次数</strong>依然是<strong>O（N^2）</strong>；</li>
</ul>
<p><strong>选择排序的思路：</strong></p>
<ul>
<li>选定<strong>第一个索引的位置</strong>比如1，然后依次和后面的元素<strong>依次进行比较</strong>；</li>
<li>如果后面的元素，<strong>小于</strong>索引1位置的元素，则<strong>交换位置</strong>到索引1处；</li>
<li>经过一轮的比较之后，可以确定一开始指定的索引1位置的元素是<strong>最小的</strong>；</li>
<li>随后使用同样的方法除索引1意外<strong>逐个比较剩下的元素</strong>即可；</li>
<li>可以看出选择排序，<strong>第一轮</strong>会选出<strong>最小值</strong>，<strong>第二轮</strong>会选出<strong>第二小的值</strong>，直到完成排序。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/6.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/6.png" alt="image-20200304213253241"></a></p>
<p><strong>实现思路：</strong></p>
<p>两层循环：</p>
<ul>
<li>外层循环控制指定的索引：<ul>
<li>第一次：j = 0，指定第一个元素 ；</li>
<li>最后一次：j = length - 1，指定最后一个元素 ；</li>
</ul>
</li>
<li>内层循环负责将指定索引（i）的元素与剩下（i - 1）的元素进行比较；</li>
</ul>
<p>动态过程：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/7.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/7.gif" alt="img"></a></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line">ArrayList.prototype.selectionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">let</span> length = <span class="built_in">this</span>.array.length</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.外层循环：从0开始获取元素</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">    <span class="keyword">let</span> min = j</span><br><span class="line">    <span class="comment">//内层循环：从i+1位置开始，和后面的元素进行比较</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = min + <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.array[min] &gt; <span class="built_in">this</span>.array[i]) &#123;</span><br><span class="line">      min = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.swap(min, j)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试代码：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line">let list = new ArrayList()</span><br><span class="line"></span><br><span class="line">//插入元素</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">66</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">88</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">12</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">87</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">100</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">5</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">566</span>)</span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">//验证选择排序</span><br><span class="line">list.selectionSort()</span><br><span class="line">console.<span class="built_in">log</span>(list);</span><br></pre></td></tr></table></figure>

<p><strong>测试结果：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/8.png" alt="image-20200304222224801"></a></p>
<p><strong>选择排序的效率：</strong></p>
<ul>
<li>选择排序的<strong>比较次数</strong>为：N * (N - 1) / 2，用大O表示法表示为：<strong>O（N^2）</strong>;</li>
<li>选择排序的<strong>交换次数</strong>为：(N - 1) / 2，用大O表示法表示为：<strong>O（N）</strong>;</li>
<li>所以选择排序的效率高于冒泡排序；</li>
</ul>
<h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h4><p>插入排序是简单排序中效率<strong>最高</strong>的一种排序。</p>
<p><strong>插入排序的思路：</strong></p>
<ul>
<li>插入排序思想的核心是<strong>局部有序</strong>。如图所示，X左边的人称为<strong>局部有序</strong>；</li>
<li>首先指定一数据X（从第一个数据开始），并将数据X的左边变成局部有序状态；</li>
<li>随后将X右移一位，再次达到局部有序之后，继续右移一位，重复前面的操作直至X移至最后一个元素。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/9.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/9.png" alt="image-20200304231400959"></a></p>
<p>插入排序的详细过程：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/10.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/10.png" alt="image-20200304231643777"></a></p>
<p>动态过程：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/11.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/11.gif" alt="img"></a></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line">ArrayList.prototype.insertionSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">let</span> length = <span class="built_in">this</span>.array.length</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.外层循环:从第二个数据开始，向左边的已经局部有序数据进行插入</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">    <span class="comment">//3.内层循环：获取i位置的元素，使用while循环(重点)与左边的局部有序数据依次进行比较</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">this</span>.array[i]</span><br><span class="line">    <span class="keyword">let</span> j = i</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.array[j - <span class="number">1</span>] &gt; temp &amp;&amp; j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.array[j] = <span class="built_in">this</span>.array[j - <span class="number">1</span>]<span class="comment">//大的数据右移</span></span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.while循环结束后，index = j左边的数据变为局部有序且array[j]最大。此时将array[j]重置为排序前的数据array[i]，方便下一次for循环</span></span><br><span class="line">    <span class="built_in">this</span>.array[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试代码：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line"> let list = new ArrayList()</span><br><span class="line"></span><br><span class="line"> //插入元素</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">66</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">88</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">12</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">87</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">100</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">5</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">566</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">23</span>)</span><br><span class="line"> // console.<span class="built_in">log</span>(list);</span><br><span class="line"></span><br><span class="line"> //验证插入排序</span><br><span class="line"> list.insertionSort()</span><br><span class="line"> console.<span class="built_in">log</span>(list);</span><br></pre></td></tr></table></figure>

<p><strong>测试结果：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/12.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/12.png" alt="image-20200304235529516"></a></p>
<p><strong>插入排序的效率：</strong></p>
<ul>
<li><strong>比较次数：</strong>第一趟时，需要的最大次数为1；第二次最大为2；以此类推，最后一趟最大为N-1；所以，插入排序的总比较次数为N * (N - 1) / 2；但是，实际上每趟发现插入点之前，平均只有全体数据项的一半需要进行比较，所以比较次数为：<strong>N * (N - 1) / 4</strong>；</li>
<li><strong>交换次数：</strong>指定第一个数据为X时交换0次，指定第二个数据为X最多需要交换1次，以此类推，指定第N个数据为X时最多需要交换N - 1次，所以一共需要交换N * (N - 1) / 2次，平局次数为<strong>N * (N - 1) / 2</strong>；</li>
<li>虽然用大O表示法表示插入排序的效率也是<strong>O（N^2）</strong>，但是插入排序整体操作次数更少，因此，在简单排序中，插入排序<strong>效率最高</strong>；</li>
</ul>
<h4 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h4><p><strong>希尔排序</strong>是<strong>插入排序</strong>的一种高效的<strong>改进版</strong>，效率比插入排序要<strong>高</strong>。</p>
<p><strong>希尔排序的历史背景：</strong></p>
<ul>
<li>希尔排序按其设计者希尔（Donald Shell）的名字命名，该算法由<strong>1959年公布</strong>；</li>
<li>希尔算法首次突破了计算机界一直认为的<strong>算法的时间复杂度都是O（N^2）</strong>的大关，为了纪念该算法里程碑式</li>
</ul>
<p>的意义，用<strong>Shell</strong>来命名该算法；</p>
<p><strong>插入排序的问题：</strong></p>
<ul>
<li>假设一个<strong>很小的数据项</strong>在<strong>很靠近右端的位置</strong>上，这里本应该是<strong>较大的数据项的位置</strong>；</li>
<li>将这个<strong>小数据项移动到左边</strong>的正确位置，所有的<strong>中间数据项都必须向右移动一位</strong>，这样效率非常低；</li>
<li>如果通过<strong>某种方式</strong>，不需要<strong>一个个移动所有中间的数据项</strong>，就能把较小的数据项移到左边，那么这个算法的执行速度就会有很大的改进。</li>
</ul>
<p><strong>希尔排序的实现思路：</strong></p>
<ul>
<li>希尔排序主要通过对数据进行<strong>分组</strong>实现快速排序；</li>
<li>根据设定的增量（gap）将数据分为gap个组（<strong>组数等于gap</strong>），再在每个分组中进行局部排序；</li>
</ul>
<blockquote>
<p>假如有数组有10个数据，第1个数据为黑色，增量为5。那么第二个为黑色的数据index=5，第3个数据为黑色的数据index = 10（不存在）。所以黑色的数据每组只有2个，10 / 2 = 5一共可分5组，即<strong>组数等于增量gap</strong>。</p>
</blockquote>
<ul>
<li>排序之后，减小增量，继续分组，再次进行局部排序，直到增量gap=1为止。随后只需进行微调就可完成数组的排序；</li>
</ul>
<p>具体过程如下：</p>
<ul>
<li>排序之前的，储存10个数据的原始数组为：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/13.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/13.png" alt="image-20200305102330304"></a></p>
<ul>
<li>设初始增量gap = length / 2 = 5，即数组被分为了5组，如图所示分别为：[8, 3]、[9, 5]、[1, 4]、[7, 6]、[2, 0]：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/14.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/14.png" alt="image-20200305104914438"></a></p>
<ul>
<li>随后分别在每组中对数据进行局部排序，5组的顺序如图所示，变为：[3, 8]、[5, 9]、[1, 4]、[6, 7]、[0, 2]：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/15.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/15.png" alt="image-20200305103136251"></a></p>
<ul>
<li>然后缩小增量gap = 5 / 2 = 2，即数组被分为了2组，如图所示分别为：[3，1，0，9，7]、[5，6，8，4，2]：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/16.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/16.png" alt="image-20200305104933858"></a></p>
<ul>
<li>随后分别在每组中对数据进行局部排序，两组的顺序如图所示，变为：[0，1，3，7，9]、[2，4，5，6，8]：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/17.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/17.png" alt="image-20200305103815262"></a></p>
<ul>
<li>然后然后缩小增量gap = 2 / 1 = 1，即数组被分为了1组，如图所示为：[0，2，1，4，3，5，7，6，9，8]：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/18.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/18.png" alt="image-20200305104847458"></a></p>
<ul>
<li>最后只需要对该组数据进行插入排序即可完成整个数组的排序：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/19.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/19.png" alt="image-20200305104707789"></a></p>
<p>动态过程：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20.gif" alt="img"></a></p>
<p>图中d表示增量gap。</p>
<p><strong>增量的选择：</strong></p>
<ul>
<li><strong>原稿</strong>中希尔建议的初始间距为<strong>N / 2</strong>，比如对于N = 100的数组，增量序列为：50，25，12，6，3，1，可以发现不能整除时向下取整。</li>
<li><strong>Hibbard增量序列：</strong>增量序列算法为：2^k - 1，即1，3，5，7… …等；这种情况的最坏复杂度为*<em>O（N3/2）*</em>,平均复杂度为**O（N5/4）**但未被证明；</li>
<li><strong>Sedgewcik增量序列：</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/21.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/21.png" alt="image-20200305110724309"></a></p>
<p>以下代码实现中采用希尔排序原稿中建议的增量即<strong>N / 2</strong> 。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line">ArrayList.prototype.shellSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.获取数组的长度</span></span><br><span class="line">  <span class="keyword">let</span> length = <span class="built_in">this</span>.array.length</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.初始化增量</span></span><br><span class="line">  <span class="keyword">let</span> gap = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.第一层循环：while循环(使gap不断减小)</span></span><br><span class="line">  <span class="keyword">while</span>(gap &gt;= <span class="number">1</span> )&#123;</span><br><span class="line">    <span class="comment">//4.第二层循环：以gap为增量，进行分组，对分组进行插入排序</span></span><br><span class="line">    <span class="comment">//重点为：将index = gap作为选中的第一个数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = gap; i &lt; length; i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> temp = <span class="built_in">this</span>.array[i]</span><br><span class="line">      <span class="keyword">let</span> j = i</span><br><span class="line">      <span class="comment">//5.第三层循环:寻找正确的插入位置</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="built_in">this</span>.array[j - gap] &gt; temp &amp;&amp; j &gt; gap - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.array[j] = <span class="built_in">this</span>.array[j - gap]</span><br><span class="line">        j -= gap</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//6.将j位置的元素设置为temp</span></span><br><span class="line">    <span class="built_in">this</span>.array[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里解释一下上述代码中的三层循环：</p>
<ul>
<li><strong>第一层循环：</strong>while循环，控制gap递减到1；</li>
<li><strong>第二层循环：</strong>分别取出根据g增量gap分成的gap组数据：将index = gap的数据作为选中的第一个数据，如下图所示，gap=5，则index = gap的数据为3，index = gap - 1的数据为8，两个数据为一组。随后gap不断加1右移，直到gap &lt; length，此时实现了将数组分为5组。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/21.5.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/21.5.png" alt="image-20200305104914438"></a></p>
<ul>
<li><strong>第三层循环：</strong>对每一组数据进行插入排序；</li>
</ul>
<p><strong>测试代码：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line"> let list = new ArrayList()</span><br><span class="line"></span><br><span class="line"> //插入元素</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">66</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">88</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">12</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">87</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">100</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">5</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">566</span>)</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">23</span>)</span><br><span class="line"> // console.<span class="built_in">log</span>(list);</span><br><span class="line"></span><br><span class="line"> //验证希尔排序</span><br><span class="line"> list.shellSort()</span><br><span class="line"> console.<span class="built_in">log</span>(list);</span><br></pre></td></tr></table></figure>

<p><strong>测试结果：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/22.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/22.png" alt="image-20200305114934209"></a></p>
<p><strong>希尔排序的效率：</strong></p>
<ul>
<li>希尔排序的效率和增量有直接关系，即使使用原稿中的增量效率都高于简单排序。</li>
</ul>
<h4 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.快速排序"></a>5.快速排序</h4><p>快速排序的介绍：</p>
<ul>
<li><strong>快速排序</strong>可以说是<strong>目前所有排序算法</strong>中，<strong>最快</strong>的一种排序算法。当然，没有任何一种算法是在任意情况下都是最优的。但是，大多数情况下快速排序是比较好的选择。</li>
<li><strong>快速排序</strong>其实是<strong>冒泡排序</strong>的升级版；</li>
</ul>
<p>快速排序的核心思想是<strong>分而治之</strong>，先选出一个数据（比如65），将比其小的数据都放在它的左边，将比它大的数据都放在它的右边。这个数据称为<strong>枢纽</strong></p>
<p>和冒泡排序的不同：</p>
<ul>
<li>我们选择的65可以一次性将它放在最正确的位置，之后就不需要做任何移动；</li>
<li>而冒泡排序即使已经找到最大值，也需要继续移动最大值，直到将它移动到最右边；</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/23.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/23.png" alt="image-20200305154504624"></a></p>
<p><strong>快速排序的枢纽：</strong></p>
<ul>
<li><strong>第一种方案：</strong>直接选择第一个元素作为枢纽。但是，当第一个元素就是最小值的情况下，效率不高；</li>
<li><strong>第二种方案：</strong>使用随机数。随机数本身十分消耗性能，不推荐；</li>
<li><strong>优秀的解决方法：</strong>取index为头、中、位的三个数据排序后的中位数；如下图所示，按下标值取出的三个数据为：92，31，0，经排序后变为：0，31，92，取其中的中位数31作为<strong>枢纽</strong>（当（length-1）/2不整除时可向下或向上取整）：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/24.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/24.png" alt="image-20200305182934710"></a></p>
<p><strong>实现枢纽选择：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换两个位置的数据</span></span><br><span class="line"><span class="keyword">let</span> swap = <span class="function"><span class="keyword">function</span>(<span class="params">arr, m, n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp  = arr[m]</span><br><span class="line">    arr[m] = arr[n]</span><br><span class="line">    arr[n] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//1.选择枢纽</span></span><br><span class="line"><span class="keyword">let</span> median = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//1.取出中间的位置</span></span><br><span class="line">  <span class="keyword">let</span> center = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> right = arr.length - <span class="number">1</span> </span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.判断大小并进行交换</span></span><br><span class="line">  <span class="keyword">if</span> (arr[left] &gt; arr[center]) &#123;</span><br><span class="line">    swap(arr, left, center)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[center] &gt; arr[right])&#123;</span><br><span class="line">    swap(arr, center, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[left] &gt; arr[right]) &#123;</span><br><span class="line">    swap(arr, left, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.返回枢纽</span></span><br><span class="line">  <span class="keyword">return</span> center</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组经过获取枢纽函数操作之后，选出的3个下标值对应的数据位置变为：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/25.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/25.png" alt="image-20200320091750654"></a></p>
<p><strong>动态过程：</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/26.gif"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/26.gif" alt="img"></a></p>
<p><strong>快速排序代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.快速排序</span></span><br><span class="line"><span class="keyword">let</span> QuickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> center = median(arr)</span><br><span class="line">  <span class="keyword">let</span> c = arr.splice(center, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> l = []</span><br><span class="line">  <span class="keyword">let</span> r = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; c) &#123;</span><br><span class="line">        l.push(arr[i])</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r.push(arr[i])</span><br><span class="line">      &#125;        </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> QuickSort(l).concat(c, QuickSort(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法的巧妙之处在于通过:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QuickSort(l)<span class="selector-class">.concat</span>(c, QuickSort(r))</span><br></pre></td></tr></table></figure>

<p>递归调用<code>QuickSort</code>函数实现了枢纽<code>Center</code>左边数据<code>l</code>和右边数据<code>r</code>的排序；</p>
<p><strong>测试代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">13</span>, <span class="number">81</span>, <span class="number">43</span>, <span class="number">31</span>, <span class="number">27</span>, <span class="number">56</span>, <span class="number">92</span>]</span><br><span class="line"><span class="built_in">console</span>.log(QuickSort(arr));</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/28.png"><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/28.png" alt="image-20200320092254048"></a></p>
<p><strong>快速排序的效率：</strong></p>
<ul>
<li>快速排序最坏情况下的效率：每次选择的枢纽都是最左边或最右边的数据，此时效率等同于冒泡排序，时间复杂度为<strong>O（n2）</strong>。可根据不同的枢纽选择避免这一情况；</li>
<li>快速排序的平均效率：为<strong>O（N*logN）</strong>，虽然其他算法效率也可达到O（N*logN），但是其中快速排序是<strong>最好的</strong>。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Aiolimp.com">Aiolimp</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://aiolimp.com/2022/07/09/JavaScript%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">http://aiolimp.com/2022/07/09/JavaScript%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Aiolimp.com" target="_blank">Aiolimp</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://static001.geekbang.org/resource/image/9f/28/9f68cbdfd275739a1cd3a4dfa85ead28.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/10/JavaScript%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%BB%93%E6%9E%84/" title="树结构简介"><img class="cover" src="https://static001.geekbang.org/resource/image/9f/28/9f68cbdfd275739a1cd3a4dfa85ead28.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">树结构简介</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/08/JavaScript%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%EF%BC%88Queue%EF%BC%89/" title="JavaScript实现队列结构（Queue）"><img class="cover" src="https://static001.geekbang.org/resource/image/9f/28/9f68cbdfd275739a1cd3a4dfa85ead28.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaScript实现队列结构（Queue）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/07/JavaScript%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/" title="JavaScript实现单向链表"><img class="cover" src="https://static001.geekbang.org/resource/image/9f/28/9f68cbdfd275739a1cd3a4dfa85ead28.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-07</div><div class="title">JavaScript实现单向链表</div></div></a></div><div><a href="/2022/07/11/JavaScript%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%BB%93%E6%9E%84%EF%BC%88Stack%EF%BC%89/" title="JavaScript实现栈结构（Stack）"><img class="cover" src="https://static001.geekbang.org/resource/image/9f/28/9f68cbdfd275739a1cd3a4dfa85ead28.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-11</div><div class="title">JavaScript实现栈结构（Stack）</div></div></a></div><div><a href="/2022/07/08/JavaScript%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%EF%BC%88Queue%EF%BC%89/" title="JavaScript实现队列结构（Queue）"><img class="cover" src="https://static001.geekbang.org/resource/image/9f/28/9f68cbdfd275739a1cd3a4dfa85ead28.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-08</div><div class="title">JavaScript实现队列结构（Queue）</div></div></a></div><div><a href="/2022/07/10/JavaScript%E5%AE%9E%E7%8E%B0%E6%A0%91%E7%BB%93%E6%9E%84/" title="树结构简介"><img class="cover" src="https://static001.geekbang.org/resource/image/9f/28/9f68cbdfd275739a1cd3a4dfa85ead28.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-10</div><div class="title">树结构简介</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Aiolimp</div><div class="author-info__description">生如长河,渡船千艘</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Aiolimp" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">JavaScript实现排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">一、大O表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">二、排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.希尔排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.快速排序</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="代理模式"><img src="https://static001.geekbang.org/resource/image/bd/2e/bddfad3dc8fb2f7c4942a0dc1286c92e.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代理模式"/></a><div class="content"><a class="title" href="/2023/08/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="代理模式">代理模式</a><time datetime="2023-08-12T08:57:49.000Z" title="发表于 2023-08-12 16:57:49">2023-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="单例模式"><img src="https://static001.geekbang.org/resource/image/bd/2e/bddfad3dc8fb2f7c4942a0dc1286c92e.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="单例模式"/></a><div class="content"><a class="title" href="/2023/08/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="单例模式">单例模式</a><time datetime="2023-08-12T08:57:49.000Z" title="发表于 2023-08-12 16:57:49">2023-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/12/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="工厂模式"><img src="https://static001.geekbang.org/resource/image/bd/2e/bddfad3dc8fb2f7c4942a0dc1286c92e.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="工厂模式"/></a><div class="content"><a class="title" href="/2023/08/12/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="工厂模式">工厂模式</a><time datetime="2023-08-12T08:57:49.000Z" title="发表于 2023-08-12 16:57:49">2023-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/12/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="抽象工厂模式"><img src="https://static001.geekbang.org/resource/image/bd/2e/bddfad3dc8fb2f7c4942a0dc1286c92e.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="抽象工厂模式"/></a><div class="content"><a class="title" href="/2023/08/12/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="抽象工厂模式">抽象工厂模式</a><time datetime="2023-08-12T08:57:49.000Z" title="发表于 2023-08-12 16:57:49">2023-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/05/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="JavaScript数据类型"><img src="https://static001.geekbang.org/resource/image/13/6b/13daccec5e12c89ea63e8c51dd20cb6b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript数据类型"/></a><div class="content"><a class="title" href="/2023/03/05/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="JavaScript数据类型">JavaScript数据类型</a><time datetime="2023-03-05T13:32:12.207Z" title="发表于 2023-03-05 21:32:12">2023-03-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Aiolimp</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>